/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("@deriv/components"), require("@deriv/shared"), require("@deriv/translations"), require("mobx"), require("react"), require("react-dom"));
	else if(typeof define === 'function' && define.amd)
		define(["@deriv/components", "@deriv/shared", "@deriv/translations", "mobx", "react", "react-dom"], factory);
	else if(typeof exports === 'object')
		exports["@deriv/account"] = factory(require("@deriv/components"), require("@deriv/shared"), require("@deriv/translations"), require("mobx"), require("react"), require("react-dom"));
	else
		root["@deriv/account"] = factory(root["@deriv/components"], root["@deriv/shared"], root["@deriv/translations"], root["mobx"], root["react"], root["react-dom"]);
})(self, (__WEBPACK_EXTERNAL_MODULE__deriv_components__, __WEBPACK_EXTERNAL_MODULE__deriv_shared__, __WEBPACK_EXTERNAL_MODULE__deriv_translations__, __WEBPACK_EXTERNAL_MODULE_mobx__, __WEBPACK_EXTERNAL_MODULE_react__, __WEBPACK_EXTERNAL_MODULE_react_dom__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../../node_modules/@binary-com/binary-document-uploader/DocumentUploader.js":
/***/ (function(module) {

eval("(function(e,t){ true?module.exports=t():0})(this,function(){var e=Math.sqrt,t=String.fromCharCode,r=Math.LN2,n=Math.log,o=Math.pow,l=Math.abs,a=Math.exp,s=Math.expm1,i=Math.max,c=Math.ceil,p=Math.floor,d=Math.min;return function(e){function t(n){if(r[n])return r[n].exports;var o=r[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var r={};return t.m=e,t.c=r,t.d=function(e,r,n){t.o(e,r)||Object.defineProperty(e,r,{configurable:!1,enumerable:!0,get:n})},t.n=function(e){var r=e&&e.__esModule?function(){return e['default']}:function(){return e};return t.d(r,'a',r),r},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p='',t(t.s=100)}([function(e,t,r){var n=r(3),o=r(20),l=r(9),a=r(17),s=r(14),i='prototype',c=function(e,t,r){var p,d,u,g,h=e&c.F,y=e&c.G,f=e&c.S,m=e&c.P,E=e&c.B,_=y?n:f?n[t]||(n[t]={}):(n[t]||{})[i],x=y?o:o[t]||(o[t]={}),S=x[i]||(x[i]={});for(p in y&&(r=t),r)d=!h&&_&&void 0!==_[p],u=(d?_:r)[p],g=E&&d?s(u,n):m&&'function'==typeof u?s(Function.call,u):u,_&&a(_,p,u,e&c.U),x[p]!=u&&l(x,p,g),m&&S[p]!=u&&(S[p]=u)};n.core=o,c.F=1,c.G=2,c.S=4,c.P=8,c.B=16,c.W=32,c.U=64,c.R=128,e.exports=c},function(e){e.exports=function(e){return'object'==typeof e?null!==e:'function'==typeof e}},function(e,t,r){var n=r(1);e.exports=function(e){if(!n(e))throw TypeError(e+' is not an object!');return e}},function(e){var t=e.exports='undefined'!=typeof window&&window.Math==Math?window:'undefined'!=typeof self&&self.Math==Math?self:Function('return this')();'number'==typeof __g&&(__g=t)},function(e,t,r){var n=r(41)('wks'),o=r(22),l=r(3).Symbol,a='function'==typeof l,s=e.exports=function(e){return n[e]||(n[e]=a&&l[e]||(a?l:o)('Symbol.'+e))};s.store=n},function(e){e.exports=function(e){try{return!!e()}catch(t){return!0}}},function(e,t,r){var n=r(18);e.exports=function(e){return 0<e?d(n(e),9007199254740991):0}},function(e,t,r){var n=r(2),o=r(70),l=r(36),a=Object.defineProperty;t.f=r(8)?Object.defineProperty:function(e,t,r){if(n(e),t=l(t,!0),n(r),o)try{return a(e,t,r)}catch(t){}if('get'in r||'set'in r)throw TypeError('Accessors not supported!');return'value'in r&&(e[t]=r.value),e}},function(e,t,r){e.exports=!r(5)(function(){return 7!=Object.defineProperty({},'a',{get:function(){return 7}}).a})},function(e,t,r){var n=r(7),o=r(21);e.exports=r(8)?function(e,t,r){return n.f(e,t,o(1,r))}:function(e,t,r){return e[t]=r,e}},function(e){var t={}.hasOwnProperty;e.exports=function(e,r){return t.call(e,r)}},function(e,t,r){var n=r(54),o=r(25);e.exports=function(e){return n(o(e))}},function(e,t,r){var n=r(25);e.exports=function(e){return Object(n(e))}},function(e,t,r){var n=r(0),o=r(20),l=r(5);e.exports=function(e,t){var r=(o.Object||{})[e]||Object[e],a={};a[e]=t(r),n(n.S+n.F*l(function(){r(1)}),'Object',a)}},function(e,t,r){var n=r(24);e.exports=function(e,t,r){return(n(e),void 0===t)?e:1===r?function(r){return e.call(t,r)}:2===r?function(r,n){return e.call(t,r,n)}:3===r?function(r,n,o){return e.call(t,r,n,o)}:function(){return e.apply(t,arguments)}}},function(e,t,r){'use strict';if(r(8)){var n=r(23),o=r(3),l=r(5),a=r(0),s=r(53),i=r(71),c=r(14),d=r(29),u=r(21),g=r(9),h=r(28),y=r(18),f=r(6),m=r(72),E=r(31),_=r(36),x=r(10),S=r(44),T=r(1),b=r(12),P=r(59),v=r(38),I=r(34),A=r(37).f,R=r(60),O=r(22),k=r(4),L=r(39),F=r(55),N=r(42),w=r(61),M=r(33),D=r(45),C=r(43),j=r(58),Y=r(78),B=r(7),G=r(16),U=B.f,H=G.f,W=o.RangeError,V=o.TypeError,z=o.Uint8Array,$='ArrayBuffer',K='Shared'+$,q='BYTES_PER_ELEMENT',X='prototype',Z=Array[X],J=i.ArrayBuffer,Q=i.DataView,ee=L(0),te=L(2),re=L(3),ne=L(4),oe=L(5),le=L(6),ae=F(!0),se=F(!1),ie=w.values,ce=w.keys,pe=w.entries,de=Z.lastIndexOf,ue=Z.reduce,ge=Z.reduceRight,he=Z.join,ye=Z.sort,fe=Z.slice,me=Z.toString,Ee=Z.toLocaleString,_e=k('iterator'),xe=k('toStringTag'),Se=O('typed_constructor'),Te=O('def_constructor'),be=s.CONSTR,Pe=s.TYPED,Oe=s.VIEW,ve='Wrong length!',Ie=L(1,function(e,t){return Fe(N(e,e[Te]),t)}),Ae=l(function(){return 1===new z(new Uint16Array([1]).buffer)[0]}),Re=!!z&&!!z[X].set&&l(function(){new z(1).set({})}),ke=function(e,t){var r=y(e);if(0>r||r%t)throw W('Wrong offset!');return r},Le=function(e){if(T(e)&&Pe in e)return e;throw V(e+' is not a typed array!')},Fe=function(e,t){if(!(T(e)&&Se in e))throw V('It is not a typed array constructor!');return new e(t)},Ne=function(e,t){return we(N(e,e[Te]),t)},we=function(e,t){for(var r=0,n=t.length,o=Fe(e,n);n>r;)o[r]=t[r++];return o},Me=function(e,t,r){U(e,t,{get:function(){return this._d[r]}})},De=function(e){var t,r,n,o,l,a,s=b(e),i=arguments.length,p=1<i?arguments[1]:void 0,d=p!==void 0,u=R(s);if(u!=void 0&&!P(u)){for(a=u.call(s),n=[],t=0;!(l=a.next()).done;t++)n.push(l.value);s=n}for(d&&2<i&&(p=c(p,arguments[2],2)),t=0,r=f(s.length),o=Fe(this,r);r>t;t++)o[t]=d?p(s[t],t):s[t];return o},Ce=function(){for(var e=0,t=arguments.length,r=Fe(this,t);t>e;)r[e]=arguments[e++];return r},je=!!z&&l(function(){Ee.call(new z(1))}),Ye=function(){return Ee.apply(je?fe.call(Le(this)):Le(this),arguments)},Be={copyWithin:function(e,t){return Y.call(Le(this),e,t,2<arguments.length?arguments[2]:void 0)},every:function(e){return ne(Le(this),e,1<arguments.length?arguments[1]:void 0)},fill:function(){return j.apply(Le(this),arguments)},filter:function(e){return Ne(this,te(Le(this),e,1<arguments.length?arguments[1]:void 0))},find:function(e){return oe(Le(this),e,1<arguments.length?arguments[1]:void 0)},findIndex:function(e){return le(Le(this),e,1<arguments.length?arguments[1]:void 0)},forEach:function(e){ee(Le(this),e,1<arguments.length?arguments[1]:void 0)},indexOf:function(e){return se(Le(this),e,1<arguments.length?arguments[1]:void 0)},includes:function(e){return ae(Le(this),e,1<arguments.length?arguments[1]:void 0)},join:function(){return he.apply(Le(this),arguments)},lastIndexOf:function(){return de.apply(Le(this),arguments)},map:function(e){return Ie(Le(this),e,1<arguments.length?arguments[1]:void 0)},reduce:function(){return ue.apply(Le(this),arguments)},reduceRight:function(){return ge.apply(Le(this),arguments)},reverse:function(){for(var e,t=this,r=Le(t).length,n=p(r/2),o=0;o<n;)e=t[o],t[o++]=t[--r],t[r]=e;return t},some:function(e){return re(Le(this),e,1<arguments.length?arguments[1]:void 0)},sort:function(e){return ye.call(Le(this),e)},subarray:function(e,t){var r=Le(this),n=r.length,o=E(e,n);return new(N(r,r[Te]))(r.buffer,r.byteOffset+o*r.BYTES_PER_ELEMENT,f((t===void 0?n:E(t,n))-o))}},Ge=function(e,t){return Ne(this,fe.call(Le(this),e,t))},Ue=function(e){Le(this);var t=ke(arguments[1],1),r=this.length,n=b(e),o=f(n.length),l=0;if(o+t>r)throw W(ve);for(;l<o;)this[t+l]=n[l++]},He={entries:function(){return pe.call(Le(this))},keys:function(){return ce.call(Le(this))},values:function(){return ie.call(Le(this))}},We=function(e,t){return T(e)&&e[Pe]&&'symbol'!=typeof t&&t in e&&+t+''==t+''},Ve=function(e,t){return We(e,t=_(t,!0))?u(2,e[t]):H(e,t)},ze=function(e,t,r){return We(e,t=_(t,!0))&&T(r)&&x(r,'value')&&!x(r,'get')&&!x(r,'set')&&!r.configurable&&(!x(r,'writable')||r.writable)&&(!x(r,'enumerable')||r.enumerable)?(e[t]=r.value,e):U(e,t,r)};be||(G.f=Ve,B.f=ze),a(a.S+a.F*!be,'Object',{getOwnPropertyDescriptor:Ve,defineProperty:ze}),l(function(){me.call({})})&&(me=Ee=function(){return he.call(this)});var $e=h({},Be);h($e,He),g($e,_e,He.values),h($e,{slice:Ge,set:Ue,constructor:function(){},toString:me,toLocaleString:Ye}),Me($e,'buffer','b'),Me($e,'byteOffset','o'),Me($e,'byteLength','l'),Me($e,'length','e'),U($e,xe,{get:function(){return this[Pe]}}),e.exports=function(e,t,r,i){i=!!i;var c=e+(i?'Clamped':'')+'Array',p=o[c],u=p||{},h=p&&I(p),y=!p||!s.ABV,E={},_=p&&p[X],x=function(r,n){var o=r._d;return o.v['get'+e](n*t+o.o,Ae)},b=function(r,n,o){var l=r._d;i&&(o=0>(o=Math.round(o))?0:255<o?255:255&o),l.v['set'+e](n*t+l.o,o,Ae)},P=function(e,t){U(e,t,{get:function(){return x(this,t)},set:function(e){return b(this,t,e)},enumerable:!0})};y?(p=r(function(e,r,n,o){d(e,p,c,'_d');var l,a,s,i,u=0,h=0;if(!T(r))s=m(r),a=s*t,l=new J(a);else if(r instanceof J||(i=S(r))==$||i==K){l=r,h=ke(n,t);var y=r.byteLength;if(void 0===o){if(y%t)throw W(ve);if(a=y-h,0>a)throw W(ve)}else if(a=f(o)*t,a+h>y)throw W(ve);s=a/t}else return Pe in r?we(p,r):De.call(p,r);for(g(e,'_d',{b:l,o:h,l:a,e:s,v:new Q(l)});u<s;)P(e,u++)}),_=p[X]=v($e),g(_,'constructor',p)):(!l(function(){p(1)})||!l(function(){new p(-1)})||!D(function(e){new p,new p(null),new p(1.5),new p(e)},!0))&&(p=r(function(e,r,n,o){d(e,p,c);var l;return T(r)?r instanceof J||(l=S(r))==$||l==K?void 0===o?void 0===n?new u(r):new u(r,ke(n,t)):new u(r,ke(n,t),o):Pe in r?we(p,r):De.call(p,r):new u(m(r))}),ee(h===Function.prototype?A(u):A(u).concat(A(h)),function(e){e in p||g(p,e,u[e])}),p[X]=_,!n&&(_.constructor=p));var O=_[_e],R=!!O&&('values'==O.name||O.name==void 0),k=He.values;g(p,Se,!0),g(_,Pe,c),g(_,Oe,!0),g(_,Te,p),(i?new p(1)[xe]!=c:!(xe in _))&&U(_,xe,{get:function(){return c}}),E[c]=p,a(a.G+a.W+a.F*(p!=u),E),a(a.S,c,{BYTES_PER_ELEMENT:t}),a(a.S+a.F*l(function(){u.of.call(p,1)}),c,{from:De,of:Ce}),q in _||g(_,q,t),a(a.P,c,Be),C(c),a(a.P+a.F*Re,c,{set:Ue}),a(a.P+a.F*!R,c,He),n||_.toString==me||(_.toString=me),a(a.P+a.F*l(function(){new p(1).slice()}),c,{slice:Ge}),a(a.P+a.F*(l(function(){return[1,2].toLocaleString()!=new p([1,2]).toLocaleString()})||!l(function(){_.toLocaleString.call([1,2])})),c,{toLocaleString:Ye}),M[c]=R?O:k,n||R||g(_,_e,k)}}else e.exports=function(){}},function(e,t,r){var n=r(40),o=r(21),l=r(11),a=r(36),s=r(10),i=r(70),c=Object.getOwnPropertyDescriptor;t.f=r(8)?c:function(e,t){if(e=l(e),t=a(t,!0),i)try{return c(e,t)}catch(t){}return s(e,t)?o(!n.f.call(e,t),e[t]):void 0}},function(e,t,r){var n=r(3),o=r(9),l=r(10),a=r(22)('src'),s=r(102),i='toString',c=(''+s).split(i);r(20).inspectSource=function(e){return s.call(e)},(e.exports=function(e,t,r,s){var i='function'==typeof r;i&&(l(r,'name')||o(r,'name',t));e[t]===r||(i&&(l(r,a)||o(r,a,e[t]?''+e[t]:c.join(t+''))),e===n?e[t]=r:s?e[t]?e[t]=r:o(e,t,r):(delete e[t],o(e,t,r)))})(Function.prototype,i,function(){return'function'==typeof this&&this[a]||s.call(this)})},function(e){e.exports=function(e){return isNaN(e=+e)?0:(0<e?p:c)(e)}},function(e,t,r){var n=r(22)('meta'),o=r(1),l=r(10),a=r(7).f,s=0,i=Object.isExtensible||function(){return!0},c=!r(5)(function(){return i(Object.preventExtensions({}))}),p=function(e){a(e,n,{value:{i:'O'+ ++s,w:{}}})},d=e.exports={KEY:n,NEED:!1,fastKey:function(e,t){if(!o(e))return'symbol'==typeof e?e:('string'==typeof e?'S':'P')+e;if(!l(e,n)){if(!i(e))return'F';if(!t)return'E';p(e)}return e[n].i},getWeak:function(e,t){if(!l(e,n)){if(!i(e))return!0;if(!t)return!1;p(e)}return e[n].w},onFreeze:function(e){return c&&d.NEED&&i(e)&&!l(e,n)&&p(e),e}}},function(e){var t=e.exports={version:'2.6.5'};'number'==typeof __e&&(__e=t)},function(e){e.exports=function(e,t){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}}},function(e){var t=0,r=Math.random();e.exports=function(e){return'Symbol('.concat(e===void 0?'':e,')_',(++t+r).toString(36))}},function(e){e.exports=!1},function(e){e.exports=function(e){if('function'!=typeof e)throw TypeError(e+' is not a function!');return e}},function(e){e.exports=function(e){if(e==void 0)throw TypeError('Can\\'t call method on  '+e);return e}},function(e,t,r){var n=r(73),o=r(57);e.exports=Object.keys||function(e){return n(e,o)}},function(e,t,r){var n=r(1);e.exports=function(e,t){if(!n(e)||e._t!==t)throw TypeError('Incompatible receiver, '+t+' required!');return e}},function(e,t,r){var n=r(17);e.exports=function(e,t,r){for(var o in t)n(e,o,t[o],r);return e}},function(e){e.exports=function(e,t,r,n){if(!(e instanceof t)||n!==void 0&&n in e)throw TypeError(r+': incorrect invocation!');return e}},function(e){var t={}.toString;e.exports=function(e){return t.call(e).slice(8,-1)}},function(e,t,r){var n=r(18);e.exports=function(e,t){return e=n(e),0>e?i(e+t,0):d(e,t)}},function(e,t,r){var n=r(7).f,o=r(10),l=r(4)('toStringTag');e.exports=function(e,t,r){e&&!o(e=r?e:e.prototype,l)&&n(e,l,{configurable:!0,value:t})}},function(e){e.exports={}},function(e,t,r){var n=r(10),o=r(12),l=r(56)('IE_PROTO'),a=Object.prototype;e.exports=Object.getPrototypeOf||function(e){return e=o(e),n(e,l)?e[l]:'function'==typeof e.constructor&&e instanceof e.constructor?e.constructor.prototype:e instanceof Object?a:null}},function(e,t,r){var n=r(4)('unscopables'),o=Array.prototype;o[n]==void 0&&r(9)(o,n,{}),e.exports=function(e){o[n][e]=!0}},function(e,t,r){var n=r(1);e.exports=function(e,t){if(!n(e))return e;var r,o;if(t&&'function'==typeof(r=e.toString)&&!n(o=r.call(e)))return o;if('function'==typeof(r=e.valueOf)&&!n(o=r.call(e)))return o;if(!t&&'function'==typeof(r=e.toString)&&!n(o=r.call(e)))return o;throw TypeError('Can\\'t convert object to primitive value')}},function(e,t,r){var n=r(73),o=r(57).concat('length','prototype');t.f=Object.getOwnPropertyNames||function(e){return n(e,o)}},function(e,t,r){var n=r(2),o=r(104),l=r(57),a=r(56)('IE_PROTO'),s=function(){},c='prototype',p=function(){var e,t=r(52)('iframe'),n=l.length,o='<',a='>';for(t.style.display='none',r(74).appendChild(t),t.src='javascript:',e=t.contentWindow.document,e.open(),e.write(o+'script'+a+'document.F=Object'+o+'/script'+a),e.close(),p=e.F;n--;)delete p[c][l[n]];return p()};e.exports=Object.create||function(e,t){var r;return null===e?r=p():(s[c]=n(e),r=new s,s[c]=null,r[a]=e),void 0===t?r:o(r,t)}},function(e,t,r){var n=r(14),o=r(54),l=r(12),a=r(6),s=r(105);e.exports=function(e,t){var r=1==e,i=4==e,c=6==e,p=t||s;return function(t,s,d){for(var u,g,h=l(t),y=o(h),m=n(s,d,3),f=a(y.length),E=0,_=r?p(t,f):2==e?p(t,0):void 0;f>E;E++)if((5==e||c||E in y)&&(u=y[E],g=m(u,E,h),e))if(r)_[E]=g;else if(g)switch(e){case 3:return!0;case 5:return u;case 6:return E;case 2:_.push(u);}else if(i)return!1;return c?-1:3==e||i?i:_}}},function(e,t){t.f={}.propertyIsEnumerable},function(e,t,r){var n=r(20),o=r(3),l='__core-js_shared__',a=o[l]||(o[l]={});(e.exports=function(e,t){return a[e]||(a[e]=t===void 0?{}:t)})('versions',[]).push({version:n.version,mode:r(23)?'pure':'global',copyright:'\\xA9 2019 Denis Pushkarev (zloirock.ru)'})},function(e,t,r){var n=r(2),o=r(24),l=r(4)('species');e.exports=function(e,t){var r,a=n(e).constructor;return a===void 0||(r=n(a)[l])==void 0?t:o(r)}},function(e,t,r){'use strict';var n=r(3),o=r(7),l=r(8),a=r(4)('species');e.exports=function(e){var t=n[e];l&&t&&!t[a]&&o.f(t,a,{configurable:!0,get:function(){return this}})}},function(e,t,r){var n=r(30),o=r(4)('toStringTag'),l='Arguments'==n(function(){return arguments}()),a=function(e,t){try{return e[t]}catch(t){}};e.exports=function(e){var t,r,s;return e===void 0?'Undefined':null===e?'Null':'string'==typeof(r=a(t=Object(e),o))?r:l?n(t):'Object'==(s=n(t))&&'function'==typeof t.callee?'Arguments':s}},function(e,t,r){var n=r(4)('iterator'),o=!1;try{var l=[7][n]();l['return']=function(){o=!0},Array.from(l,function(){throw 2})}catch(t){}e.exports=function(e,t){if(!t&&!o)return!1;var r=!1;try{var l=[7],a=l[n]();a.next=function(){return{done:r=!0}},l[n]=function(){return a},e(l)}catch(t){}return r}},function(e,t,r){var n=r(14),o=r(80),l=r(59),a=r(2),s=r(6),i=r(60),c={},p={},t=e.exports=function(e,t,r,d,u){var g,h,y,m,E=u?function(){return e}:i(e),_=n(r,d,t?2:1),f=0;if('function'!=typeof E)throw TypeError(e+' is not iterable!');if(l(E)){for(g=s(e.length);g>f;f++)if(m=t?_(a(h=e[f])[0],h[1]):_(e[f]),m===c||m===p)return m;}else for(y=E.call(e);!(h=y.next()).done;)if(m=o(y,_,h.value,t),m===c||m===p)return m};t.BREAK=c,t.RETURN=p},function(e,t,r){'use strict';var n=r(3),o=r(0),l=r(17),a=r(28),s=r(19),i=r(46),c=r(29),p=r(1),d=r(5),u=r(45),g=r(32),h=r(117);e.exports=function(e,t,r,y,f,m){var E=n[e],_=E,x=f?'set':'add',S=_&&_.prototype,T={},b=function(e){var t=S[e];l(S,e,'delete'==e?function(e){return m&&!p(e)?!1:t.call(this,0===e?0:e)}:'has'==e?function(e){return m&&!p(e)?!1:t.call(this,0===e?0:e)}:'get'==e?function(e){return m&&!p(e)?void 0:t.call(this,0===e?0:e)}:'add'==e?function(e){return t.call(this,0===e?0:e),this}:function(e,r){return t.call(this,0===e?0:e,r),this})};if('function'!=typeof _||!(m||S.forEach&&!d(function(){new _().entries().next()})))_=y.getConstructor(t,e,f,x),a(_.prototype,r),s.NEED=!0;else{var P=new _,O=P[x](m?{}:-0,1)!=P,v=d(function(){P.has(1)}),I=u(function(e){new _(e)}),A=!m&&d(function(){for(var e=new _,t=5;t--;)e[x](t,t);return!e.has(-0)});I||(_=t(function(t,r){c(t,_,e);var n=h(new E,t,_);return void 0!=r&&i(r,f,n[x],n),n}),_.prototype=S,S.constructor=_),(v||A)&&(b('delete'),b('has'),f&&b('get')),(A||O)&&b(x),m&&S.clear&&delete S.clear}return g(_,e),T[e]=_,o(o.G+o.W+o.F*(_!=E),T),m||y.setStrong(_,e,f),_}},function(e,t){t.f=Object.getOwnPropertySymbols},function(e,t,r){var n=r(3),o=n.navigator;e.exports=o&&o.userAgent||''},function(e,t,r){'use strict';var n=r(44),o=RegExp.prototype.exec;e.exports=function(e,t){var r=e.exec;if('function'==typeof r){var l=r.call(e,t);if('object'!=typeof l)throw new TypeError('RegExp exec method returned something other than an Object or null');return l}if('RegExp'!==n(e))throw new TypeError('RegExp#exec called on incompatible receiver');return o.call(e,t)}},function(e,t,r){'use strict';r(164);var n=r(17),o=r(9),l=r(5),a=r(25),s=r(4),i=r(66),c=s('species'),p=!l(function(){var e=/./;return e.exec=function(){var e=[];return e.groups={a:'7'},e},'7'!==''.replace(e,'$<a>')}),d=function(){var e=/(?:)/,t=e.exec;e.exec=function(){return t.apply(this,arguments)};var r='ab'.split(e);return 2===r.length&&'a'===r[0]&&'b'===r[1]}();e.exports=function(e,t,r){var u=s(e),g=!l(function(){var t={};return t[u]=function(){return 7},7!=''[e](t)}),h=g?!l(function(){var t=!1,r=/a/;return r.exec=function(){return t=!0,null},'split'===e&&(r.constructor={},r.constructor[c]=function(){return r}),r[u](''),!t}):void 0;if(!g||!h||'replace'===e&&!p||'split'===e&&!d){var y=/./[u],f=r(a,u,''[e],function(e,t,r,n,o){return t.exec===i?g&&!o?{done:!0,value:y.call(t,r,n)}:{done:!0,value:e.call(r,t,n)}:{done:!1}}),m=f[0],E=f[1];n(String.prototype,e,m),o(RegExp.prototype,u,2==t?function(e,t){return E.call(e,this,t)}:function(e){return E.call(e,this)})}}},function(e,t,r){var n=r(1),o=r(3).document,l=n(o)&&n(o.createElement);e.exports=function(e){return l?o.createElement(e):{}}},function(e,t,r){for(var n,o=r(3),l=r(9),a=r(22),s=a('typed_array'),c=a('view'),p=!!(o.ArrayBuffer&&o.DataView),d=p,u=0,i=['Int8Array','Uint8Array','Uint8ClampedArray','Int16Array','Uint16Array','Int32Array','Uint32Array','Float32Array','Float64Array'];u<9;)(n=o[i[u++]])?(l(n.prototype,s,!0),l(n.prototype,c,!0)):d=!1;e.exports={ABV:p,CONSTR:d,TYPED:s,VIEW:c}},function(e,t,r){var n=r(30);e.exports=Object('z').propertyIsEnumerable(0)?Object:function(e){return'String'==n(e)?e.split(''):Object(e)}},function(e,t,r){var n=r(11),o=r(6),l=r(31);e.exports=function(e){return function(t,r,a){var s,i=n(t),c=o(i.length),p=l(a,c);if(e&&r!=r){for(;c>p;)if(s=i[p++],s!=s)return!0;}else for(;c>p;p++)if((e||p in i)&&i[p]===r)return e||p||0;return!e&&-1}}},function(e,t,r){var n=r(41)('keys'),o=r(22);e.exports=function(e){return n[e]||(n[e]=o(e))}},function(e){e.exports=['constructor','hasOwnProperty','isPrototypeOf','propertyIsEnumerable','toLocaleString','toString','valueOf']},function(e,t,r){'use strict';var n=r(12),o=r(31),l=r(6);e.exports=function(e){for(var t=n(this),r=l(t.length),a=arguments.length,s=o(1<a?arguments[1]:void 0,r),i=2<a?arguments[2]:void 0,c=void 0===i?r:o(i,r);c>s;)t[s++]=e;return t}},function(e,t,r){var n=r(33),o=r(4)('iterator'),l=Array.prototype;e.exports=function(e){return e!==void 0&&(n.Array===e||l[o]===e)}},function(e,t,r){var n=r(44),o=r(4)('iterator'),l=r(33);e.exports=r(20).getIteratorMethod=function(e){if(e!=void 0)return e[o]||e['@@iterator']||l[n(e)]}},function(e,t,r){'use strict';var n=r(35),o=r(76),l=r(33),a=r(11);e.exports=r(77)(Array,'Array',function(e,t){this._t=a(e),this._i=0,this._k=t},function(){var e=this._t,t=this._k,r=this._i++;return!e||r>=e.length?(this._t=void 0,o(1)):'keys'==t?o(0,r):'values'==t?o(0,e[r]):o(0,[r,e[r]])},'values'),l.Arguments=l.Array,n('keys'),n('values'),n('entries')},function(e,t,r){var n,o,l,a=r(14),s=r(84),i=r(74),c=r(52),p=r(3),d=p.process,u=p.setImmediate,g=p.clearImmediate,h=p.MessageChannel,y=p.Dispatch,f=0,m={},E='onreadystatechange',_=function(){var e=+this;if(m.hasOwnProperty(e)){var t=m[e];delete m[e],t()}},x=function(e){_.call(e.data)};u&&g||(u=function(e){for(var t=[],r=1;arguments.length>r;)t.push(arguments[r++]);return m[++f]=function(){s('function'==typeof e?e:Function(e),t)},n(f),f},g=function(e){delete m[e]},'process'==r(30)(d)?n=function(e){d.nextTick(a(_,e,1))}:y&&y.now?n=function(e){y.now(a(_,e,1))}:h?(o=new h,l=o.port2,o.port1.onmessage=x,n=a(l.postMessage,l,1)):p.addEventListener&&'function'==typeof postMessage&&!p.importScripts?(n=function(e){p.postMessage(e+'','*')},p.addEventListener('message',x,!1)):E in c('script')?n=function(e){i.appendChild(c('script'))[E]=function(){i.removeChild(this),_.call(e)}}:n=function(e){setTimeout(a(_,e,1),0)}),e.exports={set:u,clear:g}},function(e,t,r){var n=r(92),o=r(25);e.exports=function(e,t,r){if(n(t))throw TypeError('String#'+r+' doesn\\'t accept regex!');return o(e)+''}},function(e,t,r){var n=r(4)('match');e.exports=function(e){var t=/./;try{'/./'[e](t)}catch(r){try{return t[n]=!1,!'/./'[e](t)}catch(e){}}return!0}},function(e,t,r){'use strict';var n=r(90)(!0);e.exports=function(e,t,r){return t+(r?n(e,t).length:1)}},function(e,t,r){'use strict';var n=r(93),o=RegExp.prototype.exec,l=String.prototype.replace,a=o,s='lastIndex',c=function(){var e=/a/,t=/b*/g;return o.call(e,'a'),o.call(t,'a'),0!==e[s]||0!==t[s]}(),p=/()??/.exec('')[1]!==void 0;(c||p)&&(a=function(e){var t,r,a,d,i=this;return p&&(r=new RegExp('^'+i.source+'$(?!\\\\s)',n.call(i))),c&&(t=i[s]),a=o.call(i,e),c&&a&&(i[s]=i.global?a.index+a[0].length:t),p&&a&&1<a.length&&l.call(a[0],r,function(){for(d=1;d<arguments.length-2;d++)void 0===arguments[d]&&(a[d]=void 0)}),a}),e.exports=a},function(e,t,r){'use strict';var n=r(7),o=r(21);e.exports=function(e,t,r){t in e?n.f(e,t,o(0,r)):e[t]=r}},function(e){e.exports=Math.sign||function(e){return 0==(e=+e)||e!=e?e:0>e?-1:1}},function(e){var t=s;e.exports=!t||22025.465794806718<t(10)||22025.465794806718>t(10)||-2e-17!=t(-2e-17)?function(e){return 0==(e=+e)?e:-1e-6<e&&1e-6>e?e+e*e/2:a(e)-1}:t},function(e,t,r){e.exports=!r(8)&&!r(5)(function(){return 7!=Object.defineProperty(r(52)('div'),'a',{get:function(){return 7}}).a})},function(e,t,a){'use strict';function s(t,r,n){var o,l,a,c=Array(n),p=8*n-r-1,d=(1<<p)-1,u=d>>1,g=23===r?z(2,-24)-z(2,-77):0,h=0,i=0>t||0===t&&0>1/t?1:0;for(t=V(t),t!=t||t===H?(l=t==t?0:1,o=d):(o=$(K(t)/q),1>t*(a=z(2,-o))&&(o--,a*=2),t+=1<=o+u?g/a:g*z(2,1-u),2<=t*a&&(o++,a/=2),o+u>=d?(l=0,o=d):1<=o+u?(l=(t*a-1)*z(2,r),o+=u):(l=t*z(2,u-1)*z(2,r),o=0));8<=r;c[h++]=255&l,l/=256,r-=8);for(o=o<<r|l,p+=r;0<p;c[h++]=255&o,o/=256,p-=8);return c[--h]|=128*i,c}function i(t,r,n){var o,l=8*n-r-1,a=(1<<l)-1,c=a>>1,p=l-7,d=n-1,i=t[d--],s=127&i;for(i>>=7;0<p;s=256*s+t[d],d--,p-=8);for(o=s&(1<<-p)-1,s>>=-p,p+=r;0<p;o=256*o+t[d],d--,p-=8);if(0===s)s=1-c;else{if(s===a)return o?NaN:i?-H:H;o+=z(2,r),s-=c}return(i?-1:1)*o*z(2,s-r)}function c(e){return e[3]<<24|e[2]<<16|e[1]<<8|e[0]}function d(e){return[255&e]}function u(e){return[255&e,255&e>>8]}function g(e){return[255&e,255&e>>8,255&e>>16,255&e>>24]}function h(e){return s(e,52,8)}function y(e){return s(e,23,4)}function f(e,t,r){L(e[D],t,{get:function(){return this[r]}})}function m(e,t,r,n){var o=R(+r);if(o+t>e[ee])throw U(C);var l=e[Q]._b,a=o+e[te],s=l.slice(a,a+t);return n?s:s.reverse()}function E(e,t,r,n,o,l){var a=R(+r);if(a+t>e[ee])throw U(C);for(var s=e[Q]._b,c=a+e[te],p=n(+o),d=0;d<t;d++)s[c+d]=p[l?d:t-d-1]}var _=a(3),x=a(8),S=a(23),T=a(53),b=a(9),P=a(28),O=a(5),v=a(29),I=a(18),A=a(6),R=a(72),k=a(37).f,L=a(7).f,F=a(58),N=a(32),w='ArrayBuffer',M='DataView',D='prototype',C='Wrong index!',Y=_[w],B=_[M],G=_.Math,U=_.RangeError,H=_.Infinity,W=Y,V=l,z=o,$=p,K=n,q=r,X='buffer',Z='byteLength',J='byteOffset',Q=x?'_b':X,ee=x?'_l':Z,te=x?'_o':J;if(!T.ABV)Y=function(e){v(this,Y,w);var t=R(e);this._b=F.call(Array(t),0),this[ee]=t},B=function(e,t,r){v(this,B,M),v(e,Y,M);var n=e[ee],o=I(t);if(0>o||o>n)throw U('Wrong offset!');if(r=void 0===r?n-o:A(r),o+r>n)throw U('Wrong length!');this[Q]=e,this[te]=o,this[ee]=r},x&&(f(Y,Z,'_l'),f(B,X,'_b'),f(B,Z,'_l'),f(B,J,'_o')),P(B[D],{getInt8:function(e){return m(this,1,e)[0]<<24>>24},getUint8:function(e){return m(this,1,e)[0]},getInt16:function(e){var t=m(this,2,e,arguments[1]);return(t[1]<<8|t[0])<<16>>16},getUint16:function(e){var t=m(this,2,e,arguments[1]);return t[1]<<8|t[0]},getInt32:function(e){return c(m(this,4,e,arguments[1]))},getUint32:function(e){return c(m(this,4,e,arguments[1]))>>>0},getFloat32:function(e){return i(m(this,4,e,arguments[1]),23,4)},getFloat64:function(e){return i(m(this,8,e,arguments[1]),52,8)},setInt8:function(e,t){E(this,1,e,d,t)},setUint8:function(e,t){E(this,1,e,d,t)},setInt16:function(e,t){E(this,2,e,u,t,arguments[2])},setUint16:function(e,t){E(this,2,e,u,t,arguments[2])},setInt32:function(e,t){E(this,4,e,g,t,arguments[2])},setUint32:function(e,t){E(this,4,e,g,t,arguments[2])},setFloat32:function(e,t){E(this,4,e,y,t,arguments[2])},setFloat64:function(e,t){E(this,8,e,h,t,arguments[2])}});else{if(!O(function(){Y(1)})||!O(function(){new Y(-1)})||O(function(){return new Y,new Y(1.5),new Y(NaN),Y.name!=w})){Y=function(e){return v(this,Y),new W(R(e))};for(var re,ne=Y[D]=W[D],oe=k(W),le=0;oe.length>le;)(re=oe[le++])in Y||b(Y,re,W[re]);S||(ne.constructor=Y)}var j=new B(new Y(2)),ae=B[D].setInt8;j.setInt8(0,2147483648),j.setInt8(1,2147483649),(j.getInt8(0)||!j.getInt8(1))&&P(B[D],{setInt8:function(e,t){ae.call(this,e,t<<24>>24)},setUint8:function(e,t){ae.call(this,e,t<<24>>24)}},!0)}N(Y,w),N(B,M),b(B[D],T.VIEW,!0),t[w]=Y,t[M]=B},function(e,t,r){var n=r(18),o=r(6);e.exports=function(e){if(e===void 0)return 0;var t=n(e),r=o(t);if(t!==r)throw RangeError('Wrong length!');return r}},function(e,t,r){var n=r(10),o=r(11),l=r(55)(!1),a=r(56)('IE_PROTO');e.exports=function(e,t){var r,s=o(e),c=0,i=[];for(r in s)r!=a&&n(s,r)&&i.push(r);for(;t.length>c;)n(s,r=t[c++])&&(~l(i,r)||i.push(r));return i}},function(e,t,r){var n=r(3).document;e.exports=n&&n.documentElement},function(e,t,r){var n=r(30);e.exports=Array.isArray||function(e){return'Array'==n(e)}},function(e){e.exports=function(e,t){return{value:t,done:!!e}}},function(e,t,r){'use strict';var n=r(23),o=r(0),l=r(17),a=r(9),s=r(33),i=r(107),c=r(32),p=r(34),d=r(4)('iterator'),u=!([].keys&&'next'in[].keys()),g='keys',h='values',y=function(){return this};e.exports=function(e,t,r,f,m,E,_){i(r,t,f);var x,S,T,b=function(e){return!u&&e in I?I[e]:e===g?function(){return new r(this,e)}:e===h?function(){return new r(this,e)}:function(){return new r(this,e)}},P=t+' Iterator',O=m==h,v=!1,I=e.prototype,A=I[d]||I['@@iterator']||m&&I[m],R=A||b(m),k=m?O?b('entries'):R:void 0,L='Array'==t?I.entries||A:A;if(L&&(T=p(L.call(new e)),T!==Object.prototype&&T.next&&(c(T,P,!0),!n&&'function'!=typeof T[d]&&a(T,d,y))),O&&A&&A.name!==h&&(v=!0,R=function(){return A.call(this)}),(!n||_)&&(u||v||!I[d])&&a(I,d,R),s[t]=R,s[P]=y,m)if(x={values:O?R:b(h),keys:E?R:b(g),entries:k},_)for(S in x)S in I||l(I,S,x[S]);else o(o.P+o.F*(u||v),t,x);return x}},function(e,t,r){'use strict';var n=r(12),o=r(31),l=r(6);e.exports=[].copyWithin||function(e,t){var r=n(this),a=l(r.length),s=o(e,a),i=o(t,a),c=2<arguments.length?arguments[2]:void 0,p=d((c===void 0?a:o(c,a))-i,a-s),u=1;for(i<s&&s<i+p&&(u=-1,i+=p-1,s+=p-1);0<p--;)i in r?r[s]=r[i]:delete r[s],s+=u,i+=u;return r}},function(e,t,r){'use strict';var n=r(7).f,o=r(38),l=r(28),a=r(14),s=r(29),i=r(46),c=r(77),p=r(76),d=r(43),u=r(8),g=r(19).fastKey,h=r(27),y=u?'_s':'size',f=function(e,t){var r,n=g(t);if('F'!==n)return e._i[n];for(r=e._f;r;r=r.n)if(r.k==t)return r};e.exports={getConstructor:function(e,t,r,c){var p=e(function(e,n){s(e,p,t,'_i'),e._t=t,e._i=o(null),e._f=void 0,e._l=void 0,e[y]=0,void 0!=n&&i(n,r,e[c],e)});return l(p.prototype,{clear:function(){for(var e=h(this,t),r=e._i,n=e._f;n;n=n.n)n.r=!0,n.p&&(n.p=n.p.n=void 0),delete r[n.i];e._f=e._l=void 0,e[y]=0},delete:function(e){var r=h(this,t),n=f(r,e);if(n){var o=n.n,l=n.p;delete r._i[n.i],n.r=!0,l&&(l.n=o),o&&(o.p=l),r._f==n&&(r._f=o),r._l==n&&(r._l=l),r[y]--}return!!n},forEach:function(e){h(this,t);for(var r,n=a(e,1<arguments.length?arguments[1]:void 0,3);r=r?r.n:this._f;)for(n(r.v,r.k,this);r&&r.r;)r=r.p},has:function(e){return!!f(h(this,t),e)}}),u&&n(p.prototype,'size',{get:function(){return h(this,t)[y]}}),p},def:function(e,t,r){var n,o,l=f(e,t);return l?l.v=r:(e._l=l={i:o=g(t,!0),k:t,v:r,p:n=e._l,n:void 0,r:!1},!e._f&&(e._f=l),n&&(n.n=l),e[y]++,'F'!==o&&(e._i[o]=l)),e},getEntry:f,setStrong:function(e,t,r){c(e,t,function(e,r){this._t=h(e,t),this._k=r,this._l=void 0},function(){for(var e=this,t=e._k,r=e._l;r&&r.r;)r=r.p;return e._t&&(e._l=r=r?r.n:e._t._f)?'keys'==t?p(0,r.k):'values'==t?p(0,r.v):p(0,[r.k,r.v]):(e._t=void 0,p(1))},r?'entries':'values',!r,!0),d(t)}}},function(e,t,r){var n=r(2);e.exports=function(t,e,r,o){try{return o?e(n(r)[0],r[1]):e(r)}catch(r){var l=t['return'];throw void 0!==l&&n(l.call(t)),r}}},function(e,t,r){var n=r(1),o=r(2),l=function(e,t){if(o(e),!n(t)&&null!==t)throw TypeError(t+': can\\'t set as prototype!')};e.exports={set:Object.setPrototypeOf||('__proto__'in{}?function(e,t,n){try{n=r(14)(Function.call,r(16).f(Object.prototype,'__proto__').set,2),n(e,[]),t=!(e instanceof Array)}catch(r){t=!0}return function(e,r){return l(e,r),t?e.__proto__=r:n(e,r),e}}({},!1):void 0),check:l}},function(e,t,r){'use strict';var n=r(26),o=r(48),l=r(40),a=r(12),s=r(54),i=Object.assign;e.exports=!i||r(5)(function(){var e={},t={},r=Symbol(),n='abcdefghijklmnopqrst';return e[r]=7,n.split('').forEach(function(e){t[e]=e}),7!=i({},e)[r]||Object.keys(i({},t)).join('')!=n})?function(e){for(var t=a(e),r=arguments.length,i=1,c=o.f,p=l.f;r>i;)for(var d,u=s(arguments[i++]),g=c?n(u).concat(c(u)):n(u),h=g.length,y=0;h>y;)p.call(u,d=g[y++])&&(t[d]=u[d]);return t}:i},function(e,t,r){'use strict';var n=r(28),o=r(19).getWeak,l=r(2),a=r(1),s=r(29),i=r(46),c=r(39),p=r(10),d=r(27),u=c(5),g=c(6),h=0,y=function(e){return e._l||(e._l=new f)},f=function(){this.a=[]},m=function(e,t){return u(e.a,function(e){return e[0]===t})};f.prototype={get:function(e){var t=m(this,e);if(t)return t[1]},has:function(e){return!!m(this,e)},set:function(e,t){var r=m(this,e);r?r[1]=t:this.a.push([e,t])},delete:function(e){var t=g(this.a,function(t){return t[0]===e});return~t&&this.a.splice(t,1),!!~t}},e.exports={getConstructor:function(e,t,r,l){var c=e(function(e,n){s(e,c,t,'_i'),e._t=t,e._i=h++,e._l=void 0,void 0!=n&&i(n,r,e[l],e)});return n(c.prototype,{delete:function(e){if(!a(e))return!1;var r=o(e);return!0===r?y(d(this,t))['delete'](e):r&&p(r,this._i)&&delete r[this._i]},has:function(e){if(!a(e))return!1;var r=o(e);return!0===r?y(d(this,t)).has(e):r&&p(r,this._i)}}),c},def:function(e,t,r){var n=o(l(t),!0);return!0===n?y(e).set(t,r):n[e._i]=r,e},ufstore:y}},function(e){e.exports=function(e,t,r){var n=r===void 0;switch(t.length){case 0:return n?e():e.call(r);case 1:return n?e(t[0]):e.call(r,t[0]);case 2:return n?e(t[0],t[1]):e.call(r,t[0],t[1]);case 3:return n?e(t[0],t[1],t[2]):e.call(r,t[0],t[1],t[2]);case 4:return n?e(t[0],t[1],t[2],t[3]):e.call(r,t[0],t[1],t[2],t[3]);}return e.apply(r,t)}},function(e,t,r){var n=r(37),o=r(48),l=r(2),a=r(3).Reflect;e.exports=a&&a.ownKeys||function(e){var t=n.f(l(e)),r=o.f;return r?t.concat(r(e)):t}},function(e,t,r){'use strict';function n(e){var t,r;this.promise=new e(function(e,n){if(t!=void 0||r!=void 0)throw TypeError('Bad Promise constructor');t=e,r=n}),this.resolve=o(t),this.reject=o(r)}var o=r(24);e.exports.f=function(e){return new n(e)}},function(e,t,r){t.f=r(4)},function(e,t,r){var n=r(11),o=r(37).f,l={}.toString,a='object'==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],s=function(e){try{return o(e)}catch(t){return a.slice()}};e.exports.f=function(e){return a&&'[object Window]'==l.call(e)?s(e):o(n(e))}},function(e){e.exports=Object.is||function(e,t){return e===t?0!==e||1/e==1/t:e!=e&&t!=t}},function(e,t,r){var n=r(18),o=r(25);e.exports=function(e){return function(t,r){var c,a,p=o(t)+'',s=n(r),i=p.length;return 0>s||s>=i?e?'':void 0:(c=p.charCodeAt(s),55296>c||56319<c||s+1===i||56320>(a=p.charCodeAt(s+1))||57343<a?e?p.charAt(s):c:e?p.slice(s,s+2):(c-55296<<10)+(a-56320)+65536)}}},function(e,t,r){'use strict';var o=r(18),l=r(25);e.exports=function(e){var t=l(this)+'',r='',a=o(e);if(0>a||a==Infinity)throw RangeError('Count can\\'t be negative');for(;0<a;(a>>>=1)&&(t+=t))1&a&&(r+=t);return r}},function(e,t,r){var n=r(1),o=r(30),l=r(4)('match');e.exports=function(e){var t;return n(e)&&((t=e[l])===void 0?'RegExp'==o(e):!!t)}},function(e,t,r){'use strict';var n=r(2);e.exports=function(){var e=n(this),t='';return e.global&&(t+='g'),e.ignoreCase&&(t+='i'),e.multiline&&(t+='m'),e.unicode&&(t+='u'),e.sticky&&(t+='y'),t}},function(e,t,r){var n=r(1);e.exports=function(e){return!n(e)&&isFinite(e)&&p(e)===e}},function(e){e.exports=Math.log1p||function(e){return-1e-8<(e=+e)&&1e-8>e?e-e*e/2:n(1+e)}},function(e,t,r){var n=r(26),o=r(11),l=r(40).f;e.exports=function(e){return function(t){for(var r,a=o(t),s=n(a),c=s.length,p=0,i=[];c>p;)l.call(a,r=s[p++])&&i.push(e?[r,a[r]]:a[r]);return i}}},function(e,t,r){var n=r(6),o=r(91),l=r(25);e.exports=function(e,t,r,a){var s=l(e)+'',i=s.length,p=void 0===r?' ':r+'',d=n(t);if(d<=i||''==p)return s;var u=d-i,g=o.call(p,c(u/p.length));return g.length>u&&(g=g.slice(0,u)),a?g+s:s+g}},function(e,t){'use strict';function r(e,t,r){var n=new Error(t.message||t.message_to_client||t);return n.name=t.code||e,n.passthrough=r,n}function n(e,t){for(var r=new Uint8Array(e.length+t.length),n=0;n<e.length;n++)r[n]=e[n];for(var o=0;o<t.length;o++)r[o+e.length]=t[o];return r}function o(e){var t=new Uint8Array(l),r=new DataView(t.buffer);return r.setUint32(0,e),t}Object.defineProperty(t,'__esModule',{value:!0}),t.addMetadata=function(e,t){for(var r=t.uploadId,l=t.callType,a=o(r),s=o(l),i=e,c=function(e){var t=o(e.length),r=new Uint8Array([]);return r=n(r,s),r=n(r,a),r=n(r,t),r=n(r,e),r},p=[],d=0;d<i.length;d++)p.push(c(i[d],d,i));return p},t.log=function(e){var t;if(e){for(var r=arguments.length,n=Array(1<r?r-1:0),o=1;o<r;o++)n[o-1]=arguments[o];(t=console).log.apply(t,[new Date+':'].concat(n))}},t.createError=r,t.pushToBuffer=n,t.getFile=function(e){var t=Object.assign({},e);return t.buffer=new Uint8Array(e.buffer),t},t.checkOptions=function(e){if(!e)throw Error('Options is required');for(var t=['filename','buffer','documentType','documentFormat'],n=t,o=function(t){if(!(t in e))throw r('InvocationError','Required option <'+t+'> is not found in the given options')},l=0;l<n.length;l++)o(n[l],l,n);if(e.buffer.length>a)throw r('FileSizeError','The maximum acceptable file size is '+s)};var l=4,a=t.MAX_SIZE=8388608,s=t.HUMAN_READABLE_MAX_SIZE='8 MB',i=t.generateChunks=function(e,t){for(var r,n=t.chunkSize,o=n===void 0?16384:n,l=[],a=0;a<e.length;a++)r=e[a],0==a%o?l.push([r]):l[l.length-1].push(r);for(var s=l,i=function(e){return new Uint8Array(e)},c=[],p=0;p<s.length;p++)c.push(i(s[p],p,s));return c.concat(new Uint8Array([]))}},function(e){var r={utf8:{stringToBytes:function(e){return r.bin.stringToBytes(unescape(encodeURIComponent(e)))},bytesToString:function(e){return decodeURIComponent(escape(r.bin.bytesToString(e)))}},bin:{stringToBytes:function(e){for(var t=[],r=0;r<e.length;r++)t.push(255&e.charCodeAt(r));return t},bytesToString:function(e){for(var r=[],n=0;n<e.length;n++)r.push(t(e[n]));return r.join('')}}};e.exports=r},function(e,t,r){'use strict';function n(e,t){if(!(e instanceof t))throw new TypeError('Cannot call a class as a function')}Object.defineProperty(t,'__esModule',{value:!0});var o=function(){function e(e,t){for(var r,n=0;n<t.length;n++)r=t[n],r.enumerable=r.enumerable||!1,r.configurable=!0,'value'in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}();r(101),r(103),r(108),r(109),r(110),r(111),r(112),r(113),r(114),r(115),r(116),r(118),r(119),r(120),r(121),r(122),r(124),r(125),r(126),r(127),r(128),r(129),r(130),r(131),r(132),r(133),r(134),r(135),r(139),r(142),r(143),r(144),r(145),r(146),r(147),r(148),r(149),r(150),r(151),r(152),r(153),r(154),r(155),r(156),r(157),r(158),r(159),r(160),r(161),r(162),r(163),r(165),r(166),r(167),r(168),r(169),r(170),r(171),r(172),r(173),r(61),r(174),r(175),r(176),r(177),r(178),r(179),r(180),r(181),r(182),r(183),r(184),r(185),r(186),r(187),r(188),r(190),r(191),r(192),r(193),r(194),r(195),r(196),r(197),r(198),r(199),r(200),r(201),r(202),r(203),r(204),r(205),r(206),r(207),r(208);var l=r(98),a=r(209),s=function(e){return e&&e.__esModule?e:{default:e}}(a),i=0,c=function(){function e(t){n(this,e),this.config=t,this.clients={},this.wrapConnection()}return o(e,[{key:'upload',value:function(e){var t=this,r=this.config.debug,n=(0,l.getFile)(e);(0,l.checkOptions)(n),i+=1;var o=new s.default({send:this.send,file:n,reqId:i});return this.clients[i]={client:o},new Promise(function(e,a){t.clients[i].promise={resolve:e,reject:a},(0,l.log)(void 0!==r&&r,'Uploading started, File options:',n),o.requestUpload()})}},{key:'wrapConnection',value:function(){var e=this,t=this.config,r=t.connection,n=t.debug,o=void 0!==n&&n;if(!r||1!==r.readyState)throw(0,l.createError)('ConnectionError','Connection is not ready!');this.connection=r,this.send=function(e){(0,l.log)(o,'<Sent>:',e),r.send(e)};var a=r.onmessage;r.onmessage=function(t){var n=t.data;(0,l.log)(o,'<Received>:',n);var s=JSON.parse(n);if(a&&(!s.passthrough||!s.passthrough.document_upload))return void a.call(r,t);var i=s.passthrough.document_upload;if(a&&!i)return void a.call(r,t);if(s.req_id in e.clients){var c=e.clients[s.req_id],p=c.client,d=c.promise;try{var u=p.handleMessage(s);u&&((0,l.log)(o,'Upload successful, upload info:',u),d.resolve(u))}catch(t){d.reject(t),(0,l.log)(o,t)}}}}}]),e}();t.default=c},function(e,t,r){'use strict';var n=r(0),o=r(53),l=r(71),a=r(2),s=r(31),i=r(6),c=r(1),p=r(3).ArrayBuffer,d=r(42),u=l.ArrayBuffer,g=l.DataView,h=o.ABV&&p.isView,y=u.prototype.slice,f=o.VIEW,m='ArrayBuffer';n(n.G+n.W+n.F*(p!==u),{ArrayBuffer:u}),n(n.S+n.F*!o.CONSTR,m,{isView:function(e){return h&&h(e)||c(e)&&f in e}}),n(n.P+n.U+n.F*r(5)(function(){return!new u(2).slice(1,void 0).byteLength}),m,{slice:function(e,t){if(y!==void 0&&t===void 0)return y.call(a(this),e);for(var r=a(this).byteLength,n=s(e,r),o=s(void 0===t?r:t,r),l=new(d(this,u))(i(o-n)),c=new g(this),p=new g(l),h=0;n<o;)p.setUint8(h++,c.getUint8(n++));return l}}),r(43)(m)},function(e,t,r){e.exports=r(41)('native-function-to-string',Function.toString)},function(e,t,r){r(15)('Int8',1,function(e){return function(t,r,n){return e(this,t,r,n)}})},function(e,t,r){var n=r(7),o=r(2),l=r(26);e.exports=r(8)?Object.defineProperties:function(e,t){o(e);for(var r,a=l(t),s=a.length,c=0;s>c;)n.f(e,r=a[c++],t[r]);return e}},function(e,t,r){var n=r(106);e.exports=function(e,t){return new(n(e))(t)}},function(e,t,r){var n=r(1),o=r(75),l=r(4)('species');e.exports=function(e){var t;return o(e)&&(t=e.constructor,'function'==typeof t&&(t===Array||o(t.prototype))&&(t=void 0),n(t)&&(t=t[l],null===t&&(t=void 0))),void 0===t?Array:t}},function(e,t,r){'use strict';var n=r(38),o=r(21),l=r(32),a={};r(9)(a,r(4)('iterator'),function(){return this}),e.exports=function(e,t,r){e.prototype=n(a,{next:o(1,r)}),l(e,t+' Iterator')}},function(e,t,r){r(15)('Uint8',1,function(e){return function(t,r,n){return e(this,t,r,n)}})},function(e,t,r){r(15)('Uint8',1,function(e){return function(t,r,n){return e(this,t,r,n)}},!0)},function(e,t,r){r(15)('Int16',2,function(e){return function(t,r,n){return e(this,t,r,n)}})},function(e,t,r){r(15)('Uint16',2,function(e){return function(t,r,n){return e(this,t,r,n)}})},function(e,t,r){r(15)('Int32',4,function(e){return function(t,r,n){return e(this,t,r,n)}})},function(e,t,r){r(15)('Uint32',4,function(e){return function(t,r,n){return e(this,t,r,n)}})},function(e,t,r){r(15)('Float32',4,function(e){return function(t,r,n){return e(this,t,r,n)}})},function(e,t,r){r(15)('Float64',8,function(e){return function(t,r,n){return e(this,t,r,n)}})},function(e,t,r){'use strict';var n=r(79),o=r(27),l='Map';e.exports=r(47)(l,function(e){return function(){return e(this,0<arguments.length?arguments[0]:void 0)}},{get:function(e){var t=n.getEntry(o(this,l),e);return t&&t.v},set:function(e,t){return n.def(o(this,l),0===e?0:e,t)}},n,!0)},function(e,t,r){var n=r(1),o=r(81).set;e.exports=function(e,t,r){var l,a=t.constructor;return a!==r&&'function'==typeof a&&(l=a.prototype)!==r.prototype&&n(l)&&o&&o(e,l),e}},function(e,t,r){'use strict';var n=r(79),o=r(27),l='Set';e.exports=r(47)(l,function(e){return function(){return e(this,0<arguments.length?arguments[0]:void 0)}},{add:function(e){return n.def(o(this,l),e=0===e?0:e,e)}},n)},function(e,t,r){'use strict';var n,o=r(3),l=r(39)(0),a=r(17),s=r(19),i=r(82),c=r(83),p=r(1),d=r(27),u=r(27),g=!o.ActiveXObject&&'ActiveXObject'in o,h='WeakMap',y=s.getWeak,f=Object.isExtensible,m=c.ufstore,E=function(e){return function(){return e(this,0<arguments.length?arguments[0]:void 0)}},_={get:function(e){if(p(e)){var t=y(e);return!0===t?m(d(this,h)).get(e):t?t[this._i]:void 0}},set:function(e,t){return c.def(d(this,h),e,t)}},x=e.exports=r(47)(h,E,_,c,!0,!0);u&&g&&(n=c.getConstructor(E,h),i(n.prototype,_),s.NEED=!0,l(['delete','has','get','set'],function(e){var t=x.prototype,r=t[e];a(t,e,function(t,o){if(p(t)&&!f(t)){this._f||(this._f=new n);var l=this._f[e](t,o);return'set'==e?this:l}return r.call(this,t,o)})}))},function(e,t,r){'use strict';var n=r(83),o=r(27),l='WeakSet';r(47)(l,function(e){return function(){return e(this,0<arguments.length?arguments[0]:void 0)}},{add:function(e){return n.def(o(this,l),e,!0)}},n,!1,!0)},function(e,t,r){var n=r(0),o=r(24),l=r(2),a=(r(3).Reflect||{}).apply,s=Function.apply;n(n.S+n.F*!r(5)(function(){a(function(){})}),'Reflect',{apply:function(e,t,r){var n=o(e),i=l(r);return a?a(n,t,i):s.call(n,t,i)}})},function(e,t,r){var n=r(0),o=r(38),l=r(24),a=r(2),s=r(1),i=r(5),c=r(123),p=(r(3).Reflect||{}).construct,d=i(function(){function e(){}return!(p(function(){},[],e)instanceof e)}),u=!i(function(){p(function(){})});n(n.S+n.F*(d||u),'Reflect',{construct:function(e,t){l(e),a(t);var r=3>arguments.length?e:l(arguments[2]);if(u&&!d)return p(e,t,r);if(e==r){switch(t.length){case 0:return new e;case 1:return new e(t[0]);case 2:return new e(t[0],t[1]);case 3:return new e(t[0],t[1],t[2]);case 4:return new e(t[0],t[1],t[2],t[3]);}var n=[null];return n.push.apply(n,t),new(c.apply(e,n))}var i=r.prototype,g=o(s(i)?i:Object.prototype),h=Function.apply.call(e,g,t);return s(h)?h:g}})},function(e,t,r){'use strict';var n=r(24),o=r(1),l=r(84),a=[].slice,s={},i=function(e,t,r){if(!(t in s)){for(var o=[],n=0;n<t;n++)o[n]='a['+n+']';s[t]=Function('F,a','return new F('+o.join(',')+')')}return s[t](e,r)};e.exports=Function.bind||function(e){var t=n(this),r=a.call(arguments,1),s=function(){var n=r.concat(a.call(arguments));return this instanceof s?i(t,n.length,n):l(t,n,e)};return o(t.prototype)&&(s.prototype=t.prototype),s}},function(e,t,r){var n=r(7),o=r(0),l=r(2),a=r(36);o(o.S+o.F*r(5)(function(){Reflect.defineProperty(n.f({},1,{value:1}),1,{value:2})}),'Reflect',{defineProperty:function(e,t,r){l(e),t=a(t,!0),l(r);try{return n.f(e,t,r),!0}catch(t){return!1}}})},function(e,t,r){var n=r(0),o=r(16).f,l=r(2);n(n.S,'Reflect',{deleteProperty:function(e,t){var r=o(l(e),t);return r&&!r.configurable?!1:delete e[t]}})},function(e,t,r){function n(e,t){var r,s,p=3>arguments.length?e:arguments[2];return c(e)===p?e[t]:(r=o.f(e,t))?a(r,'value')?r.value:void 0===r.get?void 0:r.get.call(p):i(s=l(e))?n(s,t,p):void 0}var o=r(16),l=r(34),a=r(10),s=r(0),i=r(1),c=r(2);s(s.S,'Reflect',{get:n})},function(e,t,r){var n=r(16),o=r(0),l=r(2);o(o.S,'Reflect',{getOwnPropertyDescriptor:function(e,t){return n.f(l(e),t)}})},function(e,t,r){var n=r(0),o=r(34),l=r(2);n(n.S,'Reflect',{getPrototypeOf:function(e){return o(l(e))}})},function(e,t,r){var n=r(0);n(n.S,'Reflect',{has:function(e,t){return t in e}})},function(e,t,r){var n=r(0),o=r(2),l=Object.isExtensible;n(n.S,'Reflect',{isExtensible:function(e){return o(e),!l||l(e)}})},function(e,t,r){var n=r(0);n(n.S,'Reflect',{ownKeys:r(85)})},function(e,t,r){var n=r(0),o=r(2),l=Object.preventExtensions;n(n.S,'Reflect',{preventExtensions:function(e){o(e);try{return l&&l(e),!0}catch(t){return!1}}})},function(e,t,r){function n(e,t,r){var i,u,g=4>arguments.length?e:arguments[3],h=l.f(p(e),t);if(!h){if(d(u=a(e)))return n(u,t,r,g);h=c(0)}if(s(h,'value')){if(!1===h.writable||!d(g))return!1;if(i=l.f(g,t)){if(i.get||i.set||!1===i.writable)return!1;i.value=r,o.f(g,t,i)}else o.f(g,t,c(0,r));return!0}return h.set!==void 0&&(h.set.call(g,r),!0)}var o=r(7),l=r(16),a=r(34),s=r(10),i=r(0),c=r(21),p=r(2),d=r(1);i(i.S,'Reflect',{set:n})},function(e,t,r){var n=r(0),o=r(81);o&&n(n.S,'Reflect',{setPrototypeOf:function(e,t){o.check(e,t);try{return o.set(e,t),!0}catch(t){return!1}}})},function(e,t,r){'use strict';var n,o,l,a,s=r(23),i=r(3),c=r(14),p=r(44),d=r(0),u=r(1),g=r(24),h=r(29),y=r(46),f=r(42),m=r(62).set,E=r(136)(),_=r(86),x=r(137),S=r(49),T=r(138),b='Promise',P=i.TypeError,O=i.process,v=O&&O.versions,I=v&&v.v8||'',A=i[b],R='process'==p(O),k=function(){},L=o=_.f,F=!!function(){try{var e=A.resolve(1),t=(e.constructor={})[r(4)('species')]=function(e){e(k,k)};return(R||'function'==typeof PromiseRejectionEvent)&&e.then(k)instanceof t&&0!==I.indexOf('6.6')&&-1===S.indexOf('Chrome/66')}catch(t){}}(),N=function(e){var t;return u(e)&&'function'==typeof(t=e.then)&&t},w=function(e,t){if(!e._n){e._n=!0;var r=e._c;E(function(){for(var n=e._v,o=1==e._s,l=0,a=function(t){var r,l,a,s=o?t.ok:t.fail,i=t.resolve,c=t.reject,p=t.domain;try{s?(!o&&(2==e._h&&C(e),e._h=1),!0===s?r=n:(p&&p.enter(),r=s(n),p&&(p.exit(),a=!0)),r===t.promise?c(P('Promise-chain cycle')):(l=N(r))?l.call(r,i,c):i(r)):c(n)}catch(t){p&&!a&&p.exit(),c(t)}};r.length>l;)a(r[l++]);e._c=[],e._n=!1,t&&!e._h&&M(e)})}},M=function(e){m.call(i,function(){var t,r,n,o=e._v,l=D(e);if(l&&(t=x(function(){R?O.emit('unhandledRejection',o,e):(r=i.onunhandledrejection)?r({promise:e,reason:o}):(n=i.console)&&n.error&&n.error('Unhandled promise rejection',o)}),e._h=R||D(e)?2:1),e._a=void 0,l&&t.e)throw t.v})},D=function(e){return 1!==e._h&&0===(e._a||e._c).length},C=function(e){m.call(i,function(){var t;R?O.emit('rejectionHandled',e):(t=i.onrejectionhandled)&&t({promise:e,reason:e._v})})},j=function(e){var t=this;t._d||(t._d=!0,t=t._w||t,t._v=e,t._s=2,!t._a&&(t._a=t._c.slice()),w(t,!0))},Y=function(e){var t,r=this;if(!r._d){r._d=!0,r=r._w||r;try{if(r===e)throw P('Promise can\\'t be resolved itself');(t=N(e))?E(function(){var n={_w:r,_d:!1};try{t.call(e,c(Y,n,1),c(j,n,1))}catch(t){j.call(n,t)}}):(r._v=e,r._s=1,w(r,!1))}catch(t){j.call({_w:r,_d:!1},t)}}};F||(A=function(e){h(this,A,b,'_h'),g(e),n.call(this);try{e(c(Y,this,1),c(j,this,1))}catch(e){j.call(this,e)}},n=function(){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},n.prototype=r(28)(A.prototype,{then:function(e,t){var r=L(f(this,A));return r.ok='function'!=typeof e||e,r.fail='function'==typeof t&&t,r.domain=R?O.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&w(this,!1),r.promise},catch:function(e){return this.then(void 0,e)}}),l=function(){var e=new n;this.promise=e,this.resolve=c(Y,e,1),this.reject=c(j,e,1)},_.f=L=function(e){return e===A||e===a?new l(e):o(e)}),d(d.G+d.W+d.F*!F,{Promise:A}),r(32)(A,b),r(43)(b),a=r(20)[b],d(d.S+d.F*!F,b,{reject:function(e){var t=L(this),r=t.reject;return r(e),t.promise}}),d(d.S+d.F*(s||!F),b,{resolve:function(e){return T(s&&this===a?A:this,e)}}),d(d.S+d.F*!(F&&r(45)(function(e){A.all(e)['catch'](k)})),b,{all:function(e){var t=this,r=L(t),n=r.resolve,o=r.reject,l=x(function(){var r=[],l=0,a=1;y(e,!1,function(e){var s=l++,i=!1;r.push(void 0),a++,t.resolve(e).then(function(e){i||(i=!0,r[s]=e,--a||n(r))},o)}),--a||n(r)});return l.e&&o(l.v),r.promise},race:function(e){var t=this,r=L(t),n=r.reject,o=x(function(){y(e,!1,function(e){t.resolve(e).then(r.resolve,n)})});return o.e&&n(o.v),r.promise}})},function(e,t,r){var n=r(3),o=r(62).set,l=n.MutationObserver||n.WebKitMutationObserver,a=n.process,s=n.Promise,i='process'==r(30)(a);e.exports=function(){var t,r,c,e=function(){var e,n;for(i&&(e=a.domain)&&e.exit();t;){n=t.fn,t=t.next;try{n()}catch(n){throw t?c():r=void 0,n}}r=void 0,e&&e.enter()};if(i)c=function(){a.nextTick(e)};else if(l&&!(n.navigator&&n.navigator.standalone)){var p=!0,d=document.createTextNode('');new l(e).observe(d,{characterData:!0}),c=function(){d.data=p=!p}}else if(s&&s.resolve){var u=s.resolve(void 0);c=function(){u.then(e)}}else c=function(){o.call(n,e)};return function(e){var n={fn:e,next:void 0};r&&(r.next=n),t||(t=n,c()),r=n}}},function(e){e.exports=function(e){try{return{e:!1,v:e()}}catch(t){return{e:!0,v:t}}}},function(e,t,r){var n=r(2),o=r(1),l=r(86);e.exports=function(e,t){if(n(e),o(t)&&t.constructor===e)return t;var r=l.f(e),a=r.resolve;return a(t),r.promise}},function(e,t,r){'use strict';var n=r(3),o=r(10),l=r(8),a=r(0),s=r(17),c=r(19).KEY,i=r(5),p=r(41),d=r(32),u=r(22),g=r(4),h=r(87),y=r(140),f=r(141),m=r(75),E=r(2),_=r(1),x=r(11),S=r(36),T=r(21),b=r(38),P=r(88),O=r(16),v=r(7),I=r(26),A=O.f,R=v.f,L=P.f,F=n.Symbol,N=n.JSON,w=N&&N.stringify,M='prototype',C=g('_hidden'),D=g('toPrimitive'),Y={}.propertyIsEnumerable,B=p('symbol-registry'),G=p('symbols'),U=p('op-symbols'),H=Object[M],W='function'==typeof F,V=n.QObject,z=!V||!V[M]||!V[M].findChild,$=l&&i(function(){return 7!=b(R({},'a',{get:function(){return R(this,'a',{value:7}).a}})).a})?function(e,t,r){var n=A(H,t);n&&delete H[t],R(e,t,r),n&&e!==H&&R(H,t,n)}:R,K=function(e){var t=G[e]=b(F[M]);return t._k=e,t},q=W&&'symbol'==typeof F.iterator?function(e){return'symbol'==typeof e}:function(e){return e instanceof F},X=function(e,t,r){return e===H&&X(U,t,r),E(e),t=S(t,!0),E(r),o(G,t)?(r.enumerable?(o(e,C)&&e[C][t]&&(e[C][t]=!1),r=b(r,{enumerable:T(0,!1)})):(!o(e,C)&&R(e,C,T(1,{})),e[C][t]=!0),$(e,t,r)):R(e,t,r)},Z=function(e,t){E(e);for(var r,n=f(t=x(t)),o=0,a=n.length;a>o;)X(e,r=n[o++],t[r]);return e},J=function(e){var t=Y.call(this,e=S(e,!0));return this===H&&o(G,e)&&!o(U,e)?!1:t||!o(this,e)||!o(G,e)||o(this,C)&&this[C][e]?t:!0},Q=function(e,t){if(e=x(e),t=S(t,!0),e!==H||!o(G,t)||o(U,t)){var r=A(e,t);return r&&o(G,t)&&!(o(e,C)&&e[C][t])&&(r.enumerable=!0),r}},ee=function(e){for(var t,r=L(x(e)),n=[],l=0;r.length>l;)o(G,t=r[l++])||t==C||t==c||n.push(t);return n},te=function(e){for(var t,r=e===H,n=L(r?U:x(e)),l=[],a=0;n.length>a;)o(G,t=n[a++])&&(!r||o(H,t))&&l.push(G[t]);return l};W||(F=function(){if(this instanceof F)throw TypeError('Symbol is not a constructor!');var e=u(0<arguments.length?arguments[0]:void 0),t=function(r){this===H&&t.call(U,r),o(this,C)&&o(this[C],e)&&(this[C][e]=!1),$(this,e,T(1,r))};return l&&z&&$(H,e,{configurable:!0,set:t}),K(e)},s(F[M],'toString',function(){return this._k}),O.f=Q,v.f=X,r(37).f=P.f=ee,r(40).f=J,r(48).f=te,l&&!r(23)&&s(H,'propertyIsEnumerable',J,!0),h.f=function(e){return K(g(e))}),a(a.G+a.W+a.F*!W,{Symbol:F});for(var re=['hasInstance','isConcatSpreadable','iterator','match','replace','search','species','split','toPrimitive','toStringTag','unscopables'],ne=0;re.length>ne;)g(re[ne++]);for(var j=I(g.store),oe=0;j.length>oe;)y(j[oe++]);a(a.S+a.F*!W,'Symbol',{for:function(e){return o(B,e+='')?B[e]:B[e]=F(e)},keyFor:function(e){if(!q(e))throw TypeError(e+' is not a symbol!');for(var t in B)if(B[t]===e)return t},useSetter:function(){z=!0},useSimple:function(){z=!1}}),a(a.S+a.F*!W,'Object',{create:function(e,t){return t===void 0?b(e):Z(b(e),t)},defineProperty:X,defineProperties:Z,getOwnPropertyDescriptor:Q,getOwnPropertyNames:ee,getOwnPropertySymbols:te}),N&&a(a.S+a.F*(!W||i(function(){var e=F();return'[null]'!=w([e])||'{}'!=w({a:e})||'{}'!=w(Object(e))})),'JSON',{stringify:function(e){for(var t,r,n=[e],o=1;arguments.length>o;)n.push(arguments[o++]);if(r=t=n[1],(_(t)||void 0!==e)&&!q(e))return m(t)||(t=function(e,t){if('function'==typeof r&&(t=r.call(this,e,t)),!q(t))return t}),n[1]=t,w.apply(N,n)}}),F[M][D]||r(9)(F[M],D,F[M].valueOf),d(F,'Symbol'),d(Math,'Math',!0),d(n.JSON,'JSON',!0)},function(e,t,r){var n=r(3),o=r(20),l=r(23),a=r(87),s=r(7).f;e.exports=function(e){var t=o.Symbol||(o.Symbol=l?{}:n.Symbol||{});'_'==e.charAt(0)||e in t||s(t,e,{value:a.f(e)})}},function(e,t,r){var n=r(26),o=r(48),l=r(40);e.exports=function(e){var t=n(e),r=o.f;if(r)for(var a,s=r(e),c=l.f,p=0;s.length>p;)c.call(e,a=s[p++])&&t.push(a);return t}},function(e,t,r){var n=r(1),o=r(19).onFreeze;r(13)('freeze',function(e){return function(t){return e&&n(t)?e(o(t)):t}})},function(e,t,r){var n=r(1),o=r(19).onFreeze;r(13)('seal',function(e){return function(t){return e&&n(t)?e(o(t)):t}})},function(e,t,r){var n=r(1),o=r(19).onFreeze;r(13)('preventExtensions',function(e){return function(t){return e&&n(t)?e(o(t)):t}})},function(e,t,r){var n=r(1);r(13)('isFrozen',function(e){return function(t){return!n(t)||!!e&&e(t)}})},function(e,t,r){var n=r(1);r(13)('isSealed',function(e){return function(t){return!n(t)||!!e&&e(t)}})},function(e,t,r){var n=r(1);r(13)('isExtensible',function(e){return function(t){return!!n(t)&&(!e||e(t))}})},function(e,t,r){var n=r(11),o=r(16).f;r(13)('getOwnPropertyDescriptor',function(){return function(e,t){return o(n(e),t)}})},function(e,t,r){var n=r(12),o=r(34);r(13)('getPrototypeOf',function(){return function(e){return o(n(e))}})},function(e,t,r){var n=r(12),o=r(26);r(13)('keys',function(){return function(e){return o(n(e))}})},function(e,t,r){r(13)('getOwnPropertyNames',function(){return r(88).f})},function(e,t,r){var n=r(0);n(n.S+n.F,'Object',{assign:r(82)})},function(e,t,r){var n=r(0);n(n.S,'Object',{is:r(89)})},function(e,t,r){var n=r(7).f,o=Function.prototype,l=/^\\s*function ([^ (]*)/,a='name';a in o||r(8)&&n(o,a,{configurable:!0,get:function(){try{return(''+this).match(l)[1]}catch(t){return''}}})},function(e,t,r){var n=r(0),o=r(11),l=r(6);n(n.S,'String',{raw:function(e){for(var t=o(e.raw),r=l(t.length),n=arguments.length,a=[],s=0;r>s;)a.push(t[s++]+''),s<n&&a.push(arguments[s]+'');return a.join('')}})},function(e,r,n){var o=n(0),l=n(31),a=t,s=String.fromCodePoint;o(o.S+o.F*(!!s&&1!=s.length),'String',{fromCodePoint:function(){for(var e,t=[],r=arguments.length,n=0;r>n;){if(e=+arguments[n++],l(e,1114111)!==e)throw RangeError(e+' is not a valid code point');t.push(65536>e?a(e):a(((e-=65536)>>10)+55296,e%1024+56320))}return t.join('')}})},function(e,t,r){'use strict';var n=r(0),o=r(90)(!1);n(n.P,'String',{codePointAt:function(e){return o(this,e)}})},function(e,t,r){var n=r(0);n(n.P,'String',{repeat:r(91)})},function(e,t,r){'use strict';var n=r(0),o=r(6),l=r(63),a='startsWith',s=''[a];n(n.P+n.F*r(64)(a),'String',{startsWith:function(e){var t=l(this,e,a),r=o(d(1<arguments.length?arguments[1]:void 0,t.length)),n=e+'';return t.slice(r,r+n.length)===n}})},function(e,t,r){'use strict';var n=r(0),o=r(6),l=r(63),a='endsWith',s=''[a];n(n.P+n.F*r(64)(a),'String',{endsWith:function(e){var t=l(this,e,a),r=1<arguments.length?arguments[1]:void 0,n=o(t.length),s=r===void 0?n:d(o(r),n),i=e+'';return t.slice(s-i.length,s)===i}})},function(e,t,r){'use strict';var n=r(0),o=r(63),l='includes';n(n.P+n.F*r(64)(l),'String',{includes:function(e){return!!~o(this,e,l).indexOf(e,1<arguments.length?arguments[1]:void 0)}})},function(e,t,r){r(8)&&'g'!=/./g.flags&&r(7).f(RegExp.prototype,'flags',{configurable:!0,get:r(93)})},function(e,t,r){'use strict';var o=r(2),l=r(6),a=r(65),s=r(50);r(51)('match',1,function(e,t,r,i){return[function(r){var n=e(this),o=r==void 0?void 0:r[t];return o===void 0?new RegExp(r)[t](n+''):o.call(r,n)},function(e){var t=i(r,e,this);if(t.done)return t.value;var c=o(e),p=this+'';if(!c.global)return s(c,p);var d=c.unicode;c.lastIndex=0;for(var u,g=[],h=0;null!==(u=s(c,p));){var n=u[0]+'';g[h]=n,''===n&&(c.lastIndex=a(p,l(c.lastIndex),d)),h++}return 0==h?null:g}]})},function(e,t,r){'use strict';var n=r(66);r(0)({target:'RegExp',proto:!0,forced:n!==/./.exec},{exec:n})},function(e,t,r){'use strict';var n=r(2),o=r(12),l=r(6),a=r(18),s=r(65),c=r(50),u=/\\$([$&`']|\\d\\d?|<[^>]*>)/g,g=/\\$([$&`']|\\d\\d?)/g,h=function(e){return e===void 0?e:e+''};r(51)('replace',2,function(e,t,r,y){function f(e,t,l,a,s,n){var i=l+e.length,c=a.length,d=g;return void 0!==s&&(s=o(s),d=u),r.call(n,d,function(r,o){var d;switch(o.charAt(0)){case'$':return'$';case'&':return e;case'`':return t.slice(0,l);case'\\'':return t.slice(i);case'<':d=s[o.slice(1,-1)];break;default:var u=+o;if(0==u)return r;if(u>c){var n=p(u/10);return 0===n?r:n<=c?void 0===a[n-1]?o.charAt(1):a[n-1]+o.charAt(1):r}d=a[u-1];}return void 0===d?'':d})}return[function(n,o){var l=e(this),a=n==void 0?void 0:n[t];return a===void 0?r.call(l+'',n,o):a.call(n,l,o)},function(e,t){var o=y(r,e,this,t);if(o.done)return o.value;var p=n(e),u=this+'',g='function'==typeof t;g||(t=t+'');var m=p.global;if(m){var E=p.unicode;p.lastIndex=0}for(var _,x=[];(_=c(p,u),null!==_)&&!(x.push(_),!m);){var S=_[0]+'';''===S&&(p.lastIndex=s(u,l(p.lastIndex),E))}for(var T='',b=0,P=0;P<x.length;P++){_=x[P];for(var O=_[0]+'',v=i(d(a(_.index),u.length),0),I=[],A=1;A<_.length;A++)I.push(h(_[A]));var R=_.groups;if(g){var k=[O].concat(I,v,u);R!==void 0&&k.push(R);var L=t.apply(void 0,k)+''}else L=f(O,u,v,I,R,t);v>=b&&(T+=u.slice(b,v)+L,b=v+O.length)}return T+u.slice(b)}]})},function(e,t,r){'use strict';var n=r(92),o=r(2),l=r(42),a=r(65),s=r(6),c=r(50),i=r(66),p=r(5),u=[].push,g='split',h='length',y='lastIndex',f=4294967295,m=!p(function(){RegExp(f,'y')});r(51)('split',2,function(e,t,r,E){var _;return _='c'=='abbc'[g](/(b)*/)[1]||4!='test'[g](/(?:)/,-1)[h]||2!='ab'[g](/(?:ab)*/)[h]||4!='.'[g](/(.?)(.?)/)[h]||1<'.'[g](/()()/)[h]||''[g](/.?/)[h]?function(e,t){var o=this+'';if(void 0===e&&0===t)return[];if(!n(e))return r.call(o,e,t);for(var l,a,s,c=[],p=(e.ignoreCase?'i':'')+(e.multiline?'m':'')+(e.unicode?'u':'')+(e.sticky?'y':''),d=0,g=void 0===t?f:t>>>0,m=new RegExp(e.source,p+'g');(l=i.call(m,o))&&(a=m[y],!(a>d&&(c.push(o.slice(d,l.index)),1<l[h]&&l.index<o[h]&&u.apply(c,l.slice(1)),s=l[0][h],d=a,c[h]>=g)));)m[y]===l.index&&m[y]++;return d===o[h]?(s||!m.test(''))&&c.push(''):c.push(o.slice(d)),c[h]>g?c.slice(0,g):c}:'0'[g](void 0,0)[h]?function(e,t){return void 0===e&&0===t?[]:r.call(this,e,t)}:r,[function(r,n){var o=e(this),l=void 0==r?void 0:r[t];return void 0===l?_.call(o+'',r,n):l.call(r,o,n)},function(t,n){var u=E(_,t,this,n,_!==r);if(u.done)return u.value;var g=o(t),h=this+'',y=l(g,RegExp),x=g.unicode,S=(g.ignoreCase?'i':'')+(g.multiline?'m':'')+(g.unicode?'u':'')+(m?'y':'g'),T=new y(m?g:'^(?:'+g.source+')',S),b=void 0===n?f:n>>>0;if(0==b)return[];if(0===h.length)return null===c(T,h)?[h]:[];for(var P=0,p=0,O=[];p<h.length;){T.lastIndex=m?p:0;var v,e=c(T,m?h:h.slice(p));if(null===e||(v=d(s(T.lastIndex+(m?0:p)),h.length))===P)p=a(h,p,x);else{if(O.push(h.slice(P,p)),O.length===b)return O;for(var I=1;I<=e.length-1;I++)if(O.push(e[I]),O.length===b)return O;p=P=v}}return O.push(h.slice(P)),O}]})},function(e,t,r){'use strict';var n=r(2),o=r(89),l=r(50);r(51)('search',1,function(e,t,r,a){return[function(r){var n=e(this),o=r==void 0?void 0:r[t];return o===void 0?new RegExp(r)[t](n+''):o.call(r,n)},function(e){var t=a(r,e,this);if(t.done)return t.value;var s=n(e),i=this+'',c=s.lastIndex;o(c,0)||(s.lastIndex=0);var p=l(s,i);return o(s.lastIndex,c)||(s.lastIndex=c),null===p?-1:p.index}]})},function(e,t,r){'use strict';var n=r(14),o=r(0),l=r(12),a=r(80),s=r(59),i=r(6),c=r(67),p=r(60);o(o.S+o.F*!r(45)(function(e){Array.from(e)}),'Array',{from:function(e){var t,r,o,d,u=l(e),g='function'==typeof this?this:Array,h=arguments.length,y=1<h?arguments[1]:void 0,f=void 0!==y,m=0,E=p(u);if(f&&(y=n(y,2<h?arguments[2]:void 0,2)),void 0!=E&&!(g==Array&&s(E)))for(d=E.call(u),r=new g;!(o=d.next()).done;m++)c(r,m,f?a(d,y,[o.value,m],!0):o.value);else for(t=i(u.length),r=new g(t);t>m;m++)c(r,m,f?y(u[m],m):u[m]);return r.length=m,r}})},function(e,t,r){'use strict';var n=r(0),o=r(67);n(n.S+n.F*r(5)(function(){function e(){}return!(Array.of.call(e)instanceof e)}),'Array',{of:function(){for(var e=0,t=arguments.length,r=new('function'==typeof this?this:Array)(t);t>e;)o(r,e,arguments[e++]);return r.length=t,r}})},function(e,t,r){var n=r(0);n(n.P,'Array',{copyWithin:r(78)}),r(35)('copyWithin')},function(e,t,r){'use strict';var n=r(0),o=r(39)(5),l='find',a=!0;l in[]&&[,][l](function(){a=!1}),n(n.P+n.F*a,'Array',{find:function(e){return o(this,e,1<arguments.length?arguments[1]:void 0)}}),r(35)(l)},function(e,t,r){'use strict';var n=r(0),o=r(39)(6),l='findIndex',a=!0;l in[]&&[,][l](function(){a=!1}),n(n.P+n.F*a,'Array',{findIndex:function(e){return o(this,e,1<arguments.length?arguments[1]:void 0)}}),r(35)(l)},function(e,t,r){var n=r(0);n(n.P,'Array',{fill:r(58)}),r(35)('fill')},function(e,t,r){var n=r(0),o=r(3).isFinite;n(n.S,'Number',{isFinite:function(e){return'number'==typeof e&&o(e)}})},function(e,t,r){var n=r(0);n(n.S,'Number',{isInteger:r(94)})},function(e,t,r){var n=r(0),o=r(94);n(n.S,'Number',{isSafeInteger:function(e){return o(e)&&9007199254740991>=l(e)}})},function(e,t,r){var n=r(0);n(n.S,'Number',{isNaN:function(e){return e!=e}})},function(e,t,r){var n=r(0);n(n.S,'Number',{EPSILON:2.220446049250313e-16})},function(e,t,r){var n=r(0);n(n.S,'Number',{MIN_SAFE_INTEGER:-9007199254740991})},function(e,t,r){var n=r(0);n(n.S,'Number',{MAX_SAFE_INTEGER:9007199254740991})},function(t,o,l){var a=l(0),s=l(95),i=e,c=Math.acosh;a(a.S+a.F*!(c&&710==p(c(Number.MAX_VALUE))&&c(Infinity)==Infinity),'Math',{acosh:function(e){return 1>(e=+e)?NaN:94906265.62425156<e?n(e)+r:s(e-1+i(e-1)*i(e+1))}})},function(t,r,o){function l(t){return isFinite(t=+t)&&0!=t?0>t?-l(-t):n(t+e(t*t+1)):t}var a=o(0),s=Math.asinh;a(a.S+a.F*!(s&&0<1/s(0)),'Math',{asinh:l})},function(e,t,r){var o=r(0),l=Math.atanh;o(o.S+o.F*!(l&&0>1/l(-0)),'Math',{atanh:function(e){return 0==(e=+e)?e:n((1+e)/(1-e))/2}})},function(e,t,r){var n=r(0),a=r(68);n(n.S,'Math',{cbrt:function(e){return a(e=+e)*o(l(e),1/3)}})},function(e,t,r){var o=r(0);o(o.S,'Math',{clz32:function(e){return(e>>>=0)?31-p(n(e+0.5)*Math.LOG2E):32}})},function(e,t,r){var n=r(0),o=a;n(n.S,'Math',{cosh:function(e){return(o(e=+e)+o(-e))/2}})},function(e,t,r){var n=r(0),o=r(69);n(n.S+n.F*(o!=s),'Math',{expm1:o})},function(e,t,r){var n=r(0);n(n.S,'Math',{fround:r(189)})},function(e,t,r){var n=r(68),a=o,s=a(2,-52),i=a(2,-23),c=a(2,127)*(2-i),p=a(2,-126),d=function(e){return e+1/s-1/s};e.exports=Math.fround||function(e){var t,r,o=l(e),a=n(e);return o<p?a*d(o/p/i)*p*i:(t=(1+i/s)*o,r=t-(t-o),r>c||r!=r?a*Infinity:a*r)}},function(t,r,n){var o=n(0);o(o.S,'Math',{hypot:function(){for(var t,r,n=0,o=0,a=arguments.length,s=0;o<a;)t=l(arguments[o++]),s<t?(r=s/t,n=n*r*r+1,s=t):0<t?(r=t/s,n+=r*r):n+=t;return s==Infinity?Infinity:s*e(n)}})},function(e,t,r){var n=r(0),o=Math.imul;n(n.S+n.F*r(5)(function(){return-5!=o(4294967295,5)||2!=o.length}),'Math',{imul:function(e,t){var r=65535,n=+e,o=+t,l=r&n,a=r&o;return 0|l*a+((r&n>>>16)*a+l*(r&o>>>16)<<16>>>0)}})},function(e,t,r){var n=r(0);n(n.S,'Math',{log1p:r(95)})},function(e,t,r){var o=r(0);o(o.S,'Math',{log10:function(e){return n(e)*Math.LOG10E}})},function(e,t,o){var l=o(0);l(l.S,'Math',{log2:function(e){return n(e)/r}})},function(e,t,r){var n=r(0);n(n.S,'Math',{sign:r(68)})},function(e,t,r){var n=r(0),o=r(69),s=a;n(n.S+n.F*r(5)(function(){return!0}),'Math',{sinh:function(e){return 1>l(e=+e)?(o(e)-o(-e))/2:(s(e-1)-s(-e-1))*(Math.E/2)}})},function(e,t,r){var n=r(0),o=r(69),l=a;n(n.S,'Math',{tanh:function(e){var t=o(e=+e),r=o(-e);return t==Infinity?1:r==Infinity?-1:(t-r)/(l(e)+l(-e))}})},function(e,t,r){var n=r(0);n(n.S,'Math',{trunc:function(e){return(0<e?p:c)(e)}})},function(e,t,r){'use strict';var n=r(0),o=r(55)(!0);n(n.P,'Array',{includes:function(e){return o(this,e,1<arguments.length?arguments[1]:void 0)}}),r(35)('includes')},function(e,t,r){var n=r(0),o=r(96)(!1);n(n.S,'Object',{values:function(e){return o(e)}})},function(e,t,r){var n=r(0),o=r(96)(!0);n(n.S,'Object',{entries:function(e){return o(e)}})},function(e,t,r){var n=r(0),o=r(85),l=r(11),a=r(16),s=r(67);n(n.S,'Object',{getOwnPropertyDescriptors:function(e){for(var t,r,n=l(e),c=a.f,p=o(n),d={},u=0;p.length>u;)r=c(n,t=p[u++]),void 0!==r&&s(d,t,r);return d}})},function(e,t,r){'use strict';var n=r(0),o=r(97),l=r(49),a=/Version\\/10\\.\\d+(\\.\\d+)?( Mobile\\/\\w+)? Safari\\//.test(l);n(n.P+n.F*a,'String',{padStart:function(e){return o(this,e,1<arguments.length?arguments[1]:void 0,!0)}})},function(e,t,r){'use strict';var n=r(0),o=r(97),l=r(49),a=/Version\\/10\\.\\d+(\\.\\d+)?( Mobile\\/\\w+)? Safari\\//.test(l);n(n.P+n.F*a,'String',{padEnd:function(e){return o(this,e,1<arguments.length?arguments[1]:void 0,!1)}})},function(e,t,r){var n=r(3),o=r(0),l=r(49),a=[].slice,s=/MSIE .\\./.test(l),i=function(e){return function(t,r){var n=2<arguments.length,o=!!n&&a.call(arguments,2);return e(n?function(){('function'==typeof t?t:Function(t)).apply(this,o)}:t,r)}};o(o.G+o.B+o.F*s,{setTimeout:i(n.setTimeout),setInterval:i(n.setInterval)})},function(e,t,r){var n=r(0),o=r(62);n(n.G+n.B,{setImmediate:o.set,clearImmediate:o.clear})},function(e,t,r){for(var n=r(61),o=r(26),l=r(17),a=r(3),s=r(9),c=r(33),p=r(4),d=p('iterator'),u=p('toStringTag'),g=c.Array,h={CSSRuleList:!0,CSSStyleDeclaration:!1,CSSValueList:!1,ClientRectList:!1,DOMRectList:!1,DOMStringList:!1,DOMTokenList:!0,DataTransferItemList:!1,FileList:!1,HTMLAllCollection:!1,HTMLCollection:!1,HTMLFormElement:!1,HTMLSelectElement:!1,MediaList:!0,MimeTypeArray:!1,NamedNodeMap:!1,NodeList:!0,PaintRequestList:!1,Plugin:!1,PluginArray:!1,SVGLengthList:!1,SVGNumberList:!1,SVGPathSegList:!1,SVGPointList:!1,SVGStringList:!1,SVGTransformList:!1,SourceBufferList:!1,StyleSheetList:!0,TextTrackCueList:!1,TextTrackList:!1,TouchList:!1},y=o(h),f=0;f<y.length;f++){var i,m=y[f],E=h[m],_=a[m],x=_&&_.prototype;if(x&&(x[d]||s(x,d,g),x[u]||s(x,u,m),c[m]=g,E))for(i in n)x[i]||l(x,i,n[i],!0)}},function(e){!function(t){'use strict';function r(e,t,r,n){var l=t&&t.prototype instanceof o?t:o,a=Object.create(l.prototype),s=new g(n||[]);return a._invoke=c(e,r,s),a}function n(e,t,r){try{return{type:'normal',arg:e.call(t,r)}}catch(e){return{type:'throw',arg:e}}}function o(){}function l(){}function a(){}function s(e){['next','throw','return'].forEach(function(t){e[t]=function(e){return this._invoke(t,e)}})}function i(e){function t(r,o,l,a){var s=n(e[r],e,o);if('throw'===s.type)a(s.arg);else{var i=s.arg,c=i.value;return c&&'object'==typeof c&&m.call(c,'__await')?Promise.resolve(c.__await).then(function(e){t('next',e,l,a)},function(e){t('throw',e,l,a)}):Promise.resolve(c).then(function(e){i.value=e,l(i)},a)}}var r;this._invoke=function(e,n){function o(){return new Promise(function(r,o){t(e,n,r,o)})}return r=r?r.then(o,o):o()}}function c(e,t,r){var o=P;return function(l,a){if(o==v)throw new Error('Generator is already running');if(o==I){if('throw'===l)throw a;return y()}for(r.method=l,r.arg=a;;){var s=r.delegate;if(s){var i=p(s,r);if(i){if(i===A)continue;return i}}if('next'===r.method)r.sent=r._sent=r.arg;else if('throw'===r.method){if(o==P)throw o=I,r.arg;r.dispatchException(r.arg)}else'return'===r.method&&r.abrupt('return',r.arg);o=v;var c=n(e,t,r);if('normal'===c.type){if(o=r.done?I:O,c.arg===A)continue;return{value:c.arg,done:r.done}}'throw'===c.type&&(o=I,r.method='throw',r.arg=c.arg)}}}function p(e,t){var r=e.iterator[t.method];if(void 0===r){if(t.delegate=null,'throw'===t.method){if(e.iterator.return&&(t.method='return',t.arg=void 0,p(e,t),'throw'===t.method))return A;t.method='throw',t.arg=new TypeError('The iterator does not provide a \\'throw\\' method')}return A}var o=n(r,e.iterator,t.arg);if('throw'===o.type)return t.method='throw',t.arg=o.arg,t.delegate=null,A;var l=o.arg;if(!l)return t.method='throw',t.arg=new TypeError('iterator result is not an object'),t.delegate=null,A;if(l.done)t[e.resultName]=l.value,t.next=e.nextLoc,'return'!==t.method&&(t.method='next',t.arg=void 0);else return l;return t.delegate=null,A}function d(e){var t={tryLoc:e[0]};1 in e&&(t.catchLoc=e[1]),2 in e&&(t.finallyLoc=e[2],t.afterLoc=e[3]),this.tryEntries.push(t)}function u(e){var t=e.completion||{};t.type='normal',delete t.arg,e.completion=t}function g(e){this.tryEntries=[{tryLoc:'root'}],e.forEach(d,this),this.reset(!0)}function h(e){if(e){var t=e[_];if(t)return t.call(e);if('function'==typeof e.next)return e;if(!isNaN(e.length)){var r=-1,n=function t(){for(;++r<e.length;)if(m.call(e,r))return t.value=e[r],t.done=!1,t;return t.value=void 0,t.done=!0,t};return n.next=n}}return{next:y}}function y(){return{value:void 0,done:!0}}var f=Object.prototype,m=f.hasOwnProperty,E='function'==typeof Symbol?Symbol:{},_=E.iterator||'@@iterator',x=E.asyncIterator||'@@asyncIterator',S=E.toStringTag||'@@toStringTag',T='object'==typeof e,b=t.regeneratorRuntime;if(b)return void(T&&(e.exports=b));b=t.regeneratorRuntime=T?e.exports:{},b.wrap=r;var P='suspendedStart',O='suspendedYield',v='executing',I='completed',A={},R={};R[_]=function(){return this};var k=Object.getPrototypeOf,L=k&&k(k(h([])));L&&L!==f&&m.call(L,_)&&(R=L);var F=a.prototype=o.prototype=Object.create(R);l.prototype=F.constructor=a,a.constructor=l,a[S]=l.displayName='GeneratorFunction',b.isGeneratorFunction=function(e){var t='function'==typeof e&&e.constructor;return!!t&&(t===l||'GeneratorFunction'===(t.displayName||t.name))},b.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,a):(e.__proto__=a,!(S in e)&&(e[S]='GeneratorFunction')),e.prototype=Object.create(F),e},b.awrap=function(e){return{__await:e}},s(i.prototype),i.prototype[x]=function(){return this},b.AsyncIterator=i,b.async=function(e,t,n,o){var l=new i(r(e,t,n,o));return b.isGeneratorFunction(t)?l:l.next().then(function(e){return e.done?e.value:l.next()})},s(F),F[S]='Generator',F[_]=function(){return this},F.toString=function(){return'[object Generator]'},b.keys=function(e){var t=[];for(var r in e)t.push(r);return t.reverse(),function r(){for(;t.length;){var n=t.pop();if(n in e)return r.value=n,r.done=!1,r}return r.done=!0,r}},b.values=h,g.prototype={constructor:g,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method='next',this.arg=void 0,this.tryEntries.forEach(u),!e)for(var t in this)'t'===t.charAt(0)&&m.call(this,t)&&!isNaN(+t.slice(1))&&(this[t]=void 0)},stop:function(){this.done=!0;var e=this.tryEntries[0],t=e.completion;if('throw'===t.type)throw t.arg;return this.rval},dispatchException:function(e){function t(t,n){return l.type='throw',l.arg=e,r.next=t,n&&(r.method='next',r.arg=void 0),!!n}if(this.done)throw e;for(var r=this,n=this.tryEntries.length-1;0<=n;--n){var o=this.tryEntries[n],l=o.completion;if('root'===o.tryLoc)return t('end');if(o.tryLoc<=this.prev){var a=m.call(o,'catchLoc'),s=m.call(o,'finallyLoc');if(a&&s){if(this.prev<o.catchLoc)return t(o.catchLoc,!0);if(this.prev<o.finallyLoc)return t(o.finallyLoc)}else if(a){if(this.prev<o.catchLoc)return t(o.catchLoc,!0);}else if(!s)throw new Error('try statement without catch or finally');else if(this.prev<o.finallyLoc)return t(o.finallyLoc)}}},abrupt:function(e,t){for(var r,n=this.tryEntries.length-1;0<=n;--n)if(r=this.tryEntries[n],r.tryLoc<=this.prev&&m.call(r,'finallyLoc')&&this.prev<r.finallyLoc){var o=r;break}o&&('break'===e||'continue'===e)&&o.tryLoc<=t&&t<=o.finallyLoc&&(o=null);var l=o?o.completion:{};return l.type=e,l.arg=t,o?(this.method='next',this.next=o.finallyLoc,A):this.complete(l)},complete:function(e,t){if('throw'===e.type)throw e.arg;return'break'===e.type||'continue'===e.type?this.next=e.arg:'return'===e.type?(this.rval=this.arg=e.arg,this.method='return',this.next='end'):'normal'===e.type&&t&&(this.next=t),A},finish:function(e){for(var t,r=this.tryEntries.length-1;0<=r;--r)if(t=this.tryEntries[r],t.finallyLoc===e)return this.complete(t.completion,t.afterLoc),u(t),A},catch:function(e){for(var t,r=this.tryEntries.length-1;0<=r;--r)if(t=this.tryEntries[r],t.tryLoc===e){var n=t.completion;if('throw'===n.type){var o=n.arg;u(t)}return o}throw new Error('illegal catch attempt')},delegateYield:function(e,t,r){return this.delegate={iterator:h(e),resultName:t,nextLoc:r},'next'===this.method&&(this.arg=void 0),A}}}(function(){return this}()||Function('return this')())},function(e,t,r){'use strict';function n(e,t){if(!(e instanceof t))throw new TypeError('Cannot call a class as a function')}Object.defineProperty(t,'__esModule',{value:!0});var o=function(){function e(e,t){for(var r,n=0;n<t.length;n++)r=t[n],r.enumerable=r.enumerable||!1,r.configurable=!0,'value'in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),l=r(210),a=function(e){return e&&e.__esModule?e:{default:e}}(l),s=r(98),i=function(){function e(t){var r=t.send,o=t.file,l=t.reqId;n(this,e),this.send=r,this.file=o,this.reqId=l;var s=o.buffer;this.checksum=(0,a.default)(Array.from(s)),this.size=s.length}return o(e,[{key:'requestUpload',value:function(){var e=this.file,t=e.documentType,r=e.documentFormat,n=e.documentId,o=e.expirationDate,l=e.lifetimeValid,a=e.pageType,s=e.buffer,i=e.proof_of_ownership,c=e.document_issuing_country,p=Object.assign(this.file.passthrough||{},{document_upload:!0}),d={req_id:this.reqId,passthrough:p,document_upload:1,document_type:t,document_format:r.toUpperCase(),expiration_date:o,document_id:n,file_size:s.length,expected_checksum:this.checksum};a&&(d.page_type=a),l&&(d.lifetime_valid=l),i&&(d.proof_of_ownership=i),c&&(d.document_issuing_country=c),this.send(JSON.stringify(d))}},{key:'handleMessage',value:function(e){var t=e.error,r=e.document_upload,n=e.passthrough;if(t)return{warning:t.code,message:t.message,passthrough:n};var o=r.checksum,l=r.size,a=r.upload_id,i=r.call_type;if(!o)return void this.startBinaryUpload(Object.assign({},this.file,{uploadId:a,callType:i}));if(l!==this.size)throw(0,s.createError)('SizeMismatch','File size does not match',n);if(o!==this.checksum)throw(0,s.createError)('ChecksumMismatch','Checksum does not match',n);return{document_upload:r,passthrough:n}}},{key:'startBinaryUpload',value:function(e){for(var t=this,r=(0,s.addMetadata)((0,s.generateChunks)(e.buffer,e),e),n=function(e){return t.send(e)},o=0;o<r.length;o++)n(r[o],o,r)}}]),e}();t.default=i},function(e,t,r){(function(){var t=r(211),n=r(99).utf8,o=r(212),s=r(99).bin,l=function(e,r){e.constructor==String?r&&'binary'===r.encoding?e=s.stringToBytes(e):e=n.stringToBytes(e):o(e)?e=Array.prototype.slice.call(e,0):!Array.isArray(e)&&(e=e.toString());for(var p=t.bytesToWords(e),u=8*e.length,g=1732584193,a=-271733879,h=-1732584194,c=271733878,d=0;d<p.length;d++)p[d]=16711935&(p[d]<<8|p[d]>>>24)|4278255360&(p[d]<<24|p[d]>>>8);p[u>>>5]|=128<<u%32,p[(u+64>>>9<<4)+14]=u;for(var i=l._ff,y=l._gg,f=l._hh,m=l._ii,d=0;d<p.length;d+=16){var E=g,_=a,x=h,S=c;g=i(g,a,h,c,p[d+0],7,-680876936),c=i(c,g,a,h,p[d+1],12,-389564586),h=i(h,c,g,a,p[d+2],17,606105819),a=i(a,h,c,g,p[d+3],22,-1044525330),g=i(g,a,h,c,p[d+4],7,-176418897),c=i(c,g,a,h,p[d+5],12,1200080426),h=i(h,c,g,a,p[d+6],17,-1473231341),a=i(a,h,c,g,p[d+7],22,-45705983),g=i(g,a,h,c,p[d+8],7,1770035416),c=i(c,g,a,h,p[d+9],12,-1958414417),h=i(h,c,g,a,p[d+10],17,-42063),a=i(a,h,c,g,p[d+11],22,-1990404162),g=i(g,a,h,c,p[d+12],7,1804603682),c=i(c,g,a,h,p[d+13],12,-40341101),h=i(h,c,g,a,p[d+14],17,-1502002290),a=i(a,h,c,g,p[d+15],22,1236535329),g=y(g,a,h,c,p[d+1],5,-165796510),c=y(c,g,a,h,p[d+6],9,-1069501632),h=y(h,c,g,a,p[d+11],14,643717713),a=y(a,h,c,g,p[d+0],20,-373897302),g=y(g,a,h,c,p[d+5],5,-701558691),c=y(c,g,a,h,p[d+10],9,38016083),h=y(h,c,g,a,p[d+15],14,-660478335),a=y(a,h,c,g,p[d+4],20,-405537848),g=y(g,a,h,c,p[d+9],5,568446438),c=y(c,g,a,h,p[d+14],9,-1019803690),h=y(h,c,g,a,p[d+3],14,-187363961),a=y(a,h,c,g,p[d+8],20,1163531501),g=y(g,a,h,c,p[d+13],5,-1444681467),c=y(c,g,a,h,p[d+2],9,-51403784),h=y(h,c,g,a,p[d+7],14,1735328473),a=y(a,h,c,g,p[d+12],20,-1926607734),g=f(g,a,h,c,p[d+5],4,-378558),c=f(c,g,a,h,p[d+8],11,-2022574463),h=f(h,c,g,a,p[d+11],16,1839030562),a=f(a,h,c,g,p[d+14],23,-35309556),g=f(g,a,h,c,p[d+1],4,-1530992060),c=f(c,g,a,h,p[d+4],11,1272893353),h=f(h,c,g,a,p[d+7],16,-155497632),a=f(a,h,c,g,p[d+10],23,-1094730640),g=f(g,a,h,c,p[d+13],4,681279174),c=f(c,g,a,h,p[d+0],11,-358537222),h=f(h,c,g,a,p[d+3],16,-722521979),a=f(a,h,c,g,p[d+6],23,76029189),g=f(g,a,h,c,p[d+9],4,-640364487),c=f(c,g,a,h,p[d+12],11,-421815835),h=f(h,c,g,a,p[d+15],16,530742520),a=f(a,h,c,g,p[d+2],23,-995338651),g=m(g,a,h,c,p[d+0],6,-198630844),c=m(c,g,a,h,p[d+7],10,1126891415),h=m(h,c,g,a,p[d+14],15,-1416354905),a=m(a,h,c,g,p[d+5],21,-57434055),g=m(g,a,h,c,p[d+12],6,1700485571),c=m(c,g,a,h,p[d+3],10,-1894986606),h=m(h,c,g,a,p[d+10],15,-1051523),a=m(a,h,c,g,p[d+1],21,-2054922799),g=m(g,a,h,c,p[d+8],6,1873313359),c=m(c,g,a,h,p[d+15],10,-30611744),h=m(h,c,g,a,p[d+6],15,-1560198380),a=m(a,h,c,g,p[d+13],21,1309151649),g=m(g,a,h,c,p[d+4],6,-145523070),c=m(c,g,a,h,p[d+11],10,-1120210379),h=m(h,c,g,a,p[d+2],15,718787259),a=m(a,h,c,g,p[d+9],21,-343485551),g=g+E>>>0,a=a+_>>>0,h=h+x>>>0,c=c+S>>>0}return t.endian([g,a,h,c])};l._ff=function(e,r,o,l,a,i,s){var t=e+(r&o|~r&l)+(a>>>0)+s;return(t<<i|t>>>32-i)+r},l._gg=function(e,r,o,l,a,i,s){var t=e+(r&l|o&~l)+(a>>>0)+s;return(t<<i|t>>>32-i)+r},l._hh=function(e,r,o,l,a,i,s){var t=e+(r^o^l)+(a>>>0)+s;return(t<<i|t>>>32-i)+r},l._ii=function(e,r,o,l,a,i,s){var t=e+(o^(r|~l))+(a>>>0)+s;return(t<<i|t>>>32-i)+r},l._blocksize=16,l._digestsize=16,e.exports=function(e,r){if(e===void 0||null===e)throw new Error('Illegal argument '+e);var n=t.wordsToBytes(l(e,r));return r&&r.asBytes?n:r&&r.asString?s.bytesToString(n):t.bytesToHex(n)}})()},function(e){(function(){var t='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',r={rotl:function(e,t){return e<<t|e>>>32-t},rotr:function(e,t){return e<<32-t|e>>>t},endian:function(e){if(e.constructor==Number)return 16711935&r.rotl(e,8)|4278255360&r.rotl(e,24);for(var t=0;t<e.length;t++)e[t]=r.endian(e[t]);return e},randomBytes:function(e){for(var t=[];0<e;e--)t.push(p(256*Math.random()));return t},bytesToWords:function(e){for(var t=[],r=0,n=0;r<e.length;r++,n+=8)t[n>>>5]|=e[r]<<24-n%32;return t},wordsToBytes:function(e){for(var t=[],r=0;r<32*e.length;r+=8)t.push(255&e[r>>>5]>>>24-r%32);return t},bytesToHex:function(e){for(var t=[],r=0;r<e.length;r++)t.push((e[r]>>>4).toString(16)),t.push((15&e[r]).toString(16));return t.join('')},hexToBytes:function(e){for(var t=[],r=0;r<e.length;r+=2)t.push(parseInt(e.substr(r,2),16));return t},bytesToBase64:function(e){for(var r,n=[],o=0;o<e.length;o+=3){r=e[o]<<16|e[o+1]<<8|e[o+2];for(var l=0;4>l;l++)8*o+6*l<=8*e.length?n.push(t.charAt(63&r>>>6*(3-l))):n.push('=')}return n.join('')},base64ToBytes:function(e){e=e.replace(/[^A-Z0-9+\\/]/ig,'');for(var r=[],n=0,l=0;n<e.length;l=++n%4)0!=l&&r.push((t.indexOf(e.charAt(n-1))&o(2,-2*l+8)-1)<<2*l|t.indexOf(e.charAt(n))>>>6-2*l);return r}};e.exports=r})()},function(e){function t(e){return!!e.constructor&&'function'==typeof e.constructor.isBuffer&&e.constructor.isBuffer(e)}function r(e){return'function'==typeof e.readFloatLE&&'function'==typeof e.slice&&t(e.slice(0,0))}e.exports=function(e){return null!=e&&(t(e)||r(e)||!!e._isBuffer)}}])['default']});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiaW5hcnktY29tL2JpbmFyeS1kb2N1bWVudC11cGxvYWRlci9Eb2N1bWVudFVwbG9hZGVyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiaW5hcnktY29tL2JpbmFyeS1kb2N1bWVudC11cGxvYWRlci9Eb2N1bWVudFVwbG9hZGVyLmpzPzYyMjQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKGUsdCl7J29iamVjdCc9PXR5cGVvZiBleHBvcnRzJiYnb2JqZWN0Jz09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6J2Z1bmN0aW9uJz09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sdCk6J29iamVjdCc9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMuRG9jdW1lbnRVcGxvYWRlcj10KCk6ZS5Eb2N1bWVudFVwbG9hZGVyPXQoKX0pKHRoaXMsZnVuY3Rpb24oKXt2YXIgZT1NYXRoLnNxcnQsdD1TdHJpbmcuZnJvbUNoYXJDb2RlLHI9TWF0aC5MTjIsbj1NYXRoLmxvZyxvPU1hdGgucG93LGw9TWF0aC5hYnMsYT1NYXRoLmV4cCxzPU1hdGguZXhwbTEsaT1NYXRoLm1heCxjPU1hdGguY2VpbCxwPU1hdGguZmxvb3IsZD1NYXRoLm1pbjtyZXR1cm4gZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChuKXtpZihyW25dKXJldHVybiByW25dLmV4cG9ydHM7dmFyIG89cltuXT17aTpuLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbbl0uY2FsbChvLmV4cG9ydHMsbyxvLmV4cG9ydHMsdCksby5sPSEwLG8uZXhwb3J0c312YXIgcj17fTtyZXR1cm4gdC5tPWUsdC5jPXIsdC5kPWZ1bmN0aW9uKGUscixuKXt0Lm8oZSxyKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscix7Y29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITAsZ2V0Om59KX0sdC5uPWZ1bmN0aW9uKGUpe3ZhciByPWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlWydkZWZhdWx0J119OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiB0LmQociwnYScscikscn0sdC5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSx0LnA9JycsdCh0LnM9MTAwKX0oW2Z1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDMpLG89cigyMCksbD1yKDkpLGE9cigxNykscz1yKDE0KSxpPSdwcm90b3R5cGUnLGM9ZnVuY3Rpb24oZSx0LHIpe3ZhciBwLGQsdSxnLGg9ZSZjLkYseT1lJmMuRyxmPWUmYy5TLG09ZSZjLlAsRT1lJmMuQixfPXk/bjpmP25bdF18fChuW3RdPXt9KTooblt0XXx8e30pW2ldLHg9eT9vOm9bdF18fChvW3RdPXt9KSxTPXhbaV18fCh4W2ldPXt9KTtmb3IocCBpbiB5JiYocj10KSxyKWQ9IWgmJl8mJnZvaWQgMCE9PV9bcF0sdT0oZD9fOnIpW3BdLGc9RSYmZD9zKHUsbik6bSYmJ2Z1bmN0aW9uJz09dHlwZW9mIHU/cyhGdW5jdGlvbi5jYWxsLHUpOnUsXyYmYShfLHAsdSxlJmMuVSkseFtwXSE9dSYmbCh4LHAsZyksbSYmU1twXSE9dSYmKFNbcF09dSl9O24uY29yZT1vLGMuRj0xLGMuRz0yLGMuUz00LGMuUD04LGMuQj0xNixjLlc9MzIsYy5VPTY0LGMuUj0xMjgsZS5leHBvcnRzPWN9LGZ1bmN0aW9uKGUpe2UuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4nb2JqZWN0Jz09dHlwZW9mIGU/bnVsbCE9PWU6J2Z1bmN0aW9uJz09dHlwZW9mIGV9fSxmdW5jdGlvbihlLHQscil7dmFyIG49cigxKTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7aWYoIW4oZSkpdGhyb3cgVHlwZUVycm9yKGUrJyBpcyBub3QgYW4gb2JqZWN0IScpO3JldHVybiBlfX0sZnVuY3Rpb24oZSl7dmFyIHQ9ZS5leHBvcnRzPSd1bmRlZmluZWQnIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cuTWF0aD09TWF0aD93aW5kb3c6J3VuZGVmaW5lZCchPXR5cGVvZiBzZWxmJiZzZWxmLk1hdGg9PU1hdGg/c2VsZjpGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpOydudW1iZXInPT10eXBlb2YgX19nJiYoX19nPXQpfSxmdW5jdGlvbihlLHQscil7dmFyIG49cig0MSkoJ3drcycpLG89cigyMiksbD1yKDMpLlN5bWJvbCxhPSdmdW5jdGlvbic9PXR5cGVvZiBsLHM9ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBuW2VdfHwobltlXT1hJiZsW2VdfHwoYT9sOm8pKCdTeW1ib2wuJytlKSl9O3Muc3RvcmU9bn0sZnVuY3Rpb24oZSl7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3RyeXtyZXR1cm4hIWUoKX1jYXRjaCh0KXtyZXR1cm4hMH19fSxmdW5jdGlvbihlLHQscil7dmFyIG49cigxOCk7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiAwPGU/ZChuKGUpLDkwMDcxOTkyNTQ3NDA5OTEpOjB9fSxmdW5jdGlvbihlLHQscil7dmFyIG49cigyKSxvPXIoNzApLGw9cigzNiksYT1PYmplY3QuZGVmaW5lUHJvcGVydHk7dC5mPXIoOCk/T2JqZWN0LmRlZmluZVByb3BlcnR5OmZ1bmN0aW9uKGUsdCxyKXtpZihuKGUpLHQ9bCh0LCEwKSxuKHIpLG8pdHJ5e3JldHVybiBhKGUsdCxyKX1jYXRjaCh0KXt9aWYoJ2dldCdpbiByfHwnc2V0J2luIHIpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtyZXR1cm4ndmFsdWUnaW4gciYmKGVbdF09ci52YWx1ZSksZX19LGZ1bmN0aW9uKGUsdCxyKXtlLmV4cG9ydHM9IXIoNSkoZnVuY3Rpb24oKXtyZXR1cm4gNyE9T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCdhJyx7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDd9fSkuYX0pfSxmdW5jdGlvbihlLHQscil7dmFyIG49cig3KSxvPXIoMjEpO2UuZXhwb3J0cz1yKDgpP2Z1bmN0aW9uKGUsdCxyKXtyZXR1cm4gbi5mKGUsdCxvKDEscikpfTpmdW5jdGlvbihlLHQscil7cmV0dXJuIGVbdF09cixlfX0sZnVuY3Rpb24oZSl7dmFyIHQ9e30uaGFzT3duUHJvcGVydHk7ZS5leHBvcnRzPWZ1bmN0aW9uKGUscil7cmV0dXJuIHQuY2FsbChlLHIpfX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoNTQpLG89cigyNSk7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBuKG8oZSkpfX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMjUpO2UuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4gT2JqZWN0KG4oZSkpfX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMCksbz1yKDIwKSxsPXIoNSk7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7dmFyIHI9KG8uT2JqZWN0fHx7fSlbZV18fE9iamVjdFtlXSxhPXt9O2FbZV09dChyKSxuKG4uUytuLkYqbChmdW5jdGlvbigpe3IoMSl9KSwnT2JqZWN0JyxhKX19LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDI0KTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0LHIpe3JldHVybihuKGUpLHZvaWQgMD09PXQpP2U6MT09PXI/ZnVuY3Rpb24ocil7cmV0dXJuIGUuY2FsbCh0LHIpfToyPT09cj9mdW5jdGlvbihyLG4pe3JldHVybiBlLmNhbGwodCxyLG4pfTozPT09cj9mdW5jdGlvbihyLG4sbyl7cmV0dXJuIGUuY2FsbCh0LHIsbixvKX06ZnVuY3Rpb24oKXtyZXR1cm4gZS5hcHBseSh0LGFyZ3VtZW50cyl9fX0sZnVuY3Rpb24oZSx0LHIpeyd1c2Ugc3RyaWN0JztpZihyKDgpKXt2YXIgbj1yKDIzKSxvPXIoMyksbD1yKDUpLGE9cigwKSxzPXIoNTMpLGk9cig3MSksYz1yKDE0KSxkPXIoMjkpLHU9cigyMSksZz1yKDkpLGg9cigyOCkseT1yKDE4KSxmPXIoNiksbT1yKDcyKSxFPXIoMzEpLF89cigzNikseD1yKDEwKSxTPXIoNDQpLFQ9cigxKSxiPXIoMTIpLFA9cig1OSksdj1yKDM4KSxJPXIoMzQpLEE9cigzNykuZixSPXIoNjApLE89cigyMiksaz1yKDQpLEw9cigzOSksRj1yKDU1KSxOPXIoNDIpLHc9cig2MSksTT1yKDMzKSxEPXIoNDUpLEM9cig0Myksaj1yKDU4KSxZPXIoNzgpLEI9cig3KSxHPXIoMTYpLFU9Qi5mLEg9Ry5mLFc9by5SYW5nZUVycm9yLFY9by5UeXBlRXJyb3Isej1vLlVpbnQ4QXJyYXksJD0nQXJyYXlCdWZmZXInLEs9J1NoYXJlZCcrJCxxPSdCWVRFU19QRVJfRUxFTUVOVCcsWD0ncHJvdG90eXBlJyxaPUFycmF5W1hdLEo9aS5BcnJheUJ1ZmZlcixRPWkuRGF0YVZpZXcsZWU9TCgwKSx0ZT1MKDIpLHJlPUwoMyksbmU9TCg0KSxvZT1MKDUpLGxlPUwoNiksYWU9RighMCksc2U9RighMSksaWU9dy52YWx1ZXMsY2U9dy5rZXlzLHBlPXcuZW50cmllcyxkZT1aLmxhc3RJbmRleE9mLHVlPVoucmVkdWNlLGdlPVoucmVkdWNlUmlnaHQsaGU9Wi5qb2luLHllPVouc29ydCxmZT1aLnNsaWNlLG1lPVoudG9TdHJpbmcsRWU9Wi50b0xvY2FsZVN0cmluZyxfZT1rKCdpdGVyYXRvcicpLHhlPWsoJ3RvU3RyaW5nVGFnJyksU2U9TygndHlwZWRfY29uc3RydWN0b3InKSxUZT1PKCdkZWZfY29uc3RydWN0b3InKSxiZT1zLkNPTlNUUixQZT1zLlRZUEVELE9lPXMuVklFVyx2ZT0nV3JvbmcgbGVuZ3RoIScsSWU9TCgxLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIEZlKE4oZSxlW1RlXSksdCl9KSxBZT1sKGZ1bmN0aW9uKCl7cmV0dXJuIDE9PT1uZXcgeihuZXcgVWludDE2QXJyYXkoWzFdKS5idWZmZXIpWzBdfSksUmU9ISF6JiYhIXpbWF0uc2V0JiZsKGZ1bmN0aW9uKCl7bmV3IHooMSkuc2V0KHt9KX0pLGtlPWZ1bmN0aW9uKGUsdCl7dmFyIHI9eShlKTtpZigwPnJ8fHIldCl0aHJvdyBXKCdXcm9uZyBvZmZzZXQhJyk7cmV0dXJuIHJ9LExlPWZ1bmN0aW9uKGUpe2lmKFQoZSkmJlBlIGluIGUpcmV0dXJuIGU7dGhyb3cgVihlKycgaXMgbm90IGEgdHlwZWQgYXJyYXkhJyl9LEZlPWZ1bmN0aW9uKGUsdCl7aWYoIShUKGUpJiZTZSBpbiBlKSl0aHJvdyBWKCdJdCBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvciEnKTtyZXR1cm4gbmV3IGUodCl9LE5lPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHdlKE4oZSxlW1RlXSksdCl9LHdlPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByPTAsbj10Lmxlbmd0aCxvPUZlKGUsbik7bj5yOylvW3JdPXRbcisrXTtyZXR1cm4gb30sTWU9ZnVuY3Rpb24oZSx0LHIpe1UoZSx0LHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZFtyXX19KX0sRGU9ZnVuY3Rpb24oZSl7dmFyIHQscixuLG8sbCxhLHM9YihlKSxpPWFyZ3VtZW50cy5sZW5ndGgscD0xPGk/YXJndW1lbnRzWzFdOnZvaWQgMCxkPXAhPT12b2lkIDAsdT1SKHMpO2lmKHUhPXZvaWQgMCYmIVAodSkpe2ZvcihhPXUuY2FsbChzKSxuPVtdLHQ9MDshKGw9YS5uZXh0KCkpLmRvbmU7dCsrKW4ucHVzaChsLnZhbHVlKTtzPW59Zm9yKGQmJjI8aSYmKHA9YyhwLGFyZ3VtZW50c1syXSwyKSksdD0wLHI9ZihzLmxlbmd0aCksbz1GZSh0aGlzLHIpO3I+dDt0Kyspb1t0XT1kP3Aoc1t0XSx0KTpzW3RdO3JldHVybiBvfSxDZT1mdW5jdGlvbigpe2Zvcih2YXIgZT0wLHQ9YXJndW1lbnRzLmxlbmd0aCxyPUZlKHRoaXMsdCk7dD5lOylyW2VdPWFyZ3VtZW50c1tlKytdO3JldHVybiByfSxqZT0hIXomJmwoZnVuY3Rpb24oKXtFZS5jYWxsKG5ldyB6KDEpKX0pLFllPWZ1bmN0aW9uKCl7cmV0dXJuIEVlLmFwcGx5KGplP2ZlLmNhbGwoTGUodGhpcykpOkxlKHRoaXMpLGFyZ3VtZW50cyl9LEJlPXtjb3B5V2l0aGluOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIFkuY2FsbChMZSh0aGlzKSxlLHQsMjxhcmd1bWVudHMubGVuZ3RoP2FyZ3VtZW50c1syXTp2b2lkIDApfSxldmVyeTpmdW5jdGlvbihlKXtyZXR1cm4gbmUoTGUodGhpcyksZSwxPGFyZ3VtZW50cy5sZW5ndGg/YXJndW1lbnRzWzFdOnZvaWQgMCl9LGZpbGw6ZnVuY3Rpb24oKXtyZXR1cm4gai5hcHBseShMZSh0aGlzKSxhcmd1bWVudHMpfSxmaWx0ZXI6ZnVuY3Rpb24oZSl7cmV0dXJuIE5lKHRoaXMsdGUoTGUodGhpcyksZSwxPGFyZ3VtZW50cy5sZW5ndGg/YXJndW1lbnRzWzFdOnZvaWQgMCkpfSxmaW5kOmZ1bmN0aW9uKGUpe3JldHVybiBvZShMZSh0aGlzKSxlLDE8YXJndW1lbnRzLmxlbmd0aD9hcmd1bWVudHNbMV06dm9pZCAwKX0sZmluZEluZGV4OmZ1bmN0aW9uKGUpe3JldHVybiBsZShMZSh0aGlzKSxlLDE8YXJndW1lbnRzLmxlbmd0aD9hcmd1bWVudHNbMV06dm9pZCAwKX0sZm9yRWFjaDpmdW5jdGlvbihlKXtlZShMZSh0aGlzKSxlLDE8YXJndW1lbnRzLmxlbmd0aD9hcmd1bWVudHNbMV06dm9pZCAwKX0saW5kZXhPZjpmdW5jdGlvbihlKXtyZXR1cm4gc2UoTGUodGhpcyksZSwxPGFyZ3VtZW50cy5sZW5ndGg/YXJndW1lbnRzWzFdOnZvaWQgMCl9LGluY2x1ZGVzOmZ1bmN0aW9uKGUpe3JldHVybiBhZShMZSh0aGlzKSxlLDE8YXJndW1lbnRzLmxlbmd0aD9hcmd1bWVudHNbMV06dm9pZCAwKX0sam9pbjpmdW5jdGlvbigpe3JldHVybiBoZS5hcHBseShMZSh0aGlzKSxhcmd1bWVudHMpfSxsYXN0SW5kZXhPZjpmdW5jdGlvbigpe3JldHVybiBkZS5hcHBseShMZSh0aGlzKSxhcmd1bWVudHMpfSxtYXA6ZnVuY3Rpb24oZSl7cmV0dXJuIEllKExlKHRoaXMpLGUsMTxhcmd1bWVudHMubGVuZ3RoP2FyZ3VtZW50c1sxXTp2b2lkIDApfSxyZWR1Y2U6ZnVuY3Rpb24oKXtyZXR1cm4gdWUuYXBwbHkoTGUodGhpcyksYXJndW1lbnRzKX0scmVkdWNlUmlnaHQ6ZnVuY3Rpb24oKXtyZXR1cm4gZ2UuYXBwbHkoTGUodGhpcyksYXJndW1lbnRzKX0scmV2ZXJzZTpmdW5jdGlvbigpe2Zvcih2YXIgZSx0PXRoaXMscj1MZSh0KS5sZW5ndGgsbj1wKHIvMiksbz0wO288bjspZT10W29dLHRbbysrXT10Wy0tcl0sdFtyXT1lO3JldHVybiB0fSxzb21lOmZ1bmN0aW9uKGUpe3JldHVybiByZShMZSh0aGlzKSxlLDE8YXJndW1lbnRzLmxlbmd0aD9hcmd1bWVudHNbMV06dm9pZCAwKX0sc29ydDpmdW5jdGlvbihlKXtyZXR1cm4geWUuY2FsbChMZSh0aGlzKSxlKX0sc3ViYXJyYXk6ZnVuY3Rpb24oZSx0KXt2YXIgcj1MZSh0aGlzKSxuPXIubGVuZ3RoLG89RShlLG4pO3JldHVybiBuZXcoTihyLHJbVGVdKSkoci5idWZmZXIsci5ieXRlT2Zmc2V0K28qci5CWVRFU19QRVJfRUxFTUVOVCxmKCh0PT09dm9pZCAwP246RSh0LG4pKS1vKSl9fSxHZT1mdW5jdGlvbihlLHQpe3JldHVybiBOZSh0aGlzLGZlLmNhbGwoTGUodGhpcyksZSx0KSl9LFVlPWZ1bmN0aW9uKGUpe0xlKHRoaXMpO3ZhciB0PWtlKGFyZ3VtZW50c1sxXSwxKSxyPXRoaXMubGVuZ3RoLG49YihlKSxvPWYobi5sZW5ndGgpLGw9MDtpZihvK3Q+cil0aHJvdyBXKHZlKTtmb3IoO2w8bzspdGhpc1t0K2xdPW5bbCsrXX0sSGU9e2VudHJpZXM6ZnVuY3Rpb24oKXtyZXR1cm4gcGUuY2FsbChMZSh0aGlzKSl9LGtleXM6ZnVuY3Rpb24oKXtyZXR1cm4gY2UuY2FsbChMZSh0aGlzKSl9LHZhbHVlczpmdW5jdGlvbigpe3JldHVybiBpZS5jYWxsKExlKHRoaXMpKX19LFdlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIFQoZSkmJmVbUGVdJiYnc3ltYm9sJyE9dHlwZW9mIHQmJnQgaW4gZSYmK3QrJyc9PXQrJyd9LFZlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIFdlKGUsdD1fKHQsITApKT91KDIsZVt0XSk6SChlLHQpfSx6ZT1mdW5jdGlvbihlLHQscil7cmV0dXJuIFdlKGUsdD1fKHQsITApKSYmVChyKSYmeChyLCd2YWx1ZScpJiYheChyLCdnZXQnKSYmIXgociwnc2V0JykmJiFyLmNvbmZpZ3VyYWJsZSYmKCF4KHIsJ3dyaXRhYmxlJyl8fHIud3JpdGFibGUpJiYoIXgociwnZW51bWVyYWJsZScpfHxyLmVudW1lcmFibGUpPyhlW3RdPXIudmFsdWUsZSk6VShlLHQscil9O2JlfHwoRy5mPVZlLEIuZj16ZSksYShhLlMrYS5GKiFiZSwnT2JqZWN0Jyx7Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOlZlLGRlZmluZVByb3BlcnR5OnplfSksbChmdW5jdGlvbigpe21lLmNhbGwoe30pfSkmJihtZT1FZT1mdW5jdGlvbigpe3JldHVybiBoZS5jYWxsKHRoaXMpfSk7dmFyICRlPWgoe30sQmUpO2goJGUsSGUpLGcoJGUsX2UsSGUudmFsdWVzKSxoKCRlLHtzbGljZTpHZSxzZXQ6VWUsY29uc3RydWN0b3I6ZnVuY3Rpb24oKXt9LHRvU3RyaW5nOm1lLHRvTG9jYWxlU3RyaW5nOlllfSksTWUoJGUsJ2J1ZmZlcicsJ2InKSxNZSgkZSwnYnl0ZU9mZnNldCcsJ28nKSxNZSgkZSwnYnl0ZUxlbmd0aCcsJ2wnKSxNZSgkZSwnbGVuZ3RoJywnZScpLFUoJGUseGUse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW1BlXX19KSxlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0LHIsaSl7aT0hIWk7dmFyIGM9ZSsoaT8nQ2xhbXBlZCc6JycpKydBcnJheScscD1vW2NdLHU9cHx8e30saD1wJiZJKHApLHk9IXB8fCFzLkFCVixFPXt9LF89cCYmcFtYXSx4PWZ1bmN0aW9uKHIsbil7dmFyIG89ci5fZDtyZXR1cm4gby52WydnZXQnK2VdKG4qdCtvLm8sQWUpfSxiPWZ1bmN0aW9uKHIsbixvKXt2YXIgbD1yLl9kO2kmJihvPTA+KG89TWF0aC5yb3VuZChvKSk/MDoyNTU8bz8yNTU6MjU1Jm8pLGwudlsnc2V0JytlXShuKnQrbC5vLG8sQWUpfSxQPWZ1bmN0aW9uKGUsdCl7VShlLHQse2dldDpmdW5jdGlvbigpe3JldHVybiB4KHRoaXMsdCl9LHNldDpmdW5jdGlvbihlKXtyZXR1cm4gYih0aGlzLHQsZSl9LGVudW1lcmFibGU6ITB9KX07eT8ocD1yKGZ1bmN0aW9uKGUscixuLG8pe2QoZSxwLGMsJ19kJyk7dmFyIGwsYSxzLGksdT0wLGg9MDtpZighVChyKSlzPW0ociksYT1zKnQsbD1uZXcgSihhKTtlbHNlIGlmKHIgaW5zdGFuY2VvZiBKfHwoaT1TKHIpKT09JHx8aT09Syl7bD1yLGg9a2Uobix0KTt2YXIgeT1yLmJ5dGVMZW5ndGg7aWYodm9pZCAwPT09byl7aWYoeSV0KXRocm93IFcodmUpO2lmKGE9eS1oLDA+YSl0aHJvdyBXKHZlKX1lbHNlIGlmKGE9ZihvKSp0LGEraD55KXRocm93IFcodmUpO3M9YS90fWVsc2UgcmV0dXJuIFBlIGluIHI/d2UocCxyKTpEZS5jYWxsKHAscik7Zm9yKGcoZSwnX2QnLHtiOmwsbzpoLGw6YSxlOnMsdjpuZXcgUShsKX0pO3U8czspUChlLHUrKyl9KSxfPXBbWF09digkZSksZyhfLCdjb25zdHJ1Y3RvcicscCkpOighbChmdW5jdGlvbigpe3AoMSl9KXx8IWwoZnVuY3Rpb24oKXtuZXcgcCgtMSl9KXx8IUQoZnVuY3Rpb24oZSl7bmV3IHAsbmV3IHAobnVsbCksbmV3IHAoMS41KSxuZXcgcChlKX0sITApKSYmKHA9cihmdW5jdGlvbihlLHIsbixvKXtkKGUscCxjKTt2YXIgbDtyZXR1cm4gVChyKT9yIGluc3RhbmNlb2YgSnx8KGw9UyhyKSk9PSR8fGw9PUs/dm9pZCAwPT09bz92b2lkIDA9PT1uP25ldyB1KHIpOm5ldyB1KHIsa2Uobix0KSk6bmV3IHUocixrZShuLHQpLG8pOlBlIGluIHI/d2UocCxyKTpEZS5jYWxsKHAscik6bmV3IHUobShyKSl9KSxlZShoPT09RnVuY3Rpb24ucHJvdG90eXBlP0EodSk6QSh1KS5jb25jYXQoQShoKSksZnVuY3Rpb24oZSl7ZSBpbiBwfHxnKHAsZSx1W2VdKX0pLHBbWF09XywhbiYmKF8uY29uc3RydWN0b3I9cCkpO3ZhciBPPV9bX2VdLFI9ISFPJiYoJ3ZhbHVlcyc9PU8ubmFtZXx8Ty5uYW1lPT12b2lkIDApLGs9SGUudmFsdWVzO2cocCxTZSwhMCksZyhfLFBlLGMpLGcoXyxPZSwhMCksZyhfLFRlLHApLChpP25ldyBwKDEpW3hlXSE9YzohKHhlIGluIF8pKSYmVShfLHhlLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gY319KSxFW2NdPXAsYShhLkcrYS5XK2EuRioocCE9dSksRSksYShhLlMsYyx7QllURVNfUEVSX0VMRU1FTlQ6dH0pLGEoYS5TK2EuRipsKGZ1bmN0aW9uKCl7dS5vZi5jYWxsKHAsMSl9KSxjLHtmcm9tOkRlLG9mOkNlfSkscSBpbiBffHxnKF8scSx0KSxhKGEuUCxjLEJlKSxDKGMpLGEoYS5QK2EuRipSZSxjLHtzZXQ6VWV9KSxhKGEuUCthLkYqIVIsYyxIZSksbnx8Xy50b1N0cmluZz09bWV8fChfLnRvU3RyaW5nPW1lKSxhKGEuUCthLkYqbChmdW5jdGlvbigpe25ldyBwKDEpLnNsaWNlKCl9KSxjLHtzbGljZTpHZX0pLGEoYS5QK2EuRioobChmdW5jdGlvbigpe3JldHVyblsxLDJdLnRvTG9jYWxlU3RyaW5nKCkhPW5ldyBwKFsxLDJdKS50b0xvY2FsZVN0cmluZygpfSl8fCFsKGZ1bmN0aW9uKCl7Xy50b0xvY2FsZVN0cmluZy5jYWxsKFsxLDJdKX0pKSxjLHt0b0xvY2FsZVN0cmluZzpZZX0pLE1bY109Uj9POmssbnx8Unx8ZyhfLF9lLGspfX1lbHNlIGUuZXhwb3J0cz1mdW5jdGlvbigpe319LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDQwKSxvPXIoMjEpLGw9cigxMSksYT1yKDM2KSxzPXIoMTApLGk9cig3MCksYz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO3QuZj1yKDgpP2M6ZnVuY3Rpb24oZSx0KXtpZihlPWwoZSksdD1hKHQsITApLGkpdHJ5e3JldHVybiBjKGUsdCl9Y2F0Y2godCl7fXJldHVybiBzKGUsdCk/byghbi5mLmNhbGwoZSx0KSxlW3RdKTp2b2lkIDB9fSxmdW5jdGlvbihlLHQscil7dmFyIG49cigzKSxvPXIoOSksbD1yKDEwKSxhPXIoMjIpKCdzcmMnKSxzPXIoMTAyKSxpPSd0b1N0cmluZycsYz0oJycrcykuc3BsaXQoaSk7cigyMCkuaW5zcGVjdFNvdXJjZT1mdW5jdGlvbihlKXtyZXR1cm4gcy5jYWxsKGUpfSwoZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxyLHMpe3ZhciBpPSdmdW5jdGlvbic9PXR5cGVvZiByO2kmJihsKHIsJ25hbWUnKXx8byhyLCduYW1lJyx0KSk7ZVt0XT09PXJ8fChpJiYobChyLGEpfHxvKHIsYSxlW3RdPycnK2VbdF06Yy5qb2luKHQrJycpKSksZT09PW4/ZVt0XT1yOnM/ZVt0XT9lW3RdPXI6byhlLHQscik6KGRlbGV0ZSBlW3RdLG8oZSx0LHIpKSl9KShGdW5jdGlvbi5wcm90b3R5cGUsaSxmdW5jdGlvbigpe3JldHVybidmdW5jdGlvbic9PXR5cGVvZiB0aGlzJiZ0aGlzW2FdfHxzLmNhbGwodGhpcyl9KX0sZnVuY3Rpb24oZSl7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBpc05hTihlPStlKT8wOigwPGU/cDpjKShlKX19LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDIyKSgnbWV0YScpLG89cigxKSxsPXIoMTApLGE9cig3KS5mLHM9MCxpPU9iamVjdC5pc0V4dGVuc2libGV8fGZ1bmN0aW9uKCl7cmV0dXJuITB9LGM9IXIoNSkoZnVuY3Rpb24oKXtyZXR1cm4gaShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKX0pLHA9ZnVuY3Rpb24oZSl7YShlLG4se3ZhbHVlOntpOidPJysgKytzLHc6e319fSl9LGQ9ZS5leHBvcnRzPXtLRVk6bixORUVEOiExLGZhc3RLZXk6ZnVuY3Rpb24oZSx0KXtpZighbyhlKSlyZXR1cm4nc3ltYm9sJz09dHlwZW9mIGU/ZTooJ3N0cmluZyc9PXR5cGVvZiBlPydTJzonUCcpK2U7aWYoIWwoZSxuKSl7aWYoIWkoZSkpcmV0dXJuJ0YnO2lmKCF0KXJldHVybidFJztwKGUpfXJldHVybiBlW25dLml9LGdldFdlYWs6ZnVuY3Rpb24oZSx0KXtpZighbChlLG4pKXtpZighaShlKSlyZXR1cm4hMDtpZighdClyZXR1cm4hMTtwKGUpfXJldHVybiBlW25dLnd9LG9uRnJlZXplOmZ1bmN0aW9uKGUpe3JldHVybiBjJiZkLk5FRUQmJmkoZSkmJiFsKGUsbikmJnAoZSksZX19fSxmdW5jdGlvbihlKXt2YXIgdD1lLmV4cG9ydHM9e3ZlcnNpb246JzIuNi41J307J251bWJlcic9PXR5cGVvZiBfX2UmJihfX2U9dCl9LGZ1bmN0aW9uKGUpe2UuZXhwb3J0cz1mdW5jdGlvbihlLHQpe3JldHVybntlbnVtZXJhYmxlOiEoMSZlKSxjb25maWd1cmFibGU6ISgyJmUpLHdyaXRhYmxlOiEoNCZlKSx2YWx1ZTp0fX19LGZ1bmN0aW9uKGUpe3ZhciB0PTAscj1NYXRoLnJhbmRvbSgpO2UuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4nU3ltYm9sKCcuY29uY2F0KGU9PT12b2lkIDA/Jyc6ZSwnKV8nLCgrK3QrcikudG9TdHJpbmcoMzYpKX19LGZ1bmN0aW9uKGUpe2UuZXhwb3J0cz0hMX0sZnVuY3Rpb24oZSl7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe2lmKCdmdW5jdGlvbichPXR5cGVvZiBlKXRocm93IFR5cGVFcnJvcihlKycgaXMgbm90IGEgZnVuY3Rpb24hJyk7cmV0dXJuIGV9fSxmdW5jdGlvbihlKXtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7aWYoZT09dm9pZCAwKXRocm93IFR5cGVFcnJvcignQ2FuXFwndCBjYWxsIG1ldGhvZCBvbiAgJytlKTtyZXR1cm4gZX19LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDczKSxvPXIoNTcpO2UuZXhwb3J0cz1PYmplY3Qua2V5c3x8ZnVuY3Rpb24oZSl7cmV0dXJuIG4oZSxvKX19LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDEpO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQpe2lmKCFuKGUpfHxlLl90IT09dCl0aHJvdyBUeXBlRXJyb3IoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyt0KycgcmVxdWlyZWQhJyk7cmV0dXJuIGV9fSxmdW5jdGlvbihlLHQscil7dmFyIG49cigxNyk7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxyKXtmb3IodmFyIG8gaW4gdCluKGUsbyx0W29dLHIpO3JldHVybiBlfX0sZnVuY3Rpb24oZSl7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxyLG4pe2lmKCEoZSBpbnN0YW5jZW9mIHQpfHxuIT09dm9pZCAwJiZuIGluIGUpdGhyb3cgVHlwZUVycm9yKHIrJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7cmV0dXJuIGV9fSxmdW5jdGlvbihlKXt2YXIgdD17fS50b1N0cmluZztlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuIHQuY2FsbChlKS5zbGljZSg4LC0xKX19LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDE4KTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT1uKGUpLDA+ZT9pKGUrdCwwKTpkKGUsdCl9fSxmdW5jdGlvbihlLHQscil7dmFyIG49cig3KS5mLG89cigxMCksbD1yKDQpKCd0b1N0cmluZ1RhZycpO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQscil7ZSYmIW8oZT1yP2U6ZS5wcm90b3R5cGUsbCkmJm4oZSxsLHtjb25maWd1cmFibGU6ITAsdmFsdWU6dH0pfX0sZnVuY3Rpb24oZSl7ZS5leHBvcnRzPXt9fSxmdW5jdGlvbihlLHQscil7dmFyIG49cigxMCksbz1yKDEyKSxsPXIoNTYpKCdJRV9QUk9UTycpLGE9T2JqZWN0LnByb3RvdHlwZTtlLmV4cG9ydHM9T2JqZWN0LmdldFByb3RvdHlwZU9mfHxmdW5jdGlvbihlKXtyZXR1cm4gZT1vKGUpLG4oZSxsKT9lW2xdOidmdW5jdGlvbic9PXR5cGVvZiBlLmNvbnN0cnVjdG9yJiZlIGluc3RhbmNlb2YgZS5jb25zdHJ1Y3Rvcj9lLmNvbnN0cnVjdG9yLnByb3RvdHlwZTplIGluc3RhbmNlb2YgT2JqZWN0P2E6bnVsbH19LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDQpKCd1bnNjb3BhYmxlcycpLG89QXJyYXkucHJvdG90eXBlO29bbl09PXZvaWQgMCYmcig5KShvLG4se30pLGUuZXhwb3J0cz1mdW5jdGlvbihlKXtvW25dW2VdPSEwfX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMSk7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7aWYoIW4oZSkpcmV0dXJuIGU7dmFyIHIsbztpZih0JiYnZnVuY3Rpb24nPT10eXBlb2Yocj1lLnRvU3RyaW5nKSYmIW4obz1yLmNhbGwoZSkpKXJldHVybiBvO2lmKCdmdW5jdGlvbic9PXR5cGVvZihyPWUudmFsdWVPZikmJiFuKG89ci5jYWxsKGUpKSlyZXR1cm4gbztpZighdCYmJ2Z1bmN0aW9uJz09dHlwZW9mKHI9ZS50b1N0cmluZykmJiFuKG89ci5jYWxsKGUpKSlyZXR1cm4gbzt0aHJvdyBUeXBlRXJyb3IoJ0NhblxcJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlJyl9fSxmdW5jdGlvbihlLHQscil7dmFyIG49cig3Myksbz1yKDU3KS5jb25jYXQoJ2xlbmd0aCcsJ3Byb3RvdHlwZScpO3QuZj1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc3x8ZnVuY3Rpb24oZSl7cmV0dXJuIG4oZSxvKX19LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDIpLG89cigxMDQpLGw9cig1NyksYT1yKDU2KSgnSUVfUFJPVE8nKSxzPWZ1bmN0aW9uKCl7fSxjPSdwcm90b3R5cGUnLHA9ZnVuY3Rpb24oKXt2YXIgZSx0PXIoNTIpKCdpZnJhbWUnKSxuPWwubGVuZ3RoLG89JzwnLGE9Jz4nO2Zvcih0LnN0eWxlLmRpc3BsYXk9J25vbmUnLHIoNzQpLmFwcGVuZENoaWxkKHQpLHQuc3JjPSdqYXZhc2NyaXB0OicsZT10LmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQsZS5vcGVuKCksZS53cml0ZShvKydzY3JpcHQnK2ErJ2RvY3VtZW50LkY9T2JqZWN0JytvKycvc2NyaXB0JythKSxlLmNsb3NlKCkscD1lLkY7bi0tOylkZWxldGUgcFtjXVtsW25dXTtyZXR1cm4gcCgpfTtlLmV4cG9ydHM9T2JqZWN0LmNyZWF0ZXx8ZnVuY3Rpb24oZSx0KXt2YXIgcjtyZXR1cm4gbnVsbD09PWU/cj1wKCk6KHNbY109bihlKSxyPW5ldyBzLHNbY109bnVsbCxyW2FdPWUpLHZvaWQgMD09PXQ/cjpvKHIsdCl9fSxmdW5jdGlvbihlLHQscil7dmFyIG49cigxNCksbz1yKDU0KSxsPXIoMTIpLGE9cig2KSxzPXIoMTA1KTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXt2YXIgcj0xPT1lLGk9ND09ZSxjPTY9PWUscD10fHxzO3JldHVybiBmdW5jdGlvbih0LHMsZCl7Zm9yKHZhciB1LGcsaD1sKHQpLHk9byhoKSxtPW4ocyxkLDMpLGY9YSh5Lmxlbmd0aCksRT0wLF89cj9wKHQsZik6Mj09ZT9wKHQsMCk6dm9pZCAwO2Y+RTtFKyspaWYoKDU9PWV8fGN8fEUgaW4geSkmJih1PXlbRV0sZz1tKHUsRSxoKSxlKSlpZihyKV9bRV09ZztlbHNlIGlmKGcpc3dpdGNoKGUpe2Nhc2UgMzpyZXR1cm4hMDtjYXNlIDU6cmV0dXJuIHU7Y2FzZSA2OnJldHVybiBFO2Nhc2UgMjpfLnB1c2godSk7fWVsc2UgaWYoaSlyZXR1cm4hMTtyZXR1cm4gYz8tMTozPT1lfHxpP2k6X319fSxmdW5jdGlvbihlLHQpe3QuZj17fS5wcm9wZXJ0eUlzRW51bWVyYWJsZX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMjApLG89cigzKSxsPSdfX2NvcmUtanNfc2hhcmVkX18nLGE9b1tsXXx8KG9bbF09e30pOyhlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gYVtlXXx8KGFbZV09dD09PXZvaWQgMD97fTp0KX0pKCd2ZXJzaW9ucycsW10pLnB1c2goe3ZlcnNpb246bi52ZXJzaW9uLG1vZGU6cigyMyk/J3B1cmUnOidnbG9iYWwnLGNvcHlyaWdodDonXFx4QTkgMjAxOSBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSd9KX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMiksbz1yKDI0KSxsPXIoNCkoJ3NwZWNpZXMnKTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXt2YXIgcixhPW4oZSkuY29uc3RydWN0b3I7cmV0dXJuIGE9PT12b2lkIDB8fChyPW4oYSlbbF0pPT12b2lkIDA/dDpvKHIpfX0sZnVuY3Rpb24oZSx0LHIpeyd1c2Ugc3RyaWN0Jzt2YXIgbj1yKDMpLG89cig3KSxsPXIoOCksYT1yKDQpKCdzcGVjaWVzJyk7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3ZhciB0PW5bZV07bCYmdCYmIXRbYV0mJm8uZih0LGEse2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc319KX19LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDMwKSxvPXIoNCkoJ3RvU3RyaW5nVGFnJyksbD0nQXJndW1lbnRzJz09bihmdW5jdGlvbigpe3JldHVybiBhcmd1bWVudHN9KCkpLGE9ZnVuY3Rpb24oZSx0KXt0cnl7cmV0dXJuIGVbdF19Y2F0Y2godCl7fX07ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3ZhciB0LHIscztyZXR1cm4gZT09PXZvaWQgMD8nVW5kZWZpbmVkJzpudWxsPT09ZT8nTnVsbCc6J3N0cmluZyc9PXR5cGVvZihyPWEodD1PYmplY3QoZSksbykpP3I6bD9uKHQpOidPYmplY3QnPT0ocz1uKHQpKSYmJ2Z1bmN0aW9uJz09dHlwZW9mIHQuY2FsbGVlPydBcmd1bWVudHMnOnN9fSxmdW5jdGlvbihlLHQscil7dmFyIG49cig0KSgnaXRlcmF0b3InKSxvPSExO3RyeXt2YXIgbD1bN11bbl0oKTtsWydyZXR1cm4nXT1mdW5jdGlvbigpe289ITB9LEFycmF5LmZyb20obCxmdW5jdGlvbigpe3Rocm93IDJ9KX1jYXRjaCh0KXt9ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7aWYoIXQmJiFvKXJldHVybiExO3ZhciByPSExO3RyeXt2YXIgbD1bN10sYT1sW25dKCk7YS5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJue2RvbmU6cj0hMH19LGxbbl09ZnVuY3Rpb24oKXtyZXR1cm4gYX0sZShsKX1jYXRjaCh0KXt9cmV0dXJuIHJ9fSxmdW5jdGlvbihlLHQscil7dmFyIG49cigxNCksbz1yKDgwKSxsPXIoNTkpLGE9cigyKSxzPXIoNiksaT1yKDYwKSxjPXt9LHA9e30sdD1lLmV4cG9ydHM9ZnVuY3Rpb24oZSx0LHIsZCx1KXt2YXIgZyxoLHksbSxFPXU/ZnVuY3Rpb24oKXtyZXR1cm4gZX06aShlKSxfPW4ocixkLHQ/MjoxKSxmPTA7aWYoJ2Z1bmN0aW9uJyE9dHlwZW9mIEUpdGhyb3cgVHlwZUVycm9yKGUrJyBpcyBub3QgaXRlcmFibGUhJyk7aWYobChFKSl7Zm9yKGc9cyhlLmxlbmd0aCk7Zz5mO2YrKylpZihtPXQ/XyhhKGg9ZVtmXSlbMF0saFsxXSk6XyhlW2ZdKSxtPT09Y3x8bT09PXApcmV0dXJuIG07fWVsc2UgZm9yKHk9RS5jYWxsKGUpOyEoaD15Lm5leHQoKSkuZG9uZTspaWYobT1vKHksXyxoLnZhbHVlLHQpLG09PT1jfHxtPT09cClyZXR1cm4gbX07dC5CUkVBSz1jLHQuUkVUVVJOPXB9LGZ1bmN0aW9uKGUsdCxyKXsndXNlIHN0cmljdCc7dmFyIG49cigzKSxvPXIoMCksbD1yKDE3KSxhPXIoMjgpLHM9cigxOSksaT1yKDQ2KSxjPXIoMjkpLHA9cigxKSxkPXIoNSksdT1yKDQ1KSxnPXIoMzIpLGg9cigxMTcpO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQscix5LGYsbSl7dmFyIEU9bltlXSxfPUUseD1mPydzZXQnOidhZGQnLFM9XyYmXy5wcm90b3R5cGUsVD17fSxiPWZ1bmN0aW9uKGUpe3ZhciB0PVNbZV07bChTLGUsJ2RlbGV0ZSc9PWU/ZnVuY3Rpb24oZSl7cmV0dXJuIG0mJiFwKGUpPyExOnQuY2FsbCh0aGlzLDA9PT1lPzA6ZSl9OidoYXMnPT1lP2Z1bmN0aW9uKGUpe3JldHVybiBtJiYhcChlKT8hMTp0LmNhbGwodGhpcywwPT09ZT8wOmUpfTonZ2V0Jz09ZT9mdW5jdGlvbihlKXtyZXR1cm4gbSYmIXAoZSk/dm9pZCAwOnQuY2FsbCh0aGlzLDA9PT1lPzA6ZSl9OidhZGQnPT1lP2Z1bmN0aW9uKGUpe3JldHVybiB0LmNhbGwodGhpcywwPT09ZT8wOmUpLHRoaXN9OmZ1bmN0aW9uKGUscil7cmV0dXJuIHQuY2FsbCh0aGlzLDA9PT1lPzA6ZSxyKSx0aGlzfSl9O2lmKCdmdW5jdGlvbichPXR5cGVvZiBffHwhKG18fFMuZm9yRWFjaCYmIWQoZnVuY3Rpb24oKXtuZXcgXygpLmVudHJpZXMoKS5uZXh0KCl9KSkpXz15LmdldENvbnN0cnVjdG9yKHQsZSxmLHgpLGEoXy5wcm90b3R5cGUscikscy5ORUVEPSEwO2Vsc2V7dmFyIFA9bmV3IF8sTz1QW3hdKG0/e306LTAsMSkhPVAsdj1kKGZ1bmN0aW9uKCl7UC5oYXMoMSl9KSxJPXUoZnVuY3Rpb24oZSl7bmV3IF8oZSl9KSxBPSFtJiZkKGZ1bmN0aW9uKCl7Zm9yKHZhciBlPW5ldyBfLHQ9NTt0LS07KWVbeF0odCx0KTtyZXR1cm4hZS5oYXMoLTApfSk7SXx8KF89dChmdW5jdGlvbih0LHIpe2ModCxfLGUpO3ZhciBuPWgobmV3IEUsdCxfKTtyZXR1cm4gdm9pZCAwIT1yJiZpKHIsZixuW3hdLG4pLG59KSxfLnByb3RvdHlwZT1TLFMuY29uc3RydWN0b3I9XyksKHZ8fEEpJiYoYignZGVsZXRlJyksYignaGFzJyksZiYmYignZ2V0JykpLChBfHxPKSYmYih4KSxtJiZTLmNsZWFyJiZkZWxldGUgUy5jbGVhcn1yZXR1cm4gZyhfLGUpLFRbZV09XyxvKG8uRytvLlcrby5GKihfIT1FKSxUKSxtfHx5LnNldFN0cm9uZyhfLGUsZiksX319LGZ1bmN0aW9uKGUsdCl7dC5mPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHN9LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDMpLG89bi5uYXZpZ2F0b3I7ZS5leHBvcnRzPW8mJm8udXNlckFnZW50fHwnJ30sZnVuY3Rpb24oZSx0LHIpeyd1c2Ugc3RyaWN0Jzt2YXIgbj1yKDQ0KSxvPVJlZ0V4cC5wcm90b3R5cGUuZXhlYztlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXt2YXIgcj1lLmV4ZWM7aWYoJ2Z1bmN0aW9uJz09dHlwZW9mIHIpe3ZhciBsPXIuY2FsbChlLHQpO2lmKCdvYmplY3QnIT10eXBlb2YgbCl0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWdFeHAgZXhlYyBtZXRob2QgcmV0dXJuZWQgc29tZXRoaW5nIG90aGVyIHRoYW4gYW4gT2JqZWN0IG9yIG51bGwnKTtyZXR1cm4gbH1pZignUmVnRXhwJyE9PW4oZSkpdGhyb3cgbmV3IFR5cGVFcnJvcignUmVnRXhwI2V4ZWMgY2FsbGVkIG9uIGluY29tcGF0aWJsZSByZWNlaXZlcicpO3JldHVybiBvLmNhbGwoZSx0KX19LGZ1bmN0aW9uKGUsdCxyKXsndXNlIHN0cmljdCc7cigxNjQpO3ZhciBuPXIoMTcpLG89cig5KSxsPXIoNSksYT1yKDI1KSxzPXIoNCksaT1yKDY2KSxjPXMoJ3NwZWNpZXMnKSxwPSFsKGZ1bmN0aW9uKCl7dmFyIGU9Ly4vO3JldHVybiBlLmV4ZWM9ZnVuY3Rpb24oKXt2YXIgZT1bXTtyZXR1cm4gZS5ncm91cHM9e2E6JzcnfSxlfSwnNychPT0nJy5yZXBsYWNlKGUsJyQ8YT4nKX0pLGQ9ZnVuY3Rpb24oKXt2YXIgZT0vKD86KS8sdD1lLmV4ZWM7ZS5leGVjPWZ1bmN0aW9uKCl7cmV0dXJuIHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfTt2YXIgcj0nYWInLnNwbGl0KGUpO3JldHVybiAyPT09ci5sZW5ndGgmJidhJz09PXJbMF0mJidiJz09PXJbMV19KCk7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxyKXt2YXIgdT1zKGUpLGc9IWwoZnVuY3Rpb24oKXt2YXIgdD17fTtyZXR1cm4gdFt1XT1mdW5jdGlvbigpe3JldHVybiA3fSw3IT0nJ1tlXSh0KX0pLGg9Zz8hbChmdW5jdGlvbigpe3ZhciB0PSExLHI9L2EvO3JldHVybiByLmV4ZWM9ZnVuY3Rpb24oKXtyZXR1cm4gdD0hMCxudWxsfSwnc3BsaXQnPT09ZSYmKHIuY29uc3RydWN0b3I9e30sci5jb25zdHJ1Y3RvcltjXT1mdW5jdGlvbigpe3JldHVybiByfSksclt1XSgnJyksIXR9KTp2b2lkIDA7aWYoIWd8fCFofHwncmVwbGFjZSc9PT1lJiYhcHx8J3NwbGl0Jz09PWUmJiFkKXt2YXIgeT0vLi9bdV0sZj1yKGEsdSwnJ1tlXSxmdW5jdGlvbihlLHQscixuLG8pe3JldHVybiB0LmV4ZWM9PT1pP2cmJiFvP3tkb25lOiEwLHZhbHVlOnkuY2FsbCh0LHIsbil9Ontkb25lOiEwLHZhbHVlOmUuY2FsbChyLHQsbil9Ontkb25lOiExfX0pLG09ZlswXSxFPWZbMV07bihTdHJpbmcucHJvdG90eXBlLGUsbSksbyhSZWdFeHAucHJvdG90eXBlLHUsMj09dD9mdW5jdGlvbihlLHQpe3JldHVybiBFLmNhbGwoZSx0aGlzLHQpfTpmdW5jdGlvbihlKXtyZXR1cm4gRS5jYWxsKGUsdGhpcyl9KX19fSxmdW5jdGlvbihlLHQscil7dmFyIG49cigxKSxvPXIoMykuZG9jdW1lbnQsbD1uKG8pJiZuKG8uY3JlYXRlRWxlbWVudCk7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBsP28uY3JlYXRlRWxlbWVudChlKTp7fX19LGZ1bmN0aW9uKGUsdCxyKXtmb3IodmFyIG4sbz1yKDMpLGw9cig5KSxhPXIoMjIpLHM9YSgndHlwZWRfYXJyYXknKSxjPWEoJ3ZpZXcnKSxwPSEhKG8uQXJyYXlCdWZmZXImJm8uRGF0YVZpZXcpLGQ9cCx1PTAsaT1bJ0ludDhBcnJheScsJ1VpbnQ4QXJyYXknLCdVaW50OENsYW1wZWRBcnJheScsJ0ludDE2QXJyYXknLCdVaW50MTZBcnJheScsJ0ludDMyQXJyYXknLCdVaW50MzJBcnJheScsJ0Zsb2F0MzJBcnJheScsJ0Zsb2F0NjRBcnJheSddO3U8OTspKG49b1tpW3UrK11dKT8obChuLnByb3RvdHlwZSxzLCEwKSxsKG4ucHJvdG90eXBlLGMsITApKTpkPSExO2UuZXhwb3J0cz17QUJWOnAsQ09OU1RSOmQsVFlQRUQ6cyxWSUVXOmN9fSxmdW5jdGlvbihlLHQscil7dmFyIG49cigzMCk7ZS5leHBvcnRzPU9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApP09iamVjdDpmdW5jdGlvbihlKXtyZXR1cm4nU3RyaW5nJz09bihlKT9lLnNwbGl0KCcnKTpPYmplY3QoZSl9fSxmdW5jdGlvbihlLHQscil7dmFyIG49cigxMSksbz1yKDYpLGw9cigzMSk7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbih0LHIsYSl7dmFyIHMsaT1uKHQpLGM9byhpLmxlbmd0aCkscD1sKGEsYyk7aWYoZSYmciE9cil7Zm9yKDtjPnA7KWlmKHM9aVtwKytdLHMhPXMpcmV0dXJuITA7fWVsc2UgZm9yKDtjPnA7cCsrKWlmKChlfHxwIGluIGkpJiZpW3BdPT09cilyZXR1cm4gZXx8cHx8MDtyZXR1cm4hZSYmLTF9fX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoNDEpKCdrZXlzJyksbz1yKDIyKTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuIG5bZV18fChuW2VdPW8oZSkpfX0sZnVuY3Rpb24oZSl7ZS5leHBvcnRzPVsnY29uc3RydWN0b3InLCdoYXNPd25Qcm9wZXJ0eScsJ2lzUHJvdG90eXBlT2YnLCdwcm9wZXJ0eUlzRW51bWVyYWJsZScsJ3RvTG9jYWxlU3RyaW5nJywndG9TdHJpbmcnLCd2YWx1ZU9mJ119LGZ1bmN0aW9uKGUsdCxyKXsndXNlIHN0cmljdCc7dmFyIG49cigxMiksbz1yKDMxKSxsPXIoNik7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1uKHRoaXMpLHI9bCh0Lmxlbmd0aCksYT1hcmd1bWVudHMubGVuZ3RoLHM9bygxPGE/YXJndW1lbnRzWzFdOnZvaWQgMCxyKSxpPTI8YT9hcmd1bWVudHNbMl06dm9pZCAwLGM9dm9pZCAwPT09aT9yOm8oaSxyKTtjPnM7KXRbcysrXT1lO3JldHVybiB0fX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMzMpLG89cig0KSgnaXRlcmF0b3InKSxsPUFycmF5LnByb3RvdHlwZTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuIGUhPT12b2lkIDAmJihuLkFycmF5PT09ZXx8bFtvXT09PWUpfX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoNDQpLG89cig0KSgnaXRlcmF0b3InKSxsPXIoMzMpO2UuZXhwb3J0cz1yKDIwKS5nZXRJdGVyYXRvck1ldGhvZD1mdW5jdGlvbihlKXtpZihlIT12b2lkIDApcmV0dXJuIGVbb118fGVbJ0BAaXRlcmF0b3InXXx8bFtuKGUpXX19LGZ1bmN0aW9uKGUsdCxyKXsndXNlIHN0cmljdCc7dmFyIG49cigzNSksbz1yKDc2KSxsPXIoMzMpLGE9cigxMSk7ZS5leHBvcnRzPXIoNzcpKEFycmF5LCdBcnJheScsZnVuY3Rpb24oZSx0KXt0aGlzLl90PWEoZSksdGhpcy5faT0wLHRoaXMuX2s9dH0sZnVuY3Rpb24oKXt2YXIgZT10aGlzLl90LHQ9dGhpcy5fayxyPXRoaXMuX2krKztyZXR1cm4hZXx8cj49ZS5sZW5ndGg/KHRoaXMuX3Q9dm9pZCAwLG8oMSkpOidrZXlzJz09dD9vKDAscik6J3ZhbHVlcyc9PXQ/bygwLGVbcl0pOm8oMCxbcixlW3JdXSl9LCd2YWx1ZXMnKSxsLkFyZ3VtZW50cz1sLkFycmF5LG4oJ2tleXMnKSxuKCd2YWx1ZXMnKSxuKCdlbnRyaWVzJyl9LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbixvLGwsYT1yKDE0KSxzPXIoODQpLGk9cig3NCksYz1yKDUyKSxwPXIoMyksZD1wLnByb2Nlc3MsdT1wLnNldEltbWVkaWF0ZSxnPXAuY2xlYXJJbW1lZGlhdGUsaD1wLk1lc3NhZ2VDaGFubmVsLHk9cC5EaXNwYXRjaCxmPTAsbT17fSxFPSdvbnJlYWR5c3RhdGVjaGFuZ2UnLF89ZnVuY3Rpb24oKXt2YXIgZT0rdGhpcztpZihtLmhhc093blByb3BlcnR5KGUpKXt2YXIgdD1tW2VdO2RlbGV0ZSBtW2VdLHQoKX19LHg9ZnVuY3Rpb24oZSl7Xy5jYWxsKGUuZGF0YSl9O3UmJmd8fCh1PWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bXSxyPTE7YXJndW1lbnRzLmxlbmd0aD5yOyl0LnB1c2goYXJndW1lbnRzW3IrK10pO3JldHVybiBtWysrZl09ZnVuY3Rpb24oKXtzKCdmdW5jdGlvbic9PXR5cGVvZiBlP2U6RnVuY3Rpb24oZSksdCl9LG4oZiksZn0sZz1mdW5jdGlvbihlKXtkZWxldGUgbVtlXX0sJ3Byb2Nlc3MnPT1yKDMwKShkKT9uPWZ1bmN0aW9uKGUpe2QubmV4dFRpY2soYShfLGUsMSkpfTp5JiZ5Lm5vdz9uPWZ1bmN0aW9uKGUpe3kubm93KGEoXyxlLDEpKX06aD8obz1uZXcgaCxsPW8ucG9ydDIsby5wb3J0MS5vbm1lc3NhZ2U9eCxuPWEobC5wb3N0TWVzc2FnZSxsLDEpKTpwLmFkZEV2ZW50TGlzdGVuZXImJidmdW5jdGlvbic9PXR5cGVvZiBwb3N0TWVzc2FnZSYmIXAuaW1wb3J0U2NyaXB0cz8obj1mdW5jdGlvbihlKXtwLnBvc3RNZXNzYWdlKGUrJycsJyonKX0scC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJyx4LCExKSk6RSBpbiBjKCdzY3JpcHQnKT9uPWZ1bmN0aW9uKGUpe2kuYXBwZW5kQ2hpbGQoYygnc2NyaXB0JykpW0VdPWZ1bmN0aW9uKCl7aS5yZW1vdmVDaGlsZCh0aGlzKSxfLmNhbGwoZSl9fTpuPWZ1bmN0aW9uKGUpe3NldFRpbWVvdXQoYShfLGUsMSksMCl9KSxlLmV4cG9ydHM9e3NldDp1LGNsZWFyOmd9fSxmdW5jdGlvbihlLHQscil7dmFyIG49cig5Miksbz1yKDI1KTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0LHIpe2lmKG4odCkpdGhyb3cgVHlwZUVycm9yKCdTdHJpbmcjJytyKycgZG9lc25cXCd0IGFjY2VwdCByZWdleCEnKTtyZXR1cm4gbyhlKSsnJ319LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDQpKCdtYXRjaCcpO2UuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdD0vLi87dHJ5eycvLi8nW2VdKHQpfWNhdGNoKHIpe3RyeXtyZXR1cm4gdFtuXT0hMSwhJy8uLydbZV0odCl9Y2F0Y2goZSl7fX1yZXR1cm4hMH19LGZ1bmN0aW9uKGUsdCxyKXsndXNlIHN0cmljdCc7dmFyIG49cig5MCkoITApO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQscil7cmV0dXJuIHQrKHI/bihlLHQpLmxlbmd0aDoxKX19LGZ1bmN0aW9uKGUsdCxyKXsndXNlIHN0cmljdCc7dmFyIG49cig5Myksbz1SZWdFeHAucHJvdG90eXBlLmV4ZWMsbD1TdHJpbmcucHJvdG90eXBlLnJlcGxhY2UsYT1vLHM9J2xhc3RJbmRleCcsYz1mdW5jdGlvbigpe3ZhciBlPS9hLyx0PS9iKi9nO3JldHVybiBvLmNhbGwoZSwnYScpLG8uY2FsbCh0LCdhJyksMCE9PWVbc118fDAhPT10W3NdfSgpLHA9LygpPz8vLmV4ZWMoJycpWzFdIT09dm9pZCAwOyhjfHxwKSYmKGE9ZnVuY3Rpb24oZSl7dmFyIHQscixhLGQsaT10aGlzO3JldHVybiBwJiYocj1uZXcgUmVnRXhwKCdeJytpLnNvdXJjZSsnJCg/IVxcXFxzKScsbi5jYWxsKGkpKSksYyYmKHQ9aVtzXSksYT1vLmNhbGwoaSxlKSxjJiZhJiYoaVtzXT1pLmdsb2JhbD9hLmluZGV4K2FbMF0ubGVuZ3RoOnQpLHAmJmEmJjE8YS5sZW5ndGgmJmwuY2FsbChhWzBdLHIsZnVuY3Rpb24oKXtmb3IoZD0xO2Q8YXJndW1lbnRzLmxlbmd0aC0yO2QrKyl2b2lkIDA9PT1hcmd1bWVudHNbZF0mJihhW2RdPXZvaWQgMCl9KSxhfSksZS5leHBvcnRzPWF9LGZ1bmN0aW9uKGUsdCxyKXsndXNlIHN0cmljdCc7dmFyIG49cig3KSxvPXIoMjEpO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQscil7dCBpbiBlP24uZihlLHQsbygwLHIpKTplW3RdPXJ9fSxmdW5jdGlvbihlKXtlLmV4cG9ydHM9TWF0aC5zaWdufHxmdW5jdGlvbihlKXtyZXR1cm4gMD09KGU9K2UpfHxlIT1lP2U6MD5lPy0xOjF9fSxmdW5jdGlvbihlKXt2YXIgdD1zO2UuZXhwb3J0cz0hdHx8MjIwMjUuNDY1Nzk0ODA2NzE4PHQoMTApfHwyMjAyNS40NjU3OTQ4MDY3MTg+dCgxMCl8fC0yZS0xNyE9dCgtMmUtMTcpP2Z1bmN0aW9uKGUpe3JldHVybiAwPT0oZT0rZSk/ZTotMWUtNjxlJiYxZS02PmU/ZStlKmUvMjphKGUpLTF9OnR9LGZ1bmN0aW9uKGUsdCxyKXtlLmV4cG9ydHM9IXIoOCkmJiFyKDUpKGZ1bmN0aW9uKCl7cmV0dXJuIDchPU9iamVjdC5kZWZpbmVQcm9wZXJ0eShyKDUyKSgnZGl2JyksJ2EnLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KS5hfSl9LGZ1bmN0aW9uKGUsdCxhKXsndXNlIHN0cmljdCc7ZnVuY3Rpb24gcyh0LHIsbil7dmFyIG8sbCxhLGM9QXJyYXkobikscD04Km4tci0xLGQ9KDE8PHApLTEsdT1kPj4xLGc9MjM9PT1yP3ooMiwtMjQpLXooMiwtNzcpOjAsaD0wLGk9MD50fHwwPT09dCYmMD4xL3Q/MTowO2Zvcih0PVYodCksdCE9dHx8dD09PUg/KGw9dD09dD8wOjEsbz1kKToobz0kKEsodCkvcSksMT50KihhPXooMiwtbykpJiYoby0tLGEqPTIpLHQrPTE8PW8rdT9nL2E6Zyp6KDIsMS11KSwyPD10KmEmJihvKyssYS89Miksbyt1Pj1kPyhsPTAsbz1kKToxPD1vK3U/KGw9KHQqYS0xKSp6KDIsciksbys9dSk6KGw9dCp6KDIsdS0xKSp6KDIsciksbz0wKSk7ODw9cjtjW2grK109MjU1JmwsbC89MjU2LHItPTgpO2ZvcihvPW88PHJ8bCxwKz1yOzA8cDtjW2grK109MjU1Jm8sby89MjU2LHAtPTgpO3JldHVybiBjWy0taF18PTEyOCppLGN9ZnVuY3Rpb24gaSh0LHIsbil7dmFyIG8sbD04Km4tci0xLGE9KDE8PGwpLTEsYz1hPj4xLHA9bC03LGQ9bi0xLGk9dFtkLS1dLHM9MTI3Jmk7Zm9yKGk+Pj03OzA8cDtzPTI1NipzK3RbZF0sZC0tLHAtPTgpO2ZvcihvPXMmKDE8PC1wKS0xLHM+Pj0tcCxwKz1yOzA8cDtvPTI1NipvK3RbZF0sZC0tLHAtPTgpO2lmKDA9PT1zKXM9MS1jO2Vsc2V7aWYocz09PWEpcmV0dXJuIG8/TmFOOmk/LUg6SDtvKz16KDIscikscy09Y31yZXR1cm4oaT8tMToxKSpvKnooMixzLXIpfWZ1bmN0aW9uIGMoZSl7cmV0dXJuIGVbM108PDI0fGVbMl08PDE2fGVbMV08PDh8ZVswXX1mdW5jdGlvbiBkKGUpe3JldHVyblsyNTUmZV19ZnVuY3Rpb24gdShlKXtyZXR1cm5bMjU1JmUsMjU1JmU+PjhdfWZ1bmN0aW9uIGcoZSl7cmV0dXJuWzI1NSZlLDI1NSZlPj44LDI1NSZlPj4xNiwyNTUmZT4+MjRdfWZ1bmN0aW9uIGgoZSl7cmV0dXJuIHMoZSw1Miw4KX1mdW5jdGlvbiB5KGUpe3JldHVybiBzKGUsMjMsNCl9ZnVuY3Rpb24gZihlLHQscil7TChlW0RdLHQse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW3JdfX0pfWZ1bmN0aW9uIG0oZSx0LHIsbil7dmFyIG89Uigrcik7aWYobyt0PmVbZWVdKXRocm93IFUoQyk7dmFyIGw9ZVtRXS5fYixhPW8rZVt0ZV0scz1sLnNsaWNlKGEsYSt0KTtyZXR1cm4gbj9zOnMucmV2ZXJzZSgpfWZ1bmN0aW9uIEUoZSx0LHIsbixvLGwpe3ZhciBhPVIoK3IpO2lmKGErdD5lW2VlXSl0aHJvdyBVKEMpO2Zvcih2YXIgcz1lW1FdLl9iLGM9YStlW3RlXSxwPW4oK28pLGQ9MDtkPHQ7ZCsrKXNbYytkXT1wW2w/ZDp0LWQtMV19dmFyIF89YSgzKSx4PWEoOCksUz1hKDIzKSxUPWEoNTMpLGI9YSg5KSxQPWEoMjgpLE89YSg1KSx2PWEoMjkpLEk9YSgxOCksQT1hKDYpLFI9YSg3Miksaz1hKDM3KS5mLEw9YSg3KS5mLEY9YSg1OCksTj1hKDMyKSx3PSdBcnJheUJ1ZmZlcicsTT0nRGF0YVZpZXcnLEQ9J3Byb3RvdHlwZScsQz0nV3JvbmcgaW5kZXghJyxZPV9bd10sQj1fW01dLEc9Xy5NYXRoLFU9Xy5SYW5nZUVycm9yLEg9Xy5JbmZpbml0eSxXPVksVj1sLHo9bywkPXAsSz1uLHE9cixYPSdidWZmZXInLFo9J2J5dGVMZW5ndGgnLEo9J2J5dGVPZmZzZXQnLFE9eD8nX2InOlgsZWU9eD8nX2wnOlosdGU9eD8nX28nOko7aWYoIVQuQUJWKVk9ZnVuY3Rpb24oZSl7dih0aGlzLFksdyk7dmFyIHQ9UihlKTt0aGlzLl9iPUYuY2FsbChBcnJheSh0KSwwKSx0aGlzW2VlXT10fSxCPWZ1bmN0aW9uKGUsdCxyKXt2KHRoaXMsQixNKSx2KGUsWSxNKTt2YXIgbj1lW2VlXSxvPUkodCk7aWYoMD5vfHxvPm4pdGhyb3cgVSgnV3Jvbmcgb2Zmc2V0IScpO2lmKHI9dm9pZCAwPT09cj9uLW86QShyKSxvK3I+bil0aHJvdyBVKCdXcm9uZyBsZW5ndGghJyk7dGhpc1tRXT1lLHRoaXNbdGVdPW8sdGhpc1tlZV09cn0seCYmKGYoWSxaLCdfbCcpLGYoQixYLCdfYicpLGYoQixaLCdfbCcpLGYoQixKLCdfbycpKSxQKEJbRF0se2dldEludDg6ZnVuY3Rpb24oZSl7cmV0dXJuIG0odGhpcywxLGUpWzBdPDwyND4+MjR9LGdldFVpbnQ4OmZ1bmN0aW9uKGUpe3JldHVybiBtKHRoaXMsMSxlKVswXX0sZ2V0SW50MTY6ZnVuY3Rpb24oZSl7dmFyIHQ9bSh0aGlzLDIsZSxhcmd1bWVudHNbMV0pO3JldHVybih0WzFdPDw4fHRbMF0pPDwxNj4+MTZ9LGdldFVpbnQxNjpmdW5jdGlvbihlKXt2YXIgdD1tKHRoaXMsMixlLGFyZ3VtZW50c1sxXSk7cmV0dXJuIHRbMV08PDh8dFswXX0sZ2V0SW50MzI6ZnVuY3Rpb24oZSl7cmV0dXJuIGMobSh0aGlzLDQsZSxhcmd1bWVudHNbMV0pKX0sZ2V0VWludDMyOmZ1bmN0aW9uKGUpe3JldHVybiBjKG0odGhpcyw0LGUsYXJndW1lbnRzWzFdKSk+Pj4wfSxnZXRGbG9hdDMyOmZ1bmN0aW9uKGUpe3JldHVybiBpKG0odGhpcyw0LGUsYXJndW1lbnRzWzFdKSwyMyw0KX0sZ2V0RmxvYXQ2NDpmdW5jdGlvbihlKXtyZXR1cm4gaShtKHRoaXMsOCxlLGFyZ3VtZW50c1sxXSksNTIsOCl9LHNldEludDg6ZnVuY3Rpb24oZSx0KXtFKHRoaXMsMSxlLGQsdCl9LHNldFVpbnQ4OmZ1bmN0aW9uKGUsdCl7RSh0aGlzLDEsZSxkLHQpfSxzZXRJbnQxNjpmdW5jdGlvbihlLHQpe0UodGhpcywyLGUsdSx0LGFyZ3VtZW50c1syXSl9LHNldFVpbnQxNjpmdW5jdGlvbihlLHQpe0UodGhpcywyLGUsdSx0LGFyZ3VtZW50c1syXSl9LHNldEludDMyOmZ1bmN0aW9uKGUsdCl7RSh0aGlzLDQsZSxnLHQsYXJndW1lbnRzWzJdKX0sc2V0VWludDMyOmZ1bmN0aW9uKGUsdCl7RSh0aGlzLDQsZSxnLHQsYXJndW1lbnRzWzJdKX0sc2V0RmxvYXQzMjpmdW5jdGlvbihlLHQpe0UodGhpcyw0LGUseSx0LGFyZ3VtZW50c1syXSl9LHNldEZsb2F0NjQ6ZnVuY3Rpb24oZSx0KXtFKHRoaXMsOCxlLGgsdCxhcmd1bWVudHNbMl0pfX0pO2Vsc2V7aWYoIU8oZnVuY3Rpb24oKXtZKDEpfSl8fCFPKGZ1bmN0aW9uKCl7bmV3IFkoLTEpfSl8fE8oZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFksbmV3IFkoMS41KSxuZXcgWShOYU4pLFkubmFtZSE9d30pKXtZPWZ1bmN0aW9uKGUpe3JldHVybiB2KHRoaXMsWSksbmV3IFcoUihlKSl9O2Zvcih2YXIgcmUsbmU9WVtEXT1XW0RdLG9lPWsoVyksbGU9MDtvZS5sZW5ndGg+bGU7KShyZT1vZVtsZSsrXSlpbiBZfHxiKFkscmUsV1tyZV0pO1N8fChuZS5jb25zdHJ1Y3Rvcj1ZKX12YXIgaj1uZXcgQihuZXcgWSgyKSksYWU9QltEXS5zZXRJbnQ4O2ouc2V0SW50OCgwLDIxNDc0ODM2NDgpLGouc2V0SW50OCgxLDIxNDc0ODM2NDkpLChqLmdldEludDgoMCl8fCFqLmdldEludDgoMSkpJiZQKEJbRF0se3NldEludDg6ZnVuY3Rpb24oZSx0KXthZS5jYWxsKHRoaXMsZSx0PDwyND4+MjQpfSxzZXRVaW50ODpmdW5jdGlvbihlLHQpe2FlLmNhbGwodGhpcyxlLHQ8PDI0Pj4yNCl9fSwhMCl9TihZLHcpLE4oQixNKSxiKEJbRF0sVC5WSUVXLCEwKSx0W3ddPVksdFtNXT1CfSxmdW5jdGlvbihlLHQscil7dmFyIG49cigxOCksbz1yKDYpO2UuZXhwb3J0cz1mdW5jdGlvbihlKXtpZihlPT09dm9pZCAwKXJldHVybiAwO3ZhciB0PW4oZSkscj1vKHQpO2lmKHQhPT1yKXRocm93IFJhbmdlRXJyb3IoJ1dyb25nIGxlbmd0aCEnKTtyZXR1cm4gcn19LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDEwKSxvPXIoMTEpLGw9cig1NSkoITEpLGE9cig1NikoJ0lFX1BST1RPJyk7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7dmFyIHIscz1vKGUpLGM9MCxpPVtdO2ZvcihyIGluIHMpciE9YSYmbihzLHIpJiZpLnB1c2gocik7Zm9yKDt0Lmxlbmd0aD5jOyluKHMscj10W2MrK10pJiYofmwoaSxyKXx8aS5wdXNoKHIpKTtyZXR1cm4gaX19LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDMpLmRvY3VtZW50O2UuZXhwb3J0cz1uJiZuLmRvY3VtZW50RWxlbWVudH0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMzApO2UuZXhwb3J0cz1BcnJheS5pc0FycmF5fHxmdW5jdGlvbihlKXtyZXR1cm4nQXJyYXknPT1uKGUpfX0sZnVuY3Rpb24oZSl7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7cmV0dXJue3ZhbHVlOnQsZG9uZTohIWV9fX0sZnVuY3Rpb24oZSx0LHIpeyd1c2Ugc3RyaWN0Jzt2YXIgbj1yKDIzKSxvPXIoMCksbD1yKDE3KSxhPXIoOSkscz1yKDMzKSxpPXIoMTA3KSxjPXIoMzIpLHA9cigzNCksZD1yKDQpKCdpdGVyYXRvcicpLHU9IShbXS5rZXlzJiYnbmV4dCdpbltdLmtleXMoKSksZz0na2V5cycsaD0ndmFsdWVzJyx5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O2UuZXhwb3J0cz1mdW5jdGlvbihlLHQscixmLG0sRSxfKXtpKHIsdCxmKTt2YXIgeCxTLFQsYj1mdW5jdGlvbihlKXtyZXR1cm4hdSYmZSBpbiBJP0lbZV06ZT09PWc/ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHIodGhpcyxlKX06ZT09PWg/ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHIodGhpcyxlKX06ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHIodGhpcyxlKX19LFA9dCsnIEl0ZXJhdG9yJyxPPW09PWgsdj0hMSxJPWUucHJvdG90eXBlLEE9SVtkXXx8SVsnQEBpdGVyYXRvciddfHxtJiZJW21dLFI9QXx8YihtKSxrPW0/Tz9iKCdlbnRyaWVzJyk6Ujp2b2lkIDAsTD0nQXJyYXknPT10P0kuZW50cmllc3x8QTpBO2lmKEwmJihUPXAoTC5jYWxsKG5ldyBlKSksVCE9PU9iamVjdC5wcm90b3R5cGUmJlQubmV4dCYmKGMoVCxQLCEwKSwhbiYmJ2Z1bmN0aW9uJyE9dHlwZW9mIFRbZF0mJmEoVCxkLHkpKSksTyYmQSYmQS5uYW1lIT09aCYmKHY9ITAsUj1mdW5jdGlvbigpe3JldHVybiBBLmNhbGwodGhpcyl9KSwoIW58fF8pJiYodXx8dnx8IUlbZF0pJiZhKEksZCxSKSxzW3RdPVIsc1tQXT15LG0paWYoeD17dmFsdWVzOk8/UjpiKGgpLGtleXM6RT9SOmIoZyksZW50cmllczprfSxfKWZvcihTIGluIHgpUyBpbiBJfHxsKEksUyx4W1NdKTtlbHNlIG8oby5QK28uRioodXx8diksdCx4KTtyZXR1cm4geH19LGZ1bmN0aW9uKGUsdCxyKXsndXNlIHN0cmljdCc7dmFyIG49cigxMiksbz1yKDMxKSxsPXIoNik7ZS5leHBvcnRzPVtdLmNvcHlXaXRoaW58fGZ1bmN0aW9uKGUsdCl7dmFyIHI9bih0aGlzKSxhPWwoci5sZW5ndGgpLHM9byhlLGEpLGk9byh0LGEpLGM9Mjxhcmd1bWVudHMubGVuZ3RoP2FyZ3VtZW50c1syXTp2b2lkIDAscD1kKChjPT09dm9pZCAwP2E6byhjLGEpKS1pLGEtcyksdT0xO2ZvcihpPHMmJnM8aStwJiYodT0tMSxpKz1wLTEscys9cC0xKTswPHAtLTspaSBpbiByP3Jbc109cltpXTpkZWxldGUgcltzXSxzKz11LGkrPXU7cmV0dXJuIHJ9fSxmdW5jdGlvbihlLHQscil7J3VzZSBzdHJpY3QnO3ZhciBuPXIoNykuZixvPXIoMzgpLGw9cigyOCksYT1yKDE0KSxzPXIoMjkpLGk9cig0NiksYz1yKDc3KSxwPXIoNzYpLGQ9cig0MyksdT1yKDgpLGc9cigxOSkuZmFzdEtleSxoPXIoMjcpLHk9dT8nX3MnOidzaXplJyxmPWZ1bmN0aW9uKGUsdCl7dmFyIHIsbj1nKHQpO2lmKCdGJyE9PW4pcmV0dXJuIGUuX2lbbl07Zm9yKHI9ZS5fZjtyO3I9ci5uKWlmKHIuaz09dClyZXR1cm4gcn07ZS5leHBvcnRzPXtnZXRDb25zdHJ1Y3RvcjpmdW5jdGlvbihlLHQscixjKXt2YXIgcD1lKGZ1bmN0aW9uKGUsbil7cyhlLHAsdCwnX2knKSxlLl90PXQsZS5faT1vKG51bGwpLGUuX2Y9dm9pZCAwLGUuX2w9dm9pZCAwLGVbeV09MCx2b2lkIDAhPW4mJmkobixyLGVbY10sZSl9KTtyZXR1cm4gbChwLnByb3RvdHlwZSx7Y2xlYXI6ZnVuY3Rpb24oKXtmb3IodmFyIGU9aCh0aGlzLHQpLHI9ZS5faSxuPWUuX2Y7bjtuPW4ubiluLnI9ITAsbi5wJiYobi5wPW4ucC5uPXZvaWQgMCksZGVsZXRlIHJbbi5pXTtlLl9mPWUuX2w9dm9pZCAwLGVbeV09MH0sZGVsZXRlOmZ1bmN0aW9uKGUpe3ZhciByPWgodGhpcyx0KSxuPWYocixlKTtpZihuKXt2YXIgbz1uLm4sbD1uLnA7ZGVsZXRlIHIuX2lbbi5pXSxuLnI9ITAsbCYmKGwubj1vKSxvJiYoby5wPWwpLHIuX2Y9PW4mJihyLl9mPW8pLHIuX2w9PW4mJihyLl9sPWwpLHJbeV0tLX1yZXR1cm4hIW59LGZvckVhY2g6ZnVuY3Rpb24oZSl7aCh0aGlzLHQpO2Zvcih2YXIgcixuPWEoZSwxPGFyZ3VtZW50cy5sZW5ndGg/YXJndW1lbnRzWzFdOnZvaWQgMCwzKTtyPXI/ci5uOnRoaXMuX2Y7KWZvcihuKHIudixyLmssdGhpcyk7ciYmci5yOylyPXIucH0saGFzOmZ1bmN0aW9uKGUpe3JldHVybiEhZihoKHRoaXMsdCksZSl9fSksdSYmbihwLnByb3RvdHlwZSwnc2l6ZScse2dldDpmdW5jdGlvbigpe3JldHVybiBoKHRoaXMsdClbeV19fSkscH0sZGVmOmZ1bmN0aW9uKGUsdCxyKXt2YXIgbixvLGw9ZihlLHQpO3JldHVybiBsP2wudj1yOihlLl9sPWw9e2k6bz1nKHQsITApLGs6dCx2OnIscDpuPWUuX2wsbjp2b2lkIDAscjohMX0sIWUuX2YmJihlLl9mPWwpLG4mJihuLm49bCksZVt5XSsrLCdGJyE9PW8mJihlLl9pW29dPWwpKSxlfSxnZXRFbnRyeTpmLHNldFN0cm9uZzpmdW5jdGlvbihlLHQscil7YyhlLHQsZnVuY3Rpb24oZSxyKXt0aGlzLl90PWgoZSx0KSx0aGlzLl9rPXIsdGhpcy5fbD12b2lkIDB9LGZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXMsdD1lLl9rLHI9ZS5fbDtyJiZyLnI7KXI9ci5wO3JldHVybiBlLl90JiYoZS5fbD1yPXI/ci5uOmUuX3QuX2YpPydrZXlzJz09dD9wKDAsci5rKTondmFsdWVzJz09dD9wKDAsci52KTpwKDAsW3IuayxyLnZdKTooZS5fdD12b2lkIDAscCgxKSl9LHI/J2VudHJpZXMnOid2YWx1ZXMnLCFyLCEwKSxkKHQpfX19LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDIpO2UuZXhwb3J0cz1mdW5jdGlvbih0LGUscixvKXt0cnl7cmV0dXJuIG8/ZShuKHIpWzBdLHJbMV0pOmUocil9Y2F0Y2gocil7dmFyIGw9dFsncmV0dXJuJ107dGhyb3cgdm9pZCAwIT09bCYmbihsLmNhbGwodCkpLHJ9fX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMSksbz1yKDIpLGw9ZnVuY3Rpb24oZSx0KXtpZihvKGUpLCFuKHQpJiZudWxsIT09dCl0aHJvdyBUeXBlRXJyb3IodCsnOiBjYW5cXCd0IHNldCBhcyBwcm90b3R5cGUhJyl9O2UuZXhwb3J0cz17c2V0Ok9iamVjdC5zZXRQcm90b3R5cGVPZnx8KCdfX3Byb3RvX18naW57fT9mdW5jdGlvbihlLHQsbil7dHJ5e249cigxNCkoRnVuY3Rpb24uY2FsbCxyKDE2KS5mKE9iamVjdC5wcm90b3R5cGUsJ19fcHJvdG9fXycpLnNldCwyKSxuKGUsW10pLHQ9IShlIGluc3RhbmNlb2YgQXJyYXkpfWNhdGNoKHIpe3Q9ITB9cmV0dXJuIGZ1bmN0aW9uKGUscil7cmV0dXJuIGwoZSxyKSx0P2UuX19wcm90b19fPXI6bihlLHIpLGV9fSh7fSwhMSk6dm9pZCAwKSxjaGVjazpsfX0sZnVuY3Rpb24oZSx0LHIpeyd1c2Ugc3RyaWN0Jzt2YXIgbj1yKDI2KSxvPXIoNDgpLGw9cig0MCksYT1yKDEyKSxzPXIoNTQpLGk9T2JqZWN0LmFzc2lnbjtlLmV4cG9ydHM9IWl8fHIoNSkoZnVuY3Rpb24oKXt2YXIgZT17fSx0PXt9LHI9U3ltYm9sKCksbj0nYWJjZGVmZ2hpamtsbW5vcHFyc3QnO3JldHVybiBlW3JdPTcsbi5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbihlKXt0W2VdPWV9KSw3IT1pKHt9LGUpW3JdfHxPYmplY3Qua2V5cyhpKHt9LHQpKS5qb2luKCcnKSE9bn0pP2Z1bmN0aW9uKGUpe2Zvcih2YXIgdD1hKGUpLHI9YXJndW1lbnRzLmxlbmd0aCxpPTEsYz1vLmYscD1sLmY7cj5pOylmb3IodmFyIGQsdT1zKGFyZ3VtZW50c1tpKytdKSxnPWM/bih1KS5jb25jYXQoYyh1KSk6bih1KSxoPWcubGVuZ3RoLHk9MDtoPnk7KXAuY2FsbCh1LGQ9Z1t5KytdKSYmKHRbZF09dVtkXSk7cmV0dXJuIHR9Oml9LGZ1bmN0aW9uKGUsdCxyKXsndXNlIHN0cmljdCc7dmFyIG49cigyOCksbz1yKDE5KS5nZXRXZWFrLGw9cigyKSxhPXIoMSkscz1yKDI5KSxpPXIoNDYpLGM9cigzOSkscD1yKDEwKSxkPXIoMjcpLHU9Yyg1KSxnPWMoNiksaD0wLHk9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX2x8fChlLl9sPW5ldyBmKX0sZj1mdW5jdGlvbigpe3RoaXMuYT1bXX0sbT1mdW5jdGlvbihlLHQpe3JldHVybiB1KGUuYSxmdW5jdGlvbihlKXtyZXR1cm4gZVswXT09PXR9KX07Zi5wcm90b3R5cGU9e2dldDpmdW5jdGlvbihlKXt2YXIgdD1tKHRoaXMsZSk7aWYodClyZXR1cm4gdFsxXX0saGFzOmZ1bmN0aW9uKGUpe3JldHVybiEhbSh0aGlzLGUpfSxzZXQ6ZnVuY3Rpb24oZSx0KXt2YXIgcj1tKHRoaXMsZSk7cj9yWzFdPXQ6dGhpcy5hLnB1c2goW2UsdF0pfSxkZWxldGU6ZnVuY3Rpb24oZSl7dmFyIHQ9Zyh0aGlzLmEsZnVuY3Rpb24odCl7cmV0dXJuIHRbMF09PT1lfSk7cmV0dXJufnQmJnRoaXMuYS5zcGxpY2UodCwxKSwhIX50fX0sZS5leHBvcnRzPXtnZXRDb25zdHJ1Y3RvcjpmdW5jdGlvbihlLHQscixsKXt2YXIgYz1lKGZ1bmN0aW9uKGUsbil7cyhlLGMsdCwnX2knKSxlLl90PXQsZS5faT1oKyssZS5fbD12b2lkIDAsdm9pZCAwIT1uJiZpKG4scixlW2xdLGUpfSk7cmV0dXJuIG4oYy5wcm90b3R5cGUse2RlbGV0ZTpmdW5jdGlvbihlKXtpZighYShlKSlyZXR1cm4hMTt2YXIgcj1vKGUpO3JldHVybiEwPT09cj95KGQodGhpcyx0KSlbJ2RlbGV0ZSddKGUpOnImJnAocix0aGlzLl9pKSYmZGVsZXRlIHJbdGhpcy5faV19LGhhczpmdW5jdGlvbihlKXtpZighYShlKSlyZXR1cm4hMTt2YXIgcj1vKGUpO3JldHVybiEwPT09cj95KGQodGhpcyx0KSkuaGFzKGUpOnImJnAocix0aGlzLl9pKX19KSxjfSxkZWY6ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPW8obCh0KSwhMCk7cmV0dXJuITA9PT1uP3koZSkuc2V0KHQscik6bltlLl9pXT1yLGV9LHVmc3RvcmU6eX19LGZ1bmN0aW9uKGUpe2UuZXhwb3J0cz1mdW5jdGlvbihlLHQscil7dmFyIG49cj09PXZvaWQgMDtzd2l0Y2godC5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gbj9lKCk6ZS5jYWxsKHIpO2Nhc2UgMTpyZXR1cm4gbj9lKHRbMF0pOmUuY2FsbChyLHRbMF0pO2Nhc2UgMjpyZXR1cm4gbj9lKHRbMF0sdFsxXSk6ZS5jYWxsKHIsdFswXSx0WzFdKTtjYXNlIDM6cmV0dXJuIG4/ZSh0WzBdLHRbMV0sdFsyXSk6ZS5jYWxsKHIsdFswXSx0WzFdLHRbMl0pO2Nhc2UgNDpyZXR1cm4gbj9lKHRbMF0sdFsxXSx0WzJdLHRbM10pOmUuY2FsbChyLHRbMF0sdFsxXSx0WzJdLHRbM10pO31yZXR1cm4gZS5hcHBseShyLHQpfX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMzcpLG89cig0OCksbD1yKDIpLGE9cigzKS5SZWZsZWN0O2UuZXhwb3J0cz1hJiZhLm93bktleXN8fGZ1bmN0aW9uKGUpe3ZhciB0PW4uZihsKGUpKSxyPW8uZjtyZXR1cm4gcj90LmNvbmNhdChyKGUpKTp0fX0sZnVuY3Rpb24oZSx0LHIpeyd1c2Ugc3RyaWN0JztmdW5jdGlvbiBuKGUpe3ZhciB0LHI7dGhpcy5wcm9taXNlPW5ldyBlKGZ1bmN0aW9uKGUsbil7aWYodCE9dm9pZCAwfHxyIT12b2lkIDApdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO3Q9ZSxyPW59KSx0aGlzLnJlc29sdmU9byh0KSx0aGlzLnJlamVjdD1vKHIpfXZhciBvPXIoMjQpO2UuZXhwb3J0cy5mPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgbihlKX19LGZ1bmN0aW9uKGUsdCxyKXt0LmY9cig0KX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMTEpLG89cigzNykuZixsPXt9LnRvU3RyaW5nLGE9J29iamVjdCc9PXR5cGVvZiB3aW5kb3cmJndpbmRvdyYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM/T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KTpbXSxzPWZ1bmN0aW9uKGUpe3RyeXtyZXR1cm4gbyhlKX1jYXRjaCh0KXtyZXR1cm4gYS5zbGljZSgpfX07ZS5leHBvcnRzLmY9ZnVuY3Rpb24oZSl7cmV0dXJuIGEmJidbb2JqZWN0IFdpbmRvd10nPT1sLmNhbGwoZSk/cyhlKTpvKG4oZSkpfX0sZnVuY3Rpb24oZSl7ZS5leHBvcnRzPU9iamVjdC5pc3x8ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT09PXQ/MCE9PWV8fDEvZT09MS90OmUhPWUmJnQhPXR9fSxmdW5jdGlvbihlLHQscil7dmFyIG49cigxOCksbz1yKDI1KTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKHQscil7dmFyIGMsYSxwPW8odCkrJycscz1uKHIpLGk9cC5sZW5ndGg7cmV0dXJuIDA+c3x8cz49aT9lPycnOnZvaWQgMDooYz1wLmNoYXJDb2RlQXQocyksNTUyOTY+Y3x8NTYzMTk8Y3x8cysxPT09aXx8NTYzMjA+KGE9cC5jaGFyQ29kZUF0KHMrMSkpfHw1NzM0MzxhP2U/cC5jaGFyQXQocyk6YzplP3Auc2xpY2UocyxzKzIpOihjLTU1Mjk2PDwxMCkrKGEtNTYzMjApKzY1NTM2KX19fSxmdW5jdGlvbihlLHQscil7J3VzZSBzdHJpY3QnO3ZhciBvPXIoMTgpLGw9cigyNSk7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3ZhciB0PWwodGhpcykrJycscj0nJyxhPW8oZSk7aWYoMD5hfHxhPT1JbmZpbml0eSl0aHJvdyBSYW5nZUVycm9yKCdDb3VudCBjYW5cXCd0IGJlIG5lZ2F0aXZlJyk7Zm9yKDswPGE7KGE+Pj49MSkmJih0Kz10KSkxJmEmJihyKz10KTtyZXR1cm4gcn19LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDEpLG89cigzMCksbD1yKDQpKCdtYXRjaCcpO2UuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdDtyZXR1cm4gbihlKSYmKCh0PWVbbF0pPT09dm9pZCAwPydSZWdFeHAnPT1vKGUpOiEhdCl9fSxmdW5jdGlvbihlLHQscil7J3VzZSBzdHJpY3QnO3ZhciBuPXIoMik7ZS5leHBvcnRzPWZ1bmN0aW9uKCl7dmFyIGU9bih0aGlzKSx0PScnO3JldHVybiBlLmdsb2JhbCYmKHQrPSdnJyksZS5pZ25vcmVDYXNlJiYodCs9J2knKSxlLm11bHRpbGluZSYmKHQrPSdtJyksZS51bmljb2RlJiYodCs9J3UnKSxlLnN0aWNreSYmKHQrPSd5JyksdH19LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDEpO2UuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4hbihlKSYmaXNGaW5pdGUoZSkmJnAoZSk9PT1lfX0sZnVuY3Rpb24oZSl7ZS5leHBvcnRzPU1hdGgubG9nMXB8fGZ1bmN0aW9uKGUpe3JldHVybi0xZS04PChlPStlKSYmMWUtOD5lP2UtZSplLzI6bigxK2UpfX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMjYpLG89cigxMSksbD1yKDQwKS5mO2UuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCl7Zm9yKHZhciByLGE9byh0KSxzPW4oYSksYz1zLmxlbmd0aCxwPTAsaT1bXTtjPnA7KWwuY2FsbChhLHI9c1twKytdKSYmaS5wdXNoKGU/W3IsYVtyXV06YVtyXSk7cmV0dXJuIGl9fX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoNiksbz1yKDkxKSxsPXIoMjUpO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQscixhKXt2YXIgcz1sKGUpKycnLGk9cy5sZW5ndGgscD12b2lkIDA9PT1yPycgJzpyKycnLGQ9bih0KTtpZihkPD1pfHwnJz09cClyZXR1cm4gczt2YXIgdT1kLWksZz1vLmNhbGwocCxjKHUvcC5sZW5ndGgpKTtyZXR1cm4gZy5sZW5ndGg+dSYmKGc9Zy5zbGljZSgwLHUpKSxhP2crczpzK2d9fSxmdW5jdGlvbihlLHQpeyd1c2Ugc3RyaWN0JztmdW5jdGlvbiByKGUsdCxyKXt2YXIgbj1uZXcgRXJyb3IodC5tZXNzYWdlfHx0Lm1lc3NhZ2VfdG9fY2xpZW50fHx0KTtyZXR1cm4gbi5uYW1lPXQuY29kZXx8ZSxuLnBhc3N0aHJvdWdoPXIsbn1mdW5jdGlvbiBuKGUsdCl7Zm9yKHZhciByPW5ldyBVaW50OEFycmF5KGUubGVuZ3RoK3QubGVuZ3RoKSxuPTA7bjxlLmxlbmd0aDtuKyspcltuXT1lW25dO2Zvcih2YXIgbz0wO288dC5sZW5ndGg7bysrKXJbbytlLmxlbmd0aF09dFtvXTtyZXR1cm4gcn1mdW5jdGlvbiBvKGUpe3ZhciB0PW5ldyBVaW50OEFycmF5KGwpLHI9bmV3IERhdGFWaWV3KHQuYnVmZmVyKTtyZXR1cm4gci5zZXRVaW50MzIoMCxlKSx0fU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCdfX2VzTW9kdWxlJyx7dmFsdWU6ITB9KSx0LmFkZE1ldGFkYXRhPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByPXQudXBsb2FkSWQsbD10LmNhbGxUeXBlLGE9byhyKSxzPW8obCksaT1lLGM9ZnVuY3Rpb24oZSl7dmFyIHQ9byhlLmxlbmd0aCkscj1uZXcgVWludDhBcnJheShbXSk7cmV0dXJuIHI9bihyLHMpLHI9bihyLGEpLHI9bihyLHQpLHI9bihyLGUpLHJ9LHA9W10sZD0wO2Q8aS5sZW5ndGg7ZCsrKXAucHVzaChjKGlbZF0sZCxpKSk7cmV0dXJuIHB9LHQubG9nPWZ1bmN0aW9uKGUpe3ZhciB0O2lmKGUpe2Zvcih2YXIgcj1hcmd1bWVudHMubGVuZ3RoLG49QXJyYXkoMTxyP3ItMTowKSxvPTE7bzxyO28rKyluW28tMV09YXJndW1lbnRzW29dOyh0PWNvbnNvbGUpLmxvZy5hcHBseSh0LFtuZXcgRGF0ZSsnOiddLmNvbmNhdChuKSl9fSx0LmNyZWF0ZUVycm9yPXIsdC5wdXNoVG9CdWZmZXI9bix0LmdldEZpbGU9ZnVuY3Rpb24oZSl7dmFyIHQ9T2JqZWN0LmFzc2lnbih7fSxlKTtyZXR1cm4gdC5idWZmZXI9bmV3IFVpbnQ4QXJyYXkoZS5idWZmZXIpLHR9LHQuY2hlY2tPcHRpb25zPWZ1bmN0aW9uKGUpe2lmKCFlKXRocm93IEVycm9yKCdPcHRpb25zIGlzIHJlcXVpcmVkJyk7Zm9yKHZhciB0PVsnZmlsZW5hbWUnLCdidWZmZXInLCdkb2N1bWVudFR5cGUnLCdkb2N1bWVudEZvcm1hdCddLG49dCxvPWZ1bmN0aW9uKHQpe2lmKCEodCBpbiBlKSl0aHJvdyByKCdJbnZvY2F0aW9uRXJyb3InLCdSZXF1aXJlZCBvcHRpb24gPCcrdCsnPiBpcyBub3QgZm91bmQgaW4gdGhlIGdpdmVuIG9wdGlvbnMnKX0sbD0wO2w8bi5sZW5ndGg7bCsrKW8obltsXSxsLG4pO2lmKGUuYnVmZmVyLmxlbmd0aD5hKXRocm93IHIoJ0ZpbGVTaXplRXJyb3InLCdUaGUgbWF4aW11bSBhY2NlcHRhYmxlIGZpbGUgc2l6ZSBpcyAnK3MpfTt2YXIgbD00LGE9dC5NQVhfU0laRT04Mzg4NjA4LHM9dC5IVU1BTl9SRUFEQUJMRV9NQVhfU0laRT0nOCBNQicsaT10LmdlbmVyYXRlQ2h1bmtzPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByLG49dC5jaHVua1NpemUsbz1uPT09dm9pZCAwPzE2Mzg0Om4sbD1bXSxhPTA7YTxlLmxlbmd0aDthKyspcj1lW2FdLDA9PWElbz9sLnB1c2goW3JdKTpsW2wubGVuZ3RoLTFdLnB1c2gocik7Zm9yKHZhciBzPWwsaT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZSl9LGM9W10scD0wO3A8cy5sZW5ndGg7cCsrKWMucHVzaChpKHNbcF0scCxzKSk7cmV0dXJuIGMuY29uY2F0KG5ldyBVaW50OEFycmF5KFtdKSl9fSxmdW5jdGlvbihlKXt2YXIgcj17dXRmODp7c3RyaW5nVG9CeXRlczpmdW5jdGlvbihlKXtyZXR1cm4gci5iaW4uc3RyaW5nVG9CeXRlcyh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoZSkpKX0sYnl0ZXNUb1N0cmluZzpmdW5jdGlvbihlKXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShyLmJpbi5ieXRlc1RvU3RyaW5nKGUpKSl9fSxiaW46e3N0cmluZ1RvQnl0ZXM6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVtdLHI9MDtyPGUubGVuZ3RoO3IrKyl0LnB1c2goMjU1JmUuY2hhckNvZGVBdChyKSk7cmV0dXJuIHR9LGJ5dGVzVG9TdHJpbmc6ZnVuY3Rpb24oZSl7Zm9yKHZhciByPVtdLG49MDtuPGUubGVuZ3RoO24rKylyLnB1c2godChlW25dKSk7cmV0dXJuIHIuam9pbignJyl9fX07ZS5leHBvcnRzPXJ9LGZ1bmN0aW9uKGUsdCxyKXsndXNlIHN0cmljdCc7ZnVuY3Rpb24gbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCdfX2VzTW9kdWxlJyx7dmFsdWU6ITB9KTt2YXIgbz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIHIsbj0wO248dC5sZW5ndGg7bisrKXI9dFtuXSxyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCwndmFsdWUnaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfXJldHVybiBmdW5jdGlvbih0LHIsbil7cmV0dXJuIHImJmUodC5wcm90b3R5cGUsciksbiYmZSh0LG4pLHR9fSgpO3IoMTAxKSxyKDEwMykscigxMDgpLHIoMTA5KSxyKDExMCkscigxMTEpLHIoMTEyKSxyKDExMykscigxMTQpLHIoMTE1KSxyKDExNikscigxMTgpLHIoMTE5KSxyKDEyMCkscigxMjEpLHIoMTIyKSxyKDEyNCkscigxMjUpLHIoMTI2KSxyKDEyNykscigxMjgpLHIoMTI5KSxyKDEzMCkscigxMzEpLHIoMTMyKSxyKDEzMykscigxMzQpLHIoMTM1KSxyKDEzOSkscigxNDIpLHIoMTQzKSxyKDE0NCkscigxNDUpLHIoMTQ2KSxyKDE0NykscigxNDgpLHIoMTQ5KSxyKDE1MCkscigxNTEpLHIoMTUyKSxyKDE1MykscigxNTQpLHIoMTU1KSxyKDE1NikscigxNTcpLHIoMTU4KSxyKDE1OSkscigxNjApLHIoMTYxKSxyKDE2MikscigxNjMpLHIoMTY1KSxyKDE2NikscigxNjcpLHIoMTY4KSxyKDE2OSkscigxNzApLHIoMTcxKSxyKDE3MikscigxNzMpLHIoNjEpLHIoMTc0KSxyKDE3NSkscigxNzYpLHIoMTc3KSxyKDE3OCkscigxNzkpLHIoMTgwKSxyKDE4MSkscigxODIpLHIoMTgzKSxyKDE4NCkscigxODUpLHIoMTg2KSxyKDE4NykscigxODgpLHIoMTkwKSxyKDE5MSkscigxOTIpLHIoMTkzKSxyKDE5NCkscigxOTUpLHIoMTk2KSxyKDE5NykscigxOTgpLHIoMTk5KSxyKDIwMCkscigyMDEpLHIoMjAyKSxyKDIwMykscigyMDQpLHIoMjA1KSxyKDIwNikscigyMDcpLHIoMjA4KTt2YXIgbD1yKDk4KSxhPXIoMjA5KSxzPWZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX0oYSksaT0wLGM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQpe24odGhpcyxlKSx0aGlzLmNvbmZpZz10LHRoaXMuY2xpZW50cz17fSx0aGlzLndyYXBDb25uZWN0aW9uKCl9cmV0dXJuIG8oZSxbe2tleTondXBsb2FkJyx2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLHI9dGhpcy5jb25maWcuZGVidWcsbj0oMCxsLmdldEZpbGUpKGUpOygwLGwuY2hlY2tPcHRpb25zKShuKSxpKz0xO3ZhciBvPW5ldyBzLmRlZmF1bHQoe3NlbmQ6dGhpcy5zZW5kLGZpbGU6bixyZXFJZDppfSk7cmV0dXJuIHRoaXMuY2xpZW50c1tpXT17Y2xpZW50Om99LG5ldyBQcm9taXNlKGZ1bmN0aW9uKGUsYSl7dC5jbGllbnRzW2ldLnByb21pc2U9e3Jlc29sdmU6ZSxyZWplY3Q6YX0sKDAsbC5sb2cpKHZvaWQgMCE9PXImJnIsJ1VwbG9hZGluZyBzdGFydGVkLCBGaWxlIG9wdGlvbnM6JyxuKSxvLnJlcXVlc3RVcGxvYWQoKX0pfX0se2tleTond3JhcENvbm5lY3Rpb24nLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PXRoaXMuY29uZmlnLHI9dC5jb25uZWN0aW9uLG49dC5kZWJ1ZyxvPXZvaWQgMCE9PW4mJm47aWYoIXJ8fDEhPT1yLnJlYWR5U3RhdGUpdGhyb3coMCxsLmNyZWF0ZUVycm9yKSgnQ29ubmVjdGlvbkVycm9yJywnQ29ubmVjdGlvbiBpcyBub3QgcmVhZHkhJyk7dGhpcy5jb25uZWN0aW9uPXIsdGhpcy5zZW5kPWZ1bmN0aW9uKGUpeygwLGwubG9nKShvLCc8U2VudD46JyxlKSxyLnNlbmQoZSl9O3ZhciBhPXIub25tZXNzYWdlO3Iub25tZXNzYWdlPWZ1bmN0aW9uKHQpe3ZhciBuPXQuZGF0YTsoMCxsLmxvZykobywnPFJlY2VpdmVkPjonLG4pO3ZhciBzPUpTT04ucGFyc2Uobik7aWYoYSYmKCFzLnBhc3N0aHJvdWdofHwhcy5wYXNzdGhyb3VnaC5kb2N1bWVudF91cGxvYWQpKXJldHVybiB2b2lkIGEuY2FsbChyLHQpO3ZhciBpPXMucGFzc3Rocm91Z2guZG9jdW1lbnRfdXBsb2FkO2lmKGEmJiFpKXJldHVybiB2b2lkIGEuY2FsbChyLHQpO2lmKHMucmVxX2lkIGluIGUuY2xpZW50cyl7dmFyIGM9ZS5jbGllbnRzW3MucmVxX2lkXSxwPWMuY2xpZW50LGQ9Yy5wcm9taXNlO3RyeXt2YXIgdT1wLmhhbmRsZU1lc3NhZ2Uocyk7dSYmKCgwLGwubG9nKShvLCdVcGxvYWQgc3VjY2Vzc2Z1bCwgdXBsb2FkIGluZm86Jyx1KSxkLnJlc29sdmUodSkpfWNhdGNoKHQpe2QucmVqZWN0KHQpLCgwLGwubG9nKShvLHQpfX19fX1dKSxlfSgpO3QuZGVmYXVsdD1jfSxmdW5jdGlvbihlLHQscil7J3VzZSBzdHJpY3QnO3ZhciBuPXIoMCksbz1yKDUzKSxsPXIoNzEpLGE9cigyKSxzPXIoMzEpLGk9cig2KSxjPXIoMSkscD1yKDMpLkFycmF5QnVmZmVyLGQ9cig0MiksdT1sLkFycmF5QnVmZmVyLGc9bC5EYXRhVmlldyxoPW8uQUJWJiZwLmlzVmlldyx5PXUucHJvdG90eXBlLnNsaWNlLGY9by5WSUVXLG09J0FycmF5QnVmZmVyJztuKG4uRytuLlcrbi5GKihwIT09dSkse0FycmF5QnVmZmVyOnV9KSxuKG4uUytuLkYqIW8uQ09OU1RSLG0se2lzVmlldzpmdW5jdGlvbihlKXtyZXR1cm4gaCYmaChlKXx8YyhlKSYmZiBpbiBlfX0pLG4obi5QK24uVStuLkYqcig1KShmdW5jdGlvbigpe3JldHVybiFuZXcgdSgyKS5zbGljZSgxLHZvaWQgMCkuYnl0ZUxlbmd0aH0pLG0se3NsaWNlOmZ1bmN0aW9uKGUsdCl7aWYoeSE9PXZvaWQgMCYmdD09PXZvaWQgMClyZXR1cm4geS5jYWxsKGEodGhpcyksZSk7Zm9yKHZhciByPWEodGhpcykuYnl0ZUxlbmd0aCxuPXMoZSxyKSxvPXModm9pZCAwPT09dD9yOnQsciksbD1uZXcoZCh0aGlzLHUpKShpKG8tbikpLGM9bmV3IGcodGhpcykscD1uZXcgZyhsKSxoPTA7bjxvOylwLnNldFVpbnQ4KGgrKyxjLmdldFVpbnQ4KG4rKykpO3JldHVybiBsfX0pLHIoNDMpKG0pfSxmdW5jdGlvbihlLHQscil7ZS5leHBvcnRzPXIoNDEpKCduYXRpdmUtZnVuY3Rpb24tdG8tc3RyaW5nJyxGdW5jdGlvbi50b1N0cmluZyl9LGZ1bmN0aW9uKGUsdCxyKXtyKDE1KSgnSW50OCcsMSxmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCxyLG4pe3JldHVybiBlKHRoaXMsdCxyLG4pfX0pfSxmdW5jdGlvbihlLHQscil7dmFyIG49cig3KSxvPXIoMiksbD1yKDI2KTtlLmV4cG9ydHM9cig4KT9PYmplY3QuZGVmaW5lUHJvcGVydGllczpmdW5jdGlvbihlLHQpe28oZSk7Zm9yKHZhciByLGE9bCh0KSxzPWEubGVuZ3RoLGM9MDtzPmM7KW4uZihlLHI9YVtjKytdLHRbcl0pO3JldHVybiBlfX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMTA2KTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbmV3KG4oZSkpKHQpfX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMSksbz1yKDc1KSxsPXIoNCkoJ3NwZWNpZXMnKTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7dmFyIHQ7cmV0dXJuIG8oZSkmJih0PWUuY29uc3RydWN0b3IsJ2Z1bmN0aW9uJz09dHlwZW9mIHQmJih0PT09QXJyYXl8fG8odC5wcm90b3R5cGUpKSYmKHQ9dm9pZCAwKSxuKHQpJiYodD10W2xdLG51bGw9PT10JiYodD12b2lkIDApKSksdm9pZCAwPT09dD9BcnJheTp0fX0sZnVuY3Rpb24oZSx0LHIpeyd1c2Ugc3RyaWN0Jzt2YXIgbj1yKDM4KSxvPXIoMjEpLGw9cigzMiksYT17fTtyKDkpKGEscig0KSgnaXRlcmF0b3InKSxmdW5jdGlvbigpe3JldHVybiB0aGlzfSksZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxyKXtlLnByb3RvdHlwZT1uKGEse25leHQ6bygxLHIpfSksbChlLHQrJyBJdGVyYXRvcicpfX0sZnVuY3Rpb24oZSx0LHIpe3IoMTUpKCdVaW50OCcsMSxmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCxyLG4pe3JldHVybiBlKHRoaXMsdCxyLG4pfX0pfSxmdW5jdGlvbihlLHQscil7cigxNSkoJ1VpbnQ4JywxLGZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbih0LHIsbil7cmV0dXJuIGUodGhpcyx0LHIsbil9fSwhMCl9LGZ1bmN0aW9uKGUsdCxyKXtyKDE1KSgnSW50MTYnLDIsZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKHQscixuKXtyZXR1cm4gZSh0aGlzLHQscixuKX19KX0sZnVuY3Rpb24oZSx0LHIpe3IoMTUpKCdVaW50MTYnLDIsZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKHQscixuKXtyZXR1cm4gZSh0aGlzLHQscixuKX19KX0sZnVuY3Rpb24oZSx0LHIpe3IoMTUpKCdJbnQzMicsNCxmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCxyLG4pe3JldHVybiBlKHRoaXMsdCxyLG4pfX0pfSxmdW5jdGlvbihlLHQscil7cigxNSkoJ1VpbnQzMicsNCxmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCxyLG4pe3JldHVybiBlKHRoaXMsdCxyLG4pfX0pfSxmdW5jdGlvbihlLHQscil7cigxNSkoJ0Zsb2F0MzInLDQsZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKHQscixuKXtyZXR1cm4gZSh0aGlzLHQscixuKX19KX0sZnVuY3Rpb24oZSx0LHIpe3IoMTUpKCdGbG9hdDY0Jyw4LGZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbih0LHIsbil7cmV0dXJuIGUodGhpcyx0LHIsbil9fSl9LGZ1bmN0aW9uKGUsdCxyKXsndXNlIHN0cmljdCc7dmFyIG49cig3OSksbz1yKDI3KSxsPSdNYXAnO2UuZXhwb3J0cz1yKDQ3KShsLGZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBlKHRoaXMsMDxhcmd1bWVudHMubGVuZ3RoP2FyZ3VtZW50c1swXTp2b2lkIDApfX0se2dldDpmdW5jdGlvbihlKXt2YXIgdD1uLmdldEVudHJ5KG8odGhpcyxsKSxlKTtyZXR1cm4gdCYmdC52fSxzZXQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbi5kZWYobyh0aGlzLGwpLDA9PT1lPzA6ZSx0KX19LG4sITApfSxmdW5jdGlvbihlLHQscil7dmFyIG49cigxKSxvPXIoODEpLnNldDtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0LHIpe3ZhciBsLGE9dC5jb25zdHJ1Y3RvcjtyZXR1cm4gYSE9PXImJidmdW5jdGlvbic9PXR5cGVvZiBhJiYobD1hLnByb3RvdHlwZSkhPT1yLnByb3RvdHlwZSYmbihsKSYmbyYmbyhlLGwpLGV9fSxmdW5jdGlvbihlLHQscil7J3VzZSBzdHJpY3QnO3ZhciBuPXIoNzkpLG89cigyNyksbD0nU2V0JztlLmV4cG9ydHM9cig0NykobCxmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gZSh0aGlzLDA8YXJndW1lbnRzLmxlbmd0aD9hcmd1bWVudHNbMF06dm9pZCAwKX19LHthZGQ6ZnVuY3Rpb24oZSl7cmV0dXJuIG4uZGVmKG8odGhpcyxsKSxlPTA9PT1lPzA6ZSxlKX19LG4pfSxmdW5jdGlvbihlLHQscil7J3VzZSBzdHJpY3QnO3ZhciBuLG89cigzKSxsPXIoMzkpKDApLGE9cigxNykscz1yKDE5KSxpPXIoODIpLGM9cig4MykscD1yKDEpLGQ9cigyNyksdT1yKDI3KSxnPSFvLkFjdGl2ZVhPYmplY3QmJidBY3RpdmVYT2JqZWN0J2luIG8saD0nV2Vha01hcCcseT1zLmdldFdlYWssZj1PYmplY3QuaXNFeHRlbnNpYmxlLG09Yy51ZnN0b3JlLEU9ZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGUodGhpcywwPGFyZ3VtZW50cy5sZW5ndGg/YXJndW1lbnRzWzBdOnZvaWQgMCl9fSxfPXtnZXQ6ZnVuY3Rpb24oZSl7aWYocChlKSl7dmFyIHQ9eShlKTtyZXR1cm4hMD09PXQ/bShkKHRoaXMsaCkpLmdldChlKTp0P3RbdGhpcy5faV06dm9pZCAwfX0sc2V0OmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGMuZGVmKGQodGhpcyxoKSxlLHQpfX0seD1lLmV4cG9ydHM9cig0NykoaCxFLF8sYywhMCwhMCk7dSYmZyYmKG49Yy5nZXRDb25zdHJ1Y3RvcihFLGgpLGkobi5wcm90b3R5cGUsXykscy5ORUVEPSEwLGwoWydkZWxldGUnLCdoYXMnLCdnZXQnLCdzZXQnXSxmdW5jdGlvbihlKXt2YXIgdD14LnByb3RvdHlwZSxyPXRbZV07YSh0LGUsZnVuY3Rpb24odCxvKXtpZihwKHQpJiYhZih0KSl7dGhpcy5fZnx8KHRoaXMuX2Y9bmV3IG4pO3ZhciBsPXRoaXMuX2ZbZV0odCxvKTtyZXR1cm4nc2V0Jz09ZT90aGlzOmx9cmV0dXJuIHIuY2FsbCh0aGlzLHQsbyl9KX0pKX0sZnVuY3Rpb24oZSx0LHIpeyd1c2Ugc3RyaWN0Jzt2YXIgbj1yKDgzKSxvPXIoMjcpLGw9J1dlYWtTZXQnO3IoNDcpKGwsZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGUodGhpcywwPGFyZ3VtZW50cy5sZW5ndGg/YXJndW1lbnRzWzBdOnZvaWQgMCl9fSx7YWRkOmZ1bmN0aW9uKGUpe3JldHVybiBuLmRlZihvKHRoaXMsbCksZSwhMCl9fSxuLCExLCEwKX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMCksbz1yKDI0KSxsPXIoMiksYT0ocigzKS5SZWZsZWN0fHx7fSkuYXBwbHkscz1GdW5jdGlvbi5hcHBseTtuKG4uUytuLkYqIXIoNSkoZnVuY3Rpb24oKXthKGZ1bmN0aW9uKCl7fSl9KSwnUmVmbGVjdCcse2FwcGx5OmZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1vKGUpLGk9bChyKTtyZXR1cm4gYT9hKG4sdCxpKTpzLmNhbGwobix0LGkpfX0pfSxmdW5jdGlvbihlLHQscil7dmFyIG49cigwKSxvPXIoMzgpLGw9cigyNCksYT1yKDIpLHM9cigxKSxpPXIoNSksYz1yKDEyMykscD0ocigzKS5SZWZsZWN0fHx7fSkuY29uc3RydWN0LGQ9aShmdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt9cmV0dXJuIShwKGZ1bmN0aW9uKCl7fSxbXSxlKWluc3RhbmNlb2YgZSl9KSx1PSFpKGZ1bmN0aW9uKCl7cChmdW5jdGlvbigpe30pfSk7bihuLlMrbi5GKihkfHx1KSwnUmVmbGVjdCcse2NvbnN0cnVjdDpmdW5jdGlvbihlLHQpe2woZSksYSh0KTt2YXIgcj0zPmFyZ3VtZW50cy5sZW5ndGg/ZTpsKGFyZ3VtZW50c1syXSk7aWYodSYmIWQpcmV0dXJuIHAoZSx0LHIpO2lmKGU9PXIpe3N3aXRjaCh0Lmxlbmd0aCl7Y2FzZSAwOnJldHVybiBuZXcgZTtjYXNlIDE6cmV0dXJuIG5ldyBlKHRbMF0pO2Nhc2UgMjpyZXR1cm4gbmV3IGUodFswXSx0WzFdKTtjYXNlIDM6cmV0dXJuIG5ldyBlKHRbMF0sdFsxXSx0WzJdKTtjYXNlIDQ6cmV0dXJuIG5ldyBlKHRbMF0sdFsxXSx0WzJdLHRbM10pO312YXIgbj1bbnVsbF07cmV0dXJuIG4ucHVzaC5hcHBseShuLHQpLG5ldyhjLmFwcGx5KGUsbikpfXZhciBpPXIucHJvdG90eXBlLGc9byhzKGkpP2k6T2JqZWN0LnByb3RvdHlwZSksaD1GdW5jdGlvbi5hcHBseS5jYWxsKGUsZyx0KTtyZXR1cm4gcyhoKT9oOmd9fSl9LGZ1bmN0aW9uKGUsdCxyKXsndXNlIHN0cmljdCc7dmFyIG49cigyNCksbz1yKDEpLGw9cig4NCksYT1bXS5zbGljZSxzPXt9LGk9ZnVuY3Rpb24oZSx0LHIpe2lmKCEodCBpbiBzKSl7Zm9yKHZhciBvPVtdLG49MDtuPHQ7bisrKW9bbl09J2FbJytuKyddJztzW3RdPUZ1bmN0aW9uKCdGLGEnLCdyZXR1cm4gbmV3IEYoJytvLmpvaW4oJywnKSsnKScpfXJldHVybiBzW3RdKGUscil9O2UuZXhwb3J0cz1GdW5jdGlvbi5iaW5kfHxmdW5jdGlvbihlKXt2YXIgdD1uKHRoaXMpLHI9YS5jYWxsKGFyZ3VtZW50cywxKSxzPWZ1bmN0aW9uKCl7dmFyIG49ci5jb25jYXQoYS5jYWxsKGFyZ3VtZW50cykpO3JldHVybiB0aGlzIGluc3RhbmNlb2Ygcz9pKHQsbi5sZW5ndGgsbik6bCh0LG4sZSl9O3JldHVybiBvKHQucHJvdG90eXBlKSYmKHMucHJvdG90eXBlPXQucHJvdG90eXBlKSxzfX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoNyksbz1yKDApLGw9cigyKSxhPXIoMzYpO28oby5TK28uRipyKDUpKGZ1bmN0aW9uKCl7UmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShuLmYoe30sMSx7dmFsdWU6MX0pLDEse3ZhbHVlOjJ9KX0pLCdSZWZsZWN0Jyx7ZGVmaW5lUHJvcGVydHk6ZnVuY3Rpb24oZSx0LHIpe2woZSksdD1hKHQsITApLGwocik7dHJ5e3JldHVybiBuLmYoZSx0LHIpLCEwfWNhdGNoKHQpe3JldHVybiExfX19KX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMCksbz1yKDE2KS5mLGw9cigyKTtuKG4uUywnUmVmbGVjdCcse2RlbGV0ZVByb3BlcnR5OmZ1bmN0aW9uKGUsdCl7dmFyIHI9byhsKGUpLHQpO3JldHVybiByJiYhci5jb25maWd1cmFibGU/ITE6ZGVsZXRlIGVbdF19fSl9LGZ1bmN0aW9uKGUsdCxyKXtmdW5jdGlvbiBuKGUsdCl7dmFyIHIscyxwPTM+YXJndW1lbnRzLmxlbmd0aD9lOmFyZ3VtZW50c1syXTtyZXR1cm4gYyhlKT09PXA/ZVt0XToocj1vLmYoZSx0KSk/YShyLCd2YWx1ZScpP3IudmFsdWU6dm9pZCAwPT09ci5nZXQ/dm9pZCAwOnIuZ2V0LmNhbGwocCk6aShzPWwoZSkpP24ocyx0LHApOnZvaWQgMH12YXIgbz1yKDE2KSxsPXIoMzQpLGE9cigxMCkscz1yKDApLGk9cigxKSxjPXIoMik7cyhzLlMsJ1JlZmxlY3QnLHtnZXQ6bn0pfSxmdW5jdGlvbihlLHQscil7dmFyIG49cigxNiksbz1yKDApLGw9cigyKTtvKG8uUywnUmVmbGVjdCcse2dldE93blByb3BlcnR5RGVzY3JpcHRvcjpmdW5jdGlvbihlLHQpe3JldHVybiBuLmYobChlKSx0KX19KX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMCksbz1yKDM0KSxsPXIoMik7bihuLlMsJ1JlZmxlY3QnLHtnZXRQcm90b3R5cGVPZjpmdW5jdGlvbihlKXtyZXR1cm4gbyhsKGUpKX19KX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMCk7bihuLlMsJ1JlZmxlY3QnLHtoYXM6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdCBpbiBlfX0pfSxmdW5jdGlvbihlLHQscil7dmFyIG49cigwKSxvPXIoMiksbD1PYmplY3QuaXNFeHRlbnNpYmxlO24obi5TLCdSZWZsZWN0Jyx7aXNFeHRlbnNpYmxlOmZ1bmN0aW9uKGUpe3JldHVybiBvKGUpLCFsfHxsKGUpfX0pfSxmdW5jdGlvbihlLHQscil7dmFyIG49cigwKTtuKG4uUywnUmVmbGVjdCcse293bktleXM6cig4NSl9KX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMCksbz1yKDIpLGw9T2JqZWN0LnByZXZlbnRFeHRlbnNpb25zO24obi5TLCdSZWZsZWN0Jyx7cHJldmVudEV4dGVuc2lvbnM6ZnVuY3Rpb24oZSl7byhlKTt0cnl7cmV0dXJuIGwmJmwoZSksITB9Y2F0Y2godCl7cmV0dXJuITF9fX0pfSxmdW5jdGlvbihlLHQscil7ZnVuY3Rpb24gbihlLHQscil7dmFyIGksdSxnPTQ+YXJndW1lbnRzLmxlbmd0aD9lOmFyZ3VtZW50c1szXSxoPWwuZihwKGUpLHQpO2lmKCFoKXtpZihkKHU9YShlKSkpcmV0dXJuIG4odSx0LHIsZyk7aD1jKDApfWlmKHMoaCwndmFsdWUnKSl7aWYoITE9PT1oLndyaXRhYmxlfHwhZChnKSlyZXR1cm4hMTtpZihpPWwuZihnLHQpKXtpZihpLmdldHx8aS5zZXR8fCExPT09aS53cml0YWJsZSlyZXR1cm4hMTtpLnZhbHVlPXIsby5mKGcsdCxpKX1lbHNlIG8uZihnLHQsYygwLHIpKTtyZXR1cm4hMH1yZXR1cm4gaC5zZXQhPT12b2lkIDAmJihoLnNldC5jYWxsKGcsciksITApfXZhciBvPXIoNyksbD1yKDE2KSxhPXIoMzQpLHM9cigxMCksaT1yKDApLGM9cigyMSkscD1yKDIpLGQ9cigxKTtpKGkuUywnUmVmbGVjdCcse3NldDpufSl9LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDApLG89cig4MSk7byYmbihuLlMsJ1JlZmxlY3QnLHtzZXRQcm90b3R5cGVPZjpmdW5jdGlvbihlLHQpe28uY2hlY2soZSx0KTt0cnl7cmV0dXJuIG8uc2V0KGUsdCksITB9Y2F0Y2godCl7cmV0dXJuITF9fX0pfSxmdW5jdGlvbihlLHQscil7J3VzZSBzdHJpY3QnO3ZhciBuLG8sbCxhLHM9cigyMyksaT1yKDMpLGM9cigxNCkscD1yKDQ0KSxkPXIoMCksdT1yKDEpLGc9cigyNCksaD1yKDI5KSx5PXIoNDYpLGY9cig0MiksbT1yKDYyKS5zZXQsRT1yKDEzNikoKSxfPXIoODYpLHg9cigxMzcpLFM9cig0OSksVD1yKDEzOCksYj0nUHJvbWlzZScsUD1pLlR5cGVFcnJvcixPPWkucHJvY2Vzcyx2PU8mJk8udmVyc2lvbnMsST12JiZ2LnY4fHwnJyxBPWlbYl0sUj0ncHJvY2Vzcyc9PXAoTyksaz1mdW5jdGlvbigpe30sTD1vPV8uZixGPSEhZnVuY3Rpb24oKXt0cnl7dmFyIGU9QS5yZXNvbHZlKDEpLHQ9KGUuY29uc3RydWN0b3I9e30pW3IoNCkoJ3NwZWNpZXMnKV09ZnVuY3Rpb24oZSl7ZShrLGspfTtyZXR1cm4oUnx8J2Z1bmN0aW9uJz09dHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCkmJmUudGhlbihrKWluc3RhbmNlb2YgdCYmMCE9PUkuaW5kZXhPZignNi42JykmJi0xPT09Uy5pbmRleE9mKCdDaHJvbWUvNjYnKX1jYXRjaCh0KXt9fSgpLE49ZnVuY3Rpb24oZSl7dmFyIHQ7cmV0dXJuIHUoZSkmJidmdW5jdGlvbic9PXR5cGVvZih0PWUudGhlbikmJnR9LHc9ZnVuY3Rpb24oZSx0KXtpZighZS5fbil7ZS5fbj0hMDt2YXIgcj1lLl9jO0UoZnVuY3Rpb24oKXtmb3IodmFyIG49ZS5fdixvPTE9PWUuX3MsbD0wLGE9ZnVuY3Rpb24odCl7dmFyIHIsbCxhLHM9bz90Lm9rOnQuZmFpbCxpPXQucmVzb2x2ZSxjPXQucmVqZWN0LHA9dC5kb21haW47dHJ5e3M/KCFvJiYoMj09ZS5faCYmQyhlKSxlLl9oPTEpLCEwPT09cz9yPW46KHAmJnAuZW50ZXIoKSxyPXMobikscCYmKHAuZXhpdCgpLGE9ITApKSxyPT09dC5wcm9taXNlP2MoUCgnUHJvbWlzZS1jaGFpbiBjeWNsZScpKToobD1OKHIpKT9sLmNhbGwocixpLGMpOmkocikpOmMobil9Y2F0Y2godCl7cCYmIWEmJnAuZXhpdCgpLGModCl9fTtyLmxlbmd0aD5sOylhKHJbbCsrXSk7ZS5fYz1bXSxlLl9uPSExLHQmJiFlLl9oJiZNKGUpfSl9fSxNPWZ1bmN0aW9uKGUpe20uY2FsbChpLGZ1bmN0aW9uKCl7dmFyIHQscixuLG89ZS5fdixsPUQoZSk7aWYobCYmKHQ9eChmdW5jdGlvbigpe1I/Ty5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLG8sZSk6KHI9aS5vbnVuaGFuZGxlZHJlamVjdGlvbik/cih7cHJvbWlzZTplLHJlYXNvbjpvfSk6KG49aS5jb25zb2xlKSYmbi5lcnJvciYmbi5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJyxvKX0pLGUuX2g9Unx8RChlKT8yOjEpLGUuX2E9dm9pZCAwLGwmJnQuZSl0aHJvdyB0LnZ9KX0sRD1mdW5jdGlvbihlKXtyZXR1cm4gMSE9PWUuX2gmJjA9PT0oZS5fYXx8ZS5fYykubGVuZ3RofSxDPWZ1bmN0aW9uKGUpe20uY2FsbChpLGZ1bmN0aW9uKCl7dmFyIHQ7Uj9PLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLGUpOih0PWkub25yZWplY3Rpb25oYW5kbGVkKSYmdCh7cHJvbWlzZTplLHJlYXNvbjplLl92fSl9KX0saj1mdW5jdGlvbihlKXt2YXIgdD10aGlzO3QuX2R8fCh0Ll9kPSEwLHQ9dC5fd3x8dCx0Ll92PWUsdC5fcz0yLCF0Ll9hJiYodC5fYT10Ll9jLnNsaWNlKCkpLHcodCwhMCkpfSxZPWZ1bmN0aW9uKGUpe3ZhciB0LHI9dGhpcztpZighci5fZCl7ci5fZD0hMCxyPXIuX3d8fHI7dHJ5e2lmKHI9PT1lKXRocm93IFAoJ1Byb21pc2UgY2FuXFwndCBiZSByZXNvbHZlZCBpdHNlbGYnKTsodD1OKGUpKT9FKGZ1bmN0aW9uKCl7dmFyIG49e193OnIsX2Q6ITF9O3RyeXt0LmNhbGwoZSxjKFksbiwxKSxjKGosbiwxKSl9Y2F0Y2godCl7ai5jYWxsKG4sdCl9fSk6KHIuX3Y9ZSxyLl9zPTEsdyhyLCExKSl9Y2F0Y2godCl7ai5jYWxsKHtfdzpyLF9kOiExfSx0KX19fTtGfHwoQT1mdW5jdGlvbihlKXtoKHRoaXMsQSxiLCdfaCcpLGcoZSksbi5jYWxsKHRoaXMpO3RyeXtlKGMoWSx0aGlzLDEpLGMoaix0aGlzLDEpKX1jYXRjaChlKXtqLmNhbGwodGhpcyxlKX19LG49ZnVuY3Rpb24oKXt0aGlzLl9jPVtdLHRoaXMuX2E9dm9pZCAwLHRoaXMuX3M9MCx0aGlzLl9kPSExLHRoaXMuX3Y9dm9pZCAwLHRoaXMuX2g9MCx0aGlzLl9uPSExfSxuLnByb3RvdHlwZT1yKDI4KShBLnByb3RvdHlwZSx7dGhlbjpmdW5jdGlvbihlLHQpe3ZhciByPUwoZih0aGlzLEEpKTtyZXR1cm4gci5vaz0nZnVuY3Rpb24nIT10eXBlb2YgZXx8ZSxyLmZhaWw9J2Z1bmN0aW9uJz09dHlwZW9mIHQmJnQsci5kb21haW49Uj9PLmRvbWFpbjp2b2lkIDAsdGhpcy5fYy5wdXNoKHIpLHRoaXMuX2EmJnRoaXMuX2EucHVzaChyKSx0aGlzLl9zJiZ3KHRoaXMsITEpLHIucHJvbWlzZX0sY2F0Y2g6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhlbih2b2lkIDAsZSl9fSksbD1mdW5jdGlvbigpe3ZhciBlPW5ldyBuO3RoaXMucHJvbWlzZT1lLHRoaXMucmVzb2x2ZT1jKFksZSwxKSx0aGlzLnJlamVjdD1jKGosZSwxKX0sXy5mPUw9ZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT1BfHxlPT09YT9uZXcgbChlKTpvKGUpfSksZChkLkcrZC5XK2QuRiohRix7UHJvbWlzZTpBfSkscigzMikoQSxiKSxyKDQzKShiKSxhPXIoMjApW2JdLGQoZC5TK2QuRiohRixiLHtyZWplY3Q6ZnVuY3Rpb24oZSl7dmFyIHQ9TCh0aGlzKSxyPXQucmVqZWN0O3JldHVybiByKGUpLHQucHJvbWlzZX19KSxkKGQuUytkLkYqKHN8fCFGKSxiLHtyZXNvbHZlOmZ1bmN0aW9uKGUpe3JldHVybiBUKHMmJnRoaXM9PT1hP0E6dGhpcyxlKX19KSxkKGQuUytkLkYqIShGJiZyKDQ1KShmdW5jdGlvbihlKXtBLmFsbChlKVsnY2F0Y2gnXShrKX0pKSxiLHthbGw6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxyPUwodCksbj1yLnJlc29sdmUsbz1yLnJlamVjdCxsPXgoZnVuY3Rpb24oKXt2YXIgcj1bXSxsPTAsYT0xO3koZSwhMSxmdW5jdGlvbihlKXt2YXIgcz1sKyssaT0hMTtyLnB1c2godm9pZCAwKSxhKyssdC5yZXNvbHZlKGUpLnRoZW4oZnVuY3Rpb24oZSl7aXx8KGk9ITAscltzXT1lLC0tYXx8bihyKSl9LG8pfSksLS1hfHxuKHIpfSk7cmV0dXJuIGwuZSYmbyhsLnYpLHIucHJvbWlzZX0scmFjZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLHI9TCh0KSxuPXIucmVqZWN0LG89eChmdW5jdGlvbigpe3koZSwhMSxmdW5jdGlvbihlKXt0LnJlc29sdmUoZSkudGhlbihyLnJlc29sdmUsbil9KX0pO3JldHVybiBvLmUmJm4oby52KSxyLnByb21pc2V9fSl9LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDMpLG89cig2Mikuc2V0LGw9bi5NdXRhdGlvbk9ic2VydmVyfHxuLldlYktpdE11dGF0aW9uT2JzZXJ2ZXIsYT1uLnByb2Nlc3Mscz1uLlByb21pc2UsaT0ncHJvY2Vzcyc9PXIoMzApKGEpO2UuZXhwb3J0cz1mdW5jdGlvbigpe3ZhciB0LHIsYyxlPWZ1bmN0aW9uKCl7dmFyIGUsbjtmb3IoaSYmKGU9YS5kb21haW4pJiZlLmV4aXQoKTt0Oyl7bj10LmZuLHQ9dC5uZXh0O3RyeXtuKCl9Y2F0Y2gobil7dGhyb3cgdD9jKCk6cj12b2lkIDAsbn19cj12b2lkIDAsZSYmZS5lbnRlcigpfTtpZihpKWM9ZnVuY3Rpb24oKXthLm5leHRUaWNrKGUpfTtlbHNlIGlmKGwmJiEobi5uYXZpZ2F0b3ImJm4ubmF2aWdhdG9yLnN0YW5kYWxvbmUpKXt2YXIgcD0hMCxkPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtuZXcgbChlKS5vYnNlcnZlKGQse2NoYXJhY3RlckRhdGE6ITB9KSxjPWZ1bmN0aW9uKCl7ZC5kYXRhPXA9IXB9fWVsc2UgaWYocyYmcy5yZXNvbHZlKXt2YXIgdT1zLnJlc29sdmUodm9pZCAwKTtjPWZ1bmN0aW9uKCl7dS50aGVuKGUpfX1lbHNlIGM9ZnVuY3Rpb24oKXtvLmNhbGwobixlKX07cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciBuPXtmbjplLG5leHQ6dm9pZCAwfTtyJiYoci5uZXh0PW4pLHR8fCh0PW4sYygpKSxyPW59fX0sZnVuY3Rpb24oZSl7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3RyeXtyZXR1cm57ZTohMSx2OmUoKX19Y2F0Y2godCl7cmV0dXJue2U6ITAsdjp0fX19fSxmdW5jdGlvbihlLHQscil7dmFyIG49cigyKSxvPXIoMSksbD1yKDg2KTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtpZihuKGUpLG8odCkmJnQuY29uc3RydWN0b3I9PT1lKXJldHVybiB0O3ZhciByPWwuZihlKSxhPXIucmVzb2x2ZTtyZXR1cm4gYSh0KSxyLnByb21pc2V9fSxmdW5jdGlvbihlLHQscil7J3VzZSBzdHJpY3QnO3ZhciBuPXIoMyksbz1yKDEwKSxsPXIoOCksYT1yKDApLHM9cigxNyksYz1yKDE5KS5LRVksaT1yKDUpLHA9cig0MSksZD1yKDMyKSx1PXIoMjIpLGc9cig0KSxoPXIoODcpLHk9cigxNDApLGY9cigxNDEpLG09cig3NSksRT1yKDIpLF89cigxKSx4PXIoMTEpLFM9cigzNiksVD1yKDIxKSxiPXIoMzgpLFA9cig4OCksTz1yKDE2KSx2PXIoNyksST1yKDI2KSxBPU8uZixSPXYuZixMPVAuZixGPW4uU3ltYm9sLE49bi5KU09OLHc9TiYmTi5zdHJpbmdpZnksTT0ncHJvdG90eXBlJyxDPWcoJ19oaWRkZW4nKSxEPWcoJ3RvUHJpbWl0aXZlJyksWT17fS5wcm9wZXJ0eUlzRW51bWVyYWJsZSxCPXAoJ3N5bWJvbC1yZWdpc3RyeScpLEc9cCgnc3ltYm9scycpLFU9cCgnb3Atc3ltYm9scycpLEg9T2JqZWN0W01dLFc9J2Z1bmN0aW9uJz09dHlwZW9mIEYsVj1uLlFPYmplY3Qsej0hVnx8IVZbTV18fCFWW01dLmZpbmRDaGlsZCwkPWwmJmkoZnVuY3Rpb24oKXtyZXR1cm4gNyE9YihSKHt9LCdhJyx7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFIodGhpcywnYScse3ZhbHVlOjd9KS5hfX0pKS5hfSk/ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPUEoSCx0KTtuJiZkZWxldGUgSFt0XSxSKGUsdCxyKSxuJiZlIT09SCYmUihILHQsbil9OlIsSz1mdW5jdGlvbihlKXt2YXIgdD1HW2VdPWIoRltNXSk7cmV0dXJuIHQuX2s9ZSx0fSxxPVcmJidzeW1ib2wnPT10eXBlb2YgRi5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4nc3ltYm9sJz09dHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgRn0sWD1mdW5jdGlvbihlLHQscil7cmV0dXJuIGU9PT1IJiZYKFUsdCxyKSxFKGUpLHQ9Uyh0LCEwKSxFKHIpLG8oRyx0KT8oci5lbnVtZXJhYmxlPyhvKGUsQykmJmVbQ11bdF0mJihlW0NdW3RdPSExKSxyPWIocix7ZW51bWVyYWJsZTpUKDAsITEpfSkpOighbyhlLEMpJiZSKGUsQyxUKDEse30pKSxlW0NdW3RdPSEwKSwkKGUsdCxyKSk6UihlLHQscil9LFo9ZnVuY3Rpb24oZSx0KXtFKGUpO2Zvcih2YXIgcixuPWYodD14KHQpKSxvPTAsYT1uLmxlbmd0aDthPm87KVgoZSxyPW5bbysrXSx0W3JdKTtyZXR1cm4gZX0sSj1mdW5jdGlvbihlKXt2YXIgdD1ZLmNhbGwodGhpcyxlPVMoZSwhMCkpO3JldHVybiB0aGlzPT09SCYmbyhHLGUpJiYhbyhVLGUpPyExOnR8fCFvKHRoaXMsZSl8fCFvKEcsZSl8fG8odGhpcyxDKSYmdGhpc1tDXVtlXT90OiEwfSxRPWZ1bmN0aW9uKGUsdCl7aWYoZT14KGUpLHQ9Uyh0LCEwKSxlIT09SHx8IW8oRyx0KXx8byhVLHQpKXt2YXIgcj1BKGUsdCk7cmV0dXJuIHImJm8oRyx0KSYmIShvKGUsQykmJmVbQ11bdF0pJiYoci5lbnVtZXJhYmxlPSEwKSxyfX0sZWU9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0LHI9TCh4KGUpKSxuPVtdLGw9MDtyLmxlbmd0aD5sOylvKEcsdD1yW2wrK10pfHx0PT1DfHx0PT1jfHxuLnB1c2godCk7cmV0dXJuIG59LHRlPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxyPWU9PT1ILG49TChyP1U6eChlKSksbD1bXSxhPTA7bi5sZW5ndGg+YTspbyhHLHQ9blthKytdKSYmKCFyfHxvKEgsdCkpJiZsLnB1c2goR1t0XSk7cmV0dXJuIGx9O1d8fChGPWZ1bmN0aW9uKCl7aWYodGhpcyBpbnN0YW5jZW9mIEYpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7dmFyIGU9dSgwPGFyZ3VtZW50cy5sZW5ndGg/YXJndW1lbnRzWzBdOnZvaWQgMCksdD1mdW5jdGlvbihyKXt0aGlzPT09SCYmdC5jYWxsKFUsciksbyh0aGlzLEMpJiZvKHRoaXNbQ10sZSkmJih0aGlzW0NdW2VdPSExKSwkKHRoaXMsZSxUKDEscikpfTtyZXR1cm4gbCYmeiYmJChILGUse2NvbmZpZ3VyYWJsZTohMCxzZXQ6dH0pLEsoZSl9LHMoRltNXSwndG9TdHJpbmcnLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2t9KSxPLmY9USx2LmY9WCxyKDM3KS5mPVAuZj1lZSxyKDQwKS5mPUoscig0OCkuZj10ZSxsJiYhcigyMykmJnMoSCwncHJvcGVydHlJc0VudW1lcmFibGUnLEosITApLGguZj1mdW5jdGlvbihlKXtyZXR1cm4gSyhnKGUpKX0pLGEoYS5HK2EuVythLkYqIVcse1N5bWJvbDpGfSk7Zm9yKHZhciByZT1bJ2hhc0luc3RhbmNlJywnaXNDb25jYXRTcHJlYWRhYmxlJywnaXRlcmF0b3InLCdtYXRjaCcsJ3JlcGxhY2UnLCdzZWFyY2gnLCdzcGVjaWVzJywnc3BsaXQnLCd0b1ByaW1pdGl2ZScsJ3RvU3RyaW5nVGFnJywndW5zY29wYWJsZXMnXSxuZT0wO3JlLmxlbmd0aD5uZTspZyhyZVtuZSsrXSk7Zm9yKHZhciBqPUkoZy5zdG9yZSksb2U9MDtqLmxlbmd0aD5vZTspeShqW29lKytdKTthKGEuUythLkYqIVcsJ1N5bWJvbCcse2ZvcjpmdW5jdGlvbihlKXtyZXR1cm4gbyhCLGUrPScnKT9CW2VdOkJbZV09RihlKX0sa2V5Rm9yOmZ1bmN0aW9uKGUpe2lmKCFxKGUpKXRocm93IFR5cGVFcnJvcihlKycgaXMgbm90IGEgc3ltYm9sIScpO2Zvcih2YXIgdCBpbiBCKWlmKEJbdF09PT1lKXJldHVybiB0fSx1c2VTZXR0ZXI6ZnVuY3Rpb24oKXt6PSEwfSx1c2VTaW1wbGU6ZnVuY3Rpb24oKXt6PSExfX0pLGEoYS5TK2EuRiohVywnT2JqZWN0Jyx7Y3JlYXRlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQ9PT12b2lkIDA/YihlKTpaKGIoZSksdCl9LGRlZmluZVByb3BlcnR5OlgsZGVmaW5lUHJvcGVydGllczpaLGdldE93blByb3BlcnR5RGVzY3JpcHRvcjpRLGdldE93blByb3BlcnR5TmFtZXM6ZWUsZ2V0T3duUHJvcGVydHlTeW1ib2xzOnRlfSksTiYmYShhLlMrYS5GKighV3x8aShmdW5jdGlvbigpe3ZhciBlPUYoKTtyZXR1cm4nW251bGxdJyE9dyhbZV0pfHwne30nIT13KHthOmV9KXx8J3t9JyE9dyhPYmplY3QoZSkpfSkpLCdKU09OJyx7c3RyaW5naWZ5OmZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxyLG49W2VdLG89MTthcmd1bWVudHMubGVuZ3RoPm87KW4ucHVzaChhcmd1bWVudHNbbysrXSk7aWYocj10PW5bMV0sKF8odCl8fHZvaWQgMCE9PWUpJiYhcShlKSlyZXR1cm4gbSh0KXx8KHQ9ZnVuY3Rpb24oZSx0KXtpZignZnVuY3Rpb24nPT10eXBlb2YgciYmKHQ9ci5jYWxsKHRoaXMsZSx0KSksIXEodCkpcmV0dXJuIHR9KSxuWzFdPXQsdy5hcHBseShOLG4pfX0pLEZbTV1bRF18fHIoOSkoRltNXSxELEZbTV0udmFsdWVPZiksZChGLCdTeW1ib2wnKSxkKE1hdGgsJ01hdGgnLCEwKSxkKG4uSlNPTiwnSlNPTicsITApfSxmdW5jdGlvbihlLHQscil7dmFyIG49cigzKSxvPXIoMjApLGw9cigyMyksYT1yKDg3KSxzPXIoNykuZjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7dmFyIHQ9by5TeW1ib2x8fChvLlN5bWJvbD1sP3t9Om4uU3ltYm9sfHx7fSk7J18nPT1lLmNoYXJBdCgwKXx8ZSBpbiB0fHxzKHQsZSx7dmFsdWU6YS5mKGUpfSl9fSxmdW5jdGlvbihlLHQscil7dmFyIG49cigyNiksbz1yKDQ4KSxsPXIoNDApO2UuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdD1uKGUpLHI9by5mO2lmKHIpZm9yKHZhciBhLHM9cihlKSxjPWwuZixwPTA7cy5sZW5ndGg+cDspYy5jYWxsKGUsYT1zW3ArK10pJiZ0LnB1c2goYSk7cmV0dXJuIHR9fSxmdW5jdGlvbihlLHQscil7dmFyIG49cigxKSxvPXIoMTkpLm9uRnJlZXplO3IoMTMpKCdmcmVlemUnLGZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4gZSYmbih0KT9lKG8odCkpOnR9fSl9LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDEpLG89cigxOSkub25GcmVlemU7cigxMykoJ3NlYWwnLGZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4gZSYmbih0KT9lKG8odCkpOnR9fSl9LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDEpLG89cigxOSkub25GcmVlemU7cigxMykoJ3ByZXZlbnRFeHRlbnNpb25zJyxmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIGUmJm4odCk/ZShvKHQpKTp0fX0pfSxmdW5jdGlvbihlLHQscil7dmFyIG49cigxKTtyKDEzKSgnaXNGcm96ZW4nLGZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4hbih0KXx8ISFlJiZlKHQpfX0pfSxmdW5jdGlvbihlLHQscil7dmFyIG49cigxKTtyKDEzKSgnaXNTZWFsZWQnLGZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4hbih0KXx8ISFlJiZlKHQpfX0pfSxmdW5jdGlvbihlLHQscil7dmFyIG49cigxKTtyKDEzKSgnaXNFeHRlbnNpYmxlJyxmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuISFuKHQpJiYoIWV8fGUodCkpfX0pfSxmdW5jdGlvbihlLHQscil7dmFyIG49cigxMSksbz1yKDE2KS5mO3IoMTMpKCdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7cmV0dXJuIG8obihlKSx0KX19KX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMTIpLG89cigzNCk7cigxMykoJ2dldFByb3RvdHlwZU9mJyxmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gbyhuKGUpKX19KX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMTIpLG89cigyNik7cigxMykoJ2tleXMnLGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBvKG4oZSkpfX0pfSxmdW5jdGlvbihlLHQscil7cigxMykoJ2dldE93blByb3BlcnR5TmFtZXMnLGZ1bmN0aW9uKCl7cmV0dXJuIHIoODgpLmZ9KX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMCk7bihuLlMrbi5GLCdPYmplY3QnLHthc3NpZ246cig4Mil9KX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMCk7bihuLlMsJ09iamVjdCcse2lzOnIoODkpfSl9LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDcpLmYsbz1GdW5jdGlvbi5wcm90b3R5cGUsbD0vXlxccypmdW5jdGlvbiAoW14gKF0qKS8sYT0nbmFtZSc7YSBpbiBvfHxyKDgpJiZuKG8sYSx7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3RyeXtyZXR1cm4oJycrdGhpcykubWF0Y2gobClbMV19Y2F0Y2godCl7cmV0dXJuJyd9fX0pfSxmdW5jdGlvbihlLHQscil7dmFyIG49cigwKSxvPXIoMTEpLGw9cig2KTtuKG4uUywnU3RyaW5nJyx7cmF3OmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1vKGUucmF3KSxyPWwodC5sZW5ndGgpLG49YXJndW1lbnRzLmxlbmd0aCxhPVtdLHM9MDtyPnM7KWEucHVzaCh0W3MrK10rJycpLHM8biYmYS5wdXNoKGFyZ3VtZW50c1tzXSsnJyk7cmV0dXJuIGEuam9pbignJyl9fSl9LGZ1bmN0aW9uKGUscixuKXt2YXIgbz1uKDApLGw9bigzMSksYT10LHM9U3RyaW5nLmZyb21Db2RlUG9pbnQ7byhvLlMrby5GKighIXMmJjEhPXMubGVuZ3RoKSwnU3RyaW5nJyx7ZnJvbUNvZGVQb2ludDpmdW5jdGlvbigpe2Zvcih2YXIgZSx0PVtdLHI9YXJndW1lbnRzLmxlbmd0aCxuPTA7cj5uOyl7aWYoZT0rYXJndW1lbnRzW24rK10sbChlLDExMTQxMTEpIT09ZSl0aHJvdyBSYW5nZUVycm9yKGUrJyBpcyBub3QgYSB2YWxpZCBjb2RlIHBvaW50Jyk7dC5wdXNoKDY1NTM2PmU/YShlKTphKCgoZS09NjU1MzYpPj4xMCkrNTUyOTYsZSUxMDI0KzU2MzIwKSl9cmV0dXJuIHQuam9pbignJyl9fSl9LGZ1bmN0aW9uKGUsdCxyKXsndXNlIHN0cmljdCc7dmFyIG49cigwKSxvPXIoOTApKCExKTtuKG4uUCwnU3RyaW5nJyx7Y29kZVBvaW50QXQ6ZnVuY3Rpb24oZSl7cmV0dXJuIG8odGhpcyxlKX19KX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMCk7bihuLlAsJ1N0cmluZycse3JlcGVhdDpyKDkxKX0pfSxmdW5jdGlvbihlLHQscil7J3VzZSBzdHJpY3QnO3ZhciBuPXIoMCksbz1yKDYpLGw9cig2MyksYT0nc3RhcnRzV2l0aCcscz0nJ1thXTtuKG4uUCtuLkYqcig2NCkoYSksJ1N0cmluZycse3N0YXJ0c1dpdGg6ZnVuY3Rpb24oZSl7dmFyIHQ9bCh0aGlzLGUsYSkscj1vKGQoMTxhcmd1bWVudHMubGVuZ3RoP2FyZ3VtZW50c1sxXTp2b2lkIDAsdC5sZW5ndGgpKSxuPWUrJyc7cmV0dXJuIHQuc2xpY2UocixyK24ubGVuZ3RoKT09PW59fSl9LGZ1bmN0aW9uKGUsdCxyKXsndXNlIHN0cmljdCc7dmFyIG49cigwKSxvPXIoNiksbD1yKDYzKSxhPSdlbmRzV2l0aCcscz0nJ1thXTtuKG4uUCtuLkYqcig2NCkoYSksJ1N0cmluZycse2VuZHNXaXRoOmZ1bmN0aW9uKGUpe3ZhciB0PWwodGhpcyxlLGEpLHI9MTxhcmd1bWVudHMubGVuZ3RoP2FyZ3VtZW50c1sxXTp2b2lkIDAsbj1vKHQubGVuZ3RoKSxzPXI9PT12b2lkIDA/bjpkKG8ociksbiksaT1lKycnO3JldHVybiB0LnNsaWNlKHMtaS5sZW5ndGgscyk9PT1pfX0pfSxmdW5jdGlvbihlLHQscil7J3VzZSBzdHJpY3QnO3ZhciBuPXIoMCksbz1yKDYzKSxsPSdpbmNsdWRlcyc7bihuLlArbi5GKnIoNjQpKGwpLCdTdHJpbmcnLHtpbmNsdWRlczpmdW5jdGlvbihlKXtyZXR1cm4hIX5vKHRoaXMsZSxsKS5pbmRleE9mKGUsMTxhcmd1bWVudHMubGVuZ3RoP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pfSxmdW5jdGlvbihlLHQscil7cig4KSYmJ2cnIT0vLi9nLmZsYWdzJiZyKDcpLmYoUmVnRXhwLnByb3RvdHlwZSwnZmxhZ3MnLHtjb25maWd1cmFibGU6ITAsZ2V0OnIoOTMpfSl9LGZ1bmN0aW9uKGUsdCxyKXsndXNlIHN0cmljdCc7dmFyIG89cigyKSxsPXIoNiksYT1yKDY1KSxzPXIoNTApO3IoNTEpKCdtYXRjaCcsMSxmdW5jdGlvbihlLHQscixpKXtyZXR1cm5bZnVuY3Rpb24ocil7dmFyIG49ZSh0aGlzKSxvPXI9PXZvaWQgMD92b2lkIDA6clt0XTtyZXR1cm4gbz09PXZvaWQgMD9uZXcgUmVnRXhwKHIpW3RdKG4rJycpOm8uY2FsbChyLG4pfSxmdW5jdGlvbihlKXt2YXIgdD1pKHIsZSx0aGlzKTtpZih0LmRvbmUpcmV0dXJuIHQudmFsdWU7dmFyIGM9byhlKSxwPXRoaXMrJyc7aWYoIWMuZ2xvYmFsKXJldHVybiBzKGMscCk7dmFyIGQ9Yy51bmljb2RlO2MubGFzdEluZGV4PTA7Zm9yKHZhciB1LGc9W10saD0wO251bGwhPT0odT1zKGMscCkpOyl7dmFyIG49dVswXSsnJztnW2hdPW4sJyc9PT1uJiYoYy5sYXN0SW5kZXg9YShwLGwoYy5sYXN0SW5kZXgpLGQpKSxoKyt9cmV0dXJuIDA9PWg/bnVsbDpnfV19KX0sZnVuY3Rpb24oZSx0LHIpeyd1c2Ugc3RyaWN0Jzt2YXIgbj1yKDY2KTtyKDApKHt0YXJnZXQ6J1JlZ0V4cCcscHJvdG86ITAsZm9yY2VkOm4hPT0vLi8uZXhlY30se2V4ZWM6bn0pfSxmdW5jdGlvbihlLHQscil7J3VzZSBzdHJpY3QnO3ZhciBuPXIoMiksbz1yKDEyKSxsPXIoNiksYT1yKDE4KSxzPXIoNjUpLGM9cig1MCksdT0vXFwkKFskJmAnXXxcXGRcXGQ/fDxbXj5dKj4pL2csZz0vXFwkKFskJmAnXXxcXGRcXGQ/KS9nLGg9ZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT12b2lkIDA/ZTplKycnfTtyKDUxKSgncmVwbGFjZScsMixmdW5jdGlvbihlLHQscix5KXtmdW5jdGlvbiBmKGUsdCxsLGEscyxuKXt2YXIgaT1sK2UubGVuZ3RoLGM9YS5sZW5ndGgsZD1nO3JldHVybiB2b2lkIDAhPT1zJiYocz1vKHMpLGQ9dSksci5jYWxsKG4sZCxmdW5jdGlvbihyLG8pe3ZhciBkO3N3aXRjaChvLmNoYXJBdCgwKSl7Y2FzZSckJzpyZXR1cm4nJCc7Y2FzZScmJzpyZXR1cm4gZTtjYXNlJ2AnOnJldHVybiB0LnNsaWNlKDAsbCk7Y2FzZSdcXCcnOnJldHVybiB0LnNsaWNlKGkpO2Nhc2UnPCc6ZD1zW28uc2xpY2UoMSwtMSldO2JyZWFrO2RlZmF1bHQ6dmFyIHU9K287aWYoMD09dSlyZXR1cm4gcjtpZih1PmMpe3ZhciBuPXAodS8xMCk7cmV0dXJuIDA9PT1uP3I6bjw9Yz92b2lkIDA9PT1hW24tMV0/by5jaGFyQXQoMSk6YVtuLTFdK28uY2hhckF0KDEpOnJ9ZD1hW3UtMV07fXJldHVybiB2b2lkIDA9PT1kPycnOmR9KX1yZXR1cm5bZnVuY3Rpb24obixvKXt2YXIgbD1lKHRoaXMpLGE9bj09dm9pZCAwP3ZvaWQgMDpuW3RdO3JldHVybiBhPT09dm9pZCAwP3IuY2FsbChsKycnLG4sbyk6YS5jYWxsKG4sbCxvKX0sZnVuY3Rpb24oZSx0KXt2YXIgbz15KHIsZSx0aGlzLHQpO2lmKG8uZG9uZSlyZXR1cm4gby52YWx1ZTt2YXIgcD1uKGUpLHU9dGhpcysnJyxnPSdmdW5jdGlvbic9PXR5cGVvZiB0O2d8fCh0PXQrJycpO3ZhciBtPXAuZ2xvYmFsO2lmKG0pe3ZhciBFPXAudW5pY29kZTtwLmxhc3RJbmRleD0wfWZvcih2YXIgXyx4PVtdOyhfPWMocCx1KSxudWxsIT09XykmJiEoeC5wdXNoKF8pLCFtKTspe3ZhciBTPV9bMF0rJyc7Jyc9PT1TJiYocC5sYXN0SW5kZXg9cyh1LGwocC5sYXN0SW5kZXgpLEUpKX1mb3IodmFyIFQ9JycsYj0wLFA9MDtQPHgubGVuZ3RoO1ArKyl7Xz14W1BdO2Zvcih2YXIgTz1fWzBdKycnLHY9aShkKGEoXy5pbmRleCksdS5sZW5ndGgpLDApLEk9W10sQT0xO0E8Xy5sZW5ndGg7QSsrKUkucHVzaChoKF9bQV0pKTt2YXIgUj1fLmdyb3VwcztpZihnKXt2YXIgaz1bT10uY29uY2F0KEksdix1KTtSIT09dm9pZCAwJiZrLnB1c2goUik7dmFyIEw9dC5hcHBseSh2b2lkIDAsaykrJyd9ZWxzZSBMPWYoTyx1LHYsSSxSLHQpO3Y+PWImJihUKz11LnNsaWNlKGIsdikrTCxiPXYrTy5sZW5ndGgpfXJldHVybiBUK3Uuc2xpY2UoYil9XX0pfSxmdW5jdGlvbihlLHQscil7J3VzZSBzdHJpY3QnO3ZhciBuPXIoOTIpLG89cigyKSxsPXIoNDIpLGE9cig2NSkscz1yKDYpLGM9cig1MCksaT1yKDY2KSxwPXIoNSksdT1bXS5wdXNoLGc9J3NwbGl0JyxoPSdsZW5ndGgnLHk9J2xhc3RJbmRleCcsZj00Mjk0OTY3Mjk1LG09IXAoZnVuY3Rpb24oKXtSZWdFeHAoZiwneScpfSk7cig1MSkoJ3NwbGl0JywyLGZ1bmN0aW9uKGUsdCxyLEUpe3ZhciBfO3JldHVybiBfPSdjJz09J2FiYmMnW2ddKC8oYikqLylbMV18fDQhPSd0ZXN0J1tnXSgvKD86KS8sLTEpW2hdfHwyIT0nYWInW2ddKC8oPzphYikqLylbaF18fDQhPScuJ1tnXSgvKC4/KSguPykvKVtoXXx8MTwnLidbZ10oLygpKCkvKVtoXXx8JydbZ10oLy4/LylbaF0/ZnVuY3Rpb24oZSx0KXt2YXIgbz10aGlzKycnO2lmKHZvaWQgMD09PWUmJjA9PT10KXJldHVybltdO2lmKCFuKGUpKXJldHVybiByLmNhbGwobyxlLHQpO2Zvcih2YXIgbCxhLHMsYz1bXSxwPShlLmlnbm9yZUNhc2U/J2knOicnKSsoZS5tdWx0aWxpbmU/J20nOicnKSsoZS51bmljb2RlPyd1JzonJykrKGUuc3RpY2t5Pyd5JzonJyksZD0wLGc9dm9pZCAwPT09dD9mOnQ+Pj4wLG09bmV3IFJlZ0V4cChlLnNvdXJjZSxwKydnJyk7KGw9aS5jYWxsKG0sbykpJiYoYT1tW3ldLCEoYT5kJiYoYy5wdXNoKG8uc2xpY2UoZCxsLmluZGV4KSksMTxsW2hdJiZsLmluZGV4PG9baF0mJnUuYXBwbHkoYyxsLnNsaWNlKDEpKSxzPWxbMF1baF0sZD1hLGNbaF0+PWcpKSk7KW1beV09PT1sLmluZGV4JiZtW3ldKys7cmV0dXJuIGQ9PT1vW2hdPyhzfHwhbS50ZXN0KCcnKSkmJmMucHVzaCgnJyk6Yy5wdXNoKG8uc2xpY2UoZCkpLGNbaF0+Zz9jLnNsaWNlKDAsZyk6Y306JzAnW2ddKHZvaWQgMCwwKVtoXT9mdW5jdGlvbihlLHQpe3JldHVybiB2b2lkIDA9PT1lJiYwPT09dD9bXTpyLmNhbGwodGhpcyxlLHQpfTpyLFtmdW5jdGlvbihyLG4pe3ZhciBvPWUodGhpcyksbD12b2lkIDA9PXI/dm9pZCAwOnJbdF07cmV0dXJuIHZvaWQgMD09PWw/Xy5jYWxsKG8rJycscixuKTpsLmNhbGwocixvLG4pfSxmdW5jdGlvbih0LG4pe3ZhciB1PUUoXyx0LHRoaXMsbixfIT09cik7aWYodS5kb25lKXJldHVybiB1LnZhbHVlO3ZhciBnPW8odCksaD10aGlzKycnLHk9bChnLFJlZ0V4cCkseD1nLnVuaWNvZGUsUz0oZy5pZ25vcmVDYXNlPydpJzonJykrKGcubXVsdGlsaW5lPydtJzonJykrKGcudW5pY29kZT8ndSc6JycpKyhtPyd5JzonZycpLFQ9bmV3IHkobT9nOideKD86JytnLnNvdXJjZSsnKScsUyksYj12b2lkIDA9PT1uP2Y6bj4+PjA7aWYoMD09YilyZXR1cm5bXTtpZigwPT09aC5sZW5ndGgpcmV0dXJuIG51bGw9PT1jKFQsaCk/W2hdOltdO2Zvcih2YXIgUD0wLHA9MCxPPVtdO3A8aC5sZW5ndGg7KXtULmxhc3RJbmRleD1tP3A6MDt2YXIgdixlPWMoVCxtP2g6aC5zbGljZShwKSk7aWYobnVsbD09PWV8fCh2PWQocyhULmxhc3RJbmRleCsobT8wOnApKSxoLmxlbmd0aCkpPT09UClwPWEoaCxwLHgpO2Vsc2V7aWYoTy5wdXNoKGguc2xpY2UoUCxwKSksTy5sZW5ndGg9PT1iKXJldHVybiBPO2Zvcih2YXIgST0xO0k8PWUubGVuZ3RoLTE7SSsrKWlmKE8ucHVzaChlW0ldKSxPLmxlbmd0aD09PWIpcmV0dXJuIE87cD1QPXZ9fXJldHVybiBPLnB1c2goaC5zbGljZShQKSksT31dfSl9LGZ1bmN0aW9uKGUsdCxyKXsndXNlIHN0cmljdCc7dmFyIG49cigyKSxvPXIoODkpLGw9cig1MCk7cig1MSkoJ3NlYXJjaCcsMSxmdW5jdGlvbihlLHQscixhKXtyZXR1cm5bZnVuY3Rpb24ocil7dmFyIG49ZSh0aGlzKSxvPXI9PXZvaWQgMD92b2lkIDA6clt0XTtyZXR1cm4gbz09PXZvaWQgMD9uZXcgUmVnRXhwKHIpW3RdKG4rJycpOm8uY2FsbChyLG4pfSxmdW5jdGlvbihlKXt2YXIgdD1hKHIsZSx0aGlzKTtpZih0LmRvbmUpcmV0dXJuIHQudmFsdWU7dmFyIHM9bihlKSxpPXRoaXMrJycsYz1zLmxhc3RJbmRleDtvKGMsMCl8fChzLmxhc3RJbmRleD0wKTt2YXIgcD1sKHMsaSk7cmV0dXJuIG8ocy5sYXN0SW5kZXgsYyl8fChzLmxhc3RJbmRleD1jKSxudWxsPT09cD8tMTpwLmluZGV4fV19KX0sZnVuY3Rpb24oZSx0LHIpeyd1c2Ugc3RyaWN0Jzt2YXIgbj1yKDE0KSxvPXIoMCksbD1yKDEyKSxhPXIoODApLHM9cig1OSksaT1yKDYpLGM9cig2NykscD1yKDYwKTtvKG8uUytvLkYqIXIoNDUpKGZ1bmN0aW9uKGUpe0FycmF5LmZyb20oZSl9KSwnQXJyYXknLHtmcm9tOmZ1bmN0aW9uKGUpe3ZhciB0LHIsbyxkLHU9bChlKSxnPSdmdW5jdGlvbic9PXR5cGVvZiB0aGlzP3RoaXM6QXJyYXksaD1hcmd1bWVudHMubGVuZ3RoLHk9MTxoP2FyZ3VtZW50c1sxXTp2b2lkIDAsZj12b2lkIDAhPT15LG09MCxFPXAodSk7aWYoZiYmKHk9bih5LDI8aD9hcmd1bWVudHNbMl06dm9pZCAwLDIpKSx2b2lkIDAhPUUmJiEoZz09QXJyYXkmJnMoRSkpKWZvcihkPUUuY2FsbCh1KSxyPW5ldyBnOyEobz1kLm5leHQoKSkuZG9uZTttKyspYyhyLG0sZj9hKGQseSxbby52YWx1ZSxtXSwhMCk6by52YWx1ZSk7ZWxzZSBmb3IodD1pKHUubGVuZ3RoKSxyPW5ldyBnKHQpO3Q+bTttKyspYyhyLG0sZj95KHVbbV0sbSk6dVttXSk7cmV0dXJuIHIubGVuZ3RoPW0scn19KX0sZnVuY3Rpb24oZSx0LHIpeyd1c2Ugc3RyaWN0Jzt2YXIgbj1yKDApLG89cig2Nyk7bihuLlMrbi5GKnIoNSkoZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7fXJldHVybiEoQXJyYXkub2YuY2FsbChlKWluc3RhbmNlb2YgZSl9KSwnQXJyYXknLHtvZjpmdW5jdGlvbigpe2Zvcih2YXIgZT0wLHQ9YXJndW1lbnRzLmxlbmd0aCxyPW5ldygnZnVuY3Rpb24nPT10eXBlb2YgdGhpcz90aGlzOkFycmF5KSh0KTt0PmU7KW8ocixlLGFyZ3VtZW50c1tlKytdKTtyZXR1cm4gci5sZW5ndGg9dCxyfX0pfSxmdW5jdGlvbihlLHQscil7dmFyIG49cigwKTtuKG4uUCwnQXJyYXknLHtjb3B5V2l0aGluOnIoNzgpfSkscigzNSkoJ2NvcHlXaXRoaW4nKX0sZnVuY3Rpb24oZSx0LHIpeyd1c2Ugc3RyaWN0Jzt2YXIgbj1yKDApLG89cigzOSkoNSksbD0nZmluZCcsYT0hMDtsIGluW10mJlssXVtsXShmdW5jdGlvbigpe2E9ITF9KSxuKG4uUCtuLkYqYSwnQXJyYXknLHtmaW5kOmZ1bmN0aW9uKGUpe3JldHVybiBvKHRoaXMsZSwxPGFyZ3VtZW50cy5sZW5ndGg/YXJndW1lbnRzWzFdOnZvaWQgMCl9fSkscigzNSkobCl9LGZ1bmN0aW9uKGUsdCxyKXsndXNlIHN0cmljdCc7dmFyIG49cigwKSxvPXIoMzkpKDYpLGw9J2ZpbmRJbmRleCcsYT0hMDtsIGluW10mJlssXVtsXShmdW5jdGlvbigpe2E9ITF9KSxuKG4uUCtuLkYqYSwnQXJyYXknLHtmaW5kSW5kZXg6ZnVuY3Rpb24oZSl7cmV0dXJuIG8odGhpcyxlLDE8YXJndW1lbnRzLmxlbmd0aD9hcmd1bWVudHNbMV06dm9pZCAwKX19KSxyKDM1KShsKX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMCk7bihuLlAsJ0FycmF5Jyx7ZmlsbDpyKDU4KX0pLHIoMzUpKCdmaWxsJyl9LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDApLG89cigzKS5pc0Zpbml0ZTtuKG4uUywnTnVtYmVyJyx7aXNGaW5pdGU6ZnVuY3Rpb24oZSl7cmV0dXJuJ251bWJlcic9PXR5cGVvZiBlJiZvKGUpfX0pfSxmdW5jdGlvbihlLHQscil7dmFyIG49cigwKTtuKG4uUywnTnVtYmVyJyx7aXNJbnRlZ2VyOnIoOTQpfSl9LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDApLG89cig5NCk7bihuLlMsJ051bWJlcicse2lzU2FmZUludGVnZXI6ZnVuY3Rpb24oZSl7cmV0dXJuIG8oZSkmJjkwMDcxOTkyNTQ3NDA5OTE+PWwoZSl9fSl9LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDApO24obi5TLCdOdW1iZXInLHtpc05hTjpmdW5jdGlvbihlKXtyZXR1cm4gZSE9ZX19KX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMCk7bihuLlMsJ051bWJlcicse0VQU0lMT046Mi4yMjA0NDYwNDkyNTAzMTNlLTE2fSl9LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDApO24obi5TLCdOdW1iZXInLHtNSU5fU0FGRV9JTlRFR0VSOi05MDA3MTk5MjU0NzQwOTkxfSl9LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDApO24obi5TLCdOdW1iZXInLHtNQVhfU0FGRV9JTlRFR0VSOjkwMDcxOTkyNTQ3NDA5OTF9KX0sZnVuY3Rpb24odCxvLGwpe3ZhciBhPWwoMCkscz1sKDk1KSxpPWUsYz1NYXRoLmFjb3NoO2EoYS5TK2EuRiohKGMmJjcxMD09cChjKE51bWJlci5NQVhfVkFMVUUpKSYmYyhJbmZpbml0eSk9PUluZmluaXR5KSwnTWF0aCcse2Fjb3NoOmZ1bmN0aW9uKGUpe3JldHVybiAxPihlPStlKT9OYU46OTQ5MDYyNjUuNjI0MjUxNTY8ZT9uKGUpK3I6cyhlLTEraShlLTEpKmkoZSsxKSl9fSl9LGZ1bmN0aW9uKHQscixvKXtmdW5jdGlvbiBsKHQpe3JldHVybiBpc0Zpbml0ZSh0PSt0KSYmMCE9dD8wPnQ/LWwoLXQpOm4odCtlKHQqdCsxKSk6dH12YXIgYT1vKDApLHM9TWF0aC5hc2luaDthKGEuUythLkYqIShzJiYwPDEvcygwKSksJ01hdGgnLHthc2luaDpsfSl9LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbz1yKDApLGw9TWF0aC5hdGFuaDtvKG8uUytvLkYqIShsJiYwPjEvbCgtMCkpLCdNYXRoJyx7YXRhbmg6ZnVuY3Rpb24oZSl7cmV0dXJuIDA9PShlPStlKT9lOm4oKDErZSkvKDEtZSkpLzJ9fSl9LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDApLGE9cig2OCk7bihuLlMsJ01hdGgnLHtjYnJ0OmZ1bmN0aW9uKGUpe3JldHVybiBhKGU9K2UpKm8obChlKSwxLzMpfX0pfSxmdW5jdGlvbihlLHQscil7dmFyIG89cigwKTtvKG8uUywnTWF0aCcse2NsejMyOmZ1bmN0aW9uKGUpe3JldHVybihlPj4+PTApPzMxLXAobihlKzAuNSkqTWF0aC5MT0cyRSk6MzJ9fSl9LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDApLG89YTtuKG4uUywnTWF0aCcse2Nvc2g6ZnVuY3Rpb24oZSl7cmV0dXJuKG8oZT0rZSkrbygtZSkpLzJ9fSl9LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDApLG89cig2OSk7bihuLlMrbi5GKihvIT1zKSwnTWF0aCcse2V4cG0xOm99KX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMCk7bihuLlMsJ01hdGgnLHtmcm91bmQ6cigxODkpfSl9LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDY4KSxhPW8scz1hKDIsLTUyKSxpPWEoMiwtMjMpLGM9YSgyLDEyNykqKDItaSkscD1hKDIsLTEyNiksZD1mdW5jdGlvbihlKXtyZXR1cm4gZSsxL3MtMS9zfTtlLmV4cG9ydHM9TWF0aC5mcm91bmR8fGZ1bmN0aW9uKGUpe3ZhciB0LHIsbz1sKGUpLGE9bihlKTtyZXR1cm4gbzxwP2EqZChvL3AvaSkqcCppOih0PSgxK2kvcykqbyxyPXQtKHQtbykscj5jfHxyIT1yP2EqSW5maW5pdHk6YSpyKX19LGZ1bmN0aW9uKHQscixuKXt2YXIgbz1uKDApO28oby5TLCdNYXRoJyx7aHlwb3Q6ZnVuY3Rpb24oKXtmb3IodmFyIHQscixuPTAsbz0wLGE9YXJndW1lbnRzLmxlbmd0aCxzPTA7bzxhOyl0PWwoYXJndW1lbnRzW28rK10pLHM8dD8ocj1zL3Qsbj1uKnIqcisxLHM9dCk6MDx0PyhyPXQvcyxuKz1yKnIpOm4rPXQ7cmV0dXJuIHM9PUluZmluaXR5P0luZmluaXR5OnMqZShuKX19KX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMCksbz1NYXRoLmltdWw7bihuLlMrbi5GKnIoNSkoZnVuY3Rpb24oKXtyZXR1cm4tNSE9byg0Mjk0OTY3Mjk1LDUpfHwyIT1vLmxlbmd0aH0pLCdNYXRoJyx7aW11bDpmdW5jdGlvbihlLHQpe3ZhciByPTY1NTM1LG49K2Usbz0rdCxsPXImbixhPXImbztyZXR1cm4gMHxsKmErKChyJm4+Pj4xNikqYStsKihyJm8+Pj4xNik8PDE2Pj4+MCl9fSl9LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDApO24obi5TLCdNYXRoJyx7bG9nMXA6cig5NSl9KX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBvPXIoMCk7byhvLlMsJ01hdGgnLHtsb2cxMDpmdW5jdGlvbihlKXtyZXR1cm4gbihlKSpNYXRoLkxPRzEwRX19KX0sZnVuY3Rpb24oZSx0LG8pe3ZhciBsPW8oMCk7bChsLlMsJ01hdGgnLHtsb2cyOmZ1bmN0aW9uKGUpe3JldHVybiBuKGUpL3J9fSl9LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDApO24obi5TLCdNYXRoJyx7c2lnbjpyKDY4KX0pfSxmdW5jdGlvbihlLHQscil7dmFyIG49cigwKSxvPXIoNjkpLHM9YTtuKG4uUytuLkYqcig1KShmdW5jdGlvbigpe3JldHVybiEwfSksJ01hdGgnLHtzaW5oOmZ1bmN0aW9uKGUpe3JldHVybiAxPmwoZT0rZSk/KG8oZSktbygtZSkpLzI6KHMoZS0xKS1zKC1lLTEpKSooTWF0aC5FLzIpfX0pfSxmdW5jdGlvbihlLHQscil7dmFyIG49cigwKSxvPXIoNjkpLGw9YTtuKG4uUywnTWF0aCcse3Rhbmg6ZnVuY3Rpb24oZSl7dmFyIHQ9byhlPStlKSxyPW8oLWUpO3JldHVybiB0PT1JbmZpbml0eT8xOnI9PUluZmluaXR5Py0xOih0LXIpLyhsKGUpK2woLWUpKX19KX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMCk7bihuLlMsJ01hdGgnLHt0cnVuYzpmdW5jdGlvbihlKXtyZXR1cm4oMDxlP3A6YykoZSl9fSl9LGZ1bmN0aW9uKGUsdCxyKXsndXNlIHN0cmljdCc7dmFyIG49cigwKSxvPXIoNTUpKCEwKTtuKG4uUCwnQXJyYXknLHtpbmNsdWRlczpmdW5jdGlvbihlKXtyZXR1cm4gbyh0aGlzLGUsMTxhcmd1bWVudHMubGVuZ3RoP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pLHIoMzUpKCdpbmNsdWRlcycpfSxmdW5jdGlvbihlLHQscil7dmFyIG49cigwKSxvPXIoOTYpKCExKTtuKG4uUywnT2JqZWN0Jyx7dmFsdWVzOmZ1bmN0aW9uKGUpe3JldHVybiBvKGUpfX0pfSxmdW5jdGlvbihlLHQscil7dmFyIG49cigwKSxvPXIoOTYpKCEwKTtuKG4uUywnT2JqZWN0Jyx7ZW50cmllczpmdW5jdGlvbihlKXtyZXR1cm4gbyhlKX19KX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMCksbz1yKDg1KSxsPXIoMTEpLGE9cigxNikscz1yKDY3KTtuKG4uUywnT2JqZWN0Jyx7Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczpmdW5jdGlvbihlKXtmb3IodmFyIHQscixuPWwoZSksYz1hLmYscD1vKG4pLGQ9e30sdT0wO3AubGVuZ3RoPnU7KXI9YyhuLHQ9cFt1KytdKSx2b2lkIDAhPT1yJiZzKGQsdCxyKTtyZXR1cm4gZH19KX0sZnVuY3Rpb24oZSx0LHIpeyd1c2Ugc3RyaWN0Jzt2YXIgbj1yKDApLG89cig5NyksbD1yKDQ5KSxhPS9WZXJzaW9uXFwvMTBcXC5cXGQrKFxcLlxcZCspPyggTW9iaWxlXFwvXFx3Kyk/IFNhZmFyaVxcLy8udGVzdChsKTtuKG4uUCtuLkYqYSwnU3RyaW5nJyx7cGFkU3RhcnQ6ZnVuY3Rpb24oZSl7cmV0dXJuIG8odGhpcyxlLDE8YXJndW1lbnRzLmxlbmd0aD9hcmd1bWVudHNbMV06dm9pZCAwLCEwKX19KX0sZnVuY3Rpb24oZSx0LHIpeyd1c2Ugc3RyaWN0Jzt2YXIgbj1yKDApLG89cig5NyksbD1yKDQ5KSxhPS9WZXJzaW9uXFwvMTBcXC5cXGQrKFxcLlxcZCspPyggTW9iaWxlXFwvXFx3Kyk/IFNhZmFyaVxcLy8udGVzdChsKTtuKG4uUCtuLkYqYSwnU3RyaW5nJyx7cGFkRW5kOmZ1bmN0aW9uKGUpe3JldHVybiBvKHRoaXMsZSwxPGFyZ3VtZW50cy5sZW5ndGg/YXJndW1lbnRzWzFdOnZvaWQgMCwhMSl9fSl9LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDMpLG89cigwKSxsPXIoNDkpLGE9W10uc2xpY2Uscz0vTVNJRSAuXFwuLy50ZXN0KGwpLGk9ZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKHQscil7dmFyIG49Mjxhcmd1bWVudHMubGVuZ3RoLG89ISFuJiZhLmNhbGwoYXJndW1lbnRzLDIpO3JldHVybiBlKG4/ZnVuY3Rpb24oKXsoJ2Z1bmN0aW9uJz09dHlwZW9mIHQ/dDpGdW5jdGlvbih0KSkuYXBwbHkodGhpcyxvKX06dCxyKX19O28oby5HK28uQitvLkYqcyx7c2V0VGltZW91dDppKG4uc2V0VGltZW91dCksc2V0SW50ZXJ2YWw6aShuLnNldEludGVydmFsKX0pfSxmdW5jdGlvbihlLHQscil7dmFyIG49cigwKSxvPXIoNjIpO24obi5HK24uQix7c2V0SW1tZWRpYXRlOm8uc2V0LGNsZWFySW1tZWRpYXRlOm8uY2xlYXJ9KX0sZnVuY3Rpb24oZSx0LHIpe2Zvcih2YXIgbj1yKDYxKSxvPXIoMjYpLGw9cigxNyksYT1yKDMpLHM9cig5KSxjPXIoMzMpLHA9cig0KSxkPXAoJ2l0ZXJhdG9yJyksdT1wKCd0b1N0cmluZ1RhZycpLGc9Yy5BcnJheSxoPXtDU1NSdWxlTGlzdDohMCxDU1NTdHlsZURlY2xhcmF0aW9uOiExLENTU1ZhbHVlTGlzdDohMSxDbGllbnRSZWN0TGlzdDohMSxET01SZWN0TGlzdDohMSxET01TdHJpbmdMaXN0OiExLERPTVRva2VuTGlzdDohMCxEYXRhVHJhbnNmZXJJdGVtTGlzdDohMSxGaWxlTGlzdDohMSxIVE1MQWxsQ29sbGVjdGlvbjohMSxIVE1MQ29sbGVjdGlvbjohMSxIVE1MRm9ybUVsZW1lbnQ6ITEsSFRNTFNlbGVjdEVsZW1lbnQ6ITEsTWVkaWFMaXN0OiEwLE1pbWVUeXBlQXJyYXk6ITEsTmFtZWROb2RlTWFwOiExLE5vZGVMaXN0OiEwLFBhaW50UmVxdWVzdExpc3Q6ITEsUGx1Z2luOiExLFBsdWdpbkFycmF5OiExLFNWR0xlbmd0aExpc3Q6ITEsU1ZHTnVtYmVyTGlzdDohMSxTVkdQYXRoU2VnTGlzdDohMSxTVkdQb2ludExpc3Q6ITEsU1ZHU3RyaW5nTGlzdDohMSxTVkdUcmFuc2Zvcm1MaXN0OiExLFNvdXJjZUJ1ZmZlckxpc3Q6ITEsU3R5bGVTaGVldExpc3Q6ITAsVGV4dFRyYWNrQ3VlTGlzdDohMSxUZXh0VHJhY2tMaXN0OiExLFRvdWNoTGlzdDohMX0seT1vKGgpLGY9MDtmPHkubGVuZ3RoO2YrKyl7dmFyIGksbT15W2ZdLEU9aFttXSxfPWFbbV0seD1fJiZfLnByb3RvdHlwZTtpZih4JiYoeFtkXXx8cyh4LGQsZykseFt1XXx8cyh4LHUsbSksY1ttXT1nLEUpKWZvcihpIGluIG4peFtpXXx8bCh4LGksbltpXSwhMCl9fSxmdW5jdGlvbihlKXshZnVuY3Rpb24odCl7J3VzZSBzdHJpY3QnO2Z1bmN0aW9uIHIoZSx0LHIsbil7dmFyIGw9dCYmdC5wcm90b3R5cGUgaW5zdGFuY2VvZiBvP3Q6byxhPU9iamVjdC5jcmVhdGUobC5wcm90b3R5cGUpLHM9bmV3IGcobnx8W10pO3JldHVybiBhLl9pbnZva2U9YyhlLHIscyksYX1mdW5jdGlvbiBuKGUsdCxyKXt0cnl7cmV0dXJue3R5cGU6J25vcm1hbCcsYXJnOmUuY2FsbCh0LHIpfX1jYXRjaChlKXtyZXR1cm57dHlwZTondGhyb3cnLGFyZzplfX19ZnVuY3Rpb24gbygpe31mdW5jdGlvbiBsKCl7fWZ1bmN0aW9uIGEoKXt9ZnVuY3Rpb24gcyhlKXtbJ25leHQnLCd0aHJvdycsJ3JldHVybiddLmZvckVhY2goZnVuY3Rpb24odCl7ZVt0XT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5faW52b2tlKHQsZSl9fSl9ZnVuY3Rpb24gaShlKXtmdW5jdGlvbiB0KHIsbyxsLGEpe3ZhciBzPW4oZVtyXSxlLG8pO2lmKCd0aHJvdyc9PT1zLnR5cGUpYShzLmFyZyk7ZWxzZXt2YXIgaT1zLmFyZyxjPWkudmFsdWU7cmV0dXJuIGMmJidvYmplY3QnPT10eXBlb2YgYyYmbS5jYWxsKGMsJ19fYXdhaXQnKT9Qcm9taXNlLnJlc29sdmUoYy5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKGUpe3QoJ25leHQnLGUsbCxhKX0sZnVuY3Rpb24oZSl7dCgndGhyb3cnLGUsbCxhKX0pOlByb21pc2UucmVzb2x2ZShjKS50aGVuKGZ1bmN0aW9uKGUpe2kudmFsdWU9ZSxsKGkpfSxhKX19dmFyIHI7dGhpcy5faW52b2tlPWZ1bmN0aW9uKGUsbil7ZnVuY3Rpb24gbygpe3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyLG8pe3QoZSxuLHIsbyl9KX1yZXR1cm4gcj1yP3IudGhlbihvLG8pOm8oKX19ZnVuY3Rpb24gYyhlLHQscil7dmFyIG89UDtyZXR1cm4gZnVuY3Rpb24obCxhKXtpZihvPT12KXRocm93IG5ldyBFcnJvcignR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZycpO2lmKG89PUkpe2lmKCd0aHJvdyc9PT1sKXRocm93IGE7cmV0dXJuIHkoKX1mb3Ioci5tZXRob2Q9bCxyLmFyZz1hOzspe3ZhciBzPXIuZGVsZWdhdGU7aWYocyl7dmFyIGk9cChzLHIpO2lmKGkpe2lmKGk9PT1BKWNvbnRpbnVlO3JldHVybiBpfX1pZignbmV4dCc9PT1yLm1ldGhvZClyLnNlbnQ9ci5fc2VudD1yLmFyZztlbHNlIGlmKCd0aHJvdyc9PT1yLm1ldGhvZCl7aWYobz09UCl0aHJvdyBvPUksci5hcmc7ci5kaXNwYXRjaEV4Y2VwdGlvbihyLmFyZyl9ZWxzZSdyZXR1cm4nPT09ci5tZXRob2QmJnIuYWJydXB0KCdyZXR1cm4nLHIuYXJnKTtvPXY7dmFyIGM9bihlLHQscik7aWYoJ25vcm1hbCc9PT1jLnR5cGUpe2lmKG89ci5kb25lP0k6TyxjLmFyZz09PUEpY29udGludWU7cmV0dXJue3ZhbHVlOmMuYXJnLGRvbmU6ci5kb25lfX0ndGhyb3cnPT09Yy50eXBlJiYobz1JLHIubWV0aG9kPSd0aHJvdycsci5hcmc9Yy5hcmcpfX19ZnVuY3Rpb24gcChlLHQpe3ZhciByPWUuaXRlcmF0b3JbdC5tZXRob2RdO2lmKHZvaWQgMD09PXIpe2lmKHQuZGVsZWdhdGU9bnVsbCwndGhyb3cnPT09dC5tZXRob2Qpe2lmKGUuaXRlcmF0b3IucmV0dXJuJiYodC5tZXRob2Q9J3JldHVybicsdC5hcmc9dm9pZCAwLHAoZSx0KSwndGhyb3cnPT09dC5tZXRob2QpKXJldHVybiBBO3QubWV0aG9kPSd0aHJvdycsdC5hcmc9bmV3IFR5cGVFcnJvcignVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSBcXCd0aHJvd1xcJyBtZXRob2QnKX1yZXR1cm4gQX12YXIgbz1uKHIsZS5pdGVyYXRvcix0LmFyZyk7aWYoJ3Rocm93Jz09PW8udHlwZSlyZXR1cm4gdC5tZXRob2Q9J3Rocm93Jyx0LmFyZz1vLmFyZyx0LmRlbGVnYXRlPW51bGwsQTt2YXIgbD1vLmFyZztpZighbClyZXR1cm4gdC5tZXRob2Q9J3Rocm93Jyx0LmFyZz1uZXcgVHlwZUVycm9yKCdpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdCcpLHQuZGVsZWdhdGU9bnVsbCxBO2lmKGwuZG9uZSl0W2UucmVzdWx0TmFtZV09bC52YWx1ZSx0Lm5leHQ9ZS5uZXh0TG9jLCdyZXR1cm4nIT09dC5tZXRob2QmJih0Lm1ldGhvZD0nbmV4dCcsdC5hcmc9dm9pZCAwKTtlbHNlIHJldHVybiBsO3JldHVybiB0LmRlbGVnYXRlPW51bGwsQX1mdW5jdGlvbiBkKGUpe3ZhciB0PXt0cnlMb2M6ZVswXX07MSBpbiBlJiYodC5jYXRjaExvYz1lWzFdKSwyIGluIGUmJih0LmZpbmFsbHlMb2M9ZVsyXSx0LmFmdGVyTG9jPWVbM10pLHRoaXMudHJ5RW50cmllcy5wdXNoKHQpfWZ1bmN0aW9uIHUoZSl7dmFyIHQ9ZS5jb21wbGV0aW9ufHx7fTt0LnR5cGU9J25vcm1hbCcsZGVsZXRlIHQuYXJnLGUuY29tcGxldGlvbj10fWZ1bmN0aW9uIGcoZSl7dGhpcy50cnlFbnRyaWVzPVt7dHJ5TG9jOidyb290J31dLGUuZm9yRWFjaChkLHRoaXMpLHRoaXMucmVzZXQoITApfWZ1bmN0aW9uIGgoZSl7aWYoZSl7dmFyIHQ9ZVtfXTtpZih0KXJldHVybiB0LmNhbGwoZSk7aWYoJ2Z1bmN0aW9uJz09dHlwZW9mIGUubmV4dClyZXR1cm4gZTtpZighaXNOYU4oZS5sZW5ndGgpKXt2YXIgcj0tMSxuPWZ1bmN0aW9uIHQoKXtmb3IoOysrcjxlLmxlbmd0aDspaWYobS5jYWxsKGUscikpcmV0dXJuIHQudmFsdWU9ZVtyXSx0LmRvbmU9ITEsdDtyZXR1cm4gdC52YWx1ZT12b2lkIDAsdC5kb25lPSEwLHR9O3JldHVybiBuLm5leHQ9bn19cmV0dXJue25leHQ6eX19ZnVuY3Rpb24geSgpe3JldHVybnt2YWx1ZTp2b2lkIDAsZG9uZTohMH19dmFyIGY9T2JqZWN0LnByb3RvdHlwZSxtPWYuaGFzT3duUHJvcGVydHksRT0nZnVuY3Rpb24nPT10eXBlb2YgU3ltYm9sP1N5bWJvbDp7fSxfPUUuaXRlcmF0b3J8fCdAQGl0ZXJhdG9yJyx4PUUuYXN5bmNJdGVyYXRvcnx8J0BAYXN5bmNJdGVyYXRvcicsUz1FLnRvU3RyaW5nVGFnfHwnQEB0b1N0cmluZ1RhZycsVD0nb2JqZWN0Jz09dHlwZW9mIGUsYj10LnJlZ2VuZXJhdG9yUnVudGltZTtpZihiKXJldHVybiB2b2lkKFQmJihlLmV4cG9ydHM9YikpO2I9dC5yZWdlbmVyYXRvclJ1bnRpbWU9VD9lLmV4cG9ydHM6e30sYi53cmFwPXI7dmFyIFA9J3N1c3BlbmRlZFN0YXJ0JyxPPSdzdXNwZW5kZWRZaWVsZCcsdj0nZXhlY3V0aW5nJyxJPSdjb21wbGV0ZWQnLEE9e30sUj17fTtSW19dPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O3ZhciBrPU9iamVjdC5nZXRQcm90b3R5cGVPZixMPWsmJmsoayhoKFtdKSkpO0wmJkwhPT1mJiZtLmNhbGwoTCxfKSYmKFI9TCk7dmFyIEY9YS5wcm90b3R5cGU9by5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShSKTtsLnByb3RvdHlwZT1GLmNvbnN0cnVjdG9yPWEsYS5jb25zdHJ1Y3Rvcj1sLGFbU109bC5kaXNwbGF5TmFtZT0nR2VuZXJhdG9yRnVuY3Rpb24nLGIuaXNHZW5lcmF0b3JGdW5jdGlvbj1mdW5jdGlvbihlKXt2YXIgdD0nZnVuY3Rpb24nPT10eXBlb2YgZSYmZS5jb25zdHJ1Y3RvcjtyZXR1cm4hIXQmJih0PT09bHx8J0dlbmVyYXRvckZ1bmN0aW9uJz09PSh0LmRpc3BsYXlOYW1lfHx0Lm5hbWUpKX0sYi5tYXJrPWZ1bmN0aW9uKGUpe3JldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKGUsYSk6KGUuX19wcm90b19fPWEsIShTIGluIGUpJiYoZVtTXT0nR2VuZXJhdG9yRnVuY3Rpb24nKSksZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShGKSxlfSxiLmF3cmFwPWZ1bmN0aW9uKGUpe3JldHVybntfX2F3YWl0OmV9fSxzKGkucHJvdG90eXBlKSxpLnByb3RvdHlwZVt4XT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxiLkFzeW5jSXRlcmF0b3I9aSxiLmFzeW5jPWZ1bmN0aW9uKGUsdCxuLG8pe3ZhciBsPW5ldyBpKHIoZSx0LG4sbykpO3JldHVybiBiLmlzR2VuZXJhdG9yRnVuY3Rpb24odCk/bDpsLm5leHQoKS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiBlLmRvbmU/ZS52YWx1ZTpsLm5leHQoKX0pfSxzKEYpLEZbU109J0dlbmVyYXRvcicsRltfXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxGLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuJ1tvYmplY3QgR2VuZXJhdG9yXSd9LGIua2V5cz1mdW5jdGlvbihlKXt2YXIgdD1bXTtmb3IodmFyIHIgaW4gZSl0LnB1c2gocik7cmV0dXJuIHQucmV2ZXJzZSgpLGZ1bmN0aW9uIHIoKXtmb3IoO3QubGVuZ3RoOyl7dmFyIG49dC5wb3AoKTtpZihuIGluIGUpcmV0dXJuIHIudmFsdWU9bixyLmRvbmU9ITEscn1yZXR1cm4gci5kb25lPSEwLHJ9fSxiLnZhbHVlcz1oLGcucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpnLHJlc2V0OmZ1bmN0aW9uKGUpe2lmKHRoaXMucHJldj0wLHRoaXMubmV4dD0wLHRoaXMuc2VudD10aGlzLl9zZW50PXZvaWQgMCx0aGlzLmRvbmU9ITEsdGhpcy5kZWxlZ2F0ZT1udWxsLHRoaXMubWV0aG9kPSduZXh0Jyx0aGlzLmFyZz12b2lkIDAsdGhpcy50cnlFbnRyaWVzLmZvckVhY2godSksIWUpZm9yKHZhciB0IGluIHRoaXMpJ3QnPT09dC5jaGFyQXQoMCkmJm0uY2FsbCh0aGlzLHQpJiYhaXNOYU4oK3Quc2xpY2UoMSkpJiYodGhpc1t0XT12b2lkIDApfSxzdG9wOmZ1bmN0aW9uKCl7dGhpcy5kb25lPSEwO3ZhciBlPXRoaXMudHJ5RW50cmllc1swXSx0PWUuY29tcGxldGlvbjtpZigndGhyb3cnPT09dC50eXBlKXRocm93IHQuYXJnO3JldHVybiB0aGlzLnJ2YWx9LGRpc3BhdGNoRXhjZXB0aW9uOmZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCxuKXtyZXR1cm4gbC50eXBlPSd0aHJvdycsbC5hcmc9ZSxyLm5leHQ9dCxuJiYoci5tZXRob2Q9J25leHQnLHIuYXJnPXZvaWQgMCksISFufWlmKHRoaXMuZG9uZSl0aHJvdyBlO2Zvcih2YXIgcj10aGlzLG49dGhpcy50cnlFbnRyaWVzLmxlbmd0aC0xOzA8PW47LS1uKXt2YXIgbz10aGlzLnRyeUVudHJpZXNbbl0sbD1vLmNvbXBsZXRpb247aWYoJ3Jvb3QnPT09by50cnlMb2MpcmV0dXJuIHQoJ2VuZCcpO2lmKG8udHJ5TG9jPD10aGlzLnByZXYpe3ZhciBhPW0uY2FsbChvLCdjYXRjaExvYycpLHM9bS5jYWxsKG8sJ2ZpbmFsbHlMb2MnKTtpZihhJiZzKXtpZih0aGlzLnByZXY8by5jYXRjaExvYylyZXR1cm4gdChvLmNhdGNoTG9jLCEwKTtpZih0aGlzLnByZXY8by5maW5hbGx5TG9jKXJldHVybiB0KG8uZmluYWxseUxvYyl9ZWxzZSBpZihhKXtpZih0aGlzLnByZXY8by5jYXRjaExvYylyZXR1cm4gdChvLmNhdGNoTG9jLCEwKTt9ZWxzZSBpZighcyl0aHJvdyBuZXcgRXJyb3IoJ3RyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5Jyk7ZWxzZSBpZih0aGlzLnByZXY8by5maW5hbGx5TG9jKXJldHVybiB0KG8uZmluYWxseUxvYyl9fX0sYWJydXB0OmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByLG49dGhpcy50cnlFbnRyaWVzLmxlbmd0aC0xOzA8PW47LS1uKWlmKHI9dGhpcy50cnlFbnRyaWVzW25dLHIudHJ5TG9jPD10aGlzLnByZXYmJm0uY2FsbChyLCdmaW5hbGx5TG9jJykmJnRoaXMucHJldjxyLmZpbmFsbHlMb2Mpe3ZhciBvPXI7YnJlYWt9byYmKCdicmVhayc9PT1lfHwnY29udGludWUnPT09ZSkmJm8udHJ5TG9jPD10JiZ0PD1vLmZpbmFsbHlMb2MmJihvPW51bGwpO3ZhciBsPW8/by5jb21wbGV0aW9uOnt9O3JldHVybiBsLnR5cGU9ZSxsLmFyZz10LG8/KHRoaXMubWV0aG9kPSduZXh0Jyx0aGlzLm5leHQ9by5maW5hbGx5TG9jLEEpOnRoaXMuY29tcGxldGUobCl9LGNvbXBsZXRlOmZ1bmN0aW9uKGUsdCl7aWYoJ3Rocm93Jz09PWUudHlwZSl0aHJvdyBlLmFyZztyZXR1cm4nYnJlYWsnPT09ZS50eXBlfHwnY29udGludWUnPT09ZS50eXBlP3RoaXMubmV4dD1lLmFyZzoncmV0dXJuJz09PWUudHlwZT8odGhpcy5ydmFsPXRoaXMuYXJnPWUuYXJnLHRoaXMubWV0aG9kPSdyZXR1cm4nLHRoaXMubmV4dD0nZW5kJyk6J25vcm1hbCc9PT1lLnR5cGUmJnQmJih0aGlzLm5leHQ9dCksQX0sZmluaXNoOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxyPXRoaXMudHJ5RW50cmllcy5sZW5ndGgtMTswPD1yOy0tcilpZih0PXRoaXMudHJ5RW50cmllc1tyXSx0LmZpbmFsbHlMb2M9PT1lKXJldHVybiB0aGlzLmNvbXBsZXRlKHQuY29tcGxldGlvbix0LmFmdGVyTG9jKSx1KHQpLEF9LGNhdGNoOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxyPXRoaXMudHJ5RW50cmllcy5sZW5ndGgtMTswPD1yOy0tcilpZih0PXRoaXMudHJ5RW50cmllc1tyXSx0LnRyeUxvYz09PWUpe3ZhciBuPXQuY29tcGxldGlvbjtpZigndGhyb3cnPT09bi50eXBlKXt2YXIgbz1uLmFyZzt1KHQpfXJldHVybiBvfXRocm93IG5ldyBFcnJvcignaWxsZWdhbCBjYXRjaCBhdHRlbXB0Jyl9LGRlbGVnYXRlWWllbGQ6ZnVuY3Rpb24oZSx0LHIpe3JldHVybiB0aGlzLmRlbGVnYXRlPXtpdGVyYXRvcjpoKGUpLHJlc3VsdE5hbWU6dCxuZXh0TG9jOnJ9LCduZXh0Jz09PXRoaXMubWV0aG9kJiYodGhpcy5hcmc9dm9pZCAwKSxBfX19KGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCl8fEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCkpfSxmdW5jdGlvbihlLHQscil7J3VzZSBzdHJpY3QnO2Z1bmN0aW9uIG4oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCwnX19lc01vZHVsZScse3ZhbHVlOiEwfSk7dmFyIG89ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7Zm9yKHZhciByLG49MDtuPHQubGVuZ3RoO24rKylyPXRbbl0sci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsJ3ZhbHVlJ2luIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX1yZXR1cm4gZnVuY3Rpb24odCxyLG4pe3JldHVybiByJiZlKHQucHJvdG90eXBlLHIpLG4mJmUodCxuKSx0fX0oKSxsPXIoMjEwKSxhPWZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX0obCkscz1yKDk4KSxpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXt2YXIgcj10LnNlbmQsbz10LmZpbGUsbD10LnJlcUlkO24odGhpcyxlKSx0aGlzLnNlbmQ9cix0aGlzLmZpbGU9byx0aGlzLnJlcUlkPWw7dmFyIHM9by5idWZmZXI7dGhpcy5jaGVja3N1bT0oMCxhLmRlZmF1bHQpKEFycmF5LmZyb20ocykpLHRoaXMuc2l6ZT1zLmxlbmd0aH1yZXR1cm4gbyhlLFt7a2V5OidyZXF1ZXN0VXBsb2FkJyx2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMuZmlsZSx0PWUuZG9jdW1lbnRUeXBlLHI9ZS5kb2N1bWVudEZvcm1hdCxuPWUuZG9jdW1lbnRJZCxvPWUuZXhwaXJhdGlvbkRhdGUsbD1lLmxpZmV0aW1lVmFsaWQsYT1lLnBhZ2VUeXBlLHM9ZS5idWZmZXIsaT1lLnByb29mX29mX293bmVyc2hpcCxjPWUuZG9jdW1lbnRfaXNzdWluZ19jb3VudHJ5LHA9T2JqZWN0LmFzc2lnbih0aGlzLmZpbGUucGFzc3Rocm91Z2h8fHt9LHtkb2N1bWVudF91cGxvYWQ6ITB9KSxkPXtyZXFfaWQ6dGhpcy5yZXFJZCxwYXNzdGhyb3VnaDpwLGRvY3VtZW50X3VwbG9hZDoxLGRvY3VtZW50X3R5cGU6dCxkb2N1bWVudF9mb3JtYXQ6ci50b1VwcGVyQ2FzZSgpLGV4cGlyYXRpb25fZGF0ZTpvLGRvY3VtZW50X2lkOm4sZmlsZV9zaXplOnMubGVuZ3RoLGV4cGVjdGVkX2NoZWNrc3VtOnRoaXMuY2hlY2tzdW19O2EmJihkLnBhZ2VfdHlwZT1hKSxsJiYoZC5saWZldGltZV92YWxpZD1sKSxpJiYoZC5wcm9vZl9vZl9vd25lcnNoaXA9aSksYyYmKGQuZG9jdW1lbnRfaXNzdWluZ19jb3VudHJ5PWMpLHRoaXMuc2VuZChKU09OLnN0cmluZ2lmeShkKSl9fSx7a2V5OidoYW5kbGVNZXNzYWdlJyx2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1lLmVycm9yLHI9ZS5kb2N1bWVudF91cGxvYWQsbj1lLnBhc3N0aHJvdWdoO2lmKHQpcmV0dXJue3dhcm5pbmc6dC5jb2RlLG1lc3NhZ2U6dC5tZXNzYWdlLHBhc3N0aHJvdWdoOm59O3ZhciBvPXIuY2hlY2tzdW0sbD1yLnNpemUsYT1yLnVwbG9hZF9pZCxpPXIuY2FsbF90eXBlO2lmKCFvKXJldHVybiB2b2lkIHRoaXMuc3RhcnRCaW5hcnlVcGxvYWQoT2JqZWN0LmFzc2lnbih7fSx0aGlzLmZpbGUse3VwbG9hZElkOmEsY2FsbFR5cGU6aX0pKTtpZihsIT09dGhpcy5zaXplKXRocm93KDAscy5jcmVhdGVFcnJvcikoJ1NpemVNaXNtYXRjaCcsJ0ZpbGUgc2l6ZSBkb2VzIG5vdCBtYXRjaCcsbik7aWYobyE9PXRoaXMuY2hlY2tzdW0pdGhyb3coMCxzLmNyZWF0ZUVycm9yKSgnQ2hlY2tzdW1NaXNtYXRjaCcsJ0NoZWNrc3VtIGRvZXMgbm90IG1hdGNoJyxuKTtyZXR1cm57ZG9jdW1lbnRfdXBsb2FkOnIscGFzc3Rocm91Z2g6bn19fSx7a2V5OidzdGFydEJpbmFyeVVwbG9hZCcsdmFsdWU6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXRoaXMscj0oMCxzLmFkZE1ldGFkYXRhKSgoMCxzLmdlbmVyYXRlQ2h1bmtzKShlLmJ1ZmZlcixlKSxlKSxuPWZ1bmN0aW9uKGUpe3JldHVybiB0LnNlbmQoZSl9LG89MDtvPHIubGVuZ3RoO28rKyluKHJbb10sbyxyKX19XSksZX0oKTt0LmRlZmF1bHQ9aX0sZnVuY3Rpb24oZSx0LHIpeyhmdW5jdGlvbigpe3ZhciB0PXIoMjExKSxuPXIoOTkpLnV0Zjgsbz1yKDIxMikscz1yKDk5KS5iaW4sbD1mdW5jdGlvbihlLHIpe2UuY29uc3RydWN0b3I9PVN0cmluZz9yJiYnYmluYXJ5Jz09PXIuZW5jb2Rpbmc/ZT1zLnN0cmluZ1RvQnl0ZXMoZSk6ZT1uLnN0cmluZ1RvQnl0ZXMoZSk6byhlKT9lPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUsMCk6IUFycmF5LmlzQXJyYXkoZSkmJihlPWUudG9TdHJpbmcoKSk7Zm9yKHZhciBwPXQuYnl0ZXNUb1dvcmRzKGUpLHU9OCplLmxlbmd0aCxnPTE3MzI1ODQxOTMsYT0tMjcxNzMzODc5LGg9LTE3MzI1ODQxOTQsYz0yNzE3MzM4NzgsZD0wO2Q8cC5sZW5ndGg7ZCsrKXBbZF09MTY3MTE5MzUmKHBbZF08PDh8cFtkXT4+PjI0KXw0Mjc4MjU1MzYwJihwW2RdPDwyNHxwW2RdPj4+OCk7cFt1Pj4+NV18PTEyODw8dSUzMixwWyh1KzY0Pj4+OTw8NCkrMTRdPXU7Zm9yKHZhciBpPWwuX2ZmLHk9bC5fZ2csZj1sLl9oaCxtPWwuX2lpLGQ9MDtkPHAubGVuZ3RoO2QrPTE2KXt2YXIgRT1nLF89YSx4PWgsUz1jO2c9aShnLGEsaCxjLHBbZCswXSw3LC02ODA4NzY5MzYpLGM9aShjLGcsYSxoLHBbZCsxXSwxMiwtMzg5NTY0NTg2KSxoPWkoaCxjLGcsYSxwW2QrMl0sMTcsNjA2MTA1ODE5KSxhPWkoYSxoLGMsZyxwW2QrM10sMjIsLTEwNDQ1MjUzMzApLGc9aShnLGEsaCxjLHBbZCs0XSw3LC0xNzY0MTg4OTcpLGM9aShjLGcsYSxoLHBbZCs1XSwxMiwxMjAwMDgwNDI2KSxoPWkoaCxjLGcsYSxwW2QrNl0sMTcsLTE0NzMyMzEzNDEpLGE9aShhLGgsYyxnLHBbZCs3XSwyMiwtNDU3MDU5ODMpLGc9aShnLGEsaCxjLHBbZCs4XSw3LDE3NzAwMzU0MTYpLGM9aShjLGcsYSxoLHBbZCs5XSwxMiwtMTk1ODQxNDQxNyksaD1pKGgsYyxnLGEscFtkKzEwXSwxNywtNDIwNjMpLGE9aShhLGgsYyxnLHBbZCsxMV0sMjIsLTE5OTA0MDQxNjIpLGc9aShnLGEsaCxjLHBbZCsxMl0sNywxODA0NjAzNjgyKSxjPWkoYyxnLGEsaCxwW2QrMTNdLDEyLC00MDM0MTEwMSksaD1pKGgsYyxnLGEscFtkKzE0XSwxNywtMTUwMjAwMjI5MCksYT1pKGEsaCxjLGcscFtkKzE1XSwyMiwxMjM2NTM1MzI5KSxnPXkoZyxhLGgsYyxwW2QrMV0sNSwtMTY1Nzk2NTEwKSxjPXkoYyxnLGEsaCxwW2QrNl0sOSwtMTA2OTUwMTYzMiksaD15KGgsYyxnLGEscFtkKzExXSwxNCw2NDM3MTc3MTMpLGE9eShhLGgsYyxnLHBbZCswXSwyMCwtMzczODk3MzAyKSxnPXkoZyxhLGgsYyxwW2QrNV0sNSwtNzAxNTU4NjkxKSxjPXkoYyxnLGEsaCxwW2QrMTBdLDksMzgwMTYwODMpLGg9eShoLGMsZyxhLHBbZCsxNV0sMTQsLTY2MDQ3ODMzNSksYT15KGEsaCxjLGcscFtkKzRdLDIwLC00MDU1Mzc4NDgpLGc9eShnLGEsaCxjLHBbZCs5XSw1LDU2ODQ0NjQzOCksYz15KGMsZyxhLGgscFtkKzE0XSw5LC0xMDE5ODAzNjkwKSxoPXkoaCxjLGcsYSxwW2QrM10sMTQsLTE4NzM2Mzk2MSksYT15KGEsaCxjLGcscFtkKzhdLDIwLDExNjM1MzE1MDEpLGc9eShnLGEsaCxjLHBbZCsxM10sNSwtMTQ0NDY4MTQ2NyksYz15KGMsZyxhLGgscFtkKzJdLDksLTUxNDAzNzg0KSxoPXkoaCxjLGcsYSxwW2QrN10sMTQsMTczNTMyODQ3MyksYT15KGEsaCxjLGcscFtkKzEyXSwyMCwtMTkyNjYwNzczNCksZz1mKGcsYSxoLGMscFtkKzVdLDQsLTM3ODU1OCksYz1mKGMsZyxhLGgscFtkKzhdLDExLC0yMDIyNTc0NDYzKSxoPWYoaCxjLGcsYSxwW2QrMTFdLDE2LDE4MzkwMzA1NjIpLGE9ZihhLGgsYyxnLHBbZCsxNF0sMjMsLTM1MzA5NTU2KSxnPWYoZyxhLGgsYyxwW2QrMV0sNCwtMTUzMDk5MjA2MCksYz1mKGMsZyxhLGgscFtkKzRdLDExLDEyNzI4OTMzNTMpLGg9ZihoLGMsZyxhLHBbZCs3XSwxNiwtMTU1NDk3NjMyKSxhPWYoYSxoLGMsZyxwW2QrMTBdLDIzLC0xMDk0NzMwNjQwKSxnPWYoZyxhLGgsYyxwW2QrMTNdLDQsNjgxMjc5MTc0KSxjPWYoYyxnLGEsaCxwW2QrMF0sMTEsLTM1ODUzNzIyMiksaD1mKGgsYyxnLGEscFtkKzNdLDE2LC03MjI1MjE5NzkpLGE9ZihhLGgsYyxnLHBbZCs2XSwyMyw3NjAyOTE4OSksZz1mKGcsYSxoLGMscFtkKzldLDQsLTY0MDM2NDQ4NyksYz1mKGMsZyxhLGgscFtkKzEyXSwxMSwtNDIxODE1ODM1KSxoPWYoaCxjLGcsYSxwW2QrMTVdLDE2LDUzMDc0MjUyMCksYT1mKGEsaCxjLGcscFtkKzJdLDIzLC05OTUzMzg2NTEpLGc9bShnLGEsaCxjLHBbZCswXSw2LC0xOTg2MzA4NDQpLGM9bShjLGcsYSxoLHBbZCs3XSwxMCwxMTI2ODkxNDE1KSxoPW0oaCxjLGcsYSxwW2QrMTRdLDE1LC0xNDE2MzU0OTA1KSxhPW0oYSxoLGMsZyxwW2QrNV0sMjEsLTU3NDM0MDU1KSxnPW0oZyxhLGgsYyxwW2QrMTJdLDYsMTcwMDQ4NTU3MSksYz1tKGMsZyxhLGgscFtkKzNdLDEwLC0xODk0OTg2NjA2KSxoPW0oaCxjLGcsYSxwW2QrMTBdLDE1LC0xMDUxNTIzKSxhPW0oYSxoLGMsZyxwW2QrMV0sMjEsLTIwNTQ5MjI3OTkpLGc9bShnLGEsaCxjLHBbZCs4XSw2LDE4NzMzMTMzNTkpLGM9bShjLGcsYSxoLHBbZCsxNV0sMTAsLTMwNjExNzQ0KSxoPW0oaCxjLGcsYSxwW2QrNl0sMTUsLTE1NjAxOTgzODApLGE9bShhLGgsYyxnLHBbZCsxM10sMjEsMTMwOTE1MTY0OSksZz1tKGcsYSxoLGMscFtkKzRdLDYsLTE0NTUyMzA3MCksYz1tKGMsZyxhLGgscFtkKzExXSwxMCwtMTEyMDIxMDM3OSksaD1tKGgsYyxnLGEscFtkKzJdLDE1LDcxODc4NzI1OSksYT1tKGEsaCxjLGcscFtkKzldLDIxLC0zNDM0ODU1NTEpLGc9ZytFPj4+MCxhPWErXz4+PjAsaD1oK3g+Pj4wLGM9YytTPj4+MH1yZXR1cm4gdC5lbmRpYW4oW2csYSxoLGNdKX07bC5fZmY9ZnVuY3Rpb24oZSxyLG8sbCxhLGkscyl7dmFyIHQ9ZSsociZvfH5yJmwpKyhhPj4+MCkrcztyZXR1cm4odDw8aXx0Pj4+MzItaSkrcn0sbC5fZ2c9ZnVuY3Rpb24oZSxyLG8sbCxhLGkscyl7dmFyIHQ9ZSsociZsfG8mfmwpKyhhPj4+MCkrcztyZXR1cm4odDw8aXx0Pj4+MzItaSkrcn0sbC5faGg9ZnVuY3Rpb24oZSxyLG8sbCxhLGkscyl7dmFyIHQ9ZSsocl5vXmwpKyhhPj4+MCkrcztyZXR1cm4odDw8aXx0Pj4+MzItaSkrcn0sbC5faWk9ZnVuY3Rpb24oZSxyLG8sbCxhLGkscyl7dmFyIHQ9ZSsob14ocnx+bCkpKyhhPj4+MCkrcztyZXR1cm4odDw8aXx0Pj4+MzItaSkrcn0sbC5fYmxvY2tzaXplPTE2LGwuX2RpZ2VzdHNpemU9MTYsZS5leHBvcnRzPWZ1bmN0aW9uKGUscil7aWYoZT09PXZvaWQgMHx8bnVsbD09PWUpdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGFyZ3VtZW50ICcrZSk7dmFyIG49dC53b3Jkc1RvQnl0ZXMobChlLHIpKTtyZXR1cm4gciYmci5hc0J5dGVzP246ciYmci5hc1N0cmluZz9zLmJ5dGVzVG9TdHJpbmcobik6dC5ieXRlc1RvSGV4KG4pfX0pKCl9LGZ1bmN0aW9uKGUpeyhmdW5jdGlvbigpe3ZhciB0PSdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyxyPXtyb3RsOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU8PHR8ZT4+PjMyLXR9LHJvdHI6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZTw8MzItdHxlPj4+dH0sZW5kaWFuOmZ1bmN0aW9uKGUpe2lmKGUuY29uc3RydWN0b3I9PU51bWJlcilyZXR1cm4gMTY3MTE5MzUmci5yb3RsKGUsOCl8NDI3ODI1NTM2MCZyLnJvdGwoZSwyNCk7Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDt0KyspZVt0XT1yLmVuZGlhbihlW3RdKTtyZXR1cm4gZX0scmFuZG9tQnl0ZXM6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVtdOzA8ZTtlLS0pdC5wdXNoKHAoMjU2Kk1hdGgucmFuZG9tKCkpKTtyZXR1cm4gdH0sYnl0ZXNUb1dvcmRzOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bXSxyPTAsbj0wO3I8ZS5sZW5ndGg7cisrLG4rPTgpdFtuPj4+NV18PWVbcl08PDI0LW4lMzI7cmV0dXJuIHR9LHdvcmRzVG9CeXRlczpmdW5jdGlvbihlKXtmb3IodmFyIHQ9W10scj0wO3I8MzIqZS5sZW5ndGg7cis9OCl0LnB1c2goMjU1JmVbcj4+PjVdPj4+MjQtciUzMik7cmV0dXJuIHR9LGJ5dGVzVG9IZXg6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVtdLHI9MDtyPGUubGVuZ3RoO3IrKyl0LnB1c2goKGVbcl0+Pj40KS50b1N0cmluZygxNikpLHQucHVzaCgoMTUmZVtyXSkudG9TdHJpbmcoMTYpKTtyZXR1cm4gdC5qb2luKCcnKX0saGV4VG9CeXRlczpmdW5jdGlvbihlKXtmb3IodmFyIHQ9W10scj0wO3I8ZS5sZW5ndGg7cis9Mil0LnB1c2gocGFyc2VJbnQoZS5zdWJzdHIociwyKSwxNikpO3JldHVybiB0fSxieXRlc1RvQmFzZTY0OmZ1bmN0aW9uKGUpe2Zvcih2YXIgcixuPVtdLG89MDtvPGUubGVuZ3RoO28rPTMpe3I9ZVtvXTw8MTZ8ZVtvKzFdPDw4fGVbbysyXTtmb3IodmFyIGw9MDs0Pmw7bCsrKTgqbys2Kmw8PTgqZS5sZW5ndGg/bi5wdXNoKHQuY2hhckF0KDYzJnI+Pj42KigzLWwpKSk6bi5wdXNoKCc9Jyl9cmV0dXJuIG4uam9pbignJyl9LGJhc2U2NFRvQnl0ZXM6ZnVuY3Rpb24oZSl7ZT1lLnJlcGxhY2UoL1teQS1aMC05K1xcL10vaWcsJycpO2Zvcih2YXIgcj1bXSxuPTAsbD0wO248ZS5sZW5ndGg7bD0rK24lNCkwIT1sJiZyLnB1c2goKHQuaW5kZXhPZihlLmNoYXJBdChuLTEpKSZvKDIsLTIqbCs4KS0xKTw8MipsfHQuaW5kZXhPZihlLmNoYXJBdChuKSk+Pj42LTIqbCk7cmV0dXJuIHJ9fTtlLmV4cG9ydHM9cn0pKCl9LGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoZSl7cmV0dXJuISFlLmNvbnN0cnVjdG9yJiYnZnVuY3Rpb24nPT10eXBlb2YgZS5jb25zdHJ1Y3Rvci5pc0J1ZmZlciYmZS5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihlKX1mdW5jdGlvbiByKGUpe3JldHVybidmdW5jdGlvbic9PXR5cGVvZiBlLnJlYWRGbG9hdExFJiYnZnVuY3Rpb24nPT10eXBlb2YgZS5zbGljZSYmdChlLnNsaWNlKDAsMCkpfWUuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9ZSYmKHQoZSl8fHIoZSl8fCEhZS5faXNCdWZmZXIpfX1dKVsnZGVmYXVsdCddfSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/@binary-com/binary-document-uploader/DocumentUploader.js\n");

/***/ }),

/***/ "../../../node_modules/@deriv/deriv-api/dist/DerivAPIBasic.js":
/***/ (function(module) {

eval("!function(e,t){ true?module.exports=t():0}(\"undefined\"!=typeof self?self:this,(function(){return(()=>{var e={757:(e,t,r)=>{e.exports=r(666)},266:(e,t,r)=>{var n=\"undefined\"!=typeof JSON?JSON:r(418);e.exports=function(e,t){t||(t={}),\"function\"==typeof t&&(t={cmp:t});var r=t.space||\"\";\"number\"==typeof r&&(r=Array(r+1).join(\" \"));var o,u=\"boolean\"==typeof t.cycles&&t.cycles,c=t.replacer||function(e,t){return t},a=t.cmp&&(o=t.cmp,function(e){return function(t,r){var n={key:t,value:e[t]},i={key:r,value:e[r]};return o(n,i)}}),p=[];return function e(t,o,d,h){var y=r?\"\\n\"+new Array(h+1).join(r):\"\",l=r?\": \":\":\";if(d&&d.toJSON&&\"function\"==typeof d.toJSON&&(d=d.toJSON()),void 0!==(d=c.call(t,o,d))){if(\"object\"!=typeof d||null===d)return n.stringify(d);if(i(d)){for(var g=[],f=0;f<d.length;f++){var _=e(d,f,d[f],h+1)||n.stringify(null);g.push(y+r+_)}return\"[\"+g.join(\",\")+y+\"]\"}if(-1!==p.indexOf(d)){if(u)return n.stringify(\"__cycle__\");throw new TypeError(\"Converting circular structure to JSON\")}p.push(d);var m=s(d).sort(a&&a(d));for(g=[],f=0;f<m.length;f++){var v=e(d,o=m[f],d[o],h+1);if(v){var q=n.stringify(o)+l+v;g.push(y+r+q)}}return p.splice(p.indexOf(d),1),\"{\"+g.join(\",\")+y+\"}\"}}({\"\":e},\"\",e,0)};var i=Array.isArray||function(e){return\"[object Array]\"==={}.toString.call(e)},s=Object.keys||function(e){var t=Object.prototype.hasOwnProperty||function(){return!0},r=[];for(var n in e)t.call(e,n)&&r.push(n);return r}},418:(e,t,r)=>{t.parse=r(396),t.stringify=r(177)},396:e=>{var t,r,n,i,s={'\"':'\"',\"\\\\\":\"\\\\\",\"/\":\"/\",b:\"\\b\",f:\"\\f\",n:\"\\n\",r:\"\\r\",t:\"\\t\"},o=function(e){throw{name:\"SyntaxError\",message:e,at:t,text:n}},u=function(e){return e&&e!==r&&o(\"Expected '\"+e+\"' instead of '\"+r+\"'\"),r=n.charAt(t),t+=1,r},c=function(){var e,t=\"\";for(\"-\"===r&&(t=\"-\",u(\"-\"));r>=\"0\"&&r<=\"9\";)t+=r,u();if(\".\"===r)for(t+=\".\";u()&&r>=\"0\"&&r<=\"9\";)t+=r;if(\"e\"===r||\"E\"===r)for(t+=r,u(),\"-\"!==r&&\"+\"!==r||(t+=r,u());r>=\"0\"&&r<=\"9\";)t+=r,u();if(e=+t,isFinite(e))return e;o(\"Bad number\")},a=function(){var e,t,n,i=\"\";if('\"'===r)for(;u();){if('\"'===r)return u(),i;if(\"\\\\\"===r)if(u(),\"u\"===r){for(n=0,t=0;t<4&&(e=parseInt(u(),16),isFinite(e));t+=1)n=16*n+e;i+=String.fromCharCode(n)}else{if(\"string\"!=typeof s[r])break;i+=s[r]}else i+=r}o(\"Bad string\")},p=function(){for(;r&&r<=\" \";)u()};i=function(){switch(p(),r){case\"{\":return function(){var e,t={};if(\"{\"===r){if(u(\"{\"),p(),\"}\"===r)return u(\"}\"),t;for(;r;){if(e=a(),p(),u(\":\"),Object.hasOwnProperty.call(t,e)&&o('Duplicate key \"'+e+'\"'),t[e]=i(),p(),\"}\"===r)return u(\"}\"),t;u(\",\"),p()}}o(\"Bad object\")}();case\"[\":return function(){var e=[];if(\"[\"===r){if(u(\"[\"),p(),\"]\"===r)return u(\"]\"),e;for(;r;){if(e.push(i()),p(),\"]\"===r)return u(\"]\"),e;u(\",\"),p()}}o(\"Bad array\")}();case'\"':return a();case\"-\":return c();default:return r>=\"0\"&&r<=\"9\"?c():function(){switch(r){case\"t\":return u(\"t\"),u(\"r\"),u(\"u\"),u(\"e\"),!0;case\"f\":return u(\"f\"),u(\"a\"),u(\"l\"),u(\"s\"),u(\"e\"),!1;case\"n\":return u(\"n\"),u(\"u\"),u(\"l\"),u(\"l\"),null}o(\"Unexpected '\"+r+\"'\")}()}},e.exports=function(e,s){var u;return n=e,t=0,r=\" \",u=i(),p(),r&&o(\"Syntax error\"),\"function\"==typeof s?function e(t,r){var n,i,o=t[r];if(o&&\"object\"==typeof o)for(n in o)Object.prototype.hasOwnProperty.call(o,n)&&(void 0!==(i=e(o,n))?o[n]=i:delete o[n]);return s.call(t,r,o)}({\"\":u},\"\"):u}},177:e=>{var t,r,n,i=/[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,s={\"\\b\":\"\\\\b\",\"\\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\\f\":\"\\\\f\",\"\\r\":\"\\\\r\",'\"':'\\\\\"',\"\\\\\":\"\\\\\\\\\"};function o(e){return i.lastIndex=0,i.test(e)?'\"'+e.replace(i,(function(e){var t=s[e];return\"string\"==typeof t?t:\"\\\\u\"+(\"0000\"+e.charCodeAt(0).toString(16)).slice(-4)}))+'\"':'\"'+e+'\"'}function u(e,i){var s,c,a,p,d,h=t,y=i[e];switch(y&&\"object\"==typeof y&&\"function\"==typeof y.toJSON&&(y=y.toJSON(e)),\"function\"==typeof n&&(y=n.call(i,e,y)),typeof y){case\"string\":return o(y);case\"number\":return isFinite(y)?String(y):\"null\";case\"boolean\":case\"null\":return String(y);case\"object\":if(!y)return\"null\";if(t+=r,d=[],\"[object Array]\"===Object.prototype.toString.apply(y)){for(p=y.length,s=0;s<p;s+=1)d[s]=u(s,y)||\"null\";return a=0===d.length?\"[]\":t?\"[\\n\"+t+d.join(\",\\n\"+t)+\"\\n\"+h+\"]\":\"[\"+d.join(\",\")+\"]\",t=h,a}if(n&&\"object\"==typeof n)for(p=n.length,s=0;s<p;s+=1)\"string\"==typeof(c=n[s])&&(a=u(c,y))&&d.push(o(c)+(t?\": \":\":\")+a);else for(c in y)Object.prototype.hasOwnProperty.call(y,c)&&(a=u(c,y))&&d.push(o(c)+(t?\": \":\":\")+a);return a=0===d.length?\"{}\":t?\"{\\n\"+t+d.join(\",\\n\"+t)+\"\\n\"+h+\"}\":\"{\"+d.join(\",\")+\"}\",t=h,a}}e.exports=function(e,i,s){var o;if(t=\"\",r=\"\",\"number\"==typeof s)for(o=0;o<s;o+=1)r+=\" \";else\"string\"==typeof s&&(r=s);if(n=i,i&&\"function\"!=typeof i&&(\"object\"!=typeof i||\"number\"!=typeof i.length))throw new Error(\"JSON.stringify\");return u(\"\",{\"\":e})}},666:e=>{var t=function(e){\"use strict\";var t,r=Object.prototype,n=r.hasOwnProperty,i=\"function\"==typeof Symbol?Symbol:{},s=i.iterator||\"@@iterator\",o=i.asyncIterator||\"@@asyncIterator\",u=i.toStringTag||\"@@toStringTag\";function c(e,t,r){return Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}),e[t]}try{c({},\"\")}catch(e){c=function(e,t,r){return e[t]=r}}function a(e,t,r,n){var i=t&&t.prototype instanceof f?t:f,s=Object.create(i.prototype),o=new O(n||[]);return s._invoke=function(e,t,r){var n=d;return function(i,s){if(n===y)throw new Error(\"Generator is already running\");if(n===l){if(\"throw\"===i)throw s;return E()}for(r.method=i,r.arg=s;;){var o=r.delegate;if(o){var u=x(o,r);if(u){if(u===g)continue;return u}}if(\"next\"===r.method)r.sent=r._sent=r.arg;else if(\"throw\"===r.method){if(n===d)throw n=l,r.arg;r.dispatchException(r.arg)}else\"return\"===r.method&&r.abrupt(\"return\",r.arg);n=y;var c=p(e,t,r);if(\"normal\"===c.type){if(n=r.done?l:h,c.arg===g)continue;return{value:c.arg,done:r.done}}\"throw\"===c.type&&(n=l,r.method=\"throw\",r.arg=c.arg)}}}(e,r,o),s}function p(e,t,r){try{return{type:\"normal\",arg:e.call(t,r)}}catch(e){return{type:\"throw\",arg:e}}}e.wrap=a;var d=\"suspendedStart\",h=\"suspendedYield\",y=\"executing\",l=\"completed\",g={};function f(){}function _(){}function m(){}var v={};c(v,s,(function(){return this}));var q=Object.getPrototypeOf,b=q&&q(q(S([])));b&&b!==r&&n.call(b,s)&&(v=b);var w=m.prototype=f.prototype=Object.create(v);function k(e){[\"next\",\"throw\",\"return\"].forEach((function(t){c(e,t,(function(e){return this._invoke(t,e)}))}))}function A(e,t){function r(i,s,o,u){var c=p(e[i],e,s);if(\"throw\"!==c.type){var a=c.arg,d=a.value;return d&&\"object\"==typeof d&&n.call(d,\"__await\")?t.resolve(d.__await).then((function(e){r(\"next\",e,o,u)}),(function(e){r(\"throw\",e,o,u)})):t.resolve(d).then((function(e){a.value=e,o(a)}),(function(e){return r(\"throw\",e,o,u)}))}u(c.arg)}var i;this._invoke=function(e,n){function s(){return new t((function(t,i){r(e,n,t,i)}))}return i=i?i.then(s,s):s()}}function x(e,r){var n=e.iterator[r.method];if(n===t){if(r.delegate=null,\"throw\"===r.method){if(e.iterator.return&&(r.method=\"return\",r.arg=t,x(e,r),\"throw\"===r.method))return g;r.method=\"throw\",r.arg=new TypeError(\"The iterator does not provide a 'throw' method\")}return g}var i=p(n,e.iterator,r.arg);if(\"throw\"===i.type)return r.method=\"throw\",r.arg=i.arg,r.delegate=null,g;var s=i.arg;return s?s.done?(r[e.resultName]=s.value,r.next=e.nextLoc,\"return\"!==r.method&&(r.method=\"next\",r.arg=t),r.delegate=null,g):s:(r.method=\"throw\",r.arg=new TypeError(\"iterator result is not an object\"),r.delegate=null,g)}function R(e){var t={tryLoc:e[0]};1 in e&&(t.catchLoc=e[1]),2 in e&&(t.finallyLoc=e[2],t.afterLoc=e[3]),this.tryEntries.push(t)}function M(e){var t=e.completion||{};t.type=\"normal\",delete t.arg,e.completion=t}function O(e){this.tryEntries=[{tryLoc:\"root\"}],e.forEach(R,this),this.reset(!0)}function S(e){if(e){var r=e[s];if(r)return r.call(e);if(\"function\"==typeof e.next)return e;if(!isNaN(e.length)){var i=-1,o=function r(){for(;++i<e.length;)if(n.call(e,i))return r.value=e[i],r.done=!1,r;return r.value=t,r.done=!0,r};return o.next=o}}return{next:E}}function E(){return{value:t,done:!0}}return _.prototype=m,c(w,\"constructor\",m),c(m,\"constructor\",_),_.displayName=c(m,u,\"GeneratorFunction\"),e.isGeneratorFunction=function(e){var t=\"function\"==typeof e&&e.constructor;return!!t&&(t===_||\"GeneratorFunction\"===(t.displayName||t.name))},e.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,m):(e.__proto__=m,c(e,u,\"GeneratorFunction\")),e.prototype=Object.create(w),e},e.awrap=function(e){return{__await:e}},k(A.prototype),c(A.prototype,o,(function(){return this})),e.AsyncIterator=A,e.async=function(t,r,n,i,s){void 0===s&&(s=Promise);var o=new A(a(t,r,n,i),s);return e.isGeneratorFunction(r)?o:o.next().then((function(e){return e.done?e.value:o.next()}))},k(w),c(w,u,\"Generator\"),c(w,s,(function(){return this})),c(w,\"toString\",(function(){return\"[object Generator]\"})),e.keys=function(e){var t=[];for(var r in e)t.push(r);return t.reverse(),function r(){for(;t.length;){var n=t.pop();if(n in e)return r.value=n,r.done=!1,r}return r.done=!0,r}},e.values=S,O.prototype={constructor:O,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method=\"next\",this.arg=t,this.tryEntries.forEach(M),!e)for(var r in this)\"t\"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var e=this.tryEntries[0].completion;if(\"throw\"===e.type)throw e.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function i(n,i){return u.type=\"throw\",u.arg=e,r.next=n,i&&(r.method=\"next\",r.arg=t),!!i}for(var s=this.tryEntries.length-1;s>=0;--s){var o=this.tryEntries[s],u=o.completion;if(\"root\"===o.tryLoc)return i(\"end\");if(o.tryLoc<=this.prev){var c=n.call(o,\"catchLoc\"),a=n.call(o,\"finallyLoc\");if(c&&a){if(this.prev<o.catchLoc)return i(o.catchLoc,!0);if(this.prev<o.finallyLoc)return i(o.finallyLoc)}else if(c){if(this.prev<o.catchLoc)return i(o.catchLoc,!0)}else{if(!a)throw new Error(\"try statement without catch or finally\");if(this.prev<o.finallyLoc)return i(o.finallyLoc)}}}},abrupt:function(e,t){for(var r=this.tryEntries.length-1;r>=0;--r){var i=this.tryEntries[r];if(i.tryLoc<=this.prev&&n.call(i,\"finallyLoc\")&&this.prev<i.finallyLoc){var s=i;break}}s&&(\"break\"===e||\"continue\"===e)&&s.tryLoc<=t&&t<=s.finallyLoc&&(s=null);var o=s?s.completion:{};return o.type=e,o.arg=t,s?(this.method=\"next\",this.next=s.finallyLoc,g):this.complete(o)},complete:function(e,t){if(\"throw\"===e.type)throw e.arg;return\"break\"===e.type||\"continue\"===e.type?this.next=e.arg:\"return\"===e.type?(this.rval=this.arg=e.arg,this.method=\"return\",this.next=\"end\"):\"normal\"===e.type&&t&&(this.next=t),g},finish:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.finallyLoc===e)return this.complete(r.completion,r.afterLoc),M(r),g}},catch:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.tryLoc===e){var n=r.completion;if(\"throw\"===n.type){var i=n.arg;M(r)}return i}}throw new Error(\"illegal catch attempt\")},delegateYield:function(e,r,n){return this.delegate={iterator:S(e),resultName:r,nextLoc:n},\"next\"===this.method&&(this.arg=t),g}},e}(e.exports);try{regeneratorRuntime=t}catch(e){\"object\"==typeof globalThis?globalThis.regeneratorRuntime=t:Function(\"r\",\"regeneratorRuntime = r\")(t)}}},t={};function r(n){var i=t[n];if(void 0!==i)return i.exports;var s=t[n]={exports:{}};return e[n](s,s.exports,r),s.exports}r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var n={};return(()=>{\"use strict\";function e(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}function t(e){return t=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e},t(e)}function i(e,t,r,n,i,s,o){try{var u=e[s](o),c=u.value}catch(e){return void r(e)}u.done?t(c):Promise.resolve(c).then(n,i)}function s(e){return function(){var t=this,r=arguments;return new Promise((function(n,s){var o=e.apply(t,r);function u(e){i(o,n,s,u,c,\"next\",e)}function c(e){i(o,n,s,u,c,\"throw\",e)}u(void 0)}))}}function o(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}function u(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function c(e,t,r){return t&&u(e.prototype,t),r&&u(e,r),Object.defineProperty(e,\"prototype\",{writable:!1}),e}function a(e){if(void 0===e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return e}function p(e,t){return p=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},p(e,t)}function d(e,t){if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function\");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,\"prototype\",{writable:!1}),t&&p(e,t)}function h(e,r){if(r&&(\"object\"===t(r)||\"function\"==typeof r))return r;if(void 0!==r)throw new TypeError(\"Derived constructors may only return object or undefined\");return a(e)}function y(e){return y=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},y(e)}r.d(n,{default:()=>Fe});var l=r(757),g=r.n(l);function f(){return Error.call(this),this.message=\"no elements in sequence\",this.name=\"EmptyError\",this}f.prototype=Object.create(Error.prototype);var _=f,m=function(e,t){return m=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])},m(e,t)};function v(e,t){function r(){this.constructor=e}m(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}function q(e){return\"function\"==typeof e}var b=!1,w={Promise:void 0,set useDeprecatedSynchronousErrorHandling(e){e&&(new Error).stack,b=e},get useDeprecatedSynchronousErrorHandling(){return b}};function k(e){setTimeout((function(){throw e}),0)}var A={closed:!0,next:function(e){},error:function(e){if(w.useDeprecatedSynchronousErrorHandling)throw e;k(e)},complete:function(){}},x=Array.isArray||function(e){return e&&\"number\"==typeof e.length};function R(e){return Error.call(this),this.message=e?e.length+\" errors occurred during unsubscription:\\n\"+e.map((function(e,t){return t+1+\") \"+e.toString()})).join(\"\\n  \"):\"\",this.name=\"UnsubscriptionError\",this.errors=e,this}R.prototype=Object.create(Error.prototype);var M=R,O=function(){function e(e){this.closed=!1,this._parentOrParents=null,this._subscriptions=null,e&&(this._unsubscribe=e)}return e.prototype.unsubscribe=function(){var t;if(!this.closed){var r,n=this,i=n._parentOrParents,s=n._unsubscribe,o=n._subscriptions;if(this.closed=!0,this._parentOrParents=null,this._subscriptions=null,i instanceof e)i.remove(this);else if(null!==i)for(var u=0;u<i.length;++u)i[u].remove(this);if(q(s))try{s.call(this)}catch(e){t=e instanceof M?S(e.errors):[e]}if(x(o)){u=-1;for(var c=o.length;++u<c;){var a=o[u];if(null!==(r=a)&&\"object\"==typeof r)try{a.unsubscribe()}catch(e){t=t||[],e instanceof M?t=t.concat(S(e.errors)):t.push(e)}}}if(t)throw new M(t)}},e.prototype.add=function(t){var r=t;if(!t)return e.EMPTY;switch(typeof t){case\"function\":r=new e(t);case\"object\":if(r===this||r.closed||\"function\"!=typeof r.unsubscribe)return r;if(this.closed)return r.unsubscribe(),r;if(!(r instanceof e)){var n=r;(r=new e)._subscriptions=[n]}break;default:throw new Error(\"unrecognized teardown \"+t+\" added to Subscription.\")}var i=r._parentOrParents;if(null===i)r._parentOrParents=this;else if(i instanceof e){if(i===this)return r;r._parentOrParents=[i,this]}else{if(-1!==i.indexOf(this))return r;i.push(this)}var s=this._subscriptions;return null===s?this._subscriptions=[r]:s.push(r),r},e.prototype.remove=function(e){var t=this._subscriptions;if(t){var r=t.indexOf(e);-1!==r&&t.splice(r,1)}},e.EMPTY=function(e){return e.closed=!0,e}(new e),e}();function S(e){return e.reduce((function(e,t){return e.concat(t instanceof M?t.errors:t)}),[])}var E=\"function\"==typeof Symbol?Symbol(\"rxSubscriber\"):\"@@rxSubscriber_\"+Math.random(),j=function(e){function t(r,n,i){var s=e.call(this)||this;switch(s.syncErrorValue=null,s.syncErrorThrown=!1,s.syncErrorThrowable=!1,s.isStopped=!1,arguments.length){case 0:s.destination=A;break;case 1:if(!r){s.destination=A;break}if(\"object\"==typeof r){r instanceof t?(s.syncErrorThrowable=r.syncErrorThrowable,s.destination=r,r.add(s)):(s.syncErrorThrowable=!0,s.destination=new P(s,r));break}default:s.syncErrorThrowable=!0,s.destination=new P(s,r,n,i)}return s}return v(t,e),t.prototype[E]=function(){return this},t.create=function(e,r,n){var i=new t(e,r,n);return i.syncErrorThrowable=!1,i},t.prototype.next=function(e){this.isStopped||this._next(e)},t.prototype.error=function(e){this.isStopped||(this.isStopped=!0,this._error(e))},t.prototype.complete=function(){this.isStopped||(this.isStopped=!0,this._complete())},t.prototype.unsubscribe=function(){this.closed||(this.isStopped=!0,e.prototype.unsubscribe.call(this))},t.prototype._next=function(e){this.destination.next(e)},t.prototype._error=function(e){this.destination.error(e),this.unsubscribe()},t.prototype._complete=function(){this.destination.complete(),this.unsubscribe()},t.prototype._unsubscribeAndRecycle=function(){var e=this._parentOrParents;return this._parentOrParents=null,this.unsubscribe(),this.closed=!1,this.isStopped=!1,this._parentOrParents=e,this},t}(O),P=function(e){function t(t,r,n,i){var s,o=e.call(this)||this;o._parentSubscriber=t;var u=o;return q(r)?s=r:r&&(s=r.next,n=r.error,i=r.complete,r!==A&&(q((u=Object.create(r)).unsubscribe)&&o.add(u.unsubscribe.bind(u)),u.unsubscribe=o.unsubscribe.bind(o))),o._context=u,o._next=s,o._error=n,o._complete=i,o}return v(t,e),t.prototype.next=function(e){if(!this.isStopped&&this._next){var t=this._parentSubscriber;w.useDeprecatedSynchronousErrorHandling&&t.syncErrorThrowable?this.__tryOrSetError(t,this._next,e)&&this.unsubscribe():this.__tryOrUnsub(this._next,e)}},t.prototype.error=function(e){if(!this.isStopped){var t=this._parentSubscriber,r=w.useDeprecatedSynchronousErrorHandling;if(this._error)r&&t.syncErrorThrowable?(this.__tryOrSetError(t,this._error,e),this.unsubscribe()):(this.__tryOrUnsub(this._error,e),this.unsubscribe());else if(t.syncErrorThrowable)r?(t.syncErrorValue=e,t.syncErrorThrown=!0):k(e),this.unsubscribe();else{if(this.unsubscribe(),r)throw e;k(e)}}},t.prototype.complete=function(){var e=this;if(!this.isStopped){var t=this._parentSubscriber;if(this._complete){var r=function(){return e._complete.call(e._context)};w.useDeprecatedSynchronousErrorHandling&&t.syncErrorThrowable?(this.__tryOrSetError(t,r),this.unsubscribe()):(this.__tryOrUnsub(r),this.unsubscribe())}else this.unsubscribe()}},t.prototype.__tryOrUnsub=function(e,t){try{e.call(this._context,t)}catch(e){if(this.unsubscribe(),w.useDeprecatedSynchronousErrorHandling)throw e;k(e)}},t.prototype.__tryOrSetError=function(e,t,r){if(!w.useDeprecatedSynchronousErrorHandling)throw new Error(\"bad call\");try{t.call(this._context,r)}catch(t){return w.useDeprecatedSynchronousErrorHandling?(e.syncErrorValue=t,e.syncErrorThrown=!0,!0):(k(t),!0)}return!1},t.prototype._unsubscribe=function(){var e=this._parentSubscriber;this._context=null,this._parentSubscriber=null,e.unsubscribe()},t}(j);function C(e,t){return function(r){return r.lift(new T(e,t))}}var T=function(){function e(e,t){this.predicate=e,this.thisArg=t}return e.prototype.call=function(e,t){return t.subscribe(new L(e,this.predicate,this.thisArg))},e}(),L=function(e){function t(t,r,n){var i=e.call(this,t)||this;return i.predicate=r,i.thisArg=n,i.count=0,i}return v(t,e),t.prototype._next=function(e){var t;try{t=this.predicate.call(this.thisArg,e,this.count++)}catch(e){return void this.destination.error(e)}t&&this.destination.next(e)},t}(j);function D(){return Error.call(this),this.message=\"argument out of range\",this.name=\"ArgumentOutOfRangeError\",this}D.prototype=Object.create(Error.prototype);var I=D,B=\"function\"==typeof Symbol&&Symbol.observable||\"@@observable\";function H(){}function N(e){return e?1===e.length?e[0]:function(t){return e.reduce((function(e,t){return t(e)}),t)}:H}var F=function(){function e(e){this._isScalar=!1,e&&(this._subscribe=e)}return e.prototype.lift=function(t){var r=new e;return r.source=this,r.operator=t,r},e.prototype.subscribe=function(e,t,r){var n=this.operator,i=function(e,t,r){if(e){if(e instanceof j)return e;if(e[E])return e[E]()}return e||t||r?new j(e,t,r):new j(A)}(e,t,r);if(n?i.add(n.call(i,this.source)):i.add(this.source||w.useDeprecatedSynchronousErrorHandling&&!i.syncErrorThrowable?this._subscribe(i):this._trySubscribe(i)),w.useDeprecatedSynchronousErrorHandling&&i.syncErrorThrowable&&(i.syncErrorThrowable=!1,i.syncErrorThrown))throw i.syncErrorValue;return i},e.prototype._trySubscribe=function(e){try{return this._subscribe(e)}catch(t){w.useDeprecatedSynchronousErrorHandling&&(e.syncErrorThrown=!0,e.syncErrorValue=t),function(e){for(;e;){var t=e,r=t.closed,n=t.destination,i=t.isStopped;if(r||i)return!1;e=n&&n instanceof j?n:null}return!0}(e)?e.error(t):console.warn(t)}},e.prototype.forEach=function(e,t){var r=this;return new(t=U(t))((function(t,n){var i;i=r.subscribe((function(t){try{e(t)}catch(e){n(e),i&&i.unsubscribe()}}),n,t)}))},e.prototype._subscribe=function(e){var t=this.source;return t&&t.subscribe(e)},e.prototype[B]=function(){return this},e.prototype.pipe=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];return 0===e.length?this:N(e)(this)},e.prototype.toPromise=function(e){var t=this;return new(e=U(e))((function(e,r){var n;t.subscribe((function(e){return n=e}),(function(e){return r(e)}),(function(){return e(n)}))}))},e.create=function(t){return new e(t)},e}();function U(e){if(e||(e=w.Promise||Promise),!e)throw new Error(\"no Promise impl found\");return e}var V=new F((function(e){return e.complete()}));function G(e){return function(t){return 0===e?r?function(e){return new F((function(t){return e.schedule((function(){return t.complete()}))}))}(r):V:t.lift(new J(e));var r}}var J=function(){function e(e){if(this.total=e,this.total<0)throw new I}return e.prototype.call=function(e,t){return t.subscribe(new z(e,this.total))},e}(),z=function(e){function t(t,r){var n=e.call(this,t)||this;return n.total=r,n.count=0,n}return v(t,e),t.prototype._next=function(e){var t=this.total,r=++this.count;r<=t&&(this.destination.next(e),r===t&&(this.destination.complete(),this.unsubscribe()))},t}(j);function W(e){return void 0===e&&(e=null),function(t){return t.lift(new Y(e))}}var Y=function(){function e(e){this.defaultValue=e}return e.prototype.call=function(e,t){return t.subscribe(new K(e,this.defaultValue))},e}(),K=function(e){function t(t,r){var n=e.call(this,t)||this;return n.defaultValue=r,n.isEmpty=!0,n}return v(t,e),t.prototype._next=function(e){this.isEmpty=!1,this.destination.next(e)},t.prototype._complete=function(){this.isEmpty&&this.destination.next(this.defaultValue),this.destination.complete()},t}(j);function $(e){return void 0===e&&(e=Z),function(t){return t.lift(new Q(e))}}var Q=function(){function e(e){this.errorFactory=e}return e.prototype.call=function(e,t){return t.subscribe(new X(e,this.errorFactory))},e}(),X=function(e){function t(t,r){var n=e.call(this,t)||this;return n.errorFactory=r,n.hasValue=!1,n}return v(t,e),t.prototype._next=function(e){this.hasValue=!0,this.destination.next(e)},t.prototype._complete=function(){if(this.hasValue)return this.destination.complete();var e=void 0;try{e=this.errorFactory()}catch(t){e=t}this.destination.error(e)},t}(j);function Z(){return new _}function ee(e){return e}function te(e,t){var r=arguments.length>=2;return function(n){return n.pipe(e?C((function(t,r){return e(t,r,n)})):ee,G(1),r?W(t):$((function(){return new _})))}}function re(){return Error.call(this),this.message=\"object unsubscribed\",this.name=\"ObjectUnsubscribedError\",this}re.prototype=Object.create(Error.prototype);var ne=re,ie=function(e){function t(t,r){var n=e.call(this)||this;return n.subject=t,n.subscriber=r,n.closed=!1,n}return v(t,e),t.prototype.unsubscribe=function(){if(!this.closed){this.closed=!0;var e=this.subject,t=e.observers;if(this.subject=null,t&&0!==t.length&&!e.isStopped&&!e.closed){var r=t.indexOf(this.subscriber);-1!==r&&t.splice(r,1)}}},t}(O),se=function(e){function t(t){var r=e.call(this,t)||this;return r.destination=t,r}return v(t,e),t}(j),oe=function(e){function t(){var t=e.call(this)||this;return t.observers=[],t.closed=!1,t.isStopped=!1,t.hasError=!1,t.thrownError=null,t}return v(t,e),t.prototype[E]=function(){return new se(this)},t.prototype.lift=function(e){var t=new ue(this,this);return t.operator=e,t},t.prototype.next=function(e){if(this.closed)throw new ne;if(!this.isStopped)for(var t=this.observers,r=t.length,n=t.slice(),i=0;i<r;i++)n[i].next(e)},t.prototype.error=function(e){if(this.closed)throw new ne;this.hasError=!0,this.thrownError=e,this.isStopped=!0;for(var t=this.observers,r=t.length,n=t.slice(),i=0;i<r;i++)n[i].error(e);this.observers.length=0},t.prototype.complete=function(){if(this.closed)throw new ne;this.isStopped=!0;for(var e=this.observers,t=e.length,r=e.slice(),n=0;n<t;n++)r[n].complete();this.observers.length=0},t.prototype.unsubscribe=function(){this.isStopped=!0,this.closed=!0,this.observers=null},t.prototype._trySubscribe=function(t){if(this.closed)throw new ne;return e.prototype._trySubscribe.call(this,t)},t.prototype._subscribe=function(e){if(this.closed)throw new ne;return this.hasError?(e.error(this.thrownError),O.EMPTY):this.isStopped?(e.complete(),O.EMPTY):(this.observers.push(e),new ie(this,e))},t.prototype.asObservable=function(){var e=new F;return e.source=this,e},t.create=function(e,t){return new ue(e,t)},t}(F),ue=function(e){function t(t,r){var n=e.call(this)||this;return n.destination=t,n.source=r,n}return v(t,e),t.prototype.next=function(e){var t=this.destination;t&&t.next&&t.next(e)},t.prototype.error=function(e){var t=this.destination;t&&t.error&&this.destination.error(e)},t.prototype.complete=function(){var e=this.destination;e&&e.complete&&this.destination.complete()},t.prototype._subscribe=function(e){return this.source?this.source.subscribe(e):O.EMPTY},t}(oe);function ce(){return function(e){return e.lift(new ae(e))}}var ae=function(){function e(e){this.connectable=e}return e.prototype.call=function(e,t){var r=this.connectable;r._refCount++;var n=new pe(e,r),i=t.subscribe(n);return n.closed||(n.connection=r.connect()),i},e}(),pe=function(e){function t(t,r){var n=e.call(this,t)||this;return n.connectable=r,n}return v(t,e),t.prototype._unsubscribe=function(){var e=this.connectable;if(e){this.connectable=null;var t=e._refCount;if(t<=0)this.connection=null;else if(e._refCount=t-1,t>1)this.connection=null;else{var r=this.connection,n=e._connection;this.connection=null,!n||r&&n!==r||n.unsubscribe()}}else this.connection=null},t}(j),de=function(e){function t(t,r){var n=e.call(this)||this;return n.source=t,n.subjectFactory=r,n._refCount=0,n._isComplete=!1,n}return v(t,e),t.prototype._subscribe=function(e){return this.getSubject().subscribe(e)},t.prototype.getSubject=function(){var e=this._subject;return e&&!e.isStopped||(this._subject=this.subjectFactory()),this._subject},t.prototype.connect=function(){var e=this._connection;return e||(this._isComplete=!1,(e=this._connection=new O).add(this.source.subscribe(new ye(this.getSubject(),this))),e.closed&&(this._connection=null,e=O.EMPTY)),e},t.prototype.refCount=function(){return ce()(this)},t}(F).prototype,he={operator:{value:null},_refCount:{value:0,writable:!0},_subject:{value:null,writable:!0},_connection:{value:null,writable:!0},_subscribe:{value:de._subscribe},_isComplete:{value:de._isComplete,writable:!0},getSubject:{value:de.getSubject},connect:{value:de.connect},refCount:{value:de.refCount}},ye=function(e){function t(t,r){var n=e.call(this,t)||this;return n.connectable=r,n}return v(t,e),t.prototype._error=function(t){this._unsubscribe(),e.prototype._error.call(this,t)},t.prototype._complete=function(){this.connectable._isComplete=!0,this._unsubscribe(),e.prototype._complete.call(this)},t.prototype._unsubscribe=function(){var e=this.connectable;if(e){this.connectable=null;var t=e._connection;e._refCount=0,e._subject=null,e._connection=null,t&&t.unsubscribe()}},t}(se);function le(){return new oe}function ge(){return function(e){return ce()((t=le,function(e){var r;r=\"function\"==typeof t?t:function(){return t};var n=Object.create(e,he);return n.source=e,n.subjectFactory=r,n})(e));var t}}function fe(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}var _e=function(){function e(){o(this,e)}return c(e,[{key:\"accountClosure\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={account_closure:{required:1,type:\"numeric\"},passthrough:{},reason:{required:1,type:\"string\"},req_id:{type:\"numeric\"}},r={method:\"account_closure\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"accountSecurity\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={account_security:{required:1,type:\"numeric\"},otp:{type:\"string\"},passthrough:{},req_id:{type:\"numeric\"},totp_action:{type:\"string\"}},r={method:\"account_security\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"accountStatistics\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={account_statistics:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"account_statistics\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"activeSymbols\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={active_symbols:{required:1,type:\"string\"},landing_company:{type:\"string\"},passthrough:{},product_type:{type:\"string\"},req_id:{type:\"numeric\"}},r={method:\"active_symbols\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"affiliateAccountAdd\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={address_city:{required:1,type:\"string\"},address_line_1:{required:1,type:\"string\"},address_line_2:{type:\"string\"},address_postcode:{required:1,type:\"string\"},address_state:{required:1,type:\"string\"},affiliate_account_add:{required:1,type:\"numeric\"},country:{required:1,type:\"string\"},first_name:{required:1,type:\"string\"},last_name:{required:1,type:\"string\"},non_pep_declaration:{required:1,type:\"numeric\"},passthrough:{},password:{required:1,type:\"string\"},phone:{required:1,type:\"string\"},req_id:{type:\"numeric\"},tnc_accepted:{required:1,type:\"numeric\"},username:{required:1,type:\"string\"}},r={method:\"affiliate_account_add\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"apiToken\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={api_token:{required:1,type:\"numeric\"},delete_token:{type:\"string\"},new_token:{type:\"string\"},new_token_scopes:{},passthrough:{},req_id:{type:\"numeric\"},valid_for_current_ip_only:{type:\"numeric\"}},r={method:\"api_token\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"appDelete\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={app_delete:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"app_delete\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"appGet\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={app_get:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"app_get\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"appList\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={app_list:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"app_list\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"appMarkupDetails\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={app_id:{type:\"numeric\"},app_markup_details:{required:1,type:\"numeric\"},client_loginid:{type:\"string\"},date_from:{required:1,type:\"string\"},date_to:{required:1,type:\"string\"},description:{type:\"numeric\"},limit:{type:\"numeric\"},offset:{type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"},sort:{type:\"string\"},sort_fields:{}},r={method:\"app_markup_details\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"appRegister\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={app_markup_percentage:{type:\"numeric\"},app_register:{required:1,type:\"numeric\"},appstore:{type:\"string\"},github:{type:\"string\"},googleplay:{type:\"string\"},homepage:{type:\"string\"},name:{required:1,type:\"string\"},passthrough:{},redirect_uri:{type:\"string\"},req_id:{type:\"numeric\"},scopes:{required:1},verification_uri:{type:\"string\"}},r={method:\"app_register\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"appUpdate\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={app_markup_percentage:{type:\"numeric\"},app_update:{required:1,type:\"numeric\"},appstore:{type:\"string\"},github:{type:\"string\"},googleplay:{type:\"string\"},homepage:{type:\"string\"},name:{required:1,type:\"string\"},passthrough:{},redirect_uri:{type:\"string\"},req_id:{type:\"numeric\"},scopes:{required:1},verification_uri:{type:\"string\"}},r={method:\"app_update\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"assetIndex\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={asset_index:{required:1,type:\"numeric\"},landing_company:{type:\"string\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"asset_index\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"authorize\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={add_to_login_history:{type:\"numeric\"},authorize:{required:1,type:\"string\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"authorize\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"balance\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={account:{type:\"string\"},balance:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"},subscribe:{type:\"numeric\"}},r={method:\"balance\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"buy\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={buy:{required:1,type:\"string\"},parameters:{amount:{type:\"numeric\"},app_markup_percentage:{type:\"numeric\"},barrier:{type:\"string\"},barrier2:{type:\"string\"},barrier_range:{type:\"string\"},basis:{type:\"string\"},cancellation:{type:\"string\"},contract_type:{required:1,type:\"string\"},currency:{required:1,type:\"string\"},date_expiry:{type:\"numeric\"},date_start:{type:\"numeric\"},duration:{type:\"numeric\"},duration_unit:{type:\"string\"},limit_order:{stop_loss:{type:\"numeric\"},take_profit:{type:\"numeric\"}},multiplier:{type:\"numeric\"},product_type:{type:\"string\"},selected_tick:{type:\"numeric\"},symbol:{required:1,type:\"string\"},trading_period_start:{type:\"numeric\"}},passthrough:{},price:{required:1,type:\"numeric\"},req_id:{type:\"numeric\"},subscribe:{type:\"numeric\"}},r={method:\"buy\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"buyContractForMultipleAccounts\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={buy_contract_for_multiple_accounts:{required:1,type:\"string\"},parameters:{amount:{type:\"numeric\"},app_markup_percentage:{type:\"numeric\"},barrier:{type:\"string\"},barrier2:{type:\"string\"},basis:{type:\"string\"},contract_type:{required:1,type:\"string\"},currency:{required:1,type:\"string\"},date_expiry:{type:\"numeric\"},date_start:{type:\"numeric\"},duration:{type:\"numeric\"},duration_unit:{type:\"string\"},multiplier:{type:\"numeric\"},selected_tick:{type:\"numeric\"},symbol:{required:1,type:\"string\"}},passthrough:{},price:{required:1,type:\"numeric\"},req_id:{type:\"numeric\"},tokens:{required:1}},r={method:\"buy_contract_for_multiple_accounts\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"cancel\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={cancel:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"cancel\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"cashier\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={address:{type:\"string\"},amount:{type:\"numeric\"},cashier:{required:1,type:\"string\"},dry_run:{type:\"numeric\"},passthrough:{},provider:{type:\"string\"},req_id:{type:\"numeric\"},type:{type:\"string\"},verification_code:{type:\"string\"}},r={method:\"cashier\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"cashierPayments\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={cashier_payments:{required:1,type:\"numeric\"},passthrough:{},provider:{type:\"string\"},req_id:{type:\"numeric\"},subscribe:{type:\"numeric\"},transaction_type:{type:\"string\"}},r={method:\"cashier_payments\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"cashierWithdrawalCancel\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={cashier_withdrawal_cancel:{required:1,type:\"numeric\"},id:{required:1,type:\"string\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"cashier_withdrawal_cancel\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"changeEmail\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={change_email:{required:1,type:\"string\"},new_email:{required:1,type:\"string\"},new_password:{type:\"string\"},passthrough:{},req_id:{type:\"numeric\"},verification_code:{required:1,type:\"string\"}},r={method:\"change_email\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"changePassword\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={change_password:{required:1,type:\"numeric\"},new_password:{required:1,type:\"string\"},old_password:{required:1,type:\"string\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"change_password\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"contractUpdate\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={contract_id:{required:1,type:\"numeric\"},contract_update:{required:1,type:\"numeric\"},limit_order:{stop_loss:{},take_profit:{}},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"contract_update\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"contractUpdateHistory\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={contract_id:{required:1,type:\"numeric\"},contract_update_history:{required:1,type:\"numeric\"},limit:{type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"contract_update_history\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"contractsFor\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={contracts_for:{required:1,type:\"string\"},currency:{type:\"string\"},landing_company:{type:\"string\"},passthrough:{},product_type:{type:\"string\"},req_id:{type:\"numeric\"}},r={method:\"contracts_for\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"copyStart\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={assets:{},copy_start:{required:1,type:\"string\"},max_trade_stake:{type:\"numeric\"},min_trade_stake:{type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"},trade_types:{}},r={method:\"copy_start\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"copyStop\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={copy_stop:{required:1,type:\"string\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"copy_stop\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"copytradingList\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={copytrading_list:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"copytrading_list\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"copytradingStatistics\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={copytrading_statistics:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"},trader_id:{required:1,type:\"string\"}},r={method:\"copytrading_statistics\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"cryptoConfig\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={crypto_config:{required:1,type:\"numeric\"},currency_code:{type:\"string\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"crypto_config\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"documentUpload\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={document_format:{required:1,type:\"string\"},document_id:{type:\"string\"},document_issuing_country:{type:\"string\"},document_type:{required:1,type:\"string\"},document_upload:{required:1,type:\"numeric\"},expected_checksum:{required:1,type:\"string\"},expiration_date:{type:\"string\"},file_size:{required:1,type:\"numeric\"},lifetime_valid:{type:\"numeric\"},page_type:{type:\"string\"},passthrough:{},proof_of_ownership:{details:{required:1},id:{required:1,type:\"numeric\"}},req_id:{type:\"numeric\"}},r={method:\"document_upload\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"economicCalendar\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={currency:{type:\"string\"},economic_calendar:{required:1,type:\"numeric\"},end_date:{type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"},start_date:{type:\"numeric\"}},r={method:\"economic_calendar\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"exchangeRates\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={base_currency:{required:1,type:\"string\"},exchange_rates:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"},subscribe:{type:\"numeric\"},target_currency:{type:\"string\"}},r={method:\"exchange_rates\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"forget\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={forget:{required:1,type:\"string\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"forget\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"forgetAll\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={forget_all:{required:1},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"forget_all\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"getAccountStatus\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={get_account_status:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"get_account_status\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"getAccountTypes\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={get_account_types:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"get_account_types\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"getAvailableAccountsToTransfer\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={get_available_accounts_to_transfer:{required:1,type:\"numeric\"},loginid:{required:1,type:\"string\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"get_available_accounts_to_transfer\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"getFinancialAssessment\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={get_financial_assessment:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"get_financial_assessment\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"getLimits\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={get_limits:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"get_limits\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"getSelfExclusion\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={get_self_exclusion:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"get_self_exclusion\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"getSettings\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={get_settings:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"get_settings\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"identityVerificationDocumentAdd\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={document_number:{required:1,type:\"string\"},document_type:{required:1,type:\"string\"},identity_verification_document_add:{required:1,type:\"numeric\"},issuing_country:{required:1,type:\"string\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"identity_verification_document_add\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"landingCompany\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={landing_company:{required:1,type:\"string\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"landing_company\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"landingCompanyDetails\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={landing_company_details:{required:1,type:\"string\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"landing_company_details\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"linkWallet\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={client_id:{required:1,type:\"string\"},link_wallet:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"},wallet_id:{required:1,type:\"string\"}},r={method:\"link_wallet\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"loginHistory\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={limit:{type:\"numeric\"},login_history:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"login_history\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"logout\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={logout:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"logout\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"mt5Deposit\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={amount:{type:\"numeric\"},from_binary:{type:\"string\"},mt5_deposit:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"},to_mt5:{required:1,type:\"string\"}},r={method:\"mt5_deposit\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"mt5GetSettings\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={login:{required:1,type:\"string\"},mt5_get_settings:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"mt5_get_settings\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"mt5LoginList\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={mt5_login_list:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"mt5_login_list\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"mt5NewAccount\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={account_type:{required:1,type:\"string\"},address:{type:\"string\"},city:{type:\"string\"},company:{type:\"string\"},country:{type:\"string\"},currency:{type:\"string\"},dry_run:{type:\"numeric\"},email:{required:1,type:\"string\"},investPassword:{type:\"string\"},leverage:{required:1,type:\"numeric\"},mainPassword:{required:1,type:\"string\"},mt5_account_category:{type:\"string\"},mt5_account_type:{type:\"string\"},mt5_new_account:{required:1,type:\"numeric\"},name:{required:1,type:\"string\"},passthrough:{},phone:{type:\"string\"},phonePassword:{type:\"string\"},req_id:{type:\"numeric\"},server:{},state:{type:\"string\"},zipCode:{type:\"string\"}},r={method:\"mt5_new_account\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"mt5PasswordChange\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={login:{required:1,type:\"string\"},mt5_password_change:{required:1,type:\"numeric\"},new_password:{required:1,type:\"string\"},old_password:{required:1,type:\"string\"},passthrough:{},password_type:{type:\"string\"},req_id:{type:\"numeric\"}},r={method:\"mt5_password_change\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"mt5PasswordCheck\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={login:{required:1,type:\"string\"},mt5_password_check:{required:1,type:\"numeric\"},passthrough:{},password:{required:1,type:\"string\"},password_type:{type:\"string\"},req_id:{type:\"numeric\"}},r={method:\"mt5_password_check\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"mt5PasswordReset\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={login:{required:1,type:\"string\"},mt5_password_reset:{required:1,type:\"numeric\"},new_password:{required:1,type:\"string\"},passthrough:{},password_type:{type:\"string\"},req_id:{type:\"numeric\"},verification_code:{required:1,type:\"string\"}},r={method:\"mt5_password_reset\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"mt5Withdrawal\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={amount:{required:1,type:\"numeric\"},from_mt5:{required:1,type:\"string\"},mt5_withdrawal:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"},to_binary:{required:1,type:\"string\"}},r={method:\"mt5_withdrawal\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"newAccountMaltainvest\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={accept_risk:{required:1,type:\"numeric\"},account_opening_reason:{type:\"string\"},account_turnover:{type:\"string\"},address_city:{required:1,type:\"string\"},address_line_1:{required:1,type:\"string\"},address_line_2:{type:\"string\"},address_postcode:{type:\"string\"},address_state:{type:\"string\"},affiliate_token:{type:\"string\"},binary_options_trading_experience:{type:\"string\"},binary_options_trading_frequency:{type:\"string\"},cfd_trading_experience:{type:\"string\"},cfd_trading_frequency:{type:\"string\"},citizen:{type:\"string\"},client_type:{type:\"string\"},currency:{type:\"string\"},date_of_birth:{required:1,type:\"string\"},education_level:{required:1,type:\"string\"},employment_industry:{required:1,type:\"string\"},employment_status:{type:\"string\"},estimated_worth:{required:1,type:\"string\"},first_name:{required:1,type:\"string\"},forex_trading_experience:{type:\"string\"},forex_trading_frequency:{type:\"string\"},income_source:{required:1,type:\"string\"},last_name:{required:1,type:\"string\"},net_income:{required:1,type:\"string\"},new_account_maltainvest:{required:1,type:\"numeric\"},non_pep_declaration:{type:\"numeric\"},occupation:{required:1,type:\"string\"},other_instruments_trading_experience:{type:\"string\"},other_instruments_trading_frequency:{type:\"string\"},passthrough:{},phone:{},place_of_birth:{type:\"string\"},req_id:{type:\"numeric\"},residence:{required:1,type:\"string\"},salutation:{required:1,type:\"string\"},secret_answer:{type:\"string\"},secret_question:{type:\"string\"},source_of_wealth:{type:\"string\"},tax_identification_number:{required:1,type:\"string\"},tax_residence:{required:1,type:\"string\"}},r={method:\"new_account_maltainvest\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"newAccountReal\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={account_opening_reason:{type:\"string\"},account_turnover:{type:\"string\"},address_city:{type:\"string\"},address_line_1:{type:\"string\"},address_line_2:{type:\"string\"},address_postcode:{type:\"string\"},address_state:{type:\"string\"},affiliate_token:{type:\"string\"},citizen:{},client_type:{type:\"string\"},currency:{type:\"string\"},date_of_birth:{type:\"string\"},first_name:{type:\"string\"},last_name:{type:\"string\"},new_account_real:{required:1,type:\"numeric\"},non_pep_declaration:{type:\"numeric\"},passthrough:{},phone:{},place_of_birth:{type:\"string\"},req_id:{type:\"numeric\"},residence:{type:\"string\"},salutation:{type:\"string\"},secret_answer:{type:\"string\"},secret_question:{type:\"string\"},tax_identification_number:{type:\"string\"},tax_residence:{type:\"string\"}},r={method:\"new_account_real\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"newAccountVirtual\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={affiliate_token:{type:\"string\"},client_password:{type:\"string\"},date_first_contact:{type:\"string\"},email_consent:{type:\"numeric\"},gclid_url:{type:\"string\"},new_account_virtual:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"},residence:{type:\"string\"},signup_device:{type:\"string\"},type:{type:\"string\"},utm_ad_id:{},utm_adgroup_id:{},utm_adrollclk_id:{},utm_campaign:{},utm_campaign_id:{},utm_content:{},utm_fbcl_id:{},utm_gl_client_id:{},utm_medium:{},utm_msclk_id:{},utm_source:{},utm_term:{},verification_code:{type:\"string\"}},r={method:\"new_account_virtual\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"newAccountWallet\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={address_city:{type:\"string\"},address_line_1:{type:\"string\"},address_line_2:{type:\"string\"},address_postcode:{type:\"string\"},address_state:{type:\"string\"},currency:{required:1,type:\"string\"},date_of_birth:{type:\"string\"},first_name:{type:\"string\"},last_name:{type:\"string\"},new_account_wallet:{required:1,type:\"numeric\"},non_pep_declaration:{type:\"numeric\"},passthrough:{},payment_method:{required:1,type:\"string\"},phone:{type:\"string\"},req_id:{type:\"numeric\"}},r={method:\"new_account_wallet\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"notificationEvent\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={args:{documents:{}},category:{required:1,type:\"string\"},event:{required:1,type:\"string\"},notification_event:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"notification_event\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"oauthApps\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={oauth_apps:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"oauth_apps\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"p2pAdvertCreate\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={amount:{required:1,type:\"numeric\"},contact_info:{type:\"string\"},description:{type:\"string\"},local_currency:{type:\"string\"},max_order_amount:{required:1,type:\"numeric\"},min_order_amount:{required:1,type:\"numeric\"},p2p_advert_create:{required:1,type:\"numeric\"},passthrough:{},payment_info:{type:\"string\"},payment_method:{type:\"string\"},payment_method_ids:{},payment_method_names:{},rate:{required:1,type:\"numeric\"},rate_type:{type:\"string\"},req_id:{type:\"numeric\"},type:{required:1,type:\"string\"}},r={method:\"p2p_advert_create\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"p2pAdvertInfo\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={id:{type:\"string\"},p2p_advert_info:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"},subscribe:{type:\"numeric\"},use_client_limits:{type:\"numeric\"}},r={method:\"p2p_advert_info\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"p2pAdvertList\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={advertiser_id:{type:\"string\"},advertiser_name:{type:\"string\"},amount:{type:\"numeric\"},counterparty_type:{type:\"string\"},favourites_only:{type:\"numeric\"},limit:{type:\"numeric\"},local_currency:{type:\"string\"},offset:{type:\"numeric\"},p2p_advert_list:{required:1,type:\"numeric\"},passthrough:{},payment_method:{},req_id:{type:\"numeric\"},sort_by:{type:\"string\"},use_client_limits:{type:\"numeric\"}},r={method:\"p2p_advert_list\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"p2pAdvertUpdate\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={contact_info:{type:\"string\"},delete:{type:\"numeric\"},description:{type:\"string\"},id:{required:1,type:\"string\"},is_active:{type:\"numeric\"},local_currency:{type:\"string\"},max_order_amount:{type:\"numeric\"},min_order_amount:{type:\"numeric\"},p2p_advert_update:{required:1,type:\"numeric\"},passthrough:{},payment_info:{type:\"string\"},payment_method_ids:{},payment_method_names:{},rate:{type:\"numeric\"},rate_type:{type:\"string\"},remaining_amount:{type:\"numeric\"},req_id:{type:\"numeric\"}},r={method:\"p2p_advert_update\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"p2pAdvertiserAdverts\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={limit:{type:\"numeric\"},offset:{type:\"numeric\"},p2p_advertiser_adverts:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"p2p_advertiser_adverts\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"p2pAdvertiserCreate\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={contact_info:{type:\"string\"},default_advert_description:{type:\"string\"},name:{required:1,type:\"string\"},p2p_advertiser_create:{required:1,type:\"numeric\"},passthrough:{},payment_info:{type:\"string\"},req_id:{type:\"numeric\"},subscribe:{type:\"numeric\"}},r={method:\"p2p_advertiser_create\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"p2pAdvertiserInfo\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={id:{type:\"string\"},p2p_advertiser_info:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"},subscribe:{type:\"numeric\"}},r={method:\"p2p_advertiser_info\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"p2pAdvertiserPaymentMethods\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={create:{},delete:{},p2p_advertiser_payment_methods:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"},update:{}},r={method:\"p2p_advertiser_payment_methods\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"p2pAdvertiserRelations\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={add_blocked:{},add_favourites:{},p2p_advertiser_relations:{required:1,type:\"numeric\"},passthrough:{},remove_blocked:{},remove_favourites:{},req_id:{type:\"numeric\"}},r={method:\"p2p_advertiser_relations\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"p2pAdvertiserUpdate\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={contact_info:{type:\"string\"},default_advert_description:{type:\"string\"},is_listed:{type:\"numeric\"},p2p_advertiser_update:{required:1,type:\"numeric\"},passthrough:{},payment_info:{type:\"string\"},req_id:{type:\"numeric\"},show_name:{type:\"numeric\"}},r={method:\"p2p_advertiser_update\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"p2pChatCreate\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={order_id:{required:1,type:\"string\"},p2p_chat_create:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"p2p_chat_create\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"p2pOrderCancel\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={id:{required:1,type:\"string\"},p2p_order_cancel:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"p2p_order_cancel\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"p2pOrderConfirm\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={id:{required:1,type:\"string\"},p2p_order_confirm:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"p2p_order_confirm\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"p2pOrderCreate\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={advert_id:{required:1,type:\"string\"},amount:{required:1,type:\"numeric\"},contact_info:{type:\"string\"},p2p_order_create:{required:1,type:\"numeric\"},passthrough:{},payment_info:{type:\"string\"},payment_method_ids:{},rate:{type:\"numeric\"},req_id:{type:\"numeric\"},subscribe:{type:\"numeric\"}},r={method:\"p2p_order_create\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"p2pOrderDispute\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={dispute_reason:{required:1,type:\"string\"},id:{required:1,type:\"string\"},p2p_order_dispute:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"p2p_order_dispute\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"p2pOrderInfo\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={id:{required:1,type:\"string\"},p2p_order_info:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"},subscribe:{type:\"numeric\"}},r={method:\"p2p_order_info\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"p2pOrderList\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={active:{type:\"numeric\"},advert_id:{type:\"string\"},limit:{type:\"numeric\"},offset:{type:\"numeric\"},p2p_order_list:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"},subscribe:{type:\"numeric\"}},r={method:\"p2p_order_list\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"p2pOrderReview\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={order_id:{required:1,type:\"string\"},p2p_order_review:{required:1,type:\"numeric\"},passthrough:{},rating:{required:1,type:\"numeric\"},recommended:{},req_id:{type:\"numeric\"}},r={method:\"p2p_order_review\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"p2pPaymentMethods\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={p2p_payment_methods:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"p2p_payment_methods\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"p2pPing\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={p2p_ping:{required:1,type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"}},r={method:\"p2p_ping\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"paymentMethods\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={country:{type:\"string\"},passthrough:{},payment_methods:{required:1,type:\"numeric\"},req_id:{type:\"numeric\"}},r={method:\"payment_methods\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"paymentagentCreate\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={affiliate_id:{type:\"string\"},code_of_conduct_approval:{required:1,type:\"numeric\"},commission_deposit:{required:1,type:\"numeric\"},commission_withdrawal:{required:1,type:\"numeric\"},email:{required:1,type:\"string\"},information:{required:1,type:\"string\"},passthrough:{},payment_agent_name:{required:1,type:\"string\"},paymentagent_create:{required:1,type:\"numeric\"},phone_numbers:{},req_id:{type:\"numeric\"},supported_payment_methods:{required:1},urls:{required:1}},r={method:\"paymentagent_create\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"paymentagentDetails\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={passthrough:{},paymentagent_details:{required:1,type:\"numeric\"},req_id:{type:\"numeric\"}},r={method:\"paymentagent_details\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"paymentagentList\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={currency:{type:\"string\"},passthrough:{},paymentagent_list:{required:1,type:\"string\"},req_id:{type:\"numeric\"}},r={method:\"paymentagent_list\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"paymentagentTransfer\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={amount:{required:1,type:\"numeric\"},currency:{required:1,type:\"string\"},description:{type:\"string\"},dry_run:{type:\"numeric\"},passthrough:{},paymentagent_transfer:{required:1,type:\"numeric\"},req_id:{type:\"numeric\"},transfer_to:{required:1,type:\"string\"}},r={method:\"paymentagent_transfer\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"paymentagentWithdraw\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={amount:{required:1,type:\"numeric\"},currency:{required:1,type:\"string\"},description:{type:\"string\"},dry_run:{type:\"numeric\"},passthrough:{},paymentagent_loginid:{required:1,type:\"string\"},paymentagent_withdraw:{required:1,type:\"numeric\"},req_id:{type:\"numeric\"},verification_code:{required:1,type:\"string\"}},r={method:\"paymentagent_withdraw\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"payoutCurrencies\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={passthrough:{},payout_currencies:{required:1,type:\"numeric\"},req_id:{type:\"numeric\"}},r={method:\"payout_currencies\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"ping\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={passthrough:{},ping:{required:1,type:\"numeric\"},req_id:{type:\"numeric\"}},r={method:\"ping\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"portfolio\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={contract_type:{},passthrough:{},portfolio:{required:1,type:\"numeric\"},req_id:{type:\"numeric\"}},r={method:\"portfolio\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"profitTable\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={contract_type:{},date_from:{type:\"string\"},date_to:{type:\"string\"},description:{type:\"numeric\"},limit:{type:\"numeric\"},offset:{type:\"numeric\"},passthrough:{},profit_table:{required:1,type:\"numeric\"},req_id:{type:\"numeric\"},sort:{type:\"string\"}},r={method:\"profit_table\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"proposal\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={amount:{type:\"numeric\"},barrier:{type:\"string\"},barrier2:{type:\"string\"},barrier_range:{type:\"string\"},basis:{type:\"string\"},cancellation:{type:\"string\"},contract_type:{required:1,type:\"string\"},currency:{required:1,type:\"string\"},date_expiry:{type:\"numeric\"},date_start:{type:\"numeric\"},duration:{type:\"numeric\"},duration_unit:{type:\"string\"},limit_order:{stop_loss:{type:\"numeric\"},take_profit:{type:\"numeric\"}},multiplier:{type:\"numeric\"},passthrough:{},product_type:{type:\"string\"},proposal:{required:1,type:\"numeric\"},req_id:{type:\"numeric\"},selected_tick:{type:\"numeric\"},subscribe:{type:\"numeric\"},symbol:{required:1,type:\"string\"},trading_period_start:{type:\"numeric\"}},r={method:\"proposal\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"proposalOpenContract\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={contract_id:{type:\"numeric\"},passthrough:{},proposal_open_contract:{required:1,type:\"numeric\"},req_id:{type:\"numeric\"},subscribe:{type:\"numeric\"}},r={method:\"proposal_open_contract\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"realityCheck\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={passthrough:{},reality_check:{required:1,type:\"numeric\"},req_id:{type:\"numeric\"}},r={method:\"reality_check\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"requestReport\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={date_from:{required:1,type:\"numeric\"},date_to:{required:1,type:\"numeric\"},passthrough:{},report_type:{required:1,type:\"string\"},req_id:{type:\"numeric\"},request_report:{required:1,type:\"numeric\"}},r={method:\"request_report\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"resetPassword\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={date_of_birth:{type:\"string\"},new_password:{required:1,type:\"string\"},passthrough:{},req_id:{type:\"numeric\"},reset_password:{required:1,type:\"numeric\"},verification_code:{required:1,type:\"string\"}},r={method:\"reset_password\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"residenceList\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={passthrough:{},req_id:{type:\"numeric\"},residence_list:{required:1,type:\"numeric\"}},r={method:\"residence_list\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"revokeOauthApp\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={passthrough:{},req_id:{type:\"numeric\"},revoke_oauth_app:{required:1,type:\"numeric\"}},r={method:\"revoke_oauth_app\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"sell\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={passthrough:{},price:{required:1,type:\"numeric\"},req_id:{type:\"numeric\"},sell:{required:1,type:\"numeric\"}},r={method:\"sell\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"sellContractForMultipleAccounts\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={passthrough:{},price:{required:1,type:\"numeric\"},req_id:{type:\"numeric\"},sell_contract_for_multiple_accounts:{required:1,type:\"numeric\"},shortcode:{required:1,type:\"string\"},tokens:{required:1}},r={method:\"sell_contract_for_multiple_accounts\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"sellExpired\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={passthrough:{},req_id:{type:\"numeric\"},sell_expired:{required:1,type:\"numeric\"}},r={method:\"sell_expired\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"serviceToken\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={country:{type:\"string\"},passthrough:{},referrer:{type:\"string\"},req_id:{type:\"numeric\"},server:{type:\"string\"},service:{required:1},service_token:{required:1,type:\"numeric\"}},r={method:\"service_token\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"setAccountCurrency\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={passthrough:{},req_id:{type:\"numeric\"},set_account_currency:{required:1,type:\"string\"}},r={method:\"set_account_currency\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"setFinancialAssessment\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={account_turnover:{type:\"string\"},binary_options_trading_experience:{type:\"string\"},binary_options_trading_frequency:{type:\"string\"},cfd_trading_experience:{type:\"string\"},cfd_trading_frequency:{type:\"string\"},education_level:{required:1,type:\"string\"},employment_industry:{required:1,type:\"string\"},employment_status:{type:\"string\"},estimated_worth:{required:1,type:\"string\"},forex_trading_experience:{type:\"string\"},forex_trading_frequency:{type:\"string\"},income_source:{required:1,type:\"string\"},net_income:{required:1,type:\"string\"},occupation:{required:1,type:\"string\"},other_instruments_trading_experience:{type:\"string\"},other_instruments_trading_frequency:{type:\"string\"},passthrough:{},req_id:{type:\"numeric\"},set_financial_assessment:{required:1,type:\"numeric\"},source_of_wealth:{type:\"string\"}},r={method:\"set_financial_assessment\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"setSelfExclusion\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={exclude_until:{},max_30day_deposit:{},max_30day_losses:{},max_30day_turnover:{},max_7day_deposit:{},max_7day_losses:{},max_7day_turnover:{},max_balance:{},max_deposit:{},max_losses:{},max_open_bets:{},max_turnover:{},passthrough:{},req_id:{type:\"numeric\"},session_duration_limit:{},set_self_exclusion:{required:1,type:\"numeric\"},timeout_until:{}},r={method:\"set_self_exclusion\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"setSettings\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={account_opening_reason:{type:\"string\"},address_city:{type:\"string\"},address_line_1:{type:\"string\"},address_line_2:{},address_postcode:{type:\"string\"},address_state:{type:\"string\"},allow_copiers:{type:\"numeric\"},citizen:{},date_of_birth:{type:\"string\"},email_consent:{type:\"numeric\"},feature_flag:{wallet:{type:\"numeric\"}},first_name:{type:\"string\"},last_name:{type:\"string\"},non_pep_declaration:{type:\"numeric\"},passthrough:{},phone:{},place_of_birth:{type:\"string\"},preferred_language:{},req_id:{type:\"numeric\"},request_professional_status:{type:\"numeric\"},residence:{},salutation:{type:\"string\"},secret_answer:{type:\"string\"},secret_question:{type:\"string\"},set_settings:{required:1,type:\"numeric\"},tax_identification_number:{type:\"string\"},tax_residence:{type:\"string\"}},r={method:\"set_settings\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"statement\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={action_type:{type:\"string\"},date_from:{type:\"numeric\"},date_to:{type:\"numeric\"},description:{type:\"numeric\"},limit:{type:\"numeric\"},offset:{type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"},statement:{required:1,type:\"numeric\"}},r={method:\"statement\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"statesList\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={passthrough:{},req_id:{type:\"numeric\"},states_list:{required:1,type:\"string\"}},r={method:\"states_list\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"ticks\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={passthrough:{},req_id:{type:\"numeric\"},subscribe:{type:\"numeric\"},ticks:{required:1}},r={method:\"ticks\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"ticksHistory\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={adjust_start_time:{type:\"numeric\"},count:{type:\"numeric\"},end:{required:1,type:\"string\"},granularity:{type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"},start:{type:\"numeric\"},style:{type:\"string\"},subscribe:{type:\"numeric\"},ticks_history:{required:1,type:\"string\"}},r={method:\"ticks_history\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"time\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={passthrough:{},req_id:{type:\"numeric\"},time:{required:1,type:\"numeric\"}},r={method:\"time\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"tncApproval\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={affiliate_coc_agreement:{type:\"numeric\"},passthrough:{},req_id:{type:\"numeric\"},tnc_approval:{required:1,type:\"numeric\"},ukgc_funds_protection:{type:\"numeric\"}},r={method:\"tnc_approval\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"topupVirtual\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={passthrough:{},req_id:{type:\"numeric\"},topup_virtual:{required:1,type:\"numeric\"}},r={method:\"topup_virtual\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"tradingDurations\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={landing_company:{type:\"string\"},passthrough:{},req_id:{type:\"numeric\"},trading_durations:{required:1,type:\"numeric\"}},r={method:\"trading_durations\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"tradingPlatformAccounts\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={passthrough:{},platform:{required:1,type:\"string\"},req_id:{type:\"numeric\"},trading_platform_accounts:{required:1,type:\"numeric\"}},r={method:\"trading_platform_accounts\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"tradingPlatformDeposit\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={amount:{type:\"numeric\"},from_account:{type:\"string\"},passthrough:{},platform:{required:1,type:\"string\"},req_id:{type:\"numeric\"},to_account:{required:1,type:\"string\"},trading_platform_deposit:{required:1,type:\"numeric\"}},r={method:\"trading_platform_deposit\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"tradingPlatformInvestorPasswordChange\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={account_id:{required:1,type:\"string\"},new_password:{required:1,type:\"string\"},old_password:{required:1,type:\"string\"},passthrough:{},platform:{required:1,type:\"string\"},req_id:{type:\"numeric\"},trading_platform_investor_password_change:{required:1,type:\"numeric\"}},r={method:\"trading_platform_investor_password_change\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"tradingPlatformInvestorPasswordReset\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={account_id:{required:1,type:\"string\"},new_password:{required:1,type:\"string\"},passthrough:{},platform:{required:1,type:\"string\"},req_id:{type:\"numeric\"},trading_platform_investor_password_reset:{required:1,type:\"numeric\"},verification_code:{required:1,type:\"string\"}},r={method:\"trading_platform_investor_password_reset\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"tradingPlatformNewAccount\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={account_type:{required:1,type:\"string\"},currency:{type:\"string\"},dry_run:{type:\"numeric\"},market_type:{required:1,type:\"string\"},passthrough:{},password:{required:1,type:\"string\"},platform:{required:1,type:\"string\"},req_id:{type:\"numeric\"},sub_account_type:{type:\"string\"},trading_platform_new_account:{required:1,type:\"numeric\"}},r={method:\"trading_platform_new_account\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"tradingPlatformPasswordChange\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={new_password:{required:1,type:\"string\"},old_password:{type:\"string\"},passthrough:{},platform:{required:1,type:\"string\"},req_id:{type:\"numeric\"},trading_platform_password_change:{required:1,type:\"numeric\"}},r={method:\"trading_platform_password_change\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"tradingPlatformPasswordReset\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={new_password:{required:1,type:\"string\"},passthrough:{},platform:{required:1,type:\"string\"},req_id:{type:\"numeric\"},trading_platform_password_reset:{required:1,type:\"numeric\"},verification_code:{required:1,type:\"string\"}},r={method:\"trading_platform_password_reset\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"tradingPlatformProductListing\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={app_id:{},country_code:{required:1,type:\"string\"},passthrough:{},req_id:{type:\"numeric\"},trading_platform_product_listing:{required:1,type:\"numeric\"}},r={method:\"trading_platform_product_listing\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"tradingPlatformWithdrawal\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={amount:{required:1,type:\"numeric\"},from_account:{required:1,type:\"string\"},passthrough:{},platform:{required:1,type:\"string\"},req_id:{type:\"numeric\"},to_account:{required:1,type:\"string\"},trading_platform_withdrawal:{required:1,type:\"numeric\"}},r={method:\"trading_platform_withdrawal\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"tradingServers\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={account_type:{type:\"string\"},environment:{type:\"string\"},market_type:{type:\"string\"},passthrough:{},platform:{type:\"string\"},req_id:{type:\"numeric\"},trading_servers:{required:1,type:\"numeric\"}},r={method:\"trading_servers\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"tradingTimes\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={passthrough:{},req_id:{type:\"numeric\"},trading_times:{required:1,type:\"string\"}},r={method:\"trading_times\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"transaction\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={passthrough:{},req_id:{type:\"numeric\"},subscribe:{required:1,type:\"numeric\"},transaction:{required:1,type:\"numeric\"}},r={method:\"transaction\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"transferBetweenAccounts\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={account_from:{type:\"string\"},account_to:{type:\"string\"},accounts:{type:\"string\"},amount:{type:\"numeric\"},currency:{type:\"string\"},passthrough:{},req_id:{type:\"numeric\"},transfer_between_accounts:{required:1,type:\"numeric\"}},r={method:\"transfer_between_accounts\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"verifyEmail\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={passthrough:{},req_id:{type:\"numeric\"},type:{required:1,type:\"string\"},url_parameters:{affiliate_token:{type:\"string\"},date_first_contact:{type:\"string\"},gclid_url:{type:\"string\"},pa_amount:{type:\"numeric\"},pa_currency:{type:\"string\"},pa_loginid:{type:\"string\"},pa_remarks:{type:\"string\"},redirect_to:{type:\"numeric\"},signup_device:{type:\"string\"},utm_ad_id:{},utm_adgroup_id:{},utm_adrollclk_id:{},utm_campaign:{},utm_campaign_id:{},utm_content:{},utm_fbcl_id:{},utm_gl_client_id:{},utm_medium:{},utm_msclk_id:{},utm_source:{},utm_term:{}},verify_email:{required:1,type:\"string\"}},r={method:\"verify_email\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"websiteStatus\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={passthrough:{},req_id:{type:\"numeric\"},subscribe:{type:\"numeric\"},website_status:{required:1,type:\"numeric\"}},r={method:\"website_status\",needsMethodArg:\"1\",args:e,config:t};return this.processRequest(r)}},{key:\"processRequest\",value:function(e){var r=e.config,n=function(e){var t=e.config,r=e.args,n=e.method,i=e.needsMethodArg,s=r;return i&&!me(s)&&(s=fe({},n,s)),s[n]=s[n]||1,Object.keys(s).forEach((function(e){var r=s[e];e in t&&(\"string\"===t[e].type?s[e]=\"\".concat(r):\"numeric\"===t[e].type?s[e]=parseFloat(r):\"boolean\"===t[e].type&&(s[e]=+r))})),s}(e),i=function(e){var r=e.config,n=e.args;if(!me(n))return\"Requires an object but a \".concat(t(n),\" is passed.\");var i=[],s=Object.keys(r).filter((function(e){return(r[e]||{}).required&&!(e in n)}));return s.length&&i.push(\"Required parameters missing: \".concat(s.join(\", \"))),Object.keys(n).forEach((function(e){var s=n[e];if(e in r){var o=r[e].type;o&&(ve[o](s)||i.push(\"\".concat(o,\" value expected but found \").concat(t(s),\": \").concat(e)))}})),i.length?i.join(\" - \"):\"\"}({config:r,args:n});return i?Promise.reject(i):this.send(n)}}]),e}(),me=function(e){return e instanceof Object},ve={object:me,numeric:function(e){return!Number.isNaN(1*e)},string:function(e){return\"string\"==typeof e},boolean:function(e){return[!0,!1,0,1].includes(e)}};function qe(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}function be(e,t,r){return be=qe()?Reflect.construct:function(e,t,r){var n=[null];n.push.apply(n,t);var i=new(Function.bind.apply(e,n));return r&&p(i,r.prototype),i},be.apply(null,arguments)}function we(e){var t=\"function\"==typeof Map?new Map:void 0;return we=function(e){if(null===e||(r=e,-1===Function.toString.call(r).indexOf(\"[native code]\")))return e;var r;if(\"function\"!=typeof e)throw new TypeError(\"Super expression must either be null or a function\");if(void 0!==t){if(t.has(e))return t.get(e);t.set(e,n)}function n(){return be(e,arguments,y(this).constructor)}return n.prototype=Object.create(e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),p(n,e)},we(e)}function ke(e){var t=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=y(e);if(t){var i=y(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return h(this,r)}}function Ae(e){return function(t){d(n,t);var r=ke(n);function n(t){var i;return o(this,n),(i=r.call(this)).type=e,i.message=t,i}return c(n,[{key:\"toString\",value:function(){return\"\".concat(this.type,\": \").concat(this.message)}}]),n}(we(Error))}var xe=function(e){d(r,e);var t=ke(r);function r(){return o(this,r),t.apply(this,arguments)}return c(r)}(Ae(\"APIError\")),Re=function(e){d(r,e);var t=ke(r);function r(){return o(this,r),t.apply(this,arguments)}return c(r)}(Ae(\"ConstructionError\")),Me=r(266),Oe=r.n(Me);function Se(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function Ee(e){var t=function(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?Se(Object(r),!0).forEach((function(t){fe(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):Se(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}({},e);return delete t.req_id,delete t.passthrough,delete t.subscribe,Oe()(t)}var je=function(e){d(f,e);var t,r,n,i,u,a,p,l=(a=f,p=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}(),function(){var e,t=y(a);if(p){var r=y(this).constructor;e=Reflect.construct(t,arguments,r)}else e=t.apply(this,arguments);return h(this,e)});function f(e,t){var r;if(o(this,f),!e)throw new Re(\"Cache object needs an API to work\");return(r=l.call(this)).api=e,r.storage=t,r}return c(f,[{key:\"send\",value:(u=s(g().mark((function e(t){var r;return g().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.has(t);case 2:if(!e.sent){e.next=4;break}return e.abrupt(\"return\",this.get(t));case 4:return e.next=6,this.api.send(t);case 6:return r=e.sent,e.next=9,this.set(t,r);case 9:return e.abrupt(\"return\",r);case 10:case\"end\":return e.stop()}}),e,this)}))),function(e){return u.apply(this,arguments)})},{key:\"has\",value:(i=s(g().mark((function e(t){return g().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt(\"return\",this.storage.has(Ee(t)));case 1:case\"end\":return e.stop()}}),e,this)}))),function(e){return i.apply(this,arguments)})},{key:\"get\",value:(n=s(g().mark((function e(t){return g().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt(\"return\",this.storage.get(Ee(t)));case 1:case\"end\":return e.stop()}}),e,this)}))),function(e){return n.apply(this,arguments)})},{key:\"getByMsgType\",value:(r=s(g().mark((function e(t){return g().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt(\"return\",this.storage.getByMsgType(t));case 1:case\"end\":return e.stop()}}),e,this)}))),function(e){return r.apply(this,arguments)})},{key:\"set\",value:(t=s(g().mark((function e(t,r){return g().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt(\"return\",this.storage.set(Ee(t),r));case 1:case\"end\":return e.stop()}}),e,this)}))),function(e,r){return t.apply(this,arguments)})}]),f}(_e);var Pe=function(e){d(i,e);var t,r,n=(t=i,r=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}(),function(){var e,n=y(t);if(r){var i=y(this).constructor;e=Reflect.construct(n,arguments,i)}else e=n.apply(this,arguments);return h(this,e)});function i(){var e,t,r,s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:function(){};return o(this,i),e=n.call(this,(function(e,n){t=e,r=n})),s(t,r),e.resolveCallback=t,e.rejectCallback=r,e.state=\"pending\",e}return c(i,[{key:\"resolve\",value:function(e){return this.resolveCallback(e),this.state=\"resolved\",this}},{key:\"reject\",value:function(e){return this.rejectCallback(e),this.state=\"rejected\",this}},{key:\"isPending\",value:function(){return\"pending\"===this.state}},{key:\"isRejected\",value:function(){return\"rejected\"===this.state}},{key:\"isResolved\",value:function(){return\"resolved\"===this.state}}],[{key:\"wrap\",value:function(e){if(e instanceof this)return e;var t=new this;return e.then(t.resolve.bind(t),t.reject.bind(t)),t}}]),i}(we(Promise)),Ce=function(){function e(){o(this,e),this.store={by_msg_type:{}}}return c(e,[{key:\"has\",value:function(e){return e in this.store}},{key:\"get\",value:function(e){return this.store[e]}},{key:\"getByMsgType\",value:function(e){return this.store.by_msg_type[e]}},{key:\"set\",value:function(e,t){this.store.by_msg_type[t.msg_type]=t,this.store[e]=t}}]),e}(),Te=function(){function e(e){this.callback=e}return e.prototype.call=function(e,t){return t.subscribe(new Le(e,this.callback))},e}(),Le=function(e){function t(t,r){var n=e.call(this,t)||this;return n.add(new O(r)),n}return v(t,e),t}(j);const De=[\"balance\",\"buy\",\"cashier_payments\",\"exchange_rates\",\"p2p_advert_info\",\"p2p_advertiser_create\",\"p2p_advertiser_info\",\"p2p_order_create\",\"p2p_order_info\",\"p2p_order_list\",\"proposal\",\"proposal_open_contract\",\"ticks\",\"ticks_history\",\"transaction\",\"website_status\"];function Ie(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function Be(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?Ie(Object(r),!0).forEach((function(t){fe(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):Ie(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}var He=function(){function e(t){o(this,e),this.api=t,this.sources={},this.subs_id_to_key={},this.key_to_subs_id={},this.buy_key_to_contract_id={},this.subs_per_msg_type=[],this.streams_list=De}return c(e,[{key:\"subscribe\",value:function(e){return this.sourceExists(e)?this.getSource(e):this.createNewSource(Be(Be({},e),{},{subscribe:1}))}},{key:\"getSource\",value:function(e){var t=Ne(e);if(t in this.sources)return this.sources[t];if(e.proposal_open_contract&&e.contract_id){var r=Object.values(this.buy_key_to_contract_id).find((function(t){return t.contract_id===e.contract_id}));if(r)return this.sources[r.buy_key]}}},{key:\"sourceExists\",value:function(e){return this.getSource(e)}},{key:\"createNewSource\",value:function(e){var t,r=this,n=Ne(e),i=this.api.sendAndGetSource(e).pipe((t=function(){n in r.key_to_subs_id&&r.forget(r.key_to_subs_id[n]).then((function(){}),(function(){}))},function(e){return e.lift(new Te(t))}),ge());return this.sources[n]=i,this.saveSubsPerMsgType(e,n),i.pipe(te()).toPromise().then((function(t){e.buy&&(r.buy_key_to_contract_id[n]={contract_id:t.buy.contract_id,buy_key:n}),r.saveSubsId(n,t)}),this.removeKeyOnError(n)),i}},{key:\"forget\",value:function(e){return this.completeSubsByIds(e),this.api.send({forget:e})}},{key:\"forgetAll\",value:function(){for(var e=this,t=arguments.length,r=new Array(t),n=0;n<t;n++)r[n]=arguments[n];return r.forEach((function(t){(e.subs_per_msg_type[t]||[]).forEach((function(t){return e.completeSubsByKey(t)})),e.subs_per_msg_type[t]=[]})),this.api.send({forget_all:r})}},{key:\"completeSubsByIds\",value:function(){for(var e=this,t=arguments.length,r=new Array(t),n=0;n<t;n++)r[n]=arguments[n];r.forEach((function(t){var r=e.subs_id_to_key[t];delete e.subs_id_to_key[t],e.completeSubsByKey(r)}))}},{key:\"saveSubsId\",value:function(e,t){var r=t.subscription;if(!r)return this.completeSubsByKey(e);var n=r.id;n in this.subs_id_to_key||(this.subs_id_to_key[n]=e,this.key_to_subs_id[e]=n)}},{key:\"saveSubsPerMsgType\",value:function(e,t){var r=this.getMsgType(e);r?(this.subs_per_msg_type[r]=this.subs_per_msg_type[r]||[],this.subs_per_msg_type[r].push(t)):this.api.sanityErrors.next(new xe(\"Subscription type is not found in deriv-api\"))}},{key:\"removeKeyOnError\",value:function(e){var t=this;return function(){return t.completeSubsByKey(e)}}},{key:\"completeSubsByKey\",value:function(e){if(e&&this.sources[e]){var t=this.sources[e];delete this.sources[e];var r=this.key_to_subs_id[e];delete this.subs_id_to_key[r],delete this.key_to_subs_id[e],delete this.buy_key_to_contract_id[e],t.complete()}}},{key:\"getMsgType\",value:function(e){return this.streams_list.find((function(t){return t in e}))}}]),e}();function Ne(e){return Ee(e)}var Fe=function(e){d(f,e);var t,r,n,i,u,p,l=(u=f,p=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}(),function(){var e,t=y(u);if(p){var r=y(this).constructor;e=Reflect.construct(t,arguments,r)}else e=t.apply(this,arguments);return h(this,e)});function f(){var e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=t.storage,n=t.app_id,i=t.connection,s=t.cache,u=void 0===s?new Ce:s,c=t.endpoint,p=void 0===c?\"ws.binaryws.com\":c,d=t.lang,h=void 0===d?\"EN\":d,y=t.brand,g=void 0===y?\"\":y,_=t.middleware,m=void 0===_?{}:_;if(o(this,f),(e=l.call(this)).events=new oe,i)e.connection=i;else{if(!n)throw Error(\"An app_id is required to connect to the API\");e.shouldReconnect=!0,e.connectionArgs={app_id:n,endpointUrl:Ue(p),lang:h.toUpperCase(),brand:g.toLowerCase()},e.connect()}return e.lang=h,e.reqId=0,e.connected=new Pe,e.sanityErrors=new oe,e.middleware=m,e.pendingRequests={},e.expect_response_types={},e.subscription_manager=new He(a(e)),e.reconnect_timeout=!1,e.keep_alive_interval=!1,r&&(e.storage=new je(a(e),r)),e.cache=new je(e.storage?e.storage:a(e),u),e.connectionHandlers(),e}return c(f,[{key:\"connectionHandlers\",value:function(){this.connection.onopen=this.openHandler.bind(this),this.connection.onclose=this.closeHandler.bind(this),this.connection.onmessage=this.messageHandler.bind(this),this.connection.onerror=this.errorHandler.bind(this)}},{key:\"connect\",value:function(){if(!this.connectionArgs)throw new Re(\"Connection arguments are required to create a connection.\");this.events.next({name:\"connect\"});var e=this.connectionArgs,t=e.endpointUrl,r=e.lang,n=e.app_id,i=e.brand;this.connection=new WebSocket(\"\".concat(t.toString(),\"websockets/v3?app_id=\").concat(n,\"&l=\").concat(r,\"&brand=\").concat(i))}},{key:\"disconnect\",value:function(){this.shouldReconnect=!1,this.connection.close()}},{key:\"isConnectionClosed\",value:function(){return 2===this.connection.readyState||3===this.connection.readyState}},{key:\"sendAndGetSource\",value:function(e){var t=this,r=new oe;return e.req_id=e.req_id||++this.reqId,this.pendingRequests[e.req_id]=r,this.connected.then((function(){t.isConnectionClosed()||t.connection.send(JSON.stringify(e))})).catch((function(e){return r.error(e)})),r}},{key:\"send\",value:(i=s(g().mark((function e(){var t,r,n,i,s,o,u,c,a=this,p=arguments;return g().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:for(t=p.length,r=new Array(t),n=0;n<t;n++)r[n]=p[n];if(!(i=this.callMiddleware(\"sendWillBeCalled\",{args:r}))){e.next=4;break}return e.abrupt(\"return\",i);case 4:if(s=r[0],o=this.callMiddleware(\"requestDataTransformer\",s)||s,this.events.next({name:\"send\",data:o}),this.deleteFromExpectResponse(o),(u=this.sendAndGetSource(o).pipe(te()).toPromise()).then((function(e){a.cache.set(o,e),a.storage&&a.storage.set(o,e)}),(function(){})),!(c=this.callMiddleware(\"sendIsCalled\",{response_promise:u,args:r}))){e.next=13;break}return e.abrupt(\"return\",c);case 13:return e.abrupt(\"return\",u);case 14:case\"end\":return e.stop()}}),e,this)}))),function(){return i.apply(this,arguments)})},{key:\"callMiddleware\",value:function(e,t){if(e in this.middleware)return this.middleware[e](t)}},{key:\"subscribe\",value:function(e){var t=this.callMiddleware(\"requestDataTransformer\",e)||e;return this.subscription_manager.subscribe(t)}},{key:\"forget\",value:(n=s(g().mark((function e(t){return g().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt(\"return\",this.subscription_manager.forget(t));case 1:case\"end\":return e.stop()}}),e,this)}))),function(e){return n.apply(this,arguments)})},{key:\"forgetAll\",value:(r=s(g().mark((function e(){var t,r=arguments;return g().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt(\"return\",(t=this.subscription_manager).forgetAll.apply(t,r));case 1:case\"end\":return e.stop()}}),e,this)}))),function(){return r.apply(this,arguments)})},{key:\"keepAlivePing\",value:function(){this.ping({ping:1}),this.reconnect_timeout=setTimeout(this.reconnect.bind(this),5e3)}},{key:\"pong\",value:function(){this.reconnect_timeout&&(clearTimeout(this.reconnect_timeout),this.reconnect_timeout=!1)}},{key:\"openHandler\",value:function(){this.events.next({name:\"open\"}),this.shouldReconnect&&(this.keep_alive_interval=setInterval(this.keepAlivePing.bind(this),3e4)),1===this.connection.readyState?this.connected.resolve():setTimeout(this.openHandler.bind(this),50)}},{key:\"messageHandler\",value:function(e){if(e.data){var t=JSON.parse(e.data);this.reconnect_timeout&&\"pong\"===t.ping&&this.pong(),this.events.next({name:\"message\",data:t});var r=t.req_id;if(r in this.pendingRequests){var n=this.expect_response_types[t.msg_type];n&&n.isPending()&&n.resolve(t);var i=t.echo_req,s=i&&i.proposal_open_contract&&!i.contract_id;if(t.error&&!s)this.pendingRequests[r].error(t);else if(this.pendingRequests[r].isStopped&&t.subscription){var o=t.subscription.id;this.forget(o)}else this.pendingRequests[r].next(t)}else this.sanityErrors.next(new xe(\"Extra response\"))}else this.sanityErrors.next(new xe(\"Something went wrong while receiving the response from API.\"))}},{key:\"closeHandler\",value:function(){this.events.next({name:\"close\"}),this.shouldReconnect&&(this.events.next({name:\"reconnecting\"}),this.reconnect())}},{key:\"reconnect\",value:function(){this.shouldReconnect&&(this.keep_alive_interval&&(clearInterval(this.keep_alive_interval),this.keep_alive_interval=!1),this.pong(),this.connect(),this.connectionHandlers())}},{key:\"errorHandler\",value:function(){this.sanityErrors.next(new xe(\"Something went wrong while receiving the response from API.\"))}},{key:\"onClose\",value:function(){return this.events.pipe(C((function(e){return\"close\"===e.name})),ge())}},{key:\"onOpen\",value:function(){return this.events.pipe(C((function(e){return\"open\"===e.name})),ge())}},{key:\"onMessage\",value:function(){return this.events.pipe(C((function(e){return\"message\"===e.name})),ge())}},{key:\"expectResponse\",value:(t=s(g().mark((function e(){var t,r,n,i=this,s=arguments;return g().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:for(t=s.length,r=new Array(t),n=0;n<t;n++)r[n]=s[n];if(r.forEach((function(e){e in i.expect_response_types||(i.expect_response_types[e]=Ve(i.cache.getByMsgType(e).then((function(t){return!t&&i.storage?i.storage.getByMsgType(e):t}))))})),1!==r.length){e.next=4;break}return e.abrupt(\"return\",this.expect_response_types[r[0]]);case 4:return e.abrupt(\"return\",Promise.all(r.map((function(e){return i.expect_response_types[e]}))));case 5:case\"end\":return e.stop()}}),e,this)}))),function(){return t.apply(this,arguments)})},{key:\"deleteFromExpectResponse\",value:function(e){var t=Object.keys(this.expect_response_types).find((function(t){return t in e}));this.expect_response_types[t]&&!this.expect_response_types[t].isPending()&&delete this.expect_response_types[t]}}]),f}(_e);function Ue(r){if(\"string\"!=typeof r)throw new Re(\"Endpoint must be a string, passed: \".concat(t(r)));var n,i,s;try{var o=(i=r.match(/((?:\\w*:\\/\\/)*)(.*)/),s=3,function(e){if(Array.isArray(e))return e}(i)||function(e,t){var r=null==e?null:\"undefined\"!=typeof Symbol&&e[Symbol.iterator]||e[\"@@iterator\"];if(null!=r){var n,i,s=[],o=!0,u=!1;try{for(r=r.call(e);!(o=(n=r.next()).done)&&(s.push(n.value),!t||s.length!==t);o=!0);}catch(e){u=!0,i=e}finally{try{o||null==r.return||r.return()}finally{if(u)throw i}}return s}}(i,s)||function(t,r){if(t){if(\"string\"==typeof t)return e(t,r);var n=Object.prototype.toString.call(t).slice(8,-1);return\"Object\"===n&&t.constructor&&(n=t.constructor.name),\"Map\"===n||\"Set\"===n?Array.from(t):\"Arguments\"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?e(t,r):void 0}}(i,s)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()),u=(o[0],o[1]),c=o[2];n=new URL(\"\".concat(\"ws://\"===u?u:\"wss://\").concat(c))}catch(e){throw new Re(\"Invalid URL: \".concat(r))}return n}function Ve(e){return Pe.wrap(e.then((function(e){return e||new Pe})))}})(),n.default})()}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZXJpdi9kZXJpdi1hcGkvZGlzdC9EZXJpdkFQSUJhc2ljLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZXJpdi9kZXJpdi1hcGkvZGlzdC9EZXJpdkFQSUJhc2ljLmpzP2E2YzQiXSwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5EZXJpdkFQSUJhc2ljPXQoKTplLkRlcml2QVBJQmFzaWM9dCgpfShcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXMsKGZ1bmN0aW9uKCl7cmV0dXJuKCgpPT57dmFyIGU9ezc1NzooZSx0LHIpPT57ZS5leHBvcnRzPXIoNjY2KX0sMjY2OihlLHQscik9Pnt2YXIgbj1cInVuZGVmaW5lZFwiIT10eXBlb2YgSlNPTj9KU09OOnIoNDE4KTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXt0fHwodD17fSksXCJmdW5jdGlvblwiPT10eXBlb2YgdCYmKHQ9e2NtcDp0fSk7dmFyIHI9dC5zcGFjZXx8XCJcIjtcIm51bWJlclwiPT10eXBlb2YgciYmKHI9QXJyYXkocisxKS5qb2luKFwiIFwiKSk7dmFyIG8sdT1cImJvb2xlYW5cIj09dHlwZW9mIHQuY3ljbGVzJiZ0LmN5Y2xlcyxjPXQucmVwbGFjZXJ8fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR9LGE9dC5jbXAmJihvPXQuY21wLGZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbih0LHIpe3ZhciBuPXtrZXk6dCx2YWx1ZTplW3RdfSxpPXtrZXk6cix2YWx1ZTplW3JdfTtyZXR1cm4gbyhuLGkpfX0pLHA9W107cmV0dXJuIGZ1bmN0aW9uIGUodCxvLGQsaCl7dmFyIHk9cj9cIlxcblwiK25ldyBBcnJheShoKzEpLmpvaW4ocik6XCJcIixsPXI/XCI6IFwiOlwiOlwiO2lmKGQmJmQudG9KU09OJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBkLnRvSlNPTiYmKGQ9ZC50b0pTT04oKSksdm9pZCAwIT09KGQ9Yy5jYWxsKHQsbyxkKSkpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBkfHxudWxsPT09ZClyZXR1cm4gbi5zdHJpbmdpZnkoZCk7aWYoaShkKSl7Zm9yKHZhciBnPVtdLGY9MDtmPGQubGVuZ3RoO2YrKyl7dmFyIF89ZShkLGYsZFtmXSxoKzEpfHxuLnN0cmluZ2lmeShudWxsKTtnLnB1c2goeStyK18pfXJldHVyblwiW1wiK2cuam9pbihcIixcIikreStcIl1cIn1pZigtMSE9PXAuaW5kZXhPZihkKSl7aWYodSlyZXR1cm4gbi5zdHJpbmdpZnkoXCJfX2N5Y2xlX19cIik7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvbnZlcnRpbmcgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEpTT05cIil9cC5wdXNoKGQpO3ZhciBtPXMoZCkuc29ydChhJiZhKGQpKTtmb3IoZz1bXSxmPTA7ZjxtLmxlbmd0aDtmKyspe3ZhciB2PWUoZCxvPW1bZl0sZFtvXSxoKzEpO2lmKHYpe3ZhciBxPW4uc3RyaW5naWZ5KG8pK2wrdjtnLnB1c2goeStyK3EpfX1yZXR1cm4gcC5zcGxpY2UocC5pbmRleE9mKGQpLDEpLFwie1wiK2cuam9pbihcIixcIikreStcIn1cIn19KHtcIlwiOmV9LFwiXCIsZSwwKX07dmFyIGk9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oZSl7cmV0dXJuXCJbb2JqZWN0IEFycmF5XVwiPT09e30udG9TdHJpbmcuY2FsbChlKX0scz1PYmplY3Qua2V5c3x8ZnVuY3Rpb24oZSl7dmFyIHQ9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eXx8ZnVuY3Rpb24oKXtyZXR1cm4hMH0scj1bXTtmb3IodmFyIG4gaW4gZSl0LmNhbGwoZSxuKSYmci5wdXNoKG4pO3JldHVybiByfX0sNDE4OihlLHQscik9Pnt0LnBhcnNlPXIoMzk2KSx0LnN0cmluZ2lmeT1yKDE3Nyl9LDM5NjplPT57dmFyIHQscixuLGkscz17J1wiJzonXCInLFwiXFxcXFwiOlwiXFxcXFwiLFwiL1wiOlwiL1wiLGI6XCJcXGJcIixmOlwiXFxmXCIsbjpcIlxcblwiLHI6XCJcXHJcIix0OlwiXFx0XCJ9LG89ZnVuY3Rpb24oZSl7dGhyb3d7bmFtZTpcIlN5bnRheEVycm9yXCIsbWVzc2FnZTplLGF0OnQsdGV4dDpufX0sdT1mdW5jdGlvbihlKXtyZXR1cm4gZSYmZSE9PXImJm8oXCJFeHBlY3RlZCAnXCIrZStcIicgaW5zdGVhZCBvZiAnXCIrcitcIidcIikscj1uLmNoYXJBdCh0KSx0Kz0xLHJ9LGM9ZnVuY3Rpb24oKXt2YXIgZSx0PVwiXCI7Zm9yKFwiLVwiPT09ciYmKHQ9XCItXCIsdShcIi1cIikpO3I+PVwiMFwiJiZyPD1cIjlcIjspdCs9cix1KCk7aWYoXCIuXCI9PT1yKWZvcih0Kz1cIi5cIjt1KCkmJnI+PVwiMFwiJiZyPD1cIjlcIjspdCs9cjtpZihcImVcIj09PXJ8fFwiRVwiPT09cilmb3IodCs9cix1KCksXCItXCIhPT1yJiZcIitcIiE9PXJ8fCh0Kz1yLHUoKSk7cj49XCIwXCImJnI8PVwiOVwiOyl0Kz1yLHUoKTtpZihlPSt0LGlzRmluaXRlKGUpKXJldHVybiBlO28oXCJCYWQgbnVtYmVyXCIpfSxhPWZ1bmN0aW9uKCl7dmFyIGUsdCxuLGk9XCJcIjtpZignXCInPT09cilmb3IoO3UoKTspe2lmKCdcIic9PT1yKXJldHVybiB1KCksaTtpZihcIlxcXFxcIj09PXIpaWYodSgpLFwidVwiPT09cil7Zm9yKG49MCx0PTA7dDw0JiYoZT1wYXJzZUludCh1KCksMTYpLGlzRmluaXRlKGUpKTt0Kz0xKW49MTYqbitlO2krPVN0cmluZy5mcm9tQ2hhckNvZGUobil9ZWxzZXtpZihcInN0cmluZ1wiIT10eXBlb2Ygc1tyXSlicmVhaztpKz1zW3JdfWVsc2UgaSs9cn1vKFwiQmFkIHN0cmluZ1wiKX0scD1mdW5jdGlvbigpe2Zvcig7ciYmcjw9XCIgXCI7KXUoKX07aT1mdW5jdGlvbigpe3N3aXRjaChwKCkscil7Y2FzZVwie1wiOnJldHVybiBmdW5jdGlvbigpe3ZhciBlLHQ9e307aWYoXCJ7XCI9PT1yKXtpZih1KFwie1wiKSxwKCksXCJ9XCI9PT1yKXJldHVybiB1KFwifVwiKSx0O2Zvcig7cjspe2lmKGU9YSgpLHAoKSx1KFwiOlwiKSxPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0LGUpJiZvKCdEdXBsaWNhdGUga2V5IFwiJytlKydcIicpLHRbZV09aSgpLHAoKSxcIn1cIj09PXIpcmV0dXJuIHUoXCJ9XCIpLHQ7dShcIixcIikscCgpfX1vKFwiQmFkIG9iamVjdFwiKX0oKTtjYXNlXCJbXCI6cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGU9W107aWYoXCJbXCI9PT1yKXtpZih1KFwiW1wiKSxwKCksXCJdXCI9PT1yKXJldHVybiB1KFwiXVwiKSxlO2Zvcig7cjspe2lmKGUucHVzaChpKCkpLHAoKSxcIl1cIj09PXIpcmV0dXJuIHUoXCJdXCIpLGU7dShcIixcIikscCgpfX1vKFwiQmFkIGFycmF5XCIpfSgpO2Nhc2UnXCInOnJldHVybiBhKCk7Y2FzZVwiLVwiOnJldHVybiBjKCk7ZGVmYXVsdDpyZXR1cm4gcj49XCIwXCImJnI8PVwiOVwiP2MoKTpmdW5jdGlvbigpe3N3aXRjaChyKXtjYXNlXCJ0XCI6cmV0dXJuIHUoXCJ0XCIpLHUoXCJyXCIpLHUoXCJ1XCIpLHUoXCJlXCIpLCEwO2Nhc2VcImZcIjpyZXR1cm4gdShcImZcIiksdShcImFcIiksdShcImxcIiksdShcInNcIiksdShcImVcIiksITE7Y2FzZVwiblwiOnJldHVybiB1KFwiblwiKSx1KFwidVwiKSx1KFwibFwiKSx1KFwibFwiKSxudWxsfW8oXCJVbmV4cGVjdGVkICdcIityK1wiJ1wiKX0oKX19LGUuZXhwb3J0cz1mdW5jdGlvbihlLHMpe3ZhciB1O3JldHVybiBuPWUsdD0wLHI9XCIgXCIsdT1pKCkscCgpLHImJm8oXCJTeW50YXggZXJyb3JcIiksXCJmdW5jdGlvblwiPT10eXBlb2Ygcz9mdW5jdGlvbiBlKHQscil7dmFyIG4saSxvPXRbcl07aWYobyYmXCJvYmplY3RcIj09dHlwZW9mIG8pZm9yKG4gaW4gbylPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobyxuKSYmKHZvaWQgMCE9PShpPWUobyxuKSk/b1tuXT1pOmRlbGV0ZSBvW25dKTtyZXR1cm4gcy5jYWxsKHQscixvKX0oe1wiXCI6dX0sXCJcIik6dX19LDE3NzplPT57dmFyIHQscixuLGk9L1tcXFxcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx4OWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxzPXtcIlxcYlwiOlwiXFxcXGJcIixcIlxcdFwiOlwiXFxcXHRcIixcIlxcblwiOlwiXFxcXG5cIixcIlxcZlwiOlwiXFxcXGZcIixcIlxcclwiOlwiXFxcXHJcIiwnXCInOidcXFxcXCInLFwiXFxcXFwiOlwiXFxcXFxcXFxcIn07ZnVuY3Rpb24gbyhlKXtyZXR1cm4gaS5sYXN0SW5kZXg9MCxpLnRlc3QoZSk/J1wiJytlLnJlcGxhY2UoaSwoZnVuY3Rpb24oZSl7dmFyIHQ9c1tlXTtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdD90OlwiXFxcXHVcIisoXCIwMDAwXCIrZS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpfSkpKydcIic6J1wiJytlKydcIid9ZnVuY3Rpb24gdShlLGkpe3ZhciBzLGMsYSxwLGQsaD10LHk9aVtlXTtzd2l0Y2goeSYmXCJvYmplY3RcIj09dHlwZW9mIHkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHkudG9KU09OJiYoeT15LnRvSlNPTihlKSksXCJmdW5jdGlvblwiPT10eXBlb2YgbiYmKHk9bi5jYWxsKGksZSx5KSksdHlwZW9mIHkpe2Nhc2VcInN0cmluZ1wiOnJldHVybiBvKHkpO2Nhc2VcIm51bWJlclwiOnJldHVybiBpc0Zpbml0ZSh5KT9TdHJpbmcoeSk6XCJudWxsXCI7Y2FzZVwiYm9vbGVhblwiOmNhc2VcIm51bGxcIjpyZXR1cm4gU3RyaW5nKHkpO2Nhc2VcIm9iamVjdFwiOmlmKCF5KXJldHVyblwibnVsbFwiO2lmKHQrPXIsZD1bXSxcIltvYmplY3QgQXJyYXldXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHkpKXtmb3IocD15Lmxlbmd0aCxzPTA7czxwO3MrPTEpZFtzXT11KHMseSl8fFwibnVsbFwiO3JldHVybiBhPTA9PT1kLmxlbmd0aD9cIltdXCI6dD9cIltcXG5cIit0K2Quam9pbihcIixcXG5cIit0KStcIlxcblwiK2grXCJdXCI6XCJbXCIrZC5qb2luKFwiLFwiKStcIl1cIix0PWgsYX1pZihuJiZcIm9iamVjdFwiPT10eXBlb2Ygbilmb3IocD1uLmxlbmd0aCxzPTA7czxwO3MrPTEpXCJzdHJpbmdcIj09dHlwZW9mKGM9bltzXSkmJihhPXUoYyx5KSkmJmQucHVzaChvKGMpKyh0P1wiOiBcIjpcIjpcIikrYSk7ZWxzZSBmb3IoYyBpbiB5KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh5LGMpJiYoYT11KGMseSkpJiZkLnB1c2gobyhjKSsodD9cIjogXCI6XCI6XCIpK2EpO3JldHVybiBhPTA9PT1kLmxlbmd0aD9cInt9XCI6dD9cIntcXG5cIit0K2Quam9pbihcIixcXG5cIit0KStcIlxcblwiK2grXCJ9XCI6XCJ7XCIrZC5qb2luKFwiLFwiKStcIn1cIix0PWgsYX19ZS5leHBvcnRzPWZ1bmN0aW9uKGUsaSxzKXt2YXIgbztpZih0PVwiXCIscj1cIlwiLFwibnVtYmVyXCI9PXR5cGVvZiBzKWZvcihvPTA7bzxzO28rPTEpcis9XCIgXCI7ZWxzZVwic3RyaW5nXCI9PXR5cGVvZiBzJiYocj1zKTtpZihuPWksaSYmXCJmdW5jdGlvblwiIT10eXBlb2YgaSYmKFwib2JqZWN0XCIhPXR5cGVvZiBpfHxcIm51bWJlclwiIT10eXBlb2YgaS5sZW5ndGgpKXRocm93IG5ldyBFcnJvcihcIkpTT04uc3RyaW5naWZ5XCIpO3JldHVybiB1KFwiXCIse1wiXCI6ZX0pfX0sNjY2OmU9Pnt2YXIgdD1mdW5jdGlvbihlKXtcInVzZSBzdHJpY3RcIjt2YXIgdCxyPU9iamVjdC5wcm90b3R5cGUsbj1yLmhhc093blByb3BlcnR5LGk9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sP1N5bWJvbDp7fSxzPWkuaXRlcmF0b3J8fFwiQEBpdGVyYXRvclwiLG89aS5hc3luY0l0ZXJhdG9yfHxcIkBAYXN5bmNJdGVyYXRvclwiLHU9aS50b1N0cmluZ1RhZ3x8XCJAQHRvU3RyaW5nVGFnXCI7ZnVuY3Rpb24gYyhlLHQscil7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOnIsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KSxlW3RdfXRyeXtjKHt9LFwiXCIpfWNhdGNoKGUpe2M9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBlW3RdPXJ9fWZ1bmN0aW9uIGEoZSx0LHIsbil7dmFyIGk9dCYmdC5wcm90b3R5cGUgaW5zdGFuY2VvZiBmP3Q6ZixzPU9iamVjdC5jcmVhdGUoaS5wcm90b3R5cGUpLG89bmV3IE8obnx8W10pO3JldHVybiBzLl9pbnZva2U9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWQ7cmV0dXJuIGZ1bmN0aW9uKGkscyl7aWYobj09PXkpdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtpZihuPT09bCl7aWYoXCJ0aHJvd1wiPT09aSl0aHJvdyBzO3JldHVybiBFKCl9Zm9yKHIubWV0aG9kPWksci5hcmc9czs7KXt2YXIgbz1yLmRlbGVnYXRlO2lmKG8pe3ZhciB1PXgobyxyKTtpZih1KXtpZih1PT09Zyljb250aW51ZTtyZXR1cm4gdX19aWYoXCJuZXh0XCI9PT1yLm1ldGhvZClyLnNlbnQ9ci5fc2VudD1yLmFyZztlbHNlIGlmKFwidGhyb3dcIj09PXIubWV0aG9kKXtpZihuPT09ZCl0aHJvdyBuPWwsci5hcmc7ci5kaXNwYXRjaEV4Y2VwdGlvbihyLmFyZyl9ZWxzZVwicmV0dXJuXCI9PT1yLm1ldGhvZCYmci5hYnJ1cHQoXCJyZXR1cm5cIixyLmFyZyk7bj15O3ZhciBjPXAoZSx0LHIpO2lmKFwibm9ybWFsXCI9PT1jLnR5cGUpe2lmKG49ci5kb25lP2w6aCxjLmFyZz09PWcpY29udGludWU7cmV0dXJue3ZhbHVlOmMuYXJnLGRvbmU6ci5kb25lfX1cInRocm93XCI9PT1jLnR5cGUmJihuPWwsci5tZXRob2Q9XCJ0aHJvd1wiLHIuYXJnPWMuYXJnKX19fShlLHIsbyksc31mdW5jdGlvbiBwKGUsdCxyKXt0cnl7cmV0dXJue3R5cGU6XCJub3JtYWxcIixhcmc6ZS5jYWxsKHQscil9fWNhdGNoKGUpe3JldHVybnt0eXBlOlwidGhyb3dcIixhcmc6ZX19fWUud3JhcD1hO3ZhciBkPVwic3VzcGVuZGVkU3RhcnRcIixoPVwic3VzcGVuZGVkWWllbGRcIix5PVwiZXhlY3V0aW5nXCIsbD1cImNvbXBsZXRlZFwiLGc9e307ZnVuY3Rpb24gZigpe31mdW5jdGlvbiBfKCl7fWZ1bmN0aW9uIG0oKXt9dmFyIHY9e307Yyh2LHMsKGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSk7dmFyIHE9T2JqZWN0LmdldFByb3RvdHlwZU9mLGI9cSYmcShxKFMoW10pKSk7YiYmYiE9PXImJm4uY2FsbChiLHMpJiYodj1iKTt2YXIgdz1tLnByb3RvdHlwZT1mLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHYpO2Z1bmN0aW9uIGsoZSl7W1wibmV4dFwiLFwidGhyb3dcIixcInJldHVyblwiXS5mb3JFYWNoKChmdW5jdGlvbih0KXtjKGUsdCwoZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX2ludm9rZSh0LGUpfSkpfSkpfWZ1bmN0aW9uIEEoZSx0KXtmdW5jdGlvbiByKGkscyxvLHUpe3ZhciBjPXAoZVtpXSxlLHMpO2lmKFwidGhyb3dcIiE9PWMudHlwZSl7dmFyIGE9Yy5hcmcsZD1hLnZhbHVlO3JldHVybiBkJiZcIm9iamVjdFwiPT10eXBlb2YgZCYmbi5jYWxsKGQsXCJfX2F3YWl0XCIpP3QucmVzb2x2ZShkLl9fYXdhaXQpLnRoZW4oKGZ1bmN0aW9uKGUpe3IoXCJuZXh0XCIsZSxvLHUpfSksKGZ1bmN0aW9uKGUpe3IoXCJ0aHJvd1wiLGUsbyx1KX0pKTp0LnJlc29sdmUoZCkudGhlbigoZnVuY3Rpb24oZSl7YS52YWx1ZT1lLG8oYSl9KSwoZnVuY3Rpb24oZSl7cmV0dXJuIHIoXCJ0aHJvd1wiLGUsbyx1KX0pKX11KGMuYXJnKX12YXIgaTt0aGlzLl9pbnZva2U9ZnVuY3Rpb24oZSxuKXtmdW5jdGlvbiBzKCl7cmV0dXJuIG5ldyB0KChmdW5jdGlvbih0LGkpe3IoZSxuLHQsaSl9KSl9cmV0dXJuIGk9aT9pLnRoZW4ocyxzKTpzKCl9fWZ1bmN0aW9uIHgoZSxyKXt2YXIgbj1lLml0ZXJhdG9yW3IubWV0aG9kXTtpZihuPT09dCl7aWYoci5kZWxlZ2F0ZT1udWxsLFwidGhyb3dcIj09PXIubWV0aG9kKXtpZihlLml0ZXJhdG9yLnJldHVybiYmKHIubWV0aG9kPVwicmV0dXJuXCIsci5hcmc9dCx4KGUsciksXCJ0aHJvd1wiPT09ci5tZXRob2QpKXJldHVybiBnO3IubWV0aG9kPVwidGhyb3dcIixyLmFyZz1uZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKX1yZXR1cm4gZ312YXIgaT1wKG4sZS5pdGVyYXRvcixyLmFyZyk7aWYoXCJ0aHJvd1wiPT09aS50eXBlKXJldHVybiByLm1ldGhvZD1cInRocm93XCIsci5hcmc9aS5hcmcsci5kZWxlZ2F0ZT1udWxsLGc7dmFyIHM9aS5hcmc7cmV0dXJuIHM/cy5kb25lPyhyW2UucmVzdWx0TmFtZV09cy52YWx1ZSxyLm5leHQ9ZS5uZXh0TG9jLFwicmV0dXJuXCIhPT1yLm1ldGhvZCYmKHIubWV0aG9kPVwibmV4dFwiLHIuYXJnPXQpLHIuZGVsZWdhdGU9bnVsbCxnKTpzOihyLm1ldGhvZD1cInRocm93XCIsci5hcmc9bmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpLHIuZGVsZWdhdGU9bnVsbCxnKX1mdW5jdGlvbiBSKGUpe3ZhciB0PXt0cnlMb2M6ZVswXX07MSBpbiBlJiYodC5jYXRjaExvYz1lWzFdKSwyIGluIGUmJih0LmZpbmFsbHlMb2M9ZVsyXSx0LmFmdGVyTG9jPWVbM10pLHRoaXMudHJ5RW50cmllcy5wdXNoKHQpfWZ1bmN0aW9uIE0oZSl7dmFyIHQ9ZS5jb21wbGV0aW9ufHx7fTt0LnR5cGU9XCJub3JtYWxcIixkZWxldGUgdC5hcmcsZS5jb21wbGV0aW9uPXR9ZnVuY3Rpb24gTyhlKXt0aGlzLnRyeUVudHJpZXM9W3t0cnlMb2M6XCJyb290XCJ9XSxlLmZvckVhY2goUix0aGlzKSx0aGlzLnJlc2V0KCEwKX1mdW5jdGlvbiBTKGUpe2lmKGUpe3ZhciByPWVbc107aWYocilyZXR1cm4gci5jYWxsKGUpO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUubmV4dClyZXR1cm4gZTtpZighaXNOYU4oZS5sZW5ndGgpKXt2YXIgaT0tMSxvPWZ1bmN0aW9uIHIoKXtmb3IoOysraTxlLmxlbmd0aDspaWYobi5jYWxsKGUsaSkpcmV0dXJuIHIudmFsdWU9ZVtpXSxyLmRvbmU9ITEscjtyZXR1cm4gci52YWx1ZT10LHIuZG9uZT0hMCxyfTtyZXR1cm4gby5uZXh0PW99fXJldHVybntuZXh0OkV9fWZ1bmN0aW9uIEUoKXtyZXR1cm57dmFsdWU6dCxkb25lOiEwfX1yZXR1cm4gXy5wcm90b3R5cGU9bSxjKHcsXCJjb25zdHJ1Y3RvclwiLG0pLGMobSxcImNvbnN0cnVjdG9yXCIsXyksXy5kaXNwbGF5TmFtZT1jKG0sdSxcIkdlbmVyYXRvckZ1bmN0aW9uXCIpLGUuaXNHZW5lcmF0b3JGdW5jdGlvbj1mdW5jdGlvbihlKXt2YXIgdD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiZlLmNvbnN0cnVjdG9yO3JldHVybiEhdCYmKHQ9PT1ffHxcIkdlbmVyYXRvckZ1bmN0aW9uXCI9PT0odC5kaXNwbGF5TmFtZXx8dC5uYW1lKSl9LGUubWFyaz1mdW5jdGlvbihlKXtyZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLG0pOihlLl9fcHJvdG9fXz1tLGMoZSx1LFwiR2VuZXJhdG9yRnVuY3Rpb25cIikpLGUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodyksZX0sZS5hd3JhcD1mdW5jdGlvbihlKXtyZXR1cm57X19hd2FpdDplfX0sayhBLnByb3RvdHlwZSksYyhBLnByb3RvdHlwZSxvLChmdW5jdGlvbigpe3JldHVybiB0aGlzfSkpLGUuQXN5bmNJdGVyYXRvcj1BLGUuYXN5bmM9ZnVuY3Rpb24odCxyLG4saSxzKXt2b2lkIDA9PT1zJiYocz1Qcm9taXNlKTt2YXIgbz1uZXcgQShhKHQscixuLGkpLHMpO3JldHVybiBlLmlzR2VuZXJhdG9yRnVuY3Rpb24ocik/bzpvLm5leHQoKS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gZS5kb25lP2UudmFsdWU6by5uZXh0KCl9KSl9LGsodyksYyh3LHUsXCJHZW5lcmF0b3JcIiksYyh3LHMsKGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSksYyh3LFwidG9TdHJpbmdcIiwoZnVuY3Rpb24oKXtyZXR1cm5cIltvYmplY3QgR2VuZXJhdG9yXVwifSkpLGUua2V5cz1mdW5jdGlvbihlKXt2YXIgdD1bXTtmb3IodmFyIHIgaW4gZSl0LnB1c2gocik7cmV0dXJuIHQucmV2ZXJzZSgpLGZ1bmN0aW9uIHIoKXtmb3IoO3QubGVuZ3RoOyl7dmFyIG49dC5wb3AoKTtpZihuIGluIGUpcmV0dXJuIHIudmFsdWU9bixyLmRvbmU9ITEscn1yZXR1cm4gci5kb25lPSEwLHJ9fSxlLnZhbHVlcz1TLE8ucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpPLHJlc2V0OmZ1bmN0aW9uKGUpe2lmKHRoaXMucHJldj0wLHRoaXMubmV4dD0wLHRoaXMuc2VudD10aGlzLl9zZW50PXQsdGhpcy5kb25lPSExLHRoaXMuZGVsZWdhdGU9bnVsbCx0aGlzLm1ldGhvZD1cIm5leHRcIix0aGlzLmFyZz10LHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKE0pLCFlKWZvcih2YXIgciBpbiB0aGlzKVwidFwiPT09ci5jaGFyQXQoMCkmJm4uY2FsbCh0aGlzLHIpJiYhaXNOYU4oK3Iuc2xpY2UoMSkpJiYodGhpc1tyXT10KX0sc3RvcDpmdW5jdGlvbigpe3RoaXMuZG9uZT0hMDt2YXIgZT10aGlzLnRyeUVudHJpZXNbMF0uY29tcGxldGlvbjtpZihcInRocm93XCI9PT1lLnR5cGUpdGhyb3cgZS5hcmc7cmV0dXJuIHRoaXMucnZhbH0sZGlzcGF0Y2hFeGNlcHRpb246ZnVuY3Rpb24oZSl7aWYodGhpcy5kb25lKXRocm93IGU7dmFyIHI9dGhpcztmdW5jdGlvbiBpKG4saSl7cmV0dXJuIHUudHlwZT1cInRocm93XCIsdS5hcmc9ZSxyLm5leHQ9bixpJiYoci5tZXRob2Q9XCJuZXh0XCIsci5hcmc9dCksISFpfWZvcih2YXIgcz10aGlzLnRyeUVudHJpZXMubGVuZ3RoLTE7cz49MDstLXMpe3ZhciBvPXRoaXMudHJ5RW50cmllc1tzXSx1PW8uY29tcGxldGlvbjtpZihcInJvb3RcIj09PW8udHJ5TG9jKXJldHVybiBpKFwiZW5kXCIpO2lmKG8udHJ5TG9jPD10aGlzLnByZXYpe3ZhciBjPW4uY2FsbChvLFwiY2F0Y2hMb2NcIiksYT1uLmNhbGwobyxcImZpbmFsbHlMb2NcIik7aWYoYyYmYSl7aWYodGhpcy5wcmV2PG8uY2F0Y2hMb2MpcmV0dXJuIGkoby5jYXRjaExvYywhMCk7aWYodGhpcy5wcmV2PG8uZmluYWxseUxvYylyZXR1cm4gaShvLmZpbmFsbHlMb2MpfWVsc2UgaWYoYyl7aWYodGhpcy5wcmV2PG8uY2F0Y2hMb2MpcmV0dXJuIGkoby5jYXRjaExvYywhMCl9ZWxzZXtpZighYSl0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtpZih0aGlzLnByZXY8by5maW5hbGx5TG9jKXJldHVybiBpKG8uZmluYWxseUxvYyl9fX19LGFicnVwdDpmdW5jdGlvbihlLHQpe2Zvcih2YXIgcj10aGlzLnRyeUVudHJpZXMubGVuZ3RoLTE7cj49MDstLXIpe3ZhciBpPXRoaXMudHJ5RW50cmllc1tyXTtpZihpLnRyeUxvYzw9dGhpcy5wcmV2JiZuLmNhbGwoaSxcImZpbmFsbHlMb2NcIikmJnRoaXMucHJldjxpLmZpbmFsbHlMb2Mpe3ZhciBzPWk7YnJlYWt9fXMmJihcImJyZWFrXCI9PT1lfHxcImNvbnRpbnVlXCI9PT1lKSYmcy50cnlMb2M8PXQmJnQ8PXMuZmluYWxseUxvYyYmKHM9bnVsbCk7dmFyIG89cz9zLmNvbXBsZXRpb246e307cmV0dXJuIG8udHlwZT1lLG8uYXJnPXQscz8odGhpcy5tZXRob2Q9XCJuZXh0XCIsdGhpcy5uZXh0PXMuZmluYWxseUxvYyxnKTp0aGlzLmNvbXBsZXRlKG8pfSxjb21wbGV0ZTpmdW5jdGlvbihlLHQpe2lmKFwidGhyb3dcIj09PWUudHlwZSl0aHJvdyBlLmFyZztyZXR1cm5cImJyZWFrXCI9PT1lLnR5cGV8fFwiY29udGludWVcIj09PWUudHlwZT90aGlzLm5leHQ9ZS5hcmc6XCJyZXR1cm5cIj09PWUudHlwZT8odGhpcy5ydmFsPXRoaXMuYXJnPWUuYXJnLHRoaXMubWV0aG9kPVwicmV0dXJuXCIsdGhpcy5uZXh0PVwiZW5kXCIpOlwibm9ybWFsXCI9PT1lLnR5cGUmJnQmJih0aGlzLm5leHQ9dCksZ30sZmluaXNoOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD10aGlzLnRyeUVudHJpZXMubGVuZ3RoLTE7dD49MDstLXQpe3ZhciByPXRoaXMudHJ5RW50cmllc1t0XTtpZihyLmZpbmFsbHlMb2M9PT1lKXJldHVybiB0aGlzLmNvbXBsZXRlKHIuY29tcGxldGlvbixyLmFmdGVyTG9jKSxNKHIpLGd9fSxjYXRjaDpmdW5jdGlvbihlKXtmb3IodmFyIHQ9dGhpcy50cnlFbnRyaWVzLmxlbmd0aC0xO3Q+PTA7LS10KXt2YXIgcj10aGlzLnRyeUVudHJpZXNbdF07aWYoci50cnlMb2M9PT1lKXt2YXIgbj1yLmNvbXBsZXRpb247aWYoXCJ0aHJvd1wiPT09bi50eXBlKXt2YXIgaT1uLmFyZztNKHIpfXJldHVybiBpfX10aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIil9LGRlbGVnYXRlWWllbGQ6ZnVuY3Rpb24oZSxyLG4pe3JldHVybiB0aGlzLmRlbGVnYXRlPXtpdGVyYXRvcjpTKGUpLHJlc3VsdE5hbWU6cixuZXh0TG9jOm59LFwibmV4dFwiPT09dGhpcy5tZXRob2QmJih0aGlzLmFyZz10KSxnfX0sZX0oZS5leHBvcnRzKTt0cnl7cmVnZW5lcmF0b3JSdW50aW1lPXR9Y2F0Y2goZSl7XCJvYmplY3RcIj09dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpcy5yZWdlbmVyYXRvclJ1bnRpbWU9dDpGdW5jdGlvbihcInJcIixcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikodCl9fX0sdD17fTtmdW5jdGlvbiByKG4pe3ZhciBpPXRbbl07aWYodm9pZCAwIT09aSlyZXR1cm4gaS5leHBvcnRzO3ZhciBzPXRbbl09e2V4cG9ydHM6e319O3JldHVybiBlW25dKHMscy5leHBvcnRzLHIpLHMuZXhwb3J0c31yLm49ZT0+e3ZhciB0PWUmJmUuX19lc01vZHVsZT8oKT0+ZS5kZWZhdWx0OigpPT5lO3JldHVybiByLmQodCx7YTp0fSksdH0sci5kPShlLHQpPT57Zm9yKHZhciBuIGluIHQpci5vKHQsbikmJiFyLm8oZSxuKSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbix7ZW51bWVyYWJsZTohMCxnZXQ6dFtuXX0pfSxyLm89KGUsdCk9Pk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpO3ZhciBuPXt9O3JldHVybigoKT0+e1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGUoZSx0KXsobnVsbD09dHx8dD5lLmxlbmd0aCkmJih0PWUubGVuZ3RoKTtmb3IodmFyIHI9MCxuPW5ldyBBcnJheSh0KTtyPHQ7cisrKW5bcl09ZVtyXTtyZXR1cm4gbn1mdW5jdGlvbiB0KGUpe3JldHVybiB0PVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9LHQoZSl9ZnVuY3Rpb24gaShlLHQscixuLGkscyxvKXt0cnl7dmFyIHU9ZVtzXShvKSxjPXUudmFsdWV9Y2F0Y2goZSl7cmV0dXJuIHZvaWQgcihlKX11LmRvbmU/dChjKTpQcm9taXNlLnJlc29sdmUoYykudGhlbihuLGkpfWZ1bmN0aW9uIHMoZSl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxyPWFyZ3VtZW50cztyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKG4scyl7dmFyIG89ZS5hcHBseSh0LHIpO2Z1bmN0aW9uIHUoZSl7aShvLG4scyx1LGMsXCJuZXh0XCIsZSl9ZnVuY3Rpb24gYyhlKXtpKG8sbixzLHUsYyxcInRocm93XCIsZSl9dSh2b2lkIDApfSkpfX1mdW5jdGlvbiBvKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiB1KGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBuPXRbcl07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4ua2V5LG4pfX1mdW5jdGlvbiBjKGUsdCxyKXtyZXR1cm4gdCYmdShlLnByb3RvdHlwZSx0KSxyJiZ1KGUsciksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJwcm90b3R5cGVcIix7d3JpdGFibGU6ITF9KSxlfWZ1bmN0aW9uIGEoZSl7aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIGV9ZnVuY3Rpb24gcChlLHQpe3JldHVybiBwPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5fX3Byb3RvX189dCxlfSxwKGUsdCl9ZnVuY3Rpb24gZChlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJwcm90b3R5cGVcIix7d3JpdGFibGU6ITF9KSx0JiZwKGUsdCl9ZnVuY3Rpb24gaChlLHIpe2lmKHImJihcIm9iamVjdFwiPT09dChyKXx8XCJmdW5jdGlvblwiPT10eXBlb2YgcikpcmV0dXJuIHI7aWYodm9pZCAwIT09cil0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7cmV0dXJuIGEoZSl9ZnVuY3Rpb24geShlKXtyZXR1cm4geT1PYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKGUpe3JldHVybiBlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpfSx5KGUpfXIuZChuLHtkZWZhdWx0OigpPT5GZX0pO3ZhciBsPXIoNzU3KSxnPXIubihsKTtmdW5jdGlvbiBmKCl7cmV0dXJuIEVycm9yLmNhbGwodGhpcyksdGhpcy5tZXNzYWdlPVwibm8gZWxlbWVudHMgaW4gc2VxdWVuY2VcIix0aGlzLm5hbWU9XCJFbXB0eUVycm9yXCIsdGhpc31mLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7dmFyIF89ZixtPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG09T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKGUsdCl7ZS5fX3Byb3RvX189dH18fGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIHQpdC5oYXNPd25Qcm9wZXJ0eShyKSYmKGVbcl09dFtyXSl9LG0oZSx0KX07ZnVuY3Rpb24gdihlLHQpe2Z1bmN0aW9uIHIoKXt0aGlzLmNvbnN0cnVjdG9yPWV9bShlLHQpLGUucHJvdG90eXBlPW51bGw9PT10P09iamVjdC5jcmVhdGUodCk6KHIucHJvdG90eXBlPXQucHJvdG90eXBlLG5ldyByKX1mdW5jdGlvbiBxKGUpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGV9dmFyIGI9ITEsdz17UHJvbWlzZTp2b2lkIDAsc2V0IHVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcoZSl7ZSYmKG5ldyBFcnJvcikuc3RhY2ssYj1lfSxnZXQgdXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZygpe3JldHVybiBifX07ZnVuY3Rpb24gayhlKXtzZXRUaW1lb3V0KChmdW5jdGlvbigpe3Rocm93IGV9KSwwKX12YXIgQT17Y2xvc2VkOiEwLG5leHQ6ZnVuY3Rpb24oZSl7fSxlcnJvcjpmdW5jdGlvbihlKXtpZih3LnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcpdGhyb3cgZTtrKGUpfSxjb21wbGV0ZTpmdW5jdGlvbigpe319LHg9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwibnVtYmVyXCI9PXR5cGVvZiBlLmxlbmd0aH07ZnVuY3Rpb24gUihlKXtyZXR1cm4gRXJyb3IuY2FsbCh0aGlzKSx0aGlzLm1lc3NhZ2U9ZT9lLmxlbmd0aCtcIiBlcnJvcnMgb2NjdXJyZWQgZHVyaW5nIHVuc3Vic2NyaXB0aW9uOlxcblwiK2UubWFwKChmdW5jdGlvbihlLHQpe3JldHVybiB0KzErXCIpIFwiK2UudG9TdHJpbmcoKX0pKS5qb2luKFwiXFxuICBcIik6XCJcIix0aGlzLm5hbWU9XCJVbnN1YnNjcmlwdGlvbkVycm9yXCIsdGhpcy5lcnJvcnM9ZSx0aGlzfVIucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTt2YXIgTT1SLE89ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe3RoaXMuY2xvc2VkPSExLHRoaXMuX3BhcmVudE9yUGFyZW50cz1udWxsLHRoaXMuX3N1YnNjcmlwdGlvbnM9bnVsbCxlJiYodGhpcy5fdW5zdWJzY3JpYmU9ZSl9cmV0dXJuIGUucHJvdG90eXBlLnVuc3Vic2NyaWJlPWZ1bmN0aW9uKCl7dmFyIHQ7aWYoIXRoaXMuY2xvc2VkKXt2YXIgcixuPXRoaXMsaT1uLl9wYXJlbnRPclBhcmVudHMscz1uLl91bnN1YnNjcmliZSxvPW4uX3N1YnNjcmlwdGlvbnM7aWYodGhpcy5jbG9zZWQ9ITAsdGhpcy5fcGFyZW50T3JQYXJlbnRzPW51bGwsdGhpcy5fc3Vic2NyaXB0aW9ucz1udWxsLGkgaW5zdGFuY2VvZiBlKWkucmVtb3ZlKHRoaXMpO2Vsc2UgaWYobnVsbCE9PWkpZm9yKHZhciB1PTA7dTxpLmxlbmd0aDsrK3UpaVt1XS5yZW1vdmUodGhpcyk7aWYocShzKSl0cnl7cy5jYWxsKHRoaXMpfWNhdGNoKGUpe3Q9ZSBpbnN0YW5jZW9mIE0/UyhlLmVycm9ycyk6W2VdfWlmKHgobykpe3U9LTE7Zm9yKHZhciBjPW8ubGVuZ3RoOysrdTxjOyl7dmFyIGE9b1t1XTtpZihudWxsIT09KHI9YSkmJlwib2JqZWN0XCI9PXR5cGVvZiByKXRyeXthLnVuc3Vic2NyaWJlKCl9Y2F0Y2goZSl7dD10fHxbXSxlIGluc3RhbmNlb2YgTT90PXQuY29uY2F0KFMoZS5lcnJvcnMpKTp0LnB1c2goZSl9fX1pZih0KXRocm93IG5ldyBNKHQpfX0sZS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3ZhciByPXQ7aWYoIXQpcmV0dXJuIGUuRU1QVFk7c3dpdGNoKHR5cGVvZiB0KXtjYXNlXCJmdW5jdGlvblwiOnI9bmV3IGUodCk7Y2FzZVwib2JqZWN0XCI6aWYocj09PXRoaXN8fHIuY2xvc2VkfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiByLnVuc3Vic2NyaWJlKXJldHVybiByO2lmKHRoaXMuY2xvc2VkKXJldHVybiByLnVuc3Vic2NyaWJlKCkscjtpZighKHIgaW5zdGFuY2VvZiBlKSl7dmFyIG49cjsocj1uZXcgZSkuX3N1YnNjcmlwdGlvbnM9W25dfWJyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwidW5yZWNvZ25pemVkIHRlYXJkb3duIFwiK3QrXCIgYWRkZWQgdG8gU3Vic2NyaXB0aW9uLlwiKX12YXIgaT1yLl9wYXJlbnRPclBhcmVudHM7aWYobnVsbD09PWkpci5fcGFyZW50T3JQYXJlbnRzPXRoaXM7ZWxzZSBpZihpIGluc3RhbmNlb2YgZSl7aWYoaT09PXRoaXMpcmV0dXJuIHI7ci5fcGFyZW50T3JQYXJlbnRzPVtpLHRoaXNdfWVsc2V7aWYoLTEhPT1pLmluZGV4T2YodGhpcykpcmV0dXJuIHI7aS5wdXNoKHRoaXMpfXZhciBzPXRoaXMuX3N1YnNjcmlwdGlvbnM7cmV0dXJuIG51bGw9PT1zP3RoaXMuX3N1YnNjcmlwdGlvbnM9W3JdOnMucHVzaChyKSxyfSxlLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5fc3Vic2NyaXB0aW9ucztpZih0KXt2YXIgcj10LmluZGV4T2YoZSk7LTEhPT1yJiZ0LnNwbGljZShyLDEpfX0sZS5FTVBUWT1mdW5jdGlvbihlKXtyZXR1cm4gZS5jbG9zZWQ9ITAsZX0obmV3IGUpLGV9KCk7ZnVuY3Rpb24gUyhlKXtyZXR1cm4gZS5yZWR1Y2UoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuY29uY2F0KHQgaW5zdGFuY2VvZiBNP3QuZXJyb3JzOnQpfSksW10pfXZhciBFPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbD9TeW1ib2woXCJyeFN1YnNjcmliZXJcIik6XCJAQHJ4U3Vic2NyaWJlcl9cIitNYXRoLnJhbmRvbSgpLGo9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChyLG4saSl7dmFyIHM9ZS5jYWxsKHRoaXMpfHx0aGlzO3N3aXRjaChzLnN5bmNFcnJvclZhbHVlPW51bGwscy5zeW5jRXJyb3JUaHJvd249ITEscy5zeW5jRXJyb3JUaHJvd2FibGU9ITEscy5pc1N0b3BwZWQ9ITEsYXJndW1lbnRzLmxlbmd0aCl7Y2FzZSAwOnMuZGVzdGluYXRpb249QTticmVhaztjYXNlIDE6aWYoIXIpe3MuZGVzdGluYXRpb249QTticmVha31pZihcIm9iamVjdFwiPT10eXBlb2Ygcil7ciBpbnN0YW5jZW9mIHQ/KHMuc3luY0Vycm9yVGhyb3dhYmxlPXIuc3luY0Vycm9yVGhyb3dhYmxlLHMuZGVzdGluYXRpb249cixyLmFkZChzKSk6KHMuc3luY0Vycm9yVGhyb3dhYmxlPSEwLHMuZGVzdGluYXRpb249bmV3IFAocyxyKSk7YnJlYWt9ZGVmYXVsdDpzLnN5bmNFcnJvclRocm93YWJsZT0hMCxzLmRlc3RpbmF0aW9uPW5ldyBQKHMscixuLGkpfXJldHVybiBzfXJldHVybiB2KHQsZSksdC5wcm90b3R5cGVbRV09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sdC5jcmVhdGU9ZnVuY3Rpb24oZSxyLG4pe3ZhciBpPW5ldyB0KGUscixuKTtyZXR1cm4gaS5zeW5jRXJyb3JUaHJvd2FibGU9ITEsaX0sdC5wcm90b3R5cGUubmV4dD1mdW5jdGlvbihlKXt0aGlzLmlzU3RvcHBlZHx8dGhpcy5fbmV4dChlKX0sdC5wcm90b3R5cGUuZXJyb3I9ZnVuY3Rpb24oZSl7dGhpcy5pc1N0b3BwZWR8fCh0aGlzLmlzU3RvcHBlZD0hMCx0aGlzLl9lcnJvcihlKSl9LHQucHJvdG90eXBlLmNvbXBsZXRlPWZ1bmN0aW9uKCl7dGhpcy5pc1N0b3BwZWR8fCh0aGlzLmlzU3RvcHBlZD0hMCx0aGlzLl9jb21wbGV0ZSgpKX0sdC5wcm90b3R5cGUudW5zdWJzY3JpYmU9ZnVuY3Rpb24oKXt0aGlzLmNsb3NlZHx8KHRoaXMuaXNTdG9wcGVkPSEwLGUucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcykpfSx0LnByb3RvdHlwZS5fbmV4dD1mdW5jdGlvbihlKXt0aGlzLmRlc3RpbmF0aW9uLm5leHQoZSl9LHQucHJvdG90eXBlLl9lcnJvcj1mdW5jdGlvbihlKXt0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGUpLHRoaXMudW5zdWJzY3JpYmUoKX0sdC5wcm90b3R5cGUuX2NvbXBsZXRlPWZ1bmN0aW9uKCl7dGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpLHRoaXMudW5zdWJzY3JpYmUoKX0sdC5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlQW5kUmVjeWNsZT1mdW5jdGlvbigpe3ZhciBlPXRoaXMuX3BhcmVudE9yUGFyZW50cztyZXR1cm4gdGhpcy5fcGFyZW50T3JQYXJlbnRzPW51bGwsdGhpcy51bnN1YnNjcmliZSgpLHRoaXMuY2xvc2VkPSExLHRoaXMuaXNTdG9wcGVkPSExLHRoaXMuX3BhcmVudE9yUGFyZW50cz1lLHRoaXN9LHR9KE8pLFA9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0LHIsbixpKXt2YXIgcyxvPWUuY2FsbCh0aGlzKXx8dGhpcztvLl9wYXJlbnRTdWJzY3JpYmVyPXQ7dmFyIHU9bztyZXR1cm4gcShyKT9zPXI6ciYmKHM9ci5uZXh0LG49ci5lcnJvcixpPXIuY29tcGxldGUsciE9PUEmJihxKCh1PU9iamVjdC5jcmVhdGUocikpLnVuc3Vic2NyaWJlKSYmby5hZGQodS51bnN1YnNjcmliZS5iaW5kKHUpKSx1LnVuc3Vic2NyaWJlPW8udW5zdWJzY3JpYmUuYmluZChvKSkpLG8uX2NvbnRleHQ9dSxvLl9uZXh0PXMsby5fZXJyb3I9bixvLl9jb21wbGV0ZT1pLG99cmV0dXJuIHYodCxlKSx0LnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKGUpe2lmKCF0aGlzLmlzU3RvcHBlZCYmdGhpcy5fbmV4dCl7dmFyIHQ9dGhpcy5fcGFyZW50U3Vic2NyaWJlcjt3LnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcmJnQuc3luY0Vycm9yVGhyb3dhYmxlP3RoaXMuX190cnlPclNldEVycm9yKHQsdGhpcy5fbmV4dCxlKSYmdGhpcy51bnN1YnNjcmliZSgpOnRoaXMuX190cnlPclVuc3ViKHRoaXMuX25leHQsZSl9fSx0LnByb3RvdHlwZS5lcnJvcj1mdW5jdGlvbihlKXtpZighdGhpcy5pc1N0b3BwZWQpe3ZhciB0PXRoaXMuX3BhcmVudFN1YnNjcmliZXIscj13LnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmc7aWYodGhpcy5fZXJyb3IpciYmdC5zeW5jRXJyb3JUaHJvd2FibGU/KHRoaXMuX190cnlPclNldEVycm9yKHQsdGhpcy5fZXJyb3IsZSksdGhpcy51bnN1YnNjcmliZSgpKToodGhpcy5fX3RyeU9yVW5zdWIodGhpcy5fZXJyb3IsZSksdGhpcy51bnN1YnNjcmliZSgpKTtlbHNlIGlmKHQuc3luY0Vycm9yVGhyb3dhYmxlKXI/KHQuc3luY0Vycm9yVmFsdWU9ZSx0LnN5bmNFcnJvclRocm93bj0hMCk6ayhlKSx0aGlzLnVuc3Vic2NyaWJlKCk7ZWxzZXtpZih0aGlzLnVuc3Vic2NyaWJlKCkscil0aHJvdyBlO2soZSl9fX0sdC5wcm90b3R5cGUuY29tcGxldGU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO2lmKCF0aGlzLmlzU3RvcHBlZCl7dmFyIHQ9dGhpcy5fcGFyZW50U3Vic2NyaWJlcjtpZih0aGlzLl9jb21wbGV0ZSl7dmFyIHI9ZnVuY3Rpb24oKXtyZXR1cm4gZS5fY29tcGxldGUuY2FsbChlLl9jb250ZXh0KX07dy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nJiZ0LnN5bmNFcnJvclRocm93YWJsZT8odGhpcy5fX3RyeU9yU2V0RXJyb3IodCxyKSx0aGlzLnVuc3Vic2NyaWJlKCkpOih0aGlzLl9fdHJ5T3JVbnN1YihyKSx0aGlzLnVuc3Vic2NyaWJlKCkpfWVsc2UgdGhpcy51bnN1YnNjcmliZSgpfX0sdC5wcm90b3R5cGUuX190cnlPclVuc3ViPWZ1bmN0aW9uKGUsdCl7dHJ5e2UuY2FsbCh0aGlzLl9jb250ZXh0LHQpfWNhdGNoKGUpe2lmKHRoaXMudW5zdWJzY3JpYmUoKSx3LnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcpdGhyb3cgZTtrKGUpfX0sdC5wcm90b3R5cGUuX190cnlPclNldEVycm9yPWZ1bmN0aW9uKGUsdCxyKXtpZighdy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nKXRocm93IG5ldyBFcnJvcihcImJhZCBjYWxsXCIpO3RyeXt0LmNhbGwodGhpcy5fY29udGV4dCxyKX1jYXRjaCh0KXtyZXR1cm4gdy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nPyhlLnN5bmNFcnJvclZhbHVlPXQsZS5zeW5jRXJyb3JUaHJvd249ITAsITApOihrKHQpLCEwKX1yZXR1cm4hMX0sdC5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5fcGFyZW50U3Vic2NyaWJlcjt0aGlzLl9jb250ZXh0PW51bGwsdGhpcy5fcGFyZW50U3Vic2NyaWJlcj1udWxsLGUudW5zdWJzY3JpYmUoKX0sdH0oaik7ZnVuY3Rpb24gQyhlLHQpe3JldHVybiBmdW5jdGlvbihyKXtyZXR1cm4gci5saWZ0KG5ldyBUKGUsdCkpfX12YXIgVD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXt0aGlzLnByZWRpY2F0ZT1lLHRoaXMudGhpc0FyZz10fXJldHVybiBlLnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQuc3Vic2NyaWJlKG5ldyBMKGUsdGhpcy5wcmVkaWNhdGUsdGhpcy50aGlzQXJnKSl9LGV9KCksTD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQscixuKXt2YXIgaT1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gaS5wcmVkaWNhdGU9cixpLnRoaXNBcmc9bixpLmNvdW50PTAsaX1yZXR1cm4gdih0LGUpLHQucHJvdG90eXBlLl9uZXh0PWZ1bmN0aW9uKGUpe3ZhciB0O3RyeXt0PXRoaXMucHJlZGljYXRlLmNhbGwodGhpcy50aGlzQXJnLGUsdGhpcy5jb3VudCsrKX1jYXRjaChlKXtyZXR1cm4gdm9pZCB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGUpfXQmJnRoaXMuZGVzdGluYXRpb24ubmV4dChlKX0sdH0oaik7ZnVuY3Rpb24gRCgpe3JldHVybiBFcnJvci5jYWxsKHRoaXMpLHRoaXMubWVzc2FnZT1cImFyZ3VtZW50IG91dCBvZiByYW5nZVwiLHRoaXMubmFtZT1cIkFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yXCIsdGhpc31ELnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7dmFyIEk9RCxCPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLm9ic2VydmFibGV8fFwiQEBvYnNlcnZhYmxlXCI7ZnVuY3Rpb24gSCgpe31mdW5jdGlvbiBOKGUpe3JldHVybiBlPzE9PT1lLmxlbmd0aD9lWzBdOmZ1bmN0aW9uKHQpe3JldHVybiBlLnJlZHVjZSgoZnVuY3Rpb24oZSx0KXtyZXR1cm4gdChlKX0pLHQpfTpIfXZhciBGPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXt0aGlzLl9pc1NjYWxhcj0hMSxlJiYodGhpcy5fc3Vic2NyaWJlPWUpfXJldHVybiBlLnByb3RvdHlwZS5saWZ0PWZ1bmN0aW9uKHQpe3ZhciByPW5ldyBlO3JldHVybiByLnNvdXJjZT10aGlzLHIub3BlcmF0b3I9dCxyfSxlLnByb3RvdHlwZS5zdWJzY3JpYmU9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXRoaXMub3BlcmF0b3IsaT1mdW5jdGlvbihlLHQscil7aWYoZSl7aWYoZSBpbnN0YW5jZW9mIGopcmV0dXJuIGU7aWYoZVtFXSlyZXR1cm4gZVtFXSgpfXJldHVybiBlfHx0fHxyP25ldyBqKGUsdCxyKTpuZXcgaihBKX0oZSx0LHIpO2lmKG4/aS5hZGQobi5jYWxsKGksdGhpcy5zb3VyY2UpKTppLmFkZCh0aGlzLnNvdXJjZXx8dy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nJiYhaS5zeW5jRXJyb3JUaHJvd2FibGU/dGhpcy5fc3Vic2NyaWJlKGkpOnRoaXMuX3RyeVN1YnNjcmliZShpKSksdy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nJiZpLnN5bmNFcnJvclRocm93YWJsZSYmKGkuc3luY0Vycm9yVGhyb3dhYmxlPSExLGkuc3luY0Vycm9yVGhyb3duKSl0aHJvdyBpLnN5bmNFcnJvclZhbHVlO3JldHVybiBpfSxlLnByb3RvdHlwZS5fdHJ5U3Vic2NyaWJlPWZ1bmN0aW9uKGUpe3RyeXtyZXR1cm4gdGhpcy5fc3Vic2NyaWJlKGUpfWNhdGNoKHQpe3cudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZyYmKGUuc3luY0Vycm9yVGhyb3duPSEwLGUuc3luY0Vycm9yVmFsdWU9dCksZnVuY3Rpb24oZSl7Zm9yKDtlOyl7dmFyIHQ9ZSxyPXQuY2xvc2VkLG49dC5kZXN0aW5hdGlvbixpPXQuaXNTdG9wcGVkO2lmKHJ8fGkpcmV0dXJuITE7ZT1uJiZuIGluc3RhbmNlb2Ygaj9uOm51bGx9cmV0dXJuITB9KGUpP2UuZXJyb3IodCk6Y29uc29sZS53YXJuKHQpfX0sZS5wcm90b3R5cGUuZm9yRWFjaD1mdW5jdGlvbihlLHQpe3ZhciByPXRoaXM7cmV0dXJuIG5ldyh0PVUodCkpKChmdW5jdGlvbih0LG4pe3ZhciBpO2k9ci5zdWJzY3JpYmUoKGZ1bmN0aW9uKHQpe3RyeXtlKHQpfWNhdGNoKGUpe24oZSksaSYmaS51bnN1YnNjcmliZSgpfX0pLG4sdCl9KSl9LGUucHJvdG90eXBlLl9zdWJzY3JpYmU9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5zb3VyY2U7cmV0dXJuIHQmJnQuc3Vic2NyaWJlKGUpfSxlLnByb3RvdHlwZVtCXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxlLnByb3RvdHlwZS5waXBlPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKWVbdF09YXJndW1lbnRzW3RdO3JldHVybiAwPT09ZS5sZW5ndGg/dGhpczpOKGUpKHRoaXMpfSxlLnByb3RvdHlwZS50b1Byb21pc2U9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gbmV3KGU9VShlKSkoKGZ1bmN0aW9uKGUscil7dmFyIG47dC5zdWJzY3JpYmUoKGZ1bmN0aW9uKGUpe3JldHVybiBuPWV9KSwoZnVuY3Rpb24oZSl7cmV0dXJuIHIoZSl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gZShuKX0pKX0pKX0sZS5jcmVhdGU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpfSxlfSgpO2Z1bmN0aW9uIFUoZSl7aWYoZXx8KGU9dy5Qcm9taXNlfHxQcm9taXNlKSwhZSl0aHJvdyBuZXcgRXJyb3IoXCJubyBQcm9taXNlIGltcGwgZm91bmRcIik7cmV0dXJuIGV9dmFyIFY9bmV3IEYoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbXBsZXRlKCl9KSk7ZnVuY3Rpb24gRyhlKXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIDA9PT1lP3I/ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBGKChmdW5jdGlvbih0KXtyZXR1cm4gZS5zY2hlZHVsZSgoZnVuY3Rpb24oKXtyZXR1cm4gdC5jb21wbGV0ZSgpfSkpfSkpfShyKTpWOnQubGlmdChuZXcgSihlKSk7dmFyIHJ9fXZhciBKPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZih0aGlzLnRvdGFsPWUsdGhpcy50b3RhbDwwKXRocm93IG5ldyBJfXJldHVybiBlLnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQuc3Vic2NyaWJlKG5ldyB6KGUsdGhpcy50b3RhbCkpfSxlfSgpLHo9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0LHIpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLnRvdGFsPXIsbi5jb3VudD0wLG59cmV0dXJuIHYodCxlKSx0LnByb3RvdHlwZS5fbmV4dD1mdW5jdGlvbihlKXt2YXIgdD10aGlzLnRvdGFsLHI9Kyt0aGlzLmNvdW50O3I8PXQmJih0aGlzLmRlc3RpbmF0aW9uLm5leHQoZSkscj09PXQmJih0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCksdGhpcy51bnN1YnNjcmliZSgpKSl9LHR9KGopO2Z1bmN0aW9uIFcoZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPW51bGwpLGZ1bmN0aW9uKHQpe3JldHVybiB0LmxpZnQobmV3IFkoZSkpfX12YXIgWT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7dGhpcy5kZWZhdWx0VmFsdWU9ZX1yZXR1cm4gZS5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3JldHVybiB0LnN1YnNjcmliZShuZXcgSyhlLHRoaXMuZGVmYXVsdFZhbHVlKSl9LGV9KCksSz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQscil7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuIG4uZGVmYXVsdFZhbHVlPXIsbi5pc0VtcHR5PSEwLG59cmV0dXJuIHYodCxlKSx0LnByb3RvdHlwZS5fbmV4dD1mdW5jdGlvbihlKXt0aGlzLmlzRW1wdHk9ITEsdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGUpfSx0LnByb3RvdHlwZS5fY29tcGxldGU9ZnVuY3Rpb24oKXt0aGlzLmlzRW1wdHkmJnRoaXMuZGVzdGluYXRpb24ubmV4dCh0aGlzLmRlZmF1bHRWYWx1ZSksdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpfSx0fShqKTtmdW5jdGlvbiAkKGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1aKSxmdW5jdGlvbih0KXtyZXR1cm4gdC5saWZ0KG5ldyBRKGUpKX19dmFyIFE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe3RoaXMuZXJyb3JGYWN0b3J5PWV9cmV0dXJuIGUucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdC5zdWJzY3JpYmUobmV3IFgoZSx0aGlzLmVycm9yRmFjdG9yeSkpfSxlfSgpLFg9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0LHIpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLmVycm9yRmFjdG9yeT1yLG4uaGFzVmFsdWU9ITEsbn1yZXR1cm4gdih0LGUpLHQucHJvdG90eXBlLl9uZXh0PWZ1bmN0aW9uKGUpe3RoaXMuaGFzVmFsdWU9ITAsdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGUpfSx0LnByb3RvdHlwZS5fY29tcGxldGU9ZnVuY3Rpb24oKXtpZih0aGlzLmhhc1ZhbHVlKXJldHVybiB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7dmFyIGU9dm9pZCAwO3RyeXtlPXRoaXMuZXJyb3JGYWN0b3J5KCl9Y2F0Y2godCl7ZT10fXRoaXMuZGVzdGluYXRpb24uZXJyb3IoZSl9LHR9KGopO2Z1bmN0aW9uIFooKXtyZXR1cm4gbmV3IF99ZnVuY3Rpb24gZWUoZSl7cmV0dXJuIGV9ZnVuY3Rpb24gdGUoZSx0KXt2YXIgcj1hcmd1bWVudHMubGVuZ3RoPj0yO3JldHVybiBmdW5jdGlvbihuKXtyZXR1cm4gbi5waXBlKGU/QygoZnVuY3Rpb24odCxyKXtyZXR1cm4gZSh0LHIsbil9KSk6ZWUsRygxKSxyP1codCk6JCgoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IF99KSkpfX1mdW5jdGlvbiByZSgpe3JldHVybiBFcnJvci5jYWxsKHRoaXMpLHRoaXMubWVzc2FnZT1cIm9iamVjdCB1bnN1YnNjcmliZWRcIix0aGlzLm5hbWU9XCJPYmplY3RVbnN1YnNjcmliZWRFcnJvclwiLHRoaXN9cmUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTt2YXIgbmU9cmUsaWU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0LHIpe3ZhciBuPWUuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi5zdWJqZWN0PXQsbi5zdWJzY3JpYmVyPXIsbi5jbG9zZWQ9ITEsbn1yZXR1cm4gdih0LGUpLHQucHJvdG90eXBlLnVuc3Vic2NyaWJlPWZ1bmN0aW9uKCl7aWYoIXRoaXMuY2xvc2VkKXt0aGlzLmNsb3NlZD0hMDt2YXIgZT10aGlzLnN1YmplY3QsdD1lLm9ic2VydmVycztpZih0aGlzLnN1YmplY3Q9bnVsbCx0JiYwIT09dC5sZW5ndGgmJiFlLmlzU3RvcHBlZCYmIWUuY2xvc2VkKXt2YXIgcj10LmluZGV4T2YodGhpcy5zdWJzY3JpYmVyKTstMSE9PXImJnQuc3BsaWNlKHIsMSl9fX0sdH0oTyksc2U9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgcj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gci5kZXN0aW5hdGlvbj10LHJ9cmV0dXJuIHYodCxlKSx0fShqKSxvZT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7dmFyIHQ9ZS5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiB0Lm9ic2VydmVycz1bXSx0LmNsb3NlZD0hMSx0LmlzU3RvcHBlZD0hMSx0Lmhhc0Vycm9yPSExLHQudGhyb3duRXJyb3I9bnVsbCx0fXJldHVybiB2KHQsZSksdC5wcm90b3R5cGVbRV09ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHNlKHRoaXMpfSx0LnByb3RvdHlwZS5saWZ0PWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyB1ZSh0aGlzLHRoaXMpO3JldHVybiB0Lm9wZXJhdG9yPWUsdH0sdC5wcm90b3R5cGUubmV4dD1mdW5jdGlvbihlKXtpZih0aGlzLmNsb3NlZCl0aHJvdyBuZXcgbmU7aWYoIXRoaXMuaXNTdG9wcGVkKWZvcih2YXIgdD10aGlzLm9ic2VydmVycyxyPXQubGVuZ3RoLG49dC5zbGljZSgpLGk9MDtpPHI7aSsrKW5baV0ubmV4dChlKX0sdC5wcm90b3R5cGUuZXJyb3I9ZnVuY3Rpb24oZSl7aWYodGhpcy5jbG9zZWQpdGhyb3cgbmV3IG5lO3RoaXMuaGFzRXJyb3I9ITAsdGhpcy50aHJvd25FcnJvcj1lLHRoaXMuaXNTdG9wcGVkPSEwO2Zvcih2YXIgdD10aGlzLm9ic2VydmVycyxyPXQubGVuZ3RoLG49dC5zbGljZSgpLGk9MDtpPHI7aSsrKW5baV0uZXJyb3IoZSk7dGhpcy5vYnNlcnZlcnMubGVuZ3RoPTB9LHQucHJvdG90eXBlLmNvbXBsZXRlPWZ1bmN0aW9uKCl7aWYodGhpcy5jbG9zZWQpdGhyb3cgbmV3IG5lO3RoaXMuaXNTdG9wcGVkPSEwO2Zvcih2YXIgZT10aGlzLm9ic2VydmVycyx0PWUubGVuZ3RoLHI9ZS5zbGljZSgpLG49MDtuPHQ7bisrKXJbbl0uY29tcGxldGUoKTt0aGlzLm9ic2VydmVycy5sZW5ndGg9MH0sdC5wcm90b3R5cGUudW5zdWJzY3JpYmU9ZnVuY3Rpb24oKXt0aGlzLmlzU3RvcHBlZD0hMCx0aGlzLmNsb3NlZD0hMCx0aGlzLm9ic2VydmVycz1udWxsfSx0LnByb3RvdHlwZS5fdHJ5U3Vic2NyaWJlPWZ1bmN0aW9uKHQpe2lmKHRoaXMuY2xvc2VkKXRocm93IG5ldyBuZTtyZXR1cm4gZS5wcm90b3R5cGUuX3RyeVN1YnNjcmliZS5jYWxsKHRoaXMsdCl9LHQucHJvdG90eXBlLl9zdWJzY3JpYmU9ZnVuY3Rpb24oZSl7aWYodGhpcy5jbG9zZWQpdGhyb3cgbmV3IG5lO3JldHVybiB0aGlzLmhhc0Vycm9yPyhlLmVycm9yKHRoaXMudGhyb3duRXJyb3IpLE8uRU1QVFkpOnRoaXMuaXNTdG9wcGVkPyhlLmNvbXBsZXRlKCksTy5FTVBUWSk6KHRoaXMub2JzZXJ2ZXJzLnB1c2goZSksbmV3IGllKHRoaXMsZSkpfSx0LnByb3RvdHlwZS5hc09ic2VydmFibGU9ZnVuY3Rpb24oKXt2YXIgZT1uZXcgRjtyZXR1cm4gZS5zb3VyY2U9dGhpcyxlfSx0LmNyZWF0ZT1mdW5jdGlvbihlLHQpe3JldHVybiBuZXcgdWUoZSx0KX0sdH0oRiksdWU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0LHIpe3ZhciBuPWUuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi5kZXN0aW5hdGlvbj10LG4uc291cmNlPXIsbn1yZXR1cm4gdih0LGUpLHQucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5kZXN0aW5hdGlvbjt0JiZ0Lm5leHQmJnQubmV4dChlKX0sdC5wcm90b3R5cGUuZXJyb3I9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5kZXN0aW5hdGlvbjt0JiZ0LmVycm9yJiZ0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGUpfSx0LnByb3RvdHlwZS5jb21wbGV0ZT1mdW5jdGlvbigpe3ZhciBlPXRoaXMuZGVzdGluYXRpb247ZSYmZS5jb21wbGV0ZSYmdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpfSx0LnByb3RvdHlwZS5fc3Vic2NyaWJlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnNvdXJjZT90aGlzLnNvdXJjZS5zdWJzY3JpYmUoZSk6Ty5FTVBUWX0sdH0ob2UpO2Z1bmN0aW9uIGNlKCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBlLmxpZnQobmV3IGFlKGUpKX19dmFyIGFlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXt0aGlzLmNvbm5lY3RhYmxlPWV9cmV0dXJuIGUucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLmNvbm5lY3RhYmxlO3IuX3JlZkNvdW50Kys7dmFyIG49bmV3IHBlKGUsciksaT10LnN1YnNjcmliZShuKTtyZXR1cm4gbi5jbG9zZWR8fChuLmNvbm5lY3Rpb249ci5jb25uZWN0KCkpLGl9LGV9KCkscGU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0LHIpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLmNvbm5lY3RhYmxlPXIsbn1yZXR1cm4gdih0LGUpLHQucHJvdG90eXBlLl91bnN1YnNjcmliZT1mdW5jdGlvbigpe3ZhciBlPXRoaXMuY29ubmVjdGFibGU7aWYoZSl7dGhpcy5jb25uZWN0YWJsZT1udWxsO3ZhciB0PWUuX3JlZkNvdW50O2lmKHQ8PTApdGhpcy5jb25uZWN0aW9uPW51bGw7ZWxzZSBpZihlLl9yZWZDb3VudD10LTEsdD4xKXRoaXMuY29ubmVjdGlvbj1udWxsO2Vsc2V7dmFyIHI9dGhpcy5jb25uZWN0aW9uLG49ZS5fY29ubmVjdGlvbjt0aGlzLmNvbm5lY3Rpb249bnVsbCwhbnx8ciYmbiE9PXJ8fG4udW5zdWJzY3JpYmUoKX19ZWxzZSB0aGlzLmNvbm5lY3Rpb249bnVsbH0sdH0oaiksZGU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0LHIpe3ZhciBuPWUuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi5zb3VyY2U9dCxuLnN1YmplY3RGYWN0b3J5PXIsbi5fcmVmQ291bnQ9MCxuLl9pc0NvbXBsZXRlPSExLG59cmV0dXJuIHYodCxlKSx0LnByb3RvdHlwZS5fc3Vic2NyaWJlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmdldFN1YmplY3QoKS5zdWJzY3JpYmUoZSl9LHQucHJvdG90eXBlLmdldFN1YmplY3Q9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLl9zdWJqZWN0O3JldHVybiBlJiYhZS5pc1N0b3BwZWR8fCh0aGlzLl9zdWJqZWN0PXRoaXMuc3ViamVjdEZhY3RvcnkoKSksdGhpcy5fc3ViamVjdH0sdC5wcm90b3R5cGUuY29ubmVjdD1mdW5jdGlvbigpe3ZhciBlPXRoaXMuX2Nvbm5lY3Rpb247cmV0dXJuIGV8fCh0aGlzLl9pc0NvbXBsZXRlPSExLChlPXRoaXMuX2Nvbm5lY3Rpb249bmV3IE8pLmFkZCh0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IHllKHRoaXMuZ2V0U3ViamVjdCgpLHRoaXMpKSksZS5jbG9zZWQmJih0aGlzLl9jb25uZWN0aW9uPW51bGwsZT1PLkVNUFRZKSksZX0sdC5wcm90b3R5cGUucmVmQ291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gY2UoKSh0aGlzKX0sdH0oRikucHJvdG90eXBlLGhlPXtvcGVyYXRvcjp7dmFsdWU6bnVsbH0sX3JlZkNvdW50Ont2YWx1ZTowLHdyaXRhYmxlOiEwfSxfc3ViamVjdDp7dmFsdWU6bnVsbCx3cml0YWJsZTohMH0sX2Nvbm5lY3Rpb246e3ZhbHVlOm51bGwsd3JpdGFibGU6ITB9LF9zdWJzY3JpYmU6e3ZhbHVlOmRlLl9zdWJzY3JpYmV9LF9pc0NvbXBsZXRlOnt2YWx1ZTpkZS5faXNDb21wbGV0ZSx3cml0YWJsZTohMH0sZ2V0U3ViamVjdDp7dmFsdWU6ZGUuZ2V0U3ViamVjdH0sY29ubmVjdDp7dmFsdWU6ZGUuY29ubmVjdH0scmVmQ291bnQ6e3ZhbHVlOmRlLnJlZkNvdW50fX0seWU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0LHIpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLmNvbm5lY3RhYmxlPXIsbn1yZXR1cm4gdih0LGUpLHQucHJvdG90eXBlLl9lcnJvcj1mdW5jdGlvbih0KXt0aGlzLl91bnN1YnNjcmliZSgpLGUucHJvdG90eXBlLl9lcnJvci5jYWxsKHRoaXMsdCl9LHQucHJvdG90eXBlLl9jb21wbGV0ZT1mdW5jdGlvbigpe3RoaXMuY29ubmVjdGFibGUuX2lzQ29tcGxldGU9ITAsdGhpcy5fdW5zdWJzY3JpYmUoKSxlLnByb3RvdHlwZS5fY29tcGxldGUuY2FsbCh0aGlzKX0sdC5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5jb25uZWN0YWJsZTtpZihlKXt0aGlzLmNvbm5lY3RhYmxlPW51bGw7dmFyIHQ9ZS5fY29ubmVjdGlvbjtlLl9yZWZDb3VudD0wLGUuX3N1YmplY3Q9bnVsbCxlLl9jb25uZWN0aW9uPW51bGwsdCYmdC51bnN1YnNjcmliZSgpfX0sdH0oc2UpO2Z1bmN0aW9uIGxlKCl7cmV0dXJuIG5ldyBvZX1mdW5jdGlvbiBnZSgpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gY2UoKSgodD1sZSxmdW5jdGlvbihlKXt2YXIgcjtyPVwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/dDpmdW5jdGlvbigpe3JldHVybiB0fTt2YXIgbj1PYmplY3QuY3JlYXRlKGUsaGUpO3JldHVybiBuLnNvdXJjZT1lLG4uc3ViamVjdEZhY3Rvcnk9cixufSkoZSkpO3ZhciB0fX1mdW5jdGlvbiBmZShlLHQscil7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTpyLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1yLGV9dmFyIF9lPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe28odGhpcyxlKX1yZXR1cm4gYyhlLFt7a2V5OlwiYWNjb3VudENsb3N1cmVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXthY2NvdW50X2Nsb3N1cmU6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scGFzc3Rocm91Z2g6e30scmVhc29uOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwiYWNjb3VudF9jbG9zdXJlXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJhY2NvdW50U2VjdXJpdHlcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXthY2NvdW50X3NlY3VyaXR5OntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LG90cDp7dHlwZTpcInN0cmluZ1wifSxwYXNzdGhyb3VnaDp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9LHRvdHBfYWN0aW9uOnt0eXBlOlwic3RyaW5nXCJ9fSxyPXttZXRob2Q6XCJhY2NvdW50X3NlY3VyaXR5XCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJhY2NvdW50U3RhdGlzdGljc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2FjY291bnRfc3RhdGlzdGljczp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxwYXNzdGhyb3VnaDp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJhY2NvdW50X3N0YXRpc3RpY3NcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcImFjdGl2ZVN5bWJvbHNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXthY3RpdmVfc3ltYm9sczp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LGxhbmRpbmdfY29tcGFueTp7dHlwZTpcInN0cmluZ1wifSxwYXNzdGhyb3VnaDp7fSxwcm9kdWN0X3R5cGU6e3R5cGU6XCJzdHJpbmdcIn0scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwiYWN0aXZlX3N5bWJvbHNcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcImFmZmlsaWF0ZUFjY291bnRBZGRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXthZGRyZXNzX2NpdHk6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxhZGRyZXNzX2xpbmVfMTp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LGFkZHJlc3NfbGluZV8yOnt0eXBlOlwic3RyaW5nXCJ9LGFkZHJlc3NfcG9zdGNvZGU6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxhZGRyZXNzX3N0YXRlOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0sYWZmaWxpYXRlX2FjY291bnRfYWRkOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LGNvdW50cnk6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxmaXJzdF9uYW1lOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0sbGFzdF9uYW1lOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0sbm9uX3BlcF9kZWNsYXJhdGlvbjp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxwYXNzdGhyb3VnaDp7fSxwYXNzd29yZDp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LHBob25lOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSx0bmNfYWNjZXB0ZWQ6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0sdXNlcm5hbWU6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifX0scj17bWV0aG9kOlwiYWZmaWxpYXRlX2FjY291bnRfYWRkXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJhcGlUb2tlblwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2FwaV90b2tlbjp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxkZWxldGVfdG9rZW46e3R5cGU6XCJzdHJpbmdcIn0sbmV3X3Rva2VuOnt0eXBlOlwic3RyaW5nXCJ9LG5ld190b2tlbl9zY29wZXM6e30scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSx2YWxpZF9mb3JfY3VycmVudF9pcF9vbmx5Ont0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwiYXBpX3Rva2VuXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJhcHBEZWxldGVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXthcHBfZGVsZXRlOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHBhc3N0aHJvdWdoOnt9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcImFwcF9kZWxldGVcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcImFwcEdldFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2FwcF9nZXQ6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwiYXBwX2dldFwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwiYXBwTGlzdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2FwcF9saXN0OntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHBhc3N0aHJvdWdoOnt9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcImFwcF9saXN0XCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJhcHBNYXJrdXBEZXRhaWxzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17YXBwX2lkOnt0eXBlOlwibnVtZXJpY1wifSxhcHBfbWFya3VwX2RldGFpbHM6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0sY2xpZW50X2xvZ2luaWQ6e3R5cGU6XCJzdHJpbmdcIn0sZGF0ZV9mcm9tOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0sZGF0ZV90bzp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LGRlc2NyaXB0aW9uOnt0eXBlOlwibnVtZXJpY1wifSxsaW1pdDp7dHlwZTpcIm51bWVyaWNcIn0sb2Zmc2V0Ont0eXBlOlwibnVtZXJpY1wifSxwYXNzdGhyb3VnaDp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9LHNvcnQ6e3R5cGU6XCJzdHJpbmdcIn0sc29ydF9maWVsZHM6e319LHI9e21ldGhvZDpcImFwcF9tYXJrdXBfZGV0YWlsc1wiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwiYXBwUmVnaXN0ZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXthcHBfbWFya3VwX3BlcmNlbnRhZ2U6e3R5cGU6XCJudW1lcmljXCJ9LGFwcF9yZWdpc3Rlcjp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxhcHBzdG9yZTp7dHlwZTpcInN0cmluZ1wifSxnaXRodWI6e3R5cGU6XCJzdHJpbmdcIn0sZ29vZ2xlcGxheTp7dHlwZTpcInN0cmluZ1wifSxob21lcGFnZTp7dHlwZTpcInN0cmluZ1wifSxuYW1lOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0scGFzc3Rocm91Z2g6e30scmVkaXJlY3RfdXJpOnt0eXBlOlwic3RyaW5nXCJ9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn0sc2NvcGVzOntyZXF1aXJlZDoxfSx2ZXJpZmljYXRpb25fdXJpOnt0eXBlOlwic3RyaW5nXCJ9fSxyPXttZXRob2Q6XCJhcHBfcmVnaXN0ZXJcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcImFwcFVwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2FwcF9tYXJrdXBfcGVyY2VudGFnZTp7dHlwZTpcIm51bWVyaWNcIn0sYXBwX3VwZGF0ZTp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxhcHBzdG9yZTp7dHlwZTpcInN0cmluZ1wifSxnaXRodWI6e3R5cGU6XCJzdHJpbmdcIn0sZ29vZ2xlcGxheTp7dHlwZTpcInN0cmluZ1wifSxob21lcGFnZTp7dHlwZTpcInN0cmluZ1wifSxuYW1lOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0scGFzc3Rocm91Z2g6e30scmVkaXJlY3RfdXJpOnt0eXBlOlwic3RyaW5nXCJ9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn0sc2NvcGVzOntyZXF1aXJlZDoxfSx2ZXJpZmljYXRpb25fdXJpOnt0eXBlOlwic3RyaW5nXCJ9fSxyPXttZXRob2Q6XCJhcHBfdXBkYXRlXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJhc3NldEluZGV4XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17YXNzZXRfaW5kZXg6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0sbGFuZGluZ19jb21wYW55Ont0eXBlOlwic3RyaW5nXCJ9LHBhc3N0aHJvdWdoOnt9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcImFzc2V0X2luZGV4XCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJhdXRob3JpemVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXthZGRfdG9fbG9naW5faGlzdG9yeTp7dHlwZTpcIm51bWVyaWNcIn0sYXV0aG9yaXplOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwiYXV0aG9yaXplXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJiYWxhbmNlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17YWNjb3VudDp7dHlwZTpcInN0cmluZ1wifSxiYWxhbmNlOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHBhc3N0aHJvdWdoOnt9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn0sc3Vic2NyaWJlOnt0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwiYmFsYW5jZVwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwiYnV5XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17YnV5OntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0scGFyYW1ldGVyczp7YW1vdW50Ont0eXBlOlwibnVtZXJpY1wifSxhcHBfbWFya3VwX3BlcmNlbnRhZ2U6e3R5cGU6XCJudW1lcmljXCJ9LGJhcnJpZXI6e3R5cGU6XCJzdHJpbmdcIn0sYmFycmllcjI6e3R5cGU6XCJzdHJpbmdcIn0sYmFycmllcl9yYW5nZTp7dHlwZTpcInN0cmluZ1wifSxiYXNpczp7dHlwZTpcInN0cmluZ1wifSxjYW5jZWxsYXRpb246e3R5cGU6XCJzdHJpbmdcIn0sY29udHJhY3RfdHlwZTp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LGN1cnJlbmN5OntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0sZGF0ZV9leHBpcnk6e3R5cGU6XCJudW1lcmljXCJ9LGRhdGVfc3RhcnQ6e3R5cGU6XCJudW1lcmljXCJ9LGR1cmF0aW9uOnt0eXBlOlwibnVtZXJpY1wifSxkdXJhdGlvbl91bml0Ont0eXBlOlwic3RyaW5nXCJ9LGxpbWl0X29yZGVyOntzdG9wX2xvc3M6e3R5cGU6XCJudW1lcmljXCJ9LHRha2VfcHJvZml0Ont0eXBlOlwibnVtZXJpY1wifX0sbXVsdGlwbGllcjp7dHlwZTpcIm51bWVyaWNcIn0scHJvZHVjdF90eXBlOnt0eXBlOlwic3RyaW5nXCJ9LHNlbGVjdGVkX3RpY2s6e3R5cGU6XCJudW1lcmljXCJ9LHN5bWJvbDp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LHRyYWRpbmdfcGVyaW9kX3N0YXJ0Ont0eXBlOlwibnVtZXJpY1wifX0scGFzc3Rocm91Z2g6e30scHJpY2U6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSxzdWJzY3JpYmU6e3R5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJidXlcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcImJ1eUNvbnRyYWN0Rm9yTXVsdGlwbGVBY2NvdW50c1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2J1eV9jb250cmFjdF9mb3JfbXVsdGlwbGVfYWNjb3VudHM6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxwYXJhbWV0ZXJzOnthbW91bnQ6e3R5cGU6XCJudW1lcmljXCJ9LGFwcF9tYXJrdXBfcGVyY2VudGFnZTp7dHlwZTpcIm51bWVyaWNcIn0sYmFycmllcjp7dHlwZTpcInN0cmluZ1wifSxiYXJyaWVyMjp7dHlwZTpcInN0cmluZ1wifSxiYXNpczp7dHlwZTpcInN0cmluZ1wifSxjb250cmFjdF90eXBlOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0sY3VycmVuY3k6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxkYXRlX2V4cGlyeTp7dHlwZTpcIm51bWVyaWNcIn0sZGF0ZV9zdGFydDp7dHlwZTpcIm51bWVyaWNcIn0sZHVyYXRpb246e3R5cGU6XCJudW1lcmljXCJ9LGR1cmF0aW9uX3VuaXQ6e3R5cGU6XCJzdHJpbmdcIn0sbXVsdGlwbGllcjp7dHlwZTpcIm51bWVyaWNcIn0sc2VsZWN0ZWRfdGljazp7dHlwZTpcIm51bWVyaWNcIn0sc3ltYm9sOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn19LHBhc3N0aHJvdWdoOnt9LHByaWNlOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn0sdG9rZW5zOntyZXF1aXJlZDoxfX0scj17bWV0aG9kOlwiYnV5X2NvbnRyYWN0X2Zvcl9tdWx0aXBsZV9hY2NvdW50c1wiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwiY2FuY2VsXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17Y2FuY2VsOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHBhc3N0aHJvdWdoOnt9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcImNhbmNlbFwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwiY2FzaGllclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2FkZHJlc3M6e3R5cGU6XCJzdHJpbmdcIn0sYW1vdW50Ont0eXBlOlwibnVtZXJpY1wifSxjYXNoaWVyOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0sZHJ5X3J1bjp7dHlwZTpcIm51bWVyaWNcIn0scGFzc3Rocm91Z2g6e30scHJvdmlkZXI6e3R5cGU6XCJzdHJpbmdcIn0scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSx0eXBlOnt0eXBlOlwic3RyaW5nXCJ9LHZlcmlmaWNhdGlvbl9jb2RlOnt0eXBlOlwic3RyaW5nXCJ9fSxyPXttZXRob2Q6XCJjYXNoaWVyXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJjYXNoaWVyUGF5bWVudHNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtjYXNoaWVyX3BheW1lbnRzOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHBhc3N0aHJvdWdoOnt9LHByb3ZpZGVyOnt0eXBlOlwic3RyaW5nXCJ9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn0sc3Vic2NyaWJlOnt0eXBlOlwibnVtZXJpY1wifSx0cmFuc2FjdGlvbl90eXBlOnt0eXBlOlwic3RyaW5nXCJ9fSxyPXttZXRob2Q6XCJjYXNoaWVyX3BheW1lbnRzXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJjYXNoaWVyV2l0aGRyYXdhbENhbmNlbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2Nhc2hpZXJfd2l0aGRyYXdhbF9jYW5jZWw6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0saWQ6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxwYXNzdGhyb3VnaDp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJjYXNoaWVyX3dpdGhkcmF3YWxfY2FuY2VsXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJjaGFuZ2VFbWFpbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2NoYW5nZV9lbWFpbDp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LG5ld19lbWFpbDp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LG5ld19wYXNzd29yZDp7dHlwZTpcInN0cmluZ1wifSxwYXNzdGhyb3VnaDp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9LHZlcmlmaWNhdGlvbl9jb2RlOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn19LHI9e21ldGhvZDpcImNoYW5nZV9lbWFpbFwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwiY2hhbmdlUGFzc3dvcmRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtjaGFuZ2VfcGFzc3dvcmQ6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0sbmV3X3Bhc3N3b3JkOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0sb2xkX3Bhc3N3b3JkOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwiY2hhbmdlX3Bhc3N3b3JkXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJjb250cmFjdFVwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2NvbnRyYWN0X2lkOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LGNvbnRyYWN0X3VwZGF0ZTp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxsaW1pdF9vcmRlcjp7c3RvcF9sb3NzOnt9LHRha2VfcHJvZml0Ont9fSxwYXNzdGhyb3VnaDp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJjb250cmFjdF91cGRhdGVcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcImNvbnRyYWN0VXBkYXRlSGlzdG9yeVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2NvbnRyYWN0X2lkOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LGNvbnRyYWN0X3VwZGF0ZV9oaXN0b3J5OntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LGxpbWl0Ont0eXBlOlwibnVtZXJpY1wifSxwYXNzdGhyb3VnaDp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJjb250cmFjdF91cGRhdGVfaGlzdG9yeVwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwiY29udHJhY3RzRm9yXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17Y29udHJhY3RzX2Zvcjp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LGN1cnJlbmN5Ont0eXBlOlwic3RyaW5nXCJ9LGxhbmRpbmdfY29tcGFueTp7dHlwZTpcInN0cmluZ1wifSxwYXNzdGhyb3VnaDp7fSxwcm9kdWN0X3R5cGU6e3R5cGU6XCJzdHJpbmdcIn0scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwiY29udHJhY3RzX2ZvclwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwiY29weVN0YXJ0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17YXNzZXRzOnt9LGNvcHlfc3RhcnQ6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxtYXhfdHJhZGVfc3Rha2U6e3R5cGU6XCJudW1lcmljXCJ9LG1pbl90cmFkZV9zdGFrZTp7dHlwZTpcIm51bWVyaWNcIn0scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSx0cmFkZV90eXBlczp7fX0scj17bWV0aG9kOlwiY29weV9zdGFydFwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwiY29weVN0b3BcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtjb3B5X3N0b3A6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxwYXNzdGhyb3VnaDp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJjb3B5X3N0b3BcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcImNvcHl0cmFkaW5nTGlzdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2NvcHl0cmFkaW5nX2xpc3Q6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwiY29weXRyYWRpbmdfbGlzdFwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwiY29weXRyYWRpbmdTdGF0aXN0aWNzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17Y29weXRyYWRpbmdfc3RhdGlzdGljczp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxwYXNzdGhyb3VnaDp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9LHRyYWRlcl9pZDp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9fSxyPXttZXRob2Q6XCJjb3B5dHJhZGluZ19zdGF0aXN0aWNzXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJjcnlwdG9Db25maWdcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtjcnlwdG9fY29uZmlnOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LGN1cnJlbmN5X2NvZGU6e3R5cGU6XCJzdHJpbmdcIn0scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwiY3J5cHRvX2NvbmZpZ1wiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwiZG9jdW1lbnRVcGxvYWRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtkb2N1bWVudF9mb3JtYXQ6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxkb2N1bWVudF9pZDp7dHlwZTpcInN0cmluZ1wifSxkb2N1bWVudF9pc3N1aW5nX2NvdW50cnk6e3R5cGU6XCJzdHJpbmdcIn0sZG9jdW1lbnRfdHlwZTp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LGRvY3VtZW50X3VwbG9hZDp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxleHBlY3RlZF9jaGVja3N1bTp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LGV4cGlyYXRpb25fZGF0ZTp7dHlwZTpcInN0cmluZ1wifSxmaWxlX3NpemU6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0sbGlmZXRpbWVfdmFsaWQ6e3R5cGU6XCJudW1lcmljXCJ9LHBhZ2VfdHlwZTp7dHlwZTpcInN0cmluZ1wifSxwYXNzdGhyb3VnaDp7fSxwcm9vZl9vZl9vd25lcnNoaXA6e2RldGFpbHM6e3JlcXVpcmVkOjF9LGlkOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJkb2N1bWVudF91cGxvYWRcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcImVjb25vbWljQ2FsZW5kYXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtjdXJyZW5jeTp7dHlwZTpcInN0cmluZ1wifSxlY29ub21pY19jYWxlbmRhcjp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxlbmRfZGF0ZTp7dHlwZTpcIm51bWVyaWNcIn0scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSxzdGFydF9kYXRlOnt0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwiZWNvbm9taWNfY2FsZW5kYXJcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcImV4Y2hhbmdlUmF0ZXNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtiYXNlX2N1cnJlbmN5OntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0sZXhjaGFuZ2VfcmF0ZXM6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSxzdWJzY3JpYmU6e3R5cGU6XCJudW1lcmljXCJ9LHRhcmdldF9jdXJyZW5jeTp7dHlwZTpcInN0cmluZ1wifX0scj17bWV0aG9kOlwiZXhjaGFuZ2VfcmF0ZXNcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcImZvcmdldFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2ZvcmdldDp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LHBhc3N0aHJvdWdoOnt9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcImZvcmdldFwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwiZm9yZ2V0QWxsXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17Zm9yZ2V0X2FsbDp7cmVxdWlyZWQ6MX0scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwiZm9yZ2V0X2FsbFwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwiZ2V0QWNjb3VudFN0YXR1c1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2dldF9hY2NvdW50X3N0YXR1czp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxwYXNzdGhyb3VnaDp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJnZXRfYWNjb3VudF9zdGF0dXNcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcImdldEFjY291bnRUeXBlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2dldF9hY2NvdW50X3R5cGVzOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHBhc3N0aHJvdWdoOnt9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcImdldF9hY2NvdW50X3R5cGVzXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJnZXRBdmFpbGFibGVBY2NvdW50c1RvVHJhbnNmZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtnZXRfYXZhaWxhYmxlX2FjY291bnRzX3RvX3RyYW5zZmVyOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LGxvZ2luaWQ6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxwYXNzdGhyb3VnaDp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJnZXRfYXZhaWxhYmxlX2FjY291bnRzX3RvX3RyYW5zZmVyXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJnZXRGaW5hbmNpYWxBc3Nlc3NtZW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17Z2V0X2ZpbmFuY2lhbF9hc3Nlc3NtZW50OntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHBhc3N0aHJvdWdoOnt9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcImdldF9maW5hbmNpYWxfYXNzZXNzbWVudFwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwiZ2V0TGltaXRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17Z2V0X2xpbWl0czp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxwYXNzdGhyb3VnaDp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJnZXRfbGltaXRzXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJnZXRTZWxmRXhjbHVzaW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17Z2V0X3NlbGZfZXhjbHVzaW9uOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHBhc3N0aHJvdWdoOnt9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcImdldF9zZWxmX2V4Y2x1c2lvblwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwiZ2V0U2V0dGluZ3NcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtnZXRfc2V0dGluZ3M6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwiZ2V0X3NldHRpbmdzXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJpZGVudGl0eVZlcmlmaWNhdGlvbkRvY3VtZW50QWRkXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17ZG9jdW1lbnRfbnVtYmVyOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0sZG9jdW1lbnRfdHlwZTp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LGlkZW50aXR5X3ZlcmlmaWNhdGlvbl9kb2N1bWVudF9hZGQ6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0saXNzdWluZ19jb3VudHJ5OntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwiaWRlbnRpdHlfdmVyaWZpY2F0aW9uX2RvY3VtZW50X2FkZFwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwibGFuZGluZ0NvbXBhbnlcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtsYW5kaW5nX2NvbXBhbnk6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxwYXNzdGhyb3VnaDp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJsYW5kaW5nX2NvbXBhbnlcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcImxhbmRpbmdDb21wYW55RGV0YWlsc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2xhbmRpbmdfY29tcGFueV9kZXRhaWxzOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwibGFuZGluZ19jb21wYW55X2RldGFpbHNcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcImxpbmtXYWxsZXRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtjbGllbnRfaWQ6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxsaW5rX3dhbGxldDp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxwYXNzdGhyb3VnaDp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9LHdhbGxldF9pZDp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9fSxyPXttZXRob2Q6XCJsaW5rX3dhbGxldFwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwibG9naW5IaXN0b3J5XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17bGltaXQ6e3R5cGU6XCJudW1lcmljXCJ9LGxvZ2luX2hpc3Rvcnk6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwibG9naW5faGlzdG9yeVwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwibG9nb3V0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17bG9nb3V0OntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHBhc3N0aHJvdWdoOnt9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcImxvZ291dFwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwibXQ1RGVwb3NpdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2Ftb3VudDp7dHlwZTpcIm51bWVyaWNcIn0sZnJvbV9iaW5hcnk6e3R5cGU6XCJzdHJpbmdcIn0sbXQ1X2RlcG9zaXQ6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSx0b19tdDU6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifX0scj17bWV0aG9kOlwibXQ1X2RlcG9zaXRcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcIm10NUdldFNldHRpbmdzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17bG9naW46e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxtdDVfZ2V0X3NldHRpbmdzOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHBhc3N0aHJvdWdoOnt9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcIm10NV9nZXRfc2V0dGluZ3NcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcIm10NUxvZ2luTGlzdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e210NV9sb2dpbl9saXN0OntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHBhc3N0aHJvdWdoOnt9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcIm10NV9sb2dpbl9saXN0XCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJtdDVOZXdBY2NvdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17YWNjb3VudF90eXBlOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0sYWRkcmVzczp7dHlwZTpcInN0cmluZ1wifSxjaXR5Ont0eXBlOlwic3RyaW5nXCJ9LGNvbXBhbnk6e3R5cGU6XCJzdHJpbmdcIn0sY291bnRyeTp7dHlwZTpcInN0cmluZ1wifSxjdXJyZW5jeTp7dHlwZTpcInN0cmluZ1wifSxkcnlfcnVuOnt0eXBlOlwibnVtZXJpY1wifSxlbWFpbDp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LGludmVzdFBhc3N3b3JkOnt0eXBlOlwic3RyaW5nXCJ9LGxldmVyYWdlOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LG1haW5QYXNzd29yZDp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LG10NV9hY2NvdW50X2NhdGVnb3J5Ont0eXBlOlwic3RyaW5nXCJ9LG10NV9hY2NvdW50X3R5cGU6e3R5cGU6XCJzdHJpbmdcIn0sbXQ1X25ld19hY2NvdW50OntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LG5hbWU6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxwYXNzdGhyb3VnaDp7fSxwaG9uZTp7dHlwZTpcInN0cmluZ1wifSxwaG9uZVBhc3N3b3JkOnt0eXBlOlwic3RyaW5nXCJ9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn0sc2VydmVyOnt9LHN0YXRlOnt0eXBlOlwic3RyaW5nXCJ9LHppcENvZGU6e3R5cGU6XCJzdHJpbmdcIn19LHI9e21ldGhvZDpcIm10NV9uZXdfYWNjb3VudFwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwibXQ1UGFzc3dvcmRDaGFuZ2VcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtsb2dpbjp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LG10NV9wYXNzd29yZF9jaGFuZ2U6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0sbmV3X3Bhc3N3b3JkOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0sb2xkX3Bhc3N3b3JkOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0scGFzc3Rocm91Z2g6e30scGFzc3dvcmRfdHlwZTp7dHlwZTpcInN0cmluZ1wifSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJtdDVfcGFzc3dvcmRfY2hhbmdlXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJtdDVQYXNzd29yZENoZWNrXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17bG9naW46e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxtdDVfcGFzc3dvcmRfY2hlY2s6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scGFzc3Rocm91Z2g6e30scGFzc3dvcmQ6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxwYXNzd29yZF90eXBlOnt0eXBlOlwic3RyaW5nXCJ9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcIm10NV9wYXNzd29yZF9jaGVja1wiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwibXQ1UGFzc3dvcmRSZXNldFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2xvZ2luOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0sbXQ1X3Bhc3N3b3JkX3Jlc2V0OntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LG5ld19wYXNzd29yZDp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LHBhc3N0aHJvdWdoOnt9LHBhc3N3b3JkX3R5cGU6e3R5cGU6XCJzdHJpbmdcIn0scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSx2ZXJpZmljYXRpb25fY29kZTp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9fSxyPXttZXRob2Q6XCJtdDVfcGFzc3dvcmRfcmVzZXRcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcIm10NVdpdGhkcmF3YWxcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXthbW91bnQ6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0sZnJvbV9tdDU6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxtdDVfd2l0aGRyYXdhbDp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxwYXNzdGhyb3VnaDp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9LHRvX2JpbmFyeTp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9fSxyPXttZXRob2Q6XCJtdDVfd2l0aGRyYXdhbFwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwibmV3QWNjb3VudE1hbHRhaW52ZXN0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17YWNjZXB0X3Jpc2s6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0sYWNjb3VudF9vcGVuaW5nX3JlYXNvbjp7dHlwZTpcInN0cmluZ1wifSxhY2NvdW50X3R1cm5vdmVyOnt0eXBlOlwic3RyaW5nXCJ9LGFkZHJlc3NfY2l0eTp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LGFkZHJlc3NfbGluZV8xOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0sYWRkcmVzc19saW5lXzI6e3R5cGU6XCJzdHJpbmdcIn0sYWRkcmVzc19wb3N0Y29kZTp7dHlwZTpcInN0cmluZ1wifSxhZGRyZXNzX3N0YXRlOnt0eXBlOlwic3RyaW5nXCJ9LGFmZmlsaWF0ZV90b2tlbjp7dHlwZTpcInN0cmluZ1wifSxiaW5hcnlfb3B0aW9uc190cmFkaW5nX2V4cGVyaWVuY2U6e3R5cGU6XCJzdHJpbmdcIn0sYmluYXJ5X29wdGlvbnNfdHJhZGluZ19mcmVxdWVuY3k6e3R5cGU6XCJzdHJpbmdcIn0sY2ZkX3RyYWRpbmdfZXhwZXJpZW5jZTp7dHlwZTpcInN0cmluZ1wifSxjZmRfdHJhZGluZ19mcmVxdWVuY3k6e3R5cGU6XCJzdHJpbmdcIn0sY2l0aXplbjp7dHlwZTpcInN0cmluZ1wifSxjbGllbnRfdHlwZTp7dHlwZTpcInN0cmluZ1wifSxjdXJyZW5jeTp7dHlwZTpcInN0cmluZ1wifSxkYXRlX29mX2JpcnRoOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0sZWR1Y2F0aW9uX2xldmVsOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0sZW1wbG95bWVudF9pbmR1c3RyeTp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LGVtcGxveW1lbnRfc3RhdHVzOnt0eXBlOlwic3RyaW5nXCJ9LGVzdGltYXRlZF93b3J0aDp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LGZpcnN0X25hbWU6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxmb3JleF90cmFkaW5nX2V4cGVyaWVuY2U6e3R5cGU6XCJzdHJpbmdcIn0sZm9yZXhfdHJhZGluZ19mcmVxdWVuY3k6e3R5cGU6XCJzdHJpbmdcIn0saW5jb21lX3NvdXJjZTp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LGxhc3RfbmFtZTp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LG5ldF9pbmNvbWU6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxuZXdfYWNjb3VudF9tYWx0YWludmVzdDp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxub25fcGVwX2RlY2xhcmF0aW9uOnt0eXBlOlwibnVtZXJpY1wifSxvY2N1cGF0aW9uOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0sb3RoZXJfaW5zdHJ1bWVudHNfdHJhZGluZ19leHBlcmllbmNlOnt0eXBlOlwic3RyaW5nXCJ9LG90aGVyX2luc3RydW1lbnRzX3RyYWRpbmdfZnJlcXVlbmN5Ont0eXBlOlwic3RyaW5nXCJ9LHBhc3N0aHJvdWdoOnt9LHBob25lOnt9LHBsYWNlX29mX2JpcnRoOnt0eXBlOlwic3RyaW5nXCJ9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn0scmVzaWRlbmNlOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0sc2FsdXRhdGlvbjp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LHNlY3JldF9hbnN3ZXI6e3R5cGU6XCJzdHJpbmdcIn0sc2VjcmV0X3F1ZXN0aW9uOnt0eXBlOlwic3RyaW5nXCJ9LHNvdXJjZV9vZl93ZWFsdGg6e3R5cGU6XCJzdHJpbmdcIn0sdGF4X2lkZW50aWZpY2F0aW9uX251bWJlcjp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LHRheF9yZXNpZGVuY2U6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifX0scj17bWV0aG9kOlwibmV3X2FjY291bnRfbWFsdGFpbnZlc3RcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcIm5ld0FjY291bnRSZWFsXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17YWNjb3VudF9vcGVuaW5nX3JlYXNvbjp7dHlwZTpcInN0cmluZ1wifSxhY2NvdW50X3R1cm5vdmVyOnt0eXBlOlwic3RyaW5nXCJ9LGFkZHJlc3NfY2l0eTp7dHlwZTpcInN0cmluZ1wifSxhZGRyZXNzX2xpbmVfMTp7dHlwZTpcInN0cmluZ1wifSxhZGRyZXNzX2xpbmVfMjp7dHlwZTpcInN0cmluZ1wifSxhZGRyZXNzX3Bvc3Rjb2RlOnt0eXBlOlwic3RyaW5nXCJ9LGFkZHJlc3Nfc3RhdGU6e3R5cGU6XCJzdHJpbmdcIn0sYWZmaWxpYXRlX3Rva2VuOnt0eXBlOlwic3RyaW5nXCJ9LGNpdGl6ZW46e30sY2xpZW50X3R5cGU6e3R5cGU6XCJzdHJpbmdcIn0sY3VycmVuY3k6e3R5cGU6XCJzdHJpbmdcIn0sZGF0ZV9vZl9iaXJ0aDp7dHlwZTpcInN0cmluZ1wifSxmaXJzdF9uYW1lOnt0eXBlOlwic3RyaW5nXCJ9LGxhc3RfbmFtZTp7dHlwZTpcInN0cmluZ1wifSxuZXdfYWNjb3VudF9yZWFsOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LG5vbl9wZXBfZGVjbGFyYXRpb246e3R5cGU6XCJudW1lcmljXCJ9LHBhc3N0aHJvdWdoOnt9LHBob25lOnt9LHBsYWNlX29mX2JpcnRoOnt0eXBlOlwic3RyaW5nXCJ9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn0scmVzaWRlbmNlOnt0eXBlOlwic3RyaW5nXCJ9LHNhbHV0YXRpb246e3R5cGU6XCJzdHJpbmdcIn0sc2VjcmV0X2Fuc3dlcjp7dHlwZTpcInN0cmluZ1wifSxzZWNyZXRfcXVlc3Rpb246e3R5cGU6XCJzdHJpbmdcIn0sdGF4X2lkZW50aWZpY2F0aW9uX251bWJlcjp7dHlwZTpcInN0cmluZ1wifSx0YXhfcmVzaWRlbmNlOnt0eXBlOlwic3RyaW5nXCJ9fSxyPXttZXRob2Q6XCJuZXdfYWNjb3VudF9yZWFsXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJuZXdBY2NvdW50VmlydHVhbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2FmZmlsaWF0ZV90b2tlbjp7dHlwZTpcInN0cmluZ1wifSxjbGllbnRfcGFzc3dvcmQ6e3R5cGU6XCJzdHJpbmdcIn0sZGF0ZV9maXJzdF9jb250YWN0Ont0eXBlOlwic3RyaW5nXCJ9LGVtYWlsX2NvbnNlbnQ6e3R5cGU6XCJudW1lcmljXCJ9LGdjbGlkX3VybDp7dHlwZTpcInN0cmluZ1wifSxuZXdfYWNjb3VudF92aXJ0dWFsOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHBhc3N0aHJvdWdoOnt9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn0scmVzaWRlbmNlOnt0eXBlOlwic3RyaW5nXCJ9LHNpZ251cF9kZXZpY2U6e3R5cGU6XCJzdHJpbmdcIn0sdHlwZTp7dHlwZTpcInN0cmluZ1wifSx1dG1fYWRfaWQ6e30sdXRtX2FkZ3JvdXBfaWQ6e30sdXRtX2Fkcm9sbGNsa19pZDp7fSx1dG1fY2FtcGFpZ246e30sdXRtX2NhbXBhaWduX2lkOnt9LHV0bV9jb250ZW50Ont9LHV0bV9mYmNsX2lkOnt9LHV0bV9nbF9jbGllbnRfaWQ6e30sdXRtX21lZGl1bTp7fSx1dG1fbXNjbGtfaWQ6e30sdXRtX3NvdXJjZTp7fSx1dG1fdGVybTp7fSx2ZXJpZmljYXRpb25fY29kZTp7dHlwZTpcInN0cmluZ1wifX0scj17bWV0aG9kOlwibmV3X2FjY291bnRfdmlydHVhbFwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwibmV3QWNjb3VudFdhbGxldFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2FkZHJlc3NfY2l0eTp7dHlwZTpcInN0cmluZ1wifSxhZGRyZXNzX2xpbmVfMTp7dHlwZTpcInN0cmluZ1wifSxhZGRyZXNzX2xpbmVfMjp7dHlwZTpcInN0cmluZ1wifSxhZGRyZXNzX3Bvc3Rjb2RlOnt0eXBlOlwic3RyaW5nXCJ9LGFkZHJlc3Nfc3RhdGU6e3R5cGU6XCJzdHJpbmdcIn0sY3VycmVuY3k6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxkYXRlX29mX2JpcnRoOnt0eXBlOlwic3RyaW5nXCJ9LGZpcnN0X25hbWU6e3R5cGU6XCJzdHJpbmdcIn0sbGFzdF9uYW1lOnt0eXBlOlwic3RyaW5nXCJ9LG5ld19hY2NvdW50X3dhbGxldDp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxub25fcGVwX2RlY2xhcmF0aW9uOnt0eXBlOlwibnVtZXJpY1wifSxwYXNzdGhyb3VnaDp7fSxwYXltZW50X21ldGhvZDp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LHBob25lOnt0eXBlOlwic3RyaW5nXCJ9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcIm5ld19hY2NvdW50X3dhbGxldFwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5Olwibm90aWZpY2F0aW9uRXZlbnRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXthcmdzOntkb2N1bWVudHM6e319LGNhdGVnb3J5OntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0sZXZlbnQ6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxub3RpZmljYXRpb25fZXZlbnQ6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwibm90aWZpY2F0aW9uX2V2ZW50XCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJvYXV0aEFwcHNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtvYXV0aF9hcHBzOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHBhc3N0aHJvdWdoOnt9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcIm9hdXRoX2FwcHNcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcInAycEFkdmVydENyZWF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2Ftb3VudDp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxjb250YWN0X2luZm86e3R5cGU6XCJzdHJpbmdcIn0sZGVzY3JpcHRpb246e3R5cGU6XCJzdHJpbmdcIn0sbG9jYWxfY3VycmVuY3k6e3R5cGU6XCJzdHJpbmdcIn0sbWF4X29yZGVyX2Ftb3VudDp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxtaW5fb3JkZXJfYW1vdW50OntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHAycF9hZHZlcnRfY3JlYXRlOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHBhc3N0aHJvdWdoOnt9LHBheW1lbnRfaW5mbzp7dHlwZTpcInN0cmluZ1wifSxwYXltZW50X21ldGhvZDp7dHlwZTpcInN0cmluZ1wifSxwYXltZW50X21ldGhvZF9pZHM6e30scGF5bWVudF9tZXRob2RfbmFtZXM6e30scmF0ZTp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxyYXRlX3R5cGU6e3R5cGU6XCJzdHJpbmdcIn0scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSx0eXBlOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn19LHI9e21ldGhvZDpcInAycF9hZHZlcnRfY3JlYXRlXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJwMnBBZHZlcnRJbmZvXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17aWQ6e3R5cGU6XCJzdHJpbmdcIn0scDJwX2FkdmVydF9pbmZvOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHBhc3N0aHJvdWdoOnt9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn0sc3Vic2NyaWJlOnt0eXBlOlwibnVtZXJpY1wifSx1c2VfY2xpZW50X2xpbWl0czp7dHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcInAycF9hZHZlcnRfaW5mb1wiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwicDJwQWR2ZXJ0TGlzdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2FkdmVydGlzZXJfaWQ6e3R5cGU6XCJzdHJpbmdcIn0sYWR2ZXJ0aXNlcl9uYW1lOnt0eXBlOlwic3RyaW5nXCJ9LGFtb3VudDp7dHlwZTpcIm51bWVyaWNcIn0sY291bnRlcnBhcnR5X3R5cGU6e3R5cGU6XCJzdHJpbmdcIn0sZmF2b3VyaXRlc19vbmx5Ont0eXBlOlwibnVtZXJpY1wifSxsaW1pdDp7dHlwZTpcIm51bWVyaWNcIn0sbG9jYWxfY3VycmVuY3k6e3R5cGU6XCJzdHJpbmdcIn0sb2Zmc2V0Ont0eXBlOlwibnVtZXJpY1wifSxwMnBfYWR2ZXJ0X2xpc3Q6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scGFzc3Rocm91Z2g6e30scGF5bWVudF9tZXRob2Q6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSxzb3J0X2J5Ont0eXBlOlwic3RyaW5nXCJ9LHVzZV9jbGllbnRfbGltaXRzOnt0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwicDJwX2FkdmVydF9saXN0XCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJwMnBBZHZlcnRVcGRhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtjb250YWN0X2luZm86e3R5cGU6XCJzdHJpbmdcIn0sZGVsZXRlOnt0eXBlOlwibnVtZXJpY1wifSxkZXNjcmlwdGlvbjp7dHlwZTpcInN0cmluZ1wifSxpZDp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LGlzX2FjdGl2ZTp7dHlwZTpcIm51bWVyaWNcIn0sbG9jYWxfY3VycmVuY3k6e3R5cGU6XCJzdHJpbmdcIn0sbWF4X29yZGVyX2Ftb3VudDp7dHlwZTpcIm51bWVyaWNcIn0sbWluX29yZGVyX2Ftb3VudDp7dHlwZTpcIm51bWVyaWNcIn0scDJwX2FkdmVydF91cGRhdGU6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scGFzc3Rocm91Z2g6e30scGF5bWVudF9pbmZvOnt0eXBlOlwic3RyaW5nXCJ9LHBheW1lbnRfbWV0aG9kX2lkczp7fSxwYXltZW50X21ldGhvZF9uYW1lczp7fSxyYXRlOnt0eXBlOlwibnVtZXJpY1wifSxyYXRlX3R5cGU6e3R5cGU6XCJzdHJpbmdcIn0scmVtYWluaW5nX2Ftb3VudDp7dHlwZTpcIm51bWVyaWNcIn0scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwicDJwX2FkdmVydF91cGRhdGVcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcInAycEFkdmVydGlzZXJBZHZlcnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17bGltaXQ6e3R5cGU6XCJudW1lcmljXCJ9LG9mZnNldDp7dHlwZTpcIm51bWVyaWNcIn0scDJwX2FkdmVydGlzZXJfYWR2ZXJ0czp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxwYXNzdGhyb3VnaDp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJwMnBfYWR2ZXJ0aXNlcl9hZHZlcnRzXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJwMnBBZHZlcnRpc2VyQ3JlYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17Y29udGFjdF9pbmZvOnt0eXBlOlwic3RyaW5nXCJ9LGRlZmF1bHRfYWR2ZXJ0X2Rlc2NyaXB0aW9uOnt0eXBlOlwic3RyaW5nXCJ9LG5hbWU6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxwMnBfYWR2ZXJ0aXNlcl9jcmVhdGU6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scGFzc3Rocm91Z2g6e30scGF5bWVudF9pbmZvOnt0eXBlOlwic3RyaW5nXCJ9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn0sc3Vic2NyaWJlOnt0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwicDJwX2FkdmVydGlzZXJfY3JlYXRlXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJwMnBBZHZlcnRpc2VySW5mb1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2lkOnt0eXBlOlwic3RyaW5nXCJ9LHAycF9hZHZlcnRpc2VyX2luZm86e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSxzdWJzY3JpYmU6e3R5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJwMnBfYWR2ZXJ0aXNlcl9pbmZvXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJwMnBBZHZlcnRpc2VyUGF5bWVudE1ldGhvZHNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtjcmVhdGU6e30sZGVsZXRlOnt9LHAycF9hZHZlcnRpc2VyX3BheW1lbnRfbWV0aG9kczp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxwYXNzdGhyb3VnaDp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9LHVwZGF0ZTp7fX0scj17bWV0aG9kOlwicDJwX2FkdmVydGlzZXJfcGF5bWVudF9tZXRob2RzXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJwMnBBZHZlcnRpc2VyUmVsYXRpb25zXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17YWRkX2Jsb2NrZWQ6e30sYWRkX2Zhdm91cml0ZXM6e30scDJwX2FkdmVydGlzZXJfcmVsYXRpb25zOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHBhc3N0aHJvdWdoOnt9LHJlbW92ZV9ibG9ja2VkOnt9LHJlbW92ZV9mYXZvdXJpdGVzOnt9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcInAycF9hZHZlcnRpc2VyX3JlbGF0aW9uc1wiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwicDJwQWR2ZXJ0aXNlclVwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2NvbnRhY3RfaW5mbzp7dHlwZTpcInN0cmluZ1wifSxkZWZhdWx0X2FkdmVydF9kZXNjcmlwdGlvbjp7dHlwZTpcInN0cmluZ1wifSxpc19saXN0ZWQ6e3R5cGU6XCJudW1lcmljXCJ9LHAycF9hZHZlcnRpc2VyX3VwZGF0ZTp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxwYXNzdGhyb3VnaDp7fSxwYXltZW50X2luZm86e3R5cGU6XCJzdHJpbmdcIn0scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSxzaG93X25hbWU6e3R5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJwMnBfYWR2ZXJ0aXNlcl91cGRhdGVcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcInAycENoYXRDcmVhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtvcmRlcl9pZDp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LHAycF9jaGF0X2NyZWF0ZTp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxwYXNzdGhyb3VnaDp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJwMnBfY2hhdF9jcmVhdGVcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcInAycE9yZGVyQ2FuY2VsXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17aWQ6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxwMnBfb3JkZXJfY2FuY2VsOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHBhc3N0aHJvdWdoOnt9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcInAycF9vcmRlcl9jYW5jZWxcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcInAycE9yZGVyQ29uZmlybVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2lkOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0scDJwX29yZGVyX2NvbmZpcm06e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwicDJwX29yZGVyX2NvbmZpcm1cIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcInAycE9yZGVyQ3JlYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17YWR2ZXJ0X2lkOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0sYW1vdW50OntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LGNvbnRhY3RfaW5mbzp7dHlwZTpcInN0cmluZ1wifSxwMnBfb3JkZXJfY3JlYXRlOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHBhc3N0aHJvdWdoOnt9LHBheW1lbnRfaW5mbzp7dHlwZTpcInN0cmluZ1wifSxwYXltZW50X21ldGhvZF9pZHM6e30scmF0ZTp7dHlwZTpcIm51bWVyaWNcIn0scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSxzdWJzY3JpYmU6e3R5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJwMnBfb3JkZXJfY3JlYXRlXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJwMnBPcmRlckRpc3B1dGVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtkaXNwdXRlX3JlYXNvbjp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LGlkOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0scDJwX29yZGVyX2Rpc3B1dGU6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwicDJwX29yZGVyX2Rpc3B1dGVcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcInAycE9yZGVySW5mb1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2lkOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0scDJwX29yZGVyX2luZm86e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSxzdWJzY3JpYmU6e3R5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJwMnBfb3JkZXJfaW5mb1wiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwicDJwT3JkZXJMaXN0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17YWN0aXZlOnt0eXBlOlwibnVtZXJpY1wifSxhZHZlcnRfaWQ6e3R5cGU6XCJzdHJpbmdcIn0sbGltaXQ6e3R5cGU6XCJudW1lcmljXCJ9LG9mZnNldDp7dHlwZTpcIm51bWVyaWNcIn0scDJwX29yZGVyX2xpc3Q6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSxzdWJzY3JpYmU6e3R5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJwMnBfb3JkZXJfbGlzdFwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwicDJwT3JkZXJSZXZpZXdcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtvcmRlcl9pZDp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LHAycF9vcmRlcl9yZXZpZXc6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scGFzc3Rocm91Z2g6e30scmF0aW5nOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHJlY29tbWVuZGVkOnt9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcInAycF9vcmRlcl9yZXZpZXdcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcInAycFBheW1lbnRNZXRob2RzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17cDJwX3BheW1lbnRfbWV0aG9kczp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxwYXNzdGhyb3VnaDp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJwMnBfcGF5bWVudF9tZXRob2RzXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJwMnBQaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17cDJwX3Bpbmc6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwicDJwX3BpbmdcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcInBheW1lbnRNZXRob2RzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17Y291bnRyeTp7dHlwZTpcInN0cmluZ1wifSxwYXNzdGhyb3VnaDp7fSxwYXltZW50X21ldGhvZHM6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwicGF5bWVudF9tZXRob2RzXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJwYXltZW50YWdlbnRDcmVhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXthZmZpbGlhdGVfaWQ6e3R5cGU6XCJzdHJpbmdcIn0sY29kZV9vZl9jb25kdWN0X2FwcHJvdmFsOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LGNvbW1pc3Npb25fZGVwb3NpdDp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxjb21taXNzaW9uX3dpdGhkcmF3YWw6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0sZW1haWw6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxpbmZvcm1hdGlvbjp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LHBhc3N0aHJvdWdoOnt9LHBheW1lbnRfYWdlbnRfbmFtZTp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LHBheW1lbnRhZ2VudF9jcmVhdGU6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scGhvbmVfbnVtYmVyczp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9LHN1cHBvcnRlZF9wYXltZW50X21ldGhvZHM6e3JlcXVpcmVkOjF9LHVybHM6e3JlcXVpcmVkOjF9fSxyPXttZXRob2Q6XCJwYXltZW50YWdlbnRfY3JlYXRlXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJwYXltZW50YWdlbnREZXRhaWxzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17cGFzc3Rocm91Z2g6e30scGF5bWVudGFnZW50X2RldGFpbHM6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwicGF5bWVudGFnZW50X2RldGFpbHNcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcInBheW1lbnRhZ2VudExpc3RcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtjdXJyZW5jeTp7dHlwZTpcInN0cmluZ1wifSxwYXNzdGhyb3VnaDp7fSxwYXltZW50YWdlbnRfbGlzdDp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcInBheW1lbnRhZ2VudF9saXN0XCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJwYXltZW50YWdlbnRUcmFuc2ZlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2Ftb3VudDp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxjdXJyZW5jeTp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LGRlc2NyaXB0aW9uOnt0eXBlOlwic3RyaW5nXCJ9LGRyeV9ydW46e3R5cGU6XCJudW1lcmljXCJ9LHBhc3N0aHJvdWdoOnt9LHBheW1lbnRhZ2VudF90cmFuc2Zlcjp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9LHRyYW5zZmVyX3RvOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn19LHI9e21ldGhvZDpcInBheW1lbnRhZ2VudF90cmFuc2ZlclwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwicGF5bWVudGFnZW50V2l0aGRyYXdcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXthbW91bnQ6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0sY3VycmVuY3k6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxkZXNjcmlwdGlvbjp7dHlwZTpcInN0cmluZ1wifSxkcnlfcnVuOnt0eXBlOlwibnVtZXJpY1wifSxwYXNzdGhyb3VnaDp7fSxwYXltZW50YWdlbnRfbG9naW5pZDp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LHBheW1lbnRhZ2VudF93aXRoZHJhdzp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9LHZlcmlmaWNhdGlvbl9jb2RlOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn19LHI9e21ldGhvZDpcInBheW1lbnRhZ2VudF93aXRoZHJhd1wiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwicGF5b3V0Q3VycmVuY2llc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e3Bhc3N0aHJvdWdoOnt9LHBheW91dF9jdXJyZW5jaWVzOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcInBheW91dF9jdXJyZW5jaWVzXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJwaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17cGFzc3Rocm91Z2g6e30scGluZzp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJwaW5nXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJwb3J0Zm9saW9cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtjb250cmFjdF90eXBlOnt9LHBhc3N0aHJvdWdoOnt9LHBvcnRmb2xpbzp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJwb3J0Zm9saW9cIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcInByb2ZpdFRhYmxlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17Y29udHJhY3RfdHlwZTp7fSxkYXRlX2Zyb206e3R5cGU6XCJzdHJpbmdcIn0sZGF0ZV90bzp7dHlwZTpcInN0cmluZ1wifSxkZXNjcmlwdGlvbjp7dHlwZTpcIm51bWVyaWNcIn0sbGltaXQ6e3R5cGU6XCJudW1lcmljXCJ9LG9mZnNldDp7dHlwZTpcIm51bWVyaWNcIn0scGFzc3Rocm91Z2g6e30scHJvZml0X3RhYmxlOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn0sc29ydDp7dHlwZTpcInN0cmluZ1wifX0scj17bWV0aG9kOlwicHJvZml0X3RhYmxlXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJwcm9wb3NhbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2Ftb3VudDp7dHlwZTpcIm51bWVyaWNcIn0sYmFycmllcjp7dHlwZTpcInN0cmluZ1wifSxiYXJyaWVyMjp7dHlwZTpcInN0cmluZ1wifSxiYXJyaWVyX3JhbmdlOnt0eXBlOlwic3RyaW5nXCJ9LGJhc2lzOnt0eXBlOlwic3RyaW5nXCJ9LGNhbmNlbGxhdGlvbjp7dHlwZTpcInN0cmluZ1wifSxjb250cmFjdF90eXBlOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0sY3VycmVuY3k6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxkYXRlX2V4cGlyeTp7dHlwZTpcIm51bWVyaWNcIn0sZGF0ZV9zdGFydDp7dHlwZTpcIm51bWVyaWNcIn0sZHVyYXRpb246e3R5cGU6XCJudW1lcmljXCJ9LGR1cmF0aW9uX3VuaXQ6e3R5cGU6XCJzdHJpbmdcIn0sbGltaXRfb3JkZXI6e3N0b3BfbG9zczp7dHlwZTpcIm51bWVyaWNcIn0sdGFrZV9wcm9maXQ6e3R5cGU6XCJudW1lcmljXCJ9fSxtdWx0aXBsaWVyOnt0eXBlOlwibnVtZXJpY1wifSxwYXNzdGhyb3VnaDp7fSxwcm9kdWN0X3R5cGU6e3R5cGU6XCJzdHJpbmdcIn0scHJvcG9zYWw6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSxzZWxlY3RlZF90aWNrOnt0eXBlOlwibnVtZXJpY1wifSxzdWJzY3JpYmU6e3R5cGU6XCJudW1lcmljXCJ9LHN5bWJvbDp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LHRyYWRpbmdfcGVyaW9kX3N0YXJ0Ont0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwicHJvcG9zYWxcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcInByb3Bvc2FsT3BlbkNvbnRyYWN0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17Y29udHJhY3RfaWQ6e3R5cGU6XCJudW1lcmljXCJ9LHBhc3N0aHJvdWdoOnt9LHByb3Bvc2FsX29wZW5fY29udHJhY3Q6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSxzdWJzY3JpYmU6e3R5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJwcm9wb3NhbF9vcGVuX2NvbnRyYWN0XCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJyZWFsaXR5Q2hlY2tcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtwYXNzdGhyb3VnaDp7fSxyZWFsaXR5X2NoZWNrOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcInJlYWxpdHlfY2hlY2tcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcInJlcXVlc3RSZXBvcnRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtkYXRlX2Zyb206e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0sZGF0ZV90bzp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxwYXNzdGhyb3VnaDp7fSxyZXBvcnRfdHlwZTp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn0scmVxdWVzdF9yZXBvcnQ6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcInJlcXVlc3RfcmVwb3J0XCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJyZXNldFBhc3N3b3JkXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17ZGF0ZV9vZl9iaXJ0aDp7dHlwZTpcInN0cmluZ1wifSxuZXdfcGFzc3dvcmQ6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxwYXNzdGhyb3VnaDp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9LHJlc2V0X3Bhc3N3b3JkOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHZlcmlmaWNhdGlvbl9jb2RlOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn19LHI9e21ldGhvZDpcInJlc2V0X3Bhc3N3b3JkXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJyZXNpZGVuY2VMaXN0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17cGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSxyZXNpZGVuY2VfbGlzdDp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwicmVzaWRlbmNlX2xpc3RcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcInJldm9rZU9hdXRoQXBwXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17cGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSxyZXZva2Vfb2F1dGhfYXBwOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJyZXZva2Vfb2F1dGhfYXBwXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJzZWxsXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17cGFzc3Rocm91Z2g6e30scHJpY2U6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSxzZWxsOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJzZWxsXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJzZWxsQ29udHJhY3RGb3JNdWx0aXBsZUFjY291bnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17cGFzc3Rocm91Z2g6e30scHJpY2U6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSxzZWxsX2NvbnRyYWN0X2Zvcl9tdWx0aXBsZV9hY2NvdW50czp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxzaG9ydGNvZGU6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSx0b2tlbnM6e3JlcXVpcmVkOjF9fSxyPXttZXRob2Q6XCJzZWxsX2NvbnRyYWN0X2Zvcl9tdWx0aXBsZV9hY2NvdW50c1wiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5Olwic2VsbEV4cGlyZWRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtwYXNzdGhyb3VnaDp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9LHNlbGxfZXhwaXJlZDp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwic2VsbF9leHBpcmVkXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJzZXJ2aWNlVG9rZW5cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtjb3VudHJ5Ont0eXBlOlwic3RyaW5nXCJ9LHBhc3N0aHJvdWdoOnt9LHJlZmVycmVyOnt0eXBlOlwic3RyaW5nXCJ9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn0sc2VydmVyOnt0eXBlOlwic3RyaW5nXCJ9LHNlcnZpY2U6e3JlcXVpcmVkOjF9LHNlcnZpY2VfdG9rZW46e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcInNlcnZpY2VfdG9rZW5cIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcInNldEFjY291bnRDdXJyZW5jeVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e3Bhc3N0aHJvdWdoOnt9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn0sc2V0X2FjY291bnRfY3VycmVuY3k6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifX0scj17bWV0aG9kOlwic2V0X2FjY291bnRfY3VycmVuY3lcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcInNldEZpbmFuY2lhbEFzc2Vzc21lbnRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXthY2NvdW50X3R1cm5vdmVyOnt0eXBlOlwic3RyaW5nXCJ9LGJpbmFyeV9vcHRpb25zX3RyYWRpbmdfZXhwZXJpZW5jZTp7dHlwZTpcInN0cmluZ1wifSxiaW5hcnlfb3B0aW9uc190cmFkaW5nX2ZyZXF1ZW5jeTp7dHlwZTpcInN0cmluZ1wifSxjZmRfdHJhZGluZ19leHBlcmllbmNlOnt0eXBlOlwic3RyaW5nXCJ9LGNmZF90cmFkaW5nX2ZyZXF1ZW5jeTp7dHlwZTpcInN0cmluZ1wifSxlZHVjYXRpb25fbGV2ZWw6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxlbXBsb3ltZW50X2luZHVzdHJ5OntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0sZW1wbG95bWVudF9zdGF0dXM6e3R5cGU6XCJzdHJpbmdcIn0sZXN0aW1hdGVkX3dvcnRoOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0sZm9yZXhfdHJhZGluZ19leHBlcmllbmNlOnt0eXBlOlwic3RyaW5nXCJ9LGZvcmV4X3RyYWRpbmdfZnJlcXVlbmN5Ont0eXBlOlwic3RyaW5nXCJ9LGluY29tZV9zb3VyY2U6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxuZXRfaW5jb21lOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0sb2NjdXBhdGlvbjp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LG90aGVyX2luc3RydW1lbnRzX3RyYWRpbmdfZXhwZXJpZW5jZTp7dHlwZTpcInN0cmluZ1wifSxvdGhlcl9pbnN0cnVtZW50c190cmFkaW5nX2ZyZXF1ZW5jeTp7dHlwZTpcInN0cmluZ1wifSxwYXNzdGhyb3VnaDp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9LHNldF9maW5hbmNpYWxfYXNzZXNzbWVudDp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSxzb3VyY2Vfb2Zfd2VhbHRoOnt0eXBlOlwic3RyaW5nXCJ9fSxyPXttZXRob2Q6XCJzZXRfZmluYW5jaWFsX2Fzc2Vzc21lbnRcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcInNldFNlbGZFeGNsdXNpb25cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtleGNsdWRlX3VudGlsOnt9LG1heF8zMGRheV9kZXBvc2l0Ont9LG1heF8zMGRheV9sb3NzZXM6e30sbWF4XzMwZGF5X3R1cm5vdmVyOnt9LG1heF83ZGF5X2RlcG9zaXQ6e30sbWF4XzdkYXlfbG9zc2VzOnt9LG1heF83ZGF5X3R1cm5vdmVyOnt9LG1heF9iYWxhbmNlOnt9LG1heF9kZXBvc2l0Ont9LG1heF9sb3NzZXM6e30sbWF4X29wZW5fYmV0czp7fSxtYXhfdHVybm92ZXI6e30scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSxzZXNzaW9uX2R1cmF0aW9uX2xpbWl0Ont9LHNldF9zZWxmX2V4Y2x1c2lvbjp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifSx0aW1lb3V0X3VudGlsOnt9fSxyPXttZXRob2Q6XCJzZXRfc2VsZl9leGNsdXNpb25cIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcInNldFNldHRpbmdzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17YWNjb3VudF9vcGVuaW5nX3JlYXNvbjp7dHlwZTpcInN0cmluZ1wifSxhZGRyZXNzX2NpdHk6e3R5cGU6XCJzdHJpbmdcIn0sYWRkcmVzc19saW5lXzE6e3R5cGU6XCJzdHJpbmdcIn0sYWRkcmVzc19saW5lXzI6e30sYWRkcmVzc19wb3N0Y29kZTp7dHlwZTpcInN0cmluZ1wifSxhZGRyZXNzX3N0YXRlOnt0eXBlOlwic3RyaW5nXCJ9LGFsbG93X2NvcGllcnM6e3R5cGU6XCJudW1lcmljXCJ9LGNpdGl6ZW46e30sZGF0ZV9vZl9iaXJ0aDp7dHlwZTpcInN0cmluZ1wifSxlbWFpbF9jb25zZW50Ont0eXBlOlwibnVtZXJpY1wifSxmZWF0dXJlX2ZsYWc6e3dhbGxldDp7dHlwZTpcIm51bWVyaWNcIn19LGZpcnN0X25hbWU6e3R5cGU6XCJzdHJpbmdcIn0sbGFzdF9uYW1lOnt0eXBlOlwic3RyaW5nXCJ9LG5vbl9wZXBfZGVjbGFyYXRpb246e3R5cGU6XCJudW1lcmljXCJ9LHBhc3N0aHJvdWdoOnt9LHBob25lOnt9LHBsYWNlX29mX2JpcnRoOnt0eXBlOlwic3RyaW5nXCJ9LHByZWZlcnJlZF9sYW5ndWFnZTp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9LHJlcXVlc3RfcHJvZmVzc2lvbmFsX3N0YXR1czp7dHlwZTpcIm51bWVyaWNcIn0scmVzaWRlbmNlOnt9LHNhbHV0YXRpb246e3R5cGU6XCJzdHJpbmdcIn0sc2VjcmV0X2Fuc3dlcjp7dHlwZTpcInN0cmluZ1wifSxzZWNyZXRfcXVlc3Rpb246e3R5cGU6XCJzdHJpbmdcIn0sc2V0X3NldHRpbmdzOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHRheF9pZGVudGlmaWNhdGlvbl9udW1iZXI6e3R5cGU6XCJzdHJpbmdcIn0sdGF4X3Jlc2lkZW5jZTp7dHlwZTpcInN0cmluZ1wifX0scj17bWV0aG9kOlwic2V0X3NldHRpbmdzXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJzdGF0ZW1lbnRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXthY3Rpb25fdHlwZTp7dHlwZTpcInN0cmluZ1wifSxkYXRlX2Zyb206e3R5cGU6XCJudW1lcmljXCJ9LGRhdGVfdG86e3R5cGU6XCJudW1lcmljXCJ9LGRlc2NyaXB0aW9uOnt0eXBlOlwibnVtZXJpY1wifSxsaW1pdDp7dHlwZTpcIm51bWVyaWNcIn0sb2Zmc2V0Ont0eXBlOlwibnVtZXJpY1wifSxwYXNzdGhyb3VnaDp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9LHN0YXRlbWVudDp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwic3RhdGVtZW50XCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJzdGF0ZXNMaXN0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17cGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSxzdGF0ZXNfbGlzdDp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9fSxyPXttZXRob2Q6XCJzdGF0ZXNfbGlzdFwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwidGlja3NcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtwYXNzdGhyb3VnaDp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9LHN1YnNjcmliZTp7dHlwZTpcIm51bWVyaWNcIn0sdGlja3M6e3JlcXVpcmVkOjF9fSxyPXttZXRob2Q6XCJ0aWNrc1wiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwidGlja3NIaXN0b3J5XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17YWRqdXN0X3N0YXJ0X3RpbWU6e3R5cGU6XCJudW1lcmljXCJ9LGNvdW50Ont0eXBlOlwibnVtZXJpY1wifSxlbmQ6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxncmFudWxhcml0eTp7dHlwZTpcIm51bWVyaWNcIn0scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSxzdGFydDp7dHlwZTpcIm51bWVyaWNcIn0sc3R5bGU6e3R5cGU6XCJzdHJpbmdcIn0sc3Vic2NyaWJlOnt0eXBlOlwibnVtZXJpY1wifSx0aWNrc19oaXN0b3J5OntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn19LHI9e21ldGhvZDpcInRpY2tzX2hpc3RvcnlcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcInRpbWVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXtwYXNzdGhyb3VnaDp7fSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9LHRpbWU6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcInRpbWVcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcInRuY0FwcHJvdmFsXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17YWZmaWxpYXRlX2NvY19hZ3JlZW1lbnQ6e3R5cGU6XCJudW1lcmljXCJ9LHBhc3N0aHJvdWdoOnt9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn0sdG5jX2FwcHJvdmFsOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9LHVrZ2NfZnVuZHNfcHJvdGVjdGlvbjp7dHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcInRuY19hcHByb3ZhbFwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwidG9wdXBWaXJ0dWFsXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17cGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSx0b3B1cF92aXJ0dWFsOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJ0b3B1cF92aXJ0dWFsXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJ0cmFkaW5nRHVyYXRpb25zXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17bGFuZGluZ19jb21wYW55Ont0eXBlOlwic3RyaW5nXCJ9LHBhc3N0aHJvdWdoOnt9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn0sdHJhZGluZ19kdXJhdGlvbnM6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcInRyYWRpbmdfZHVyYXRpb25zXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJ0cmFkaW5nUGxhdGZvcm1BY2NvdW50c1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e3Bhc3N0aHJvdWdoOnt9LHBsYXRmb3JtOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSx0cmFkaW5nX3BsYXRmb3JtX2FjY291bnRzOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJ0cmFkaW5nX3BsYXRmb3JtX2FjY291bnRzXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJ0cmFkaW5nUGxhdGZvcm1EZXBvc2l0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17YW1vdW50Ont0eXBlOlwibnVtZXJpY1wifSxmcm9tX2FjY291bnQ6e3R5cGU6XCJzdHJpbmdcIn0scGFzc3Rocm91Z2g6e30scGxhdGZvcm06e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9LHRvX2FjY291bnQ6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSx0cmFkaW5nX3BsYXRmb3JtX2RlcG9zaXQ6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcInRyYWRpbmdfcGxhdGZvcm1fZGVwb3NpdFwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwidHJhZGluZ1BsYXRmb3JtSW52ZXN0b3JQYXNzd29yZENoYW5nZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2FjY291bnRfaWQ6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxuZXdfcGFzc3dvcmQ6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxvbGRfcGFzc3dvcmQ6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxwYXNzdGhyb3VnaDp7fSxwbGF0Zm9ybTp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn0sdHJhZGluZ19wbGF0Zm9ybV9pbnZlc3Rvcl9wYXNzd29yZF9jaGFuZ2U6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcInRyYWRpbmdfcGxhdGZvcm1faW52ZXN0b3JfcGFzc3dvcmRfY2hhbmdlXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJ0cmFkaW5nUGxhdGZvcm1JbnZlc3RvclBhc3N3b3JkUmVzZXRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXthY2NvdW50X2lkOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0sbmV3X3Bhc3N3b3JkOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0scGFzc3Rocm91Z2g6e30scGxhdGZvcm06e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9LHRyYWRpbmdfcGxhdGZvcm1faW52ZXN0b3JfcGFzc3dvcmRfcmVzZXQ6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0sdmVyaWZpY2F0aW9uX2NvZGU6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifX0scj17bWV0aG9kOlwidHJhZGluZ19wbGF0Zm9ybV9pbnZlc3Rvcl9wYXNzd29yZF9yZXNldFwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwidHJhZGluZ1BsYXRmb3JtTmV3QWNjb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2FjY291bnRfdHlwZTp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LGN1cnJlbmN5Ont0eXBlOlwic3RyaW5nXCJ9LGRyeV9ydW46e3R5cGU6XCJudW1lcmljXCJ9LG1hcmtldF90eXBlOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0scGFzc3Rocm91Z2g6e30scGFzc3dvcmQ6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxwbGF0Zm9ybTp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn0sc3ViX2FjY291bnRfdHlwZTp7dHlwZTpcInN0cmluZ1wifSx0cmFkaW5nX3BsYXRmb3JtX25ld19hY2NvdW50OntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJ0cmFkaW5nX3BsYXRmb3JtX25ld19hY2NvdW50XCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJ0cmFkaW5nUGxhdGZvcm1QYXNzd29yZENoYW5nZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e25ld19wYXNzd29yZDp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LG9sZF9wYXNzd29yZDp7dHlwZTpcInN0cmluZ1wifSxwYXNzdGhyb3VnaDp7fSxwbGF0Zm9ybTp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn0sdHJhZGluZ19wbGF0Zm9ybV9wYXNzd29yZF9jaGFuZ2U6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcInRyYWRpbmdfcGxhdGZvcm1fcGFzc3dvcmRfY2hhbmdlXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJ0cmFkaW5nUGxhdGZvcm1QYXNzd29yZFJlc2V0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17bmV3X3Bhc3N3b3JkOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0scGFzc3Rocm91Z2g6e30scGxhdGZvcm06e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9LHRyYWRpbmdfcGxhdGZvcm1fcGFzc3dvcmRfcmVzZXQ6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0sdmVyaWZpY2F0aW9uX2NvZGU6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifX0scj17bWV0aG9kOlwidHJhZGluZ19wbGF0Zm9ybV9wYXNzd29yZF9yZXNldFwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwidHJhZGluZ1BsYXRmb3JtUHJvZHVjdExpc3RpbmdcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXthcHBfaWQ6e30sY291bnRyeV9jb2RlOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSx0cmFkaW5nX3BsYXRmb3JtX3Byb2R1Y3RfbGlzdGluZzp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwidHJhZGluZ19wbGF0Zm9ybV9wcm9kdWN0X2xpc3RpbmdcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcInRyYWRpbmdQbGF0Zm9ybVdpdGhkcmF3YWxcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXthbW91bnQ6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0sZnJvbV9hY2NvdW50OntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn0scGFzc3Rocm91Z2g6e30scGxhdGZvcm06e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSxyZXFfaWQ6e3R5cGU6XCJudW1lcmljXCJ9LHRvX2FjY291bnQ6e3JlcXVpcmVkOjEsdHlwZTpcInN0cmluZ1wifSx0cmFkaW5nX3BsYXRmb3JtX3dpdGhkcmF3YWw6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcInRyYWRpbmdfcGxhdGZvcm1fd2l0aGRyYXdhbFwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwidHJhZGluZ1NlcnZlcnNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PXthY2NvdW50X3R5cGU6e3R5cGU6XCJzdHJpbmdcIn0sZW52aXJvbm1lbnQ6e3R5cGU6XCJzdHJpbmdcIn0sbWFya2V0X3R5cGU6e3R5cGU6XCJzdHJpbmdcIn0scGFzc3Rocm91Z2g6e30scGxhdGZvcm06e3R5cGU6XCJzdHJpbmdcIn0scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSx0cmFkaW5nX3NlcnZlcnM6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcInRyYWRpbmdfc2VydmVyc1wiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5OlwidHJhZGluZ1RpbWVzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17cGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSx0cmFkaW5nX3RpbWVzOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn19LHI9e21ldGhvZDpcInRyYWRpbmdfdGltZXNcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcInRyYW5zYWN0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17cGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSxzdWJzY3JpYmU6e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn0sdHJhbnNhY3Rpb246e3JlcXVpcmVkOjEsdHlwZTpcIm51bWVyaWNcIn19LHI9e21ldGhvZDpcInRyYW5zYWN0aW9uXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJ0cmFuc2ZlckJldHdlZW5BY2NvdW50c1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e2FjY291bnRfZnJvbTp7dHlwZTpcInN0cmluZ1wifSxhY2NvdW50X3RvOnt0eXBlOlwic3RyaW5nXCJ9LGFjY291bnRzOnt0eXBlOlwic3RyaW5nXCJ9LGFtb3VudDp7dHlwZTpcIm51bWVyaWNcIn0sY3VycmVuY3k6e3R5cGU6XCJzdHJpbmdcIn0scGFzc3Rocm91Z2g6e30scmVxX2lkOnt0eXBlOlwibnVtZXJpY1wifSx0cmFuc2Zlcl9iZXR3ZWVuX2FjY291bnRzOntyZXF1aXJlZDoxLHR5cGU6XCJudW1lcmljXCJ9fSxyPXttZXRob2Q6XCJ0cmFuc2Zlcl9iZXR3ZWVuX2FjY291bnRzXCIsbmVlZHNNZXRob2RBcmc6XCIxXCIsYXJnczplLGNvbmZpZzp0fTtyZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChyKX19LHtrZXk6XCJ2ZXJpZnlFbWFpbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e3Bhc3N0aHJvdWdoOnt9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn0sdHlwZTp7cmVxdWlyZWQ6MSx0eXBlOlwic3RyaW5nXCJ9LHVybF9wYXJhbWV0ZXJzOnthZmZpbGlhdGVfdG9rZW46e3R5cGU6XCJzdHJpbmdcIn0sZGF0ZV9maXJzdF9jb250YWN0Ont0eXBlOlwic3RyaW5nXCJ9LGdjbGlkX3VybDp7dHlwZTpcInN0cmluZ1wifSxwYV9hbW91bnQ6e3R5cGU6XCJudW1lcmljXCJ9LHBhX2N1cnJlbmN5Ont0eXBlOlwic3RyaW5nXCJ9LHBhX2xvZ2luaWQ6e3R5cGU6XCJzdHJpbmdcIn0scGFfcmVtYXJrczp7dHlwZTpcInN0cmluZ1wifSxyZWRpcmVjdF90bzp7dHlwZTpcIm51bWVyaWNcIn0sc2lnbnVwX2RldmljZTp7dHlwZTpcInN0cmluZ1wifSx1dG1fYWRfaWQ6e30sdXRtX2FkZ3JvdXBfaWQ6e30sdXRtX2Fkcm9sbGNsa19pZDp7fSx1dG1fY2FtcGFpZ246e30sdXRtX2NhbXBhaWduX2lkOnt9LHV0bV9jb250ZW50Ont9LHV0bV9mYmNsX2lkOnt9LHV0bV9nbF9jbGllbnRfaWQ6e30sdXRtX21lZGl1bTp7fSx1dG1fbXNjbGtfaWQ6e30sdXRtX3NvdXJjZTp7fSx1dG1fdGVybTp7fX0sdmVyaWZ5X2VtYWlsOntyZXF1aXJlZDoxLHR5cGU6XCJzdHJpbmdcIn19LHI9e21ldGhvZDpcInZlcmlmeV9lbWFpbFwiLG5lZWRzTWV0aG9kQXJnOlwiMVwiLGFyZ3M6ZSxjb25maWc6dH07cmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3Qocil9fSx7a2V5Olwid2Vic2l0ZVN0YXR1c1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHQ9e3Bhc3N0aHJvdWdoOnt9LHJlcV9pZDp7dHlwZTpcIm51bWVyaWNcIn0sc3Vic2NyaWJlOnt0eXBlOlwibnVtZXJpY1wifSx3ZWJzaXRlX3N0YXR1czp7cmVxdWlyZWQ6MSx0eXBlOlwibnVtZXJpY1wifX0scj17bWV0aG9kOlwid2Vic2l0ZV9zdGF0dXNcIixuZWVkc01ldGhvZEFyZzpcIjFcIixhcmdzOmUsY29uZmlnOnR9O3JldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHIpfX0se2tleTpcInByb2Nlc3NSZXF1ZXN0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHI9ZS5jb25maWcsbj1mdW5jdGlvbihlKXt2YXIgdD1lLmNvbmZpZyxyPWUuYXJncyxuPWUubWV0aG9kLGk9ZS5uZWVkc01ldGhvZEFyZyxzPXI7cmV0dXJuIGkmJiFtZShzKSYmKHM9ZmUoe30sbixzKSksc1tuXT1zW25dfHwxLE9iamVjdC5rZXlzKHMpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciByPXNbZV07ZSBpbiB0JiYoXCJzdHJpbmdcIj09PXRbZV0udHlwZT9zW2VdPVwiXCIuY29uY2F0KHIpOlwibnVtZXJpY1wiPT09dFtlXS50eXBlP3NbZV09cGFyc2VGbG9hdChyKTpcImJvb2xlYW5cIj09PXRbZV0udHlwZSYmKHNbZV09K3IpKX0pKSxzfShlKSxpPWZ1bmN0aW9uKGUpe3ZhciByPWUuY29uZmlnLG49ZS5hcmdzO2lmKCFtZShuKSlyZXR1cm5cIlJlcXVpcmVzIGFuIG9iamVjdCBidXQgYSBcIi5jb25jYXQodChuKSxcIiBpcyBwYXNzZWQuXCIpO3ZhciBpPVtdLHM9T2JqZWN0LmtleXMocikuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4ocltlXXx8e30pLnJlcXVpcmVkJiYhKGUgaW4gbil9KSk7cmV0dXJuIHMubGVuZ3RoJiZpLnB1c2goXCJSZXF1aXJlZCBwYXJhbWV0ZXJzIG1pc3Npbmc6IFwiLmNvbmNhdChzLmpvaW4oXCIsIFwiKSkpLE9iamVjdC5rZXlzKG4pLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBzPW5bZV07aWYoZSBpbiByKXt2YXIgbz1yW2VdLnR5cGU7byYmKHZlW29dKHMpfHxpLnB1c2goXCJcIi5jb25jYXQobyxcIiB2YWx1ZSBleHBlY3RlZCBidXQgZm91bmQgXCIpLmNvbmNhdCh0KHMpLFwiOiBcIikuY29uY2F0KGUpKSl9fSkpLGkubGVuZ3RoP2kuam9pbihcIiAtIFwiKTpcIlwifSh7Y29uZmlnOnIsYXJnczpufSk7cmV0dXJuIGk/UHJvbWlzZS5yZWplY3QoaSk6dGhpcy5zZW5kKG4pfX1dKSxlfSgpLG1lPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgT2JqZWN0fSx2ZT17b2JqZWN0Om1lLG51bWVyaWM6ZnVuY3Rpb24oZSl7cmV0dXJuIU51bWJlci5pc05hTigxKmUpfSxzdHJpbmc6ZnVuY3Rpb24oZSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGV9LGJvb2xlYW46ZnVuY3Rpb24oZSl7cmV0dXJuWyEwLCExLDAsMV0uaW5jbHVkZXMoZSl9fTtmdW5jdGlvbiBxZSgpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhUmVmbGVjdC5jb25zdHJ1Y3QpcmV0dXJuITE7aWYoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2goZSl7cmV0dXJuITF9fWZ1bmN0aW9uIGJlKGUsdCxyKXtyZXR1cm4gYmU9cWUoKT9SZWZsZWN0LmNvbnN0cnVjdDpmdW5jdGlvbihlLHQscil7dmFyIG49W251bGxdO24ucHVzaC5hcHBseShuLHQpO3ZhciBpPW5ldyhGdW5jdGlvbi5iaW5kLmFwcGx5KGUsbikpO3JldHVybiByJiZwKGksci5wcm90b3R5cGUpLGl9LGJlLmFwcGx5KG51bGwsYXJndW1lbnRzKX1mdW5jdGlvbiB3ZShlKXt2YXIgdD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBNYXA/bmV3IE1hcDp2b2lkIDA7cmV0dXJuIHdlPWZ1bmN0aW9uKGUpe2lmKG51bGw9PT1lfHwocj1lLC0xPT09RnVuY3Rpb24udG9TdHJpbmcuY2FsbChyKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSkpcmV0dXJuIGU7dmFyIHI7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7aWYodm9pZCAwIT09dCl7aWYodC5oYXMoZSkpcmV0dXJuIHQuZ2V0KGUpO3Quc2V0KGUsbil9ZnVuY3Rpb24gbigpe3JldHVybiBiZShlLGFyZ3VtZW50cyx5KHRoaXMpLmNvbnN0cnVjdG9yKX1yZXR1cm4gbi5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOm4sZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSkscChuLGUpfSx3ZShlKX1mdW5jdGlvbiBrZShlKXt2YXIgdD1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhUmVmbGVjdC5jb25zdHJ1Y3QpcmV0dXJuITE7aWYoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2goZSl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciByLG49eShlKTtpZih0KXt2YXIgaT15KHRoaXMpLmNvbnN0cnVjdG9yO3I9UmVmbGVjdC5jb25zdHJ1Y3Qobixhcmd1bWVudHMsaSl9ZWxzZSByPW4uYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiBoKHRoaXMscil9fWZ1bmN0aW9uIEFlKGUpe3JldHVybiBmdW5jdGlvbih0KXtkKG4sdCk7dmFyIHI9a2Uobik7ZnVuY3Rpb24gbih0KXt2YXIgaTtyZXR1cm4gbyh0aGlzLG4pLChpPXIuY2FsbCh0aGlzKSkudHlwZT1lLGkubWVzc2FnZT10LGl9cmV0dXJuIGMobixbe2tleTpcInRvU3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm5cIlwiLmNvbmNhdCh0aGlzLnR5cGUsXCI6IFwiKS5jb25jYXQodGhpcy5tZXNzYWdlKX19XSksbn0od2UoRXJyb3IpKX12YXIgeGU9ZnVuY3Rpb24oZSl7ZChyLGUpO3ZhciB0PWtlKHIpO2Z1bmN0aW9uIHIoKXtyZXR1cm4gbyh0aGlzLHIpLHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBjKHIpfShBZShcIkFQSUVycm9yXCIpKSxSZT1mdW5jdGlvbihlKXtkKHIsZSk7dmFyIHQ9a2Uocik7ZnVuY3Rpb24gcigpe3JldHVybiBvKHRoaXMsciksdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIGMocil9KEFlKFwiQ29uc3RydWN0aW9uRXJyb3JcIikpLE1lPXIoMjY2KSxPZT1yLm4oTWUpO2Z1bmN0aW9uIFNlKGUsdCl7dmFyIHI9T2JqZWN0LmtleXMoZSk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTt0JiYobj1uLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSx0KS5lbnVtZXJhYmxlfSkpKSxyLnB1c2guYXBwbHkocixuKX1yZXR1cm4gcn1mdW5jdGlvbiBFZShlKXt2YXIgdD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXt2YXIgcj1udWxsIT1hcmd1bWVudHNbdF0/YXJndW1lbnRzW3RdOnt9O3QlMj9TZShPYmplY3QociksITApLmZvckVhY2goKGZ1bmN0aW9uKHQpe2ZlKGUsdCxyW3RdKX0pKTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHIpKTpTZShPYmplY3QocikpLmZvckVhY2goKGZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLHQpKX0pKX1yZXR1cm4gZX0oe30sZSk7cmV0dXJuIGRlbGV0ZSB0LnJlcV9pZCxkZWxldGUgdC5wYXNzdGhyb3VnaCxkZWxldGUgdC5zdWJzY3JpYmUsT2UoKSh0KX12YXIgamU9ZnVuY3Rpb24oZSl7ZChmLGUpO3ZhciB0LHIsbixpLHUsYSxwLGw9KGE9ZixwPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCFSZWZsZWN0LmNvbnN0cnVjdClyZXR1cm4hMTtpZihSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaChlKXtyZXR1cm4hMX19KCksZnVuY3Rpb24oKXt2YXIgZSx0PXkoYSk7aWYocCl7dmFyIHI9eSh0aGlzKS5jb25zdHJ1Y3RvcjtlPVJlZmxlY3QuY29uc3RydWN0KHQsYXJndW1lbnRzLHIpfWVsc2UgZT10LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gaCh0aGlzLGUpfSk7ZnVuY3Rpb24gZihlLHQpe3ZhciByO2lmKG8odGhpcyxmKSwhZSl0aHJvdyBuZXcgUmUoXCJDYWNoZSBvYmplY3QgbmVlZHMgYW4gQVBJIHRvIHdvcmtcIik7cmV0dXJuKHI9bC5jYWxsKHRoaXMpKS5hcGk9ZSxyLnN0b3JhZ2U9dCxyfXJldHVybiBjKGYsW3trZXk6XCJzZW5kXCIsdmFsdWU6KHU9cyhnKCkubWFyaygoZnVuY3Rpb24gZSh0KXt2YXIgcjtyZXR1cm4gZygpLndyYXAoKGZ1bmN0aW9uKGUpe2Zvcig7Oylzd2l0Y2goZS5wcmV2PWUubmV4dCl7Y2FzZSAwOnJldHVybiBlLm5leHQ9Mix0aGlzLmhhcyh0KTtjYXNlIDI6aWYoIWUuc2VudCl7ZS5uZXh0PTQ7YnJlYWt9cmV0dXJuIGUuYWJydXB0KFwicmV0dXJuXCIsdGhpcy5nZXQodCkpO2Nhc2UgNDpyZXR1cm4gZS5uZXh0PTYsdGhpcy5hcGkuc2VuZCh0KTtjYXNlIDY6cmV0dXJuIHI9ZS5zZW50LGUubmV4dD05LHRoaXMuc2V0KHQscik7Y2FzZSA5OnJldHVybiBlLmFicnVwdChcInJldHVyblwiLHIpO2Nhc2UgMTA6Y2FzZVwiZW5kXCI6cmV0dXJuIGUuc3RvcCgpfX0pLGUsdGhpcyl9KSkpLGZ1bmN0aW9uKGUpe3JldHVybiB1LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pfSx7a2V5OlwiaGFzXCIsdmFsdWU6KGk9cyhnKCkubWFyaygoZnVuY3Rpb24gZSh0KXtyZXR1cm4gZygpLndyYXAoKGZ1bmN0aW9uKGUpe2Zvcig7Oylzd2l0Y2goZS5wcmV2PWUubmV4dCl7Y2FzZSAwOnJldHVybiBlLmFicnVwdChcInJldHVyblwiLHRoaXMuc3RvcmFnZS5oYXMoRWUodCkpKTtjYXNlIDE6Y2FzZVwiZW5kXCI6cmV0dXJuIGUuc3RvcCgpfX0pLGUsdGhpcyl9KSkpLGZ1bmN0aW9uKGUpe3JldHVybiBpLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pfSx7a2V5OlwiZ2V0XCIsdmFsdWU6KG49cyhnKCkubWFyaygoZnVuY3Rpb24gZSh0KXtyZXR1cm4gZygpLndyYXAoKGZ1bmN0aW9uKGUpe2Zvcig7Oylzd2l0Y2goZS5wcmV2PWUubmV4dCl7Y2FzZSAwOnJldHVybiBlLmFicnVwdChcInJldHVyblwiLHRoaXMuc3RvcmFnZS5nZXQoRWUodCkpKTtjYXNlIDE6Y2FzZVwiZW5kXCI6cmV0dXJuIGUuc3RvcCgpfX0pLGUsdGhpcyl9KSkpLGZ1bmN0aW9uKGUpe3JldHVybiBuLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pfSx7a2V5OlwiZ2V0QnlNc2dUeXBlXCIsdmFsdWU6KHI9cyhnKCkubWFyaygoZnVuY3Rpb24gZSh0KXtyZXR1cm4gZygpLndyYXAoKGZ1bmN0aW9uKGUpe2Zvcig7Oylzd2l0Y2goZS5wcmV2PWUubmV4dCl7Y2FzZSAwOnJldHVybiBlLmFicnVwdChcInJldHVyblwiLHRoaXMuc3RvcmFnZS5nZXRCeU1zZ1R5cGUodCkpO2Nhc2UgMTpjYXNlXCJlbmRcIjpyZXR1cm4gZS5zdG9wKCl9fSksZSx0aGlzKX0pKSksZnVuY3Rpb24oZSl7cmV0dXJuIHIuYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9LHtrZXk6XCJzZXRcIix2YWx1ZToodD1zKGcoKS5tYXJrKChmdW5jdGlvbiBlKHQscil7cmV0dXJuIGcoKS53cmFwKChmdW5jdGlvbihlKXtmb3IoOzspc3dpdGNoKGUucHJldj1lLm5leHQpe2Nhc2UgMDpyZXR1cm4gZS5hYnJ1cHQoXCJyZXR1cm5cIix0aGlzLnN0b3JhZ2Uuc2V0KEVlKHQpLHIpKTtjYXNlIDE6Y2FzZVwiZW5kXCI6cmV0dXJuIGUuc3RvcCgpfX0pLGUsdGhpcyl9KSkpLGZ1bmN0aW9uKGUscil7cmV0dXJuIHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9XSksZn0oX2UpO3ZhciBQZT1mdW5jdGlvbihlKXtkKGksZSk7dmFyIHQscixuPSh0PWkscj1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhUmVmbGVjdC5jb25zdHJ1Y3QpcmV0dXJuITE7aWYoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2goZSl7cmV0dXJuITF9fSgpLGZ1bmN0aW9uKCl7dmFyIGUsbj15KHQpO2lmKHIpe3ZhciBpPXkodGhpcykuY29uc3RydWN0b3I7ZT1SZWZsZWN0LmNvbnN0cnVjdChuLGFyZ3VtZW50cyxpKX1lbHNlIGU9bi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIGgodGhpcyxlKX0pO2Z1bmN0aW9uIGkoKXt2YXIgZSx0LHIscz1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06ZnVuY3Rpb24oKXt9O3JldHVybiBvKHRoaXMsaSksZT1uLmNhbGwodGhpcywoZnVuY3Rpb24oZSxuKXt0PWUscj1ufSkpLHModCxyKSxlLnJlc29sdmVDYWxsYmFjaz10LGUucmVqZWN0Q2FsbGJhY2s9cixlLnN0YXRlPVwicGVuZGluZ1wiLGV9cmV0dXJuIGMoaSxbe2tleTpcInJlc29sdmVcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXNvbHZlQ2FsbGJhY2soZSksdGhpcy5zdGF0ZT1cInJlc29sdmVkXCIsdGhpc319LHtrZXk6XCJyZWplY3RcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZWplY3RDYWxsYmFjayhlKSx0aGlzLnN0YXRlPVwicmVqZWN0ZWRcIix0aGlzfX0se2tleTpcImlzUGVuZGluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuXCJwZW5kaW5nXCI9PT10aGlzLnN0YXRlfX0se2tleTpcImlzUmVqZWN0ZWRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVyblwicmVqZWN0ZWRcIj09PXRoaXMuc3RhdGV9fSx7a2V5OlwiaXNSZXNvbHZlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuXCJyZXNvbHZlZFwiPT09dGhpcy5zdGF0ZX19XSxbe2tleTpcIndyYXBcIix2YWx1ZTpmdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgdGhpcylyZXR1cm4gZTt2YXIgdD1uZXcgdGhpcztyZXR1cm4gZS50aGVuKHQucmVzb2x2ZS5iaW5kKHQpLHQucmVqZWN0LmJpbmQodCkpLHR9fV0pLGl9KHdlKFByb21pc2UpKSxDZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXtvKHRoaXMsZSksdGhpcy5zdG9yZT17YnlfbXNnX3R5cGU6e319fXJldHVybiBjKGUsW3trZXk6XCJoYXNcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZSBpbiB0aGlzLnN0b3JlfX0se2tleTpcImdldFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnN0b3JlW2VdfX0se2tleTpcImdldEJ5TXNnVHlwZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnN0b3JlLmJ5X21zZ190eXBlW2VdfX0se2tleTpcInNldFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dGhpcy5zdG9yZS5ieV9tc2dfdHlwZVt0Lm1zZ190eXBlXT10LHRoaXMuc3RvcmVbZV09dH19XSksZX0oKSxUZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7dGhpcy5jYWxsYmFjaz1lfXJldHVybiBlLnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQuc3Vic2NyaWJlKG5ldyBMZShlLHRoaXMuY2FsbGJhY2spKX0sZX0oKSxMZT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQscil7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuIG4uYWRkKG5ldyBPKHIpKSxufXJldHVybiB2KHQsZSksdH0oaik7Y29uc3QgRGU9W1wiYmFsYW5jZVwiLFwiYnV5XCIsXCJjYXNoaWVyX3BheW1lbnRzXCIsXCJleGNoYW5nZV9yYXRlc1wiLFwicDJwX2FkdmVydF9pbmZvXCIsXCJwMnBfYWR2ZXJ0aXNlcl9jcmVhdGVcIixcInAycF9hZHZlcnRpc2VyX2luZm9cIixcInAycF9vcmRlcl9jcmVhdGVcIixcInAycF9vcmRlcl9pbmZvXCIsXCJwMnBfb3JkZXJfbGlzdFwiLFwicHJvcG9zYWxcIixcInByb3Bvc2FsX29wZW5fY29udHJhY3RcIixcInRpY2tzXCIsXCJ0aWNrc19oaXN0b3J5XCIsXCJ0cmFuc2FjdGlvblwiLFwid2Vic2l0ZV9zdGF0dXNcIl07ZnVuY3Rpb24gSWUoZSx0KXt2YXIgcj1PYmplY3Qua2V5cyhlKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO3QmJihuPW4uZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLHQpLmVudW1lcmFibGV9KSkpLHIucHVzaC5hcHBseShyLG4pfXJldHVybiByfWZ1bmN0aW9uIEJlKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciByPW51bGwhPWFyZ3VtZW50c1t0XT9hcmd1bWVudHNbdF06e307dCUyP0llKE9iamVjdChyKSwhMCkuZm9yRWFjaCgoZnVuY3Rpb24odCl7ZmUoZSx0LHJbdF0pfSkpOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocikpOkllKE9iamVjdChyKSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsdCkpfSkpfXJldHVybiBlfXZhciBIZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7byh0aGlzLGUpLHRoaXMuYXBpPXQsdGhpcy5zb3VyY2VzPXt9LHRoaXMuc3Vic19pZF90b19rZXk9e30sdGhpcy5rZXlfdG9fc3Vic19pZD17fSx0aGlzLmJ1eV9rZXlfdG9fY29udHJhY3RfaWQ9e30sdGhpcy5zdWJzX3Blcl9tc2dfdHlwZT1bXSx0aGlzLnN0cmVhbXNfbGlzdD1EZX1yZXR1cm4gYyhlLFt7a2V5Olwic3Vic2NyaWJlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuc291cmNlRXhpc3RzKGUpP3RoaXMuZ2V0U291cmNlKGUpOnRoaXMuY3JlYXRlTmV3U291cmNlKEJlKEJlKHt9LGUpLHt9LHtzdWJzY3JpYmU6MX0pKX19LHtrZXk6XCJnZXRTb3VyY2VcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1OZShlKTtpZih0IGluIHRoaXMuc291cmNlcylyZXR1cm4gdGhpcy5zb3VyY2VzW3RdO2lmKGUucHJvcG9zYWxfb3Blbl9jb250cmFjdCYmZS5jb250cmFjdF9pZCl7dmFyIHI9T2JqZWN0LnZhbHVlcyh0aGlzLmJ1eV9rZXlfdG9fY29udHJhY3RfaWQpLmZpbmQoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNvbnRyYWN0X2lkPT09ZS5jb250cmFjdF9pZH0pKTtpZihyKXJldHVybiB0aGlzLnNvdXJjZXNbci5idXlfa2V5XX19fSx7a2V5Olwic291cmNlRXhpc3RzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZ2V0U291cmNlKGUpfX0se2tleTpcImNyZWF0ZU5ld1NvdXJjZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0LHI9dGhpcyxuPU5lKGUpLGk9dGhpcy5hcGkuc2VuZEFuZEdldFNvdXJjZShlKS5waXBlKCh0PWZ1bmN0aW9uKCl7biBpbiByLmtleV90b19zdWJzX2lkJiZyLmZvcmdldChyLmtleV90b19zdWJzX2lkW25dKS50aGVuKChmdW5jdGlvbigpe30pLChmdW5jdGlvbigpe30pKX0sZnVuY3Rpb24oZSl7cmV0dXJuIGUubGlmdChuZXcgVGUodCkpfSksZ2UoKSk7cmV0dXJuIHRoaXMuc291cmNlc1tuXT1pLHRoaXMuc2F2ZVN1YnNQZXJNc2dUeXBlKGUsbiksaS5waXBlKHRlKCkpLnRvUHJvbWlzZSgpLnRoZW4oKGZ1bmN0aW9uKHQpe2UuYnV5JiYoci5idXlfa2V5X3RvX2NvbnRyYWN0X2lkW25dPXtjb250cmFjdF9pZDp0LmJ1eS5jb250cmFjdF9pZCxidXlfa2V5Om59KSxyLnNhdmVTdWJzSWQobix0KX0pLHRoaXMucmVtb3ZlS2V5T25FcnJvcihuKSksaX19LHtrZXk6XCJmb3JnZXRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5jb21wbGV0ZVN1YnNCeUlkcyhlKSx0aGlzLmFwaS5zZW5kKHtmb3JnZXQ6ZX0pfX0se2tleTpcImZvcmdldEFsbFwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXMsdD1hcmd1bWVudHMubGVuZ3RoLHI9bmV3IEFycmF5KHQpLG49MDtuPHQ7bisrKXJbbl09YXJndW1lbnRzW25dO3JldHVybiByLmZvckVhY2goKGZ1bmN0aW9uKHQpeyhlLnN1YnNfcGVyX21zZ190eXBlW3RdfHxbXSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIGUuY29tcGxldGVTdWJzQnlLZXkodCl9KSksZS5zdWJzX3Blcl9tc2dfdHlwZVt0XT1bXX0pKSx0aGlzLmFwaS5zZW5kKHtmb3JnZXRfYWxsOnJ9KX19LHtrZXk6XCJjb21wbGV0ZVN1YnNCeUlkc1wiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXMsdD1hcmd1bWVudHMubGVuZ3RoLHI9bmV3IEFycmF5KHQpLG49MDtuPHQ7bisrKXJbbl09YXJndW1lbnRzW25dO3IuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIHI9ZS5zdWJzX2lkX3RvX2tleVt0XTtkZWxldGUgZS5zdWJzX2lkX3RvX2tleVt0XSxlLmNvbXBsZXRlU3Vic0J5S2V5KHIpfSkpfX0se2tleTpcInNhdmVTdWJzSWRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciByPXQuc3Vic2NyaXB0aW9uO2lmKCFyKXJldHVybiB0aGlzLmNvbXBsZXRlU3Vic0J5S2V5KGUpO3ZhciBuPXIuaWQ7biBpbiB0aGlzLnN1YnNfaWRfdG9fa2V5fHwodGhpcy5zdWJzX2lkX3RvX2tleVtuXT1lLHRoaXMua2V5X3RvX3N1YnNfaWRbZV09bil9fSx7a2V5Olwic2F2ZVN1YnNQZXJNc2dUeXBlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLmdldE1zZ1R5cGUoZSk7cj8odGhpcy5zdWJzX3Blcl9tc2dfdHlwZVtyXT10aGlzLnN1YnNfcGVyX21zZ190eXBlW3JdfHxbXSx0aGlzLnN1YnNfcGVyX21zZ190eXBlW3JdLnB1c2godCkpOnRoaXMuYXBpLnNhbml0eUVycm9ycy5uZXh0KG5ldyB4ZShcIlN1YnNjcmlwdGlvbiB0eXBlIGlzIG5vdCBmb3VuZCBpbiBkZXJpdi1hcGlcIikpfX0se2tleTpcInJlbW92ZUtleU9uRXJyb3JcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmNvbXBsZXRlU3Vic0J5S2V5KGUpfX19LHtrZXk6XCJjb21wbGV0ZVN1YnNCeUtleVwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKGUmJnRoaXMuc291cmNlc1tlXSl7dmFyIHQ9dGhpcy5zb3VyY2VzW2VdO2RlbGV0ZSB0aGlzLnNvdXJjZXNbZV07dmFyIHI9dGhpcy5rZXlfdG9fc3Vic19pZFtlXTtkZWxldGUgdGhpcy5zdWJzX2lkX3RvX2tleVtyXSxkZWxldGUgdGhpcy5rZXlfdG9fc3Vic19pZFtlXSxkZWxldGUgdGhpcy5idXlfa2V5X3RvX2NvbnRyYWN0X2lkW2VdLHQuY29tcGxldGUoKX19fSx7a2V5OlwiZ2V0TXNnVHlwZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnN0cmVhbXNfbGlzdC5maW5kKChmdW5jdGlvbih0KXtyZXR1cm4gdCBpbiBlfSkpfX1dKSxlfSgpO2Z1bmN0aW9uIE5lKGUpe3JldHVybiBFZShlKX12YXIgRmU9ZnVuY3Rpb24oZSl7ZChmLGUpO3ZhciB0LHIsbixpLHUscCxsPSh1PWYscD1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhUmVmbGVjdC5jb25zdHJ1Y3QpcmV0dXJuITE7aWYoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2goZSl7cmV0dXJuITF9fSgpLGZ1bmN0aW9uKCl7dmFyIGUsdD15KHUpO2lmKHApe3ZhciByPXkodGhpcykuY29uc3RydWN0b3I7ZT1SZWZsZWN0LmNvbnN0cnVjdCh0LGFyZ3VtZW50cyxyKX1lbHNlIGU9dC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIGgodGhpcyxlKX0pO2Z1bmN0aW9uIGYoKXt2YXIgZSx0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSxyPXQuc3RvcmFnZSxuPXQuYXBwX2lkLGk9dC5jb25uZWN0aW9uLHM9dC5jYWNoZSx1PXZvaWQgMD09PXM/bmV3IENlOnMsYz10LmVuZHBvaW50LHA9dm9pZCAwPT09Yz9cIndzLmJpbmFyeXdzLmNvbVwiOmMsZD10LmxhbmcsaD12b2lkIDA9PT1kP1wiRU5cIjpkLHk9dC5icmFuZCxnPXZvaWQgMD09PXk/XCJcIjp5LF89dC5taWRkbGV3YXJlLG09dm9pZCAwPT09Xz97fTpfO2lmKG8odGhpcyxmKSwoZT1sLmNhbGwodGhpcykpLmV2ZW50cz1uZXcgb2UsaSllLmNvbm5lY3Rpb249aTtlbHNle2lmKCFuKXRocm93IEVycm9yKFwiQW4gYXBwX2lkIGlzIHJlcXVpcmVkIHRvIGNvbm5lY3QgdG8gdGhlIEFQSVwiKTtlLnNob3VsZFJlY29ubmVjdD0hMCxlLmNvbm5lY3Rpb25BcmdzPXthcHBfaWQ6bixlbmRwb2ludFVybDpVZShwKSxsYW5nOmgudG9VcHBlckNhc2UoKSxicmFuZDpnLnRvTG93ZXJDYXNlKCl9LGUuY29ubmVjdCgpfXJldHVybiBlLmxhbmc9aCxlLnJlcUlkPTAsZS5jb25uZWN0ZWQ9bmV3IFBlLGUuc2FuaXR5RXJyb3JzPW5ldyBvZSxlLm1pZGRsZXdhcmU9bSxlLnBlbmRpbmdSZXF1ZXN0cz17fSxlLmV4cGVjdF9yZXNwb25zZV90eXBlcz17fSxlLnN1YnNjcmlwdGlvbl9tYW5hZ2VyPW5ldyBIZShhKGUpKSxlLnJlY29ubmVjdF90aW1lb3V0PSExLGUua2VlcF9hbGl2ZV9pbnRlcnZhbD0hMSxyJiYoZS5zdG9yYWdlPW5ldyBqZShhKGUpLHIpKSxlLmNhY2hlPW5ldyBqZShlLnN0b3JhZ2U/ZS5zdG9yYWdlOmEoZSksdSksZS5jb25uZWN0aW9uSGFuZGxlcnMoKSxlfXJldHVybiBjKGYsW3trZXk6XCJjb25uZWN0aW9uSGFuZGxlcnNcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuY29ubmVjdGlvbi5vbm9wZW49dGhpcy5vcGVuSGFuZGxlci5iaW5kKHRoaXMpLHRoaXMuY29ubmVjdGlvbi5vbmNsb3NlPXRoaXMuY2xvc2VIYW5kbGVyLmJpbmQodGhpcyksdGhpcy5jb25uZWN0aW9uLm9ubWVzc2FnZT10aGlzLm1lc3NhZ2VIYW5kbGVyLmJpbmQodGhpcyksdGhpcy5jb25uZWN0aW9uLm9uZXJyb3I9dGhpcy5lcnJvckhhbmRsZXIuYmluZCh0aGlzKX19LHtrZXk6XCJjb25uZWN0XCIsdmFsdWU6ZnVuY3Rpb24oKXtpZighdGhpcy5jb25uZWN0aW9uQXJncyl0aHJvdyBuZXcgUmUoXCJDb25uZWN0aW9uIGFyZ3VtZW50cyBhcmUgcmVxdWlyZWQgdG8gY3JlYXRlIGEgY29ubmVjdGlvbi5cIik7dGhpcy5ldmVudHMubmV4dCh7bmFtZTpcImNvbm5lY3RcIn0pO3ZhciBlPXRoaXMuY29ubmVjdGlvbkFyZ3MsdD1lLmVuZHBvaW50VXJsLHI9ZS5sYW5nLG49ZS5hcHBfaWQsaT1lLmJyYW5kO3RoaXMuY29ubmVjdGlvbj1uZXcgV2ViU29ja2V0KFwiXCIuY29uY2F0KHQudG9TdHJpbmcoKSxcIndlYnNvY2tldHMvdjM/YXBwX2lkPVwiKS5jb25jYXQobixcIiZsPVwiKS5jb25jYXQocixcIiZicmFuZD1cIikuY29uY2F0KGkpKX19LHtrZXk6XCJkaXNjb25uZWN0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnNob3VsZFJlY29ubmVjdD0hMSx0aGlzLmNvbm5lY3Rpb24uY2xvc2UoKX19LHtrZXk6XCJpc0Nvbm5lY3Rpb25DbG9zZWRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiAyPT09dGhpcy5jb25uZWN0aW9uLnJlYWR5U3RhdGV8fDM9PT10aGlzLmNvbm5lY3Rpb24ucmVhZHlTdGF0ZX19LHtrZXk6XCJzZW5kQW5kR2V0U291cmNlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxyPW5ldyBvZTtyZXR1cm4gZS5yZXFfaWQ9ZS5yZXFfaWR8fCsrdGhpcy5yZXFJZCx0aGlzLnBlbmRpbmdSZXF1ZXN0c1tlLnJlcV9pZF09cix0aGlzLmNvbm5lY3RlZC50aGVuKChmdW5jdGlvbigpe3QuaXNDb25uZWN0aW9uQ2xvc2VkKCl8fHQuY29ubmVjdGlvbi5zZW5kKEpTT04uc3RyaW5naWZ5KGUpKX0pKS5jYXRjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIHIuZXJyb3IoZSl9KSkscn19LHtrZXk6XCJzZW5kXCIsdmFsdWU6KGk9cyhnKCkubWFyaygoZnVuY3Rpb24gZSgpe3ZhciB0LHIsbixpLHMsbyx1LGMsYT10aGlzLHA9YXJndW1lbnRzO3JldHVybiBnKCkud3JhcCgoZnVuY3Rpb24oZSl7Zm9yKDs7KXN3aXRjaChlLnByZXY9ZS5uZXh0KXtjYXNlIDA6Zm9yKHQ9cC5sZW5ndGgscj1uZXcgQXJyYXkodCksbj0wO248dDtuKyspcltuXT1wW25dO2lmKCEoaT10aGlzLmNhbGxNaWRkbGV3YXJlKFwic2VuZFdpbGxCZUNhbGxlZFwiLHthcmdzOnJ9KSkpe2UubmV4dD00O2JyZWFrfXJldHVybiBlLmFicnVwdChcInJldHVyblwiLGkpO2Nhc2UgNDppZihzPXJbMF0sbz10aGlzLmNhbGxNaWRkbGV3YXJlKFwicmVxdWVzdERhdGFUcmFuc2Zvcm1lclwiLHMpfHxzLHRoaXMuZXZlbnRzLm5leHQoe25hbWU6XCJzZW5kXCIsZGF0YTpvfSksdGhpcy5kZWxldGVGcm9tRXhwZWN0UmVzcG9uc2UobyksKHU9dGhpcy5zZW5kQW5kR2V0U291cmNlKG8pLnBpcGUodGUoKSkudG9Qcm9taXNlKCkpLnRoZW4oKGZ1bmN0aW9uKGUpe2EuY2FjaGUuc2V0KG8sZSksYS5zdG9yYWdlJiZhLnN0b3JhZ2Uuc2V0KG8sZSl9KSwoZnVuY3Rpb24oKXt9KSksIShjPXRoaXMuY2FsbE1pZGRsZXdhcmUoXCJzZW5kSXNDYWxsZWRcIix7cmVzcG9uc2VfcHJvbWlzZTp1LGFyZ3M6cn0pKSl7ZS5uZXh0PTEzO2JyZWFrfXJldHVybiBlLmFicnVwdChcInJldHVyblwiLGMpO2Nhc2UgMTM6cmV0dXJuIGUuYWJydXB0KFwicmV0dXJuXCIsdSk7Y2FzZSAxNDpjYXNlXCJlbmRcIjpyZXR1cm4gZS5zdG9wKCl9fSksZSx0aGlzKX0pKSksZnVuY3Rpb24oKXtyZXR1cm4gaS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KX0se2tleTpcImNhbGxNaWRkbGV3YXJlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtpZihlIGluIHRoaXMubWlkZGxld2FyZSlyZXR1cm4gdGhpcy5taWRkbGV3YXJlW2VdKHQpfX0se2tleTpcInN1YnNjcmliZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuY2FsbE1pZGRsZXdhcmUoXCJyZXF1ZXN0RGF0YVRyYW5zZm9ybWVyXCIsZSl8fGU7cmV0dXJuIHRoaXMuc3Vic2NyaXB0aW9uX21hbmFnZXIuc3Vic2NyaWJlKHQpfX0se2tleTpcImZvcmdldFwiLHZhbHVlOihuPXMoZygpLm1hcmsoKGZ1bmN0aW9uIGUodCl7cmV0dXJuIGcoKS53cmFwKChmdW5jdGlvbihlKXtmb3IoOzspc3dpdGNoKGUucHJldj1lLm5leHQpe2Nhc2UgMDpyZXR1cm4gZS5hYnJ1cHQoXCJyZXR1cm5cIix0aGlzLnN1YnNjcmlwdGlvbl9tYW5hZ2VyLmZvcmdldCh0KSk7Y2FzZSAxOmNhc2VcImVuZFwiOnJldHVybiBlLnN0b3AoKX19KSxlLHRoaXMpfSkpKSxmdW5jdGlvbihlKXtyZXR1cm4gbi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KX0se2tleTpcImZvcmdldEFsbFwiLHZhbHVlOihyPXMoZygpLm1hcmsoKGZ1bmN0aW9uIGUoKXt2YXIgdCxyPWFyZ3VtZW50cztyZXR1cm4gZygpLndyYXAoKGZ1bmN0aW9uKGUpe2Zvcig7Oylzd2l0Y2goZS5wcmV2PWUubmV4dCl7Y2FzZSAwOnJldHVybiBlLmFicnVwdChcInJldHVyblwiLCh0PXRoaXMuc3Vic2NyaXB0aW9uX21hbmFnZXIpLmZvcmdldEFsbC5hcHBseSh0LHIpKTtjYXNlIDE6Y2FzZVwiZW5kXCI6cmV0dXJuIGUuc3RvcCgpfX0pLGUsdGhpcyl9KSkpLGZ1bmN0aW9uKCl7cmV0dXJuIHIuYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9LHtrZXk6XCJrZWVwQWxpdmVQaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnBpbmcoe3Bpbmc6MX0pLHRoaXMucmVjb25uZWN0X3RpbWVvdXQ9c2V0VGltZW91dCh0aGlzLnJlY29ubmVjdC5iaW5kKHRoaXMpLDVlMyl9fSx7a2V5OlwicG9uZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5yZWNvbm5lY3RfdGltZW91dCYmKGNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdF90aW1lb3V0KSx0aGlzLnJlY29ubmVjdF90aW1lb3V0PSExKX19LHtrZXk6XCJvcGVuSGFuZGxlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5ldmVudHMubmV4dCh7bmFtZTpcIm9wZW5cIn0pLHRoaXMuc2hvdWxkUmVjb25uZWN0JiYodGhpcy5rZWVwX2FsaXZlX2ludGVydmFsPXNldEludGVydmFsKHRoaXMua2VlcEFsaXZlUGluZy5iaW5kKHRoaXMpLDNlNCkpLDE9PT10aGlzLmNvbm5lY3Rpb24ucmVhZHlTdGF0ZT90aGlzLmNvbm5lY3RlZC5yZXNvbHZlKCk6c2V0VGltZW91dCh0aGlzLm9wZW5IYW5kbGVyLmJpbmQodGhpcyksNTApfX0se2tleTpcIm1lc3NhZ2VIYW5kbGVyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYoZS5kYXRhKXt2YXIgdD1KU09OLnBhcnNlKGUuZGF0YSk7dGhpcy5yZWNvbm5lY3RfdGltZW91dCYmXCJwb25nXCI9PT10LnBpbmcmJnRoaXMucG9uZygpLHRoaXMuZXZlbnRzLm5leHQoe25hbWU6XCJtZXNzYWdlXCIsZGF0YTp0fSk7dmFyIHI9dC5yZXFfaWQ7aWYociBpbiB0aGlzLnBlbmRpbmdSZXF1ZXN0cyl7dmFyIG49dGhpcy5leHBlY3RfcmVzcG9uc2VfdHlwZXNbdC5tc2dfdHlwZV07biYmbi5pc1BlbmRpbmcoKSYmbi5yZXNvbHZlKHQpO3ZhciBpPXQuZWNob19yZXEscz1pJiZpLnByb3Bvc2FsX29wZW5fY29udHJhY3QmJiFpLmNvbnRyYWN0X2lkO2lmKHQuZXJyb3ImJiFzKXRoaXMucGVuZGluZ1JlcXVlc3RzW3JdLmVycm9yKHQpO2Vsc2UgaWYodGhpcy5wZW5kaW5nUmVxdWVzdHNbcl0uaXNTdG9wcGVkJiZ0LnN1YnNjcmlwdGlvbil7dmFyIG89dC5zdWJzY3JpcHRpb24uaWQ7dGhpcy5mb3JnZXQobyl9ZWxzZSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1tyXS5uZXh0KHQpfWVsc2UgdGhpcy5zYW5pdHlFcnJvcnMubmV4dChuZXcgeGUoXCJFeHRyYSByZXNwb25zZVwiKSl9ZWxzZSB0aGlzLnNhbml0eUVycm9ycy5uZXh0KG5ldyB4ZShcIlNvbWV0aGluZyB3ZW50IHdyb25nIHdoaWxlIHJlY2VpdmluZyB0aGUgcmVzcG9uc2UgZnJvbSBBUEkuXCIpKX19LHtrZXk6XCJjbG9zZUhhbmRsZXJcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuZXZlbnRzLm5leHQoe25hbWU6XCJjbG9zZVwifSksdGhpcy5zaG91bGRSZWNvbm5lY3QmJih0aGlzLmV2ZW50cy5uZXh0KHtuYW1lOlwicmVjb25uZWN0aW5nXCJ9KSx0aGlzLnJlY29ubmVjdCgpKX19LHtrZXk6XCJyZWNvbm5lY3RcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuc2hvdWxkUmVjb25uZWN0JiYodGhpcy5rZWVwX2FsaXZlX2ludGVydmFsJiYoY2xlYXJJbnRlcnZhbCh0aGlzLmtlZXBfYWxpdmVfaW50ZXJ2YWwpLHRoaXMua2VlcF9hbGl2ZV9pbnRlcnZhbD0hMSksdGhpcy5wb25nKCksdGhpcy5jb25uZWN0KCksdGhpcy5jb25uZWN0aW9uSGFuZGxlcnMoKSl9fSx7a2V5OlwiZXJyb3JIYW5kbGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnNhbml0eUVycm9ycy5uZXh0KG5ldyB4ZShcIlNvbWV0aGluZyB3ZW50IHdyb25nIHdoaWxlIHJlY2VpdmluZyB0aGUgcmVzcG9uc2UgZnJvbSBBUEkuXCIpKX19LHtrZXk6XCJvbkNsb3NlXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ldmVudHMucGlwZShDKChmdW5jdGlvbihlKXtyZXR1cm5cImNsb3NlXCI9PT1lLm5hbWV9KSksZ2UoKSl9fSx7a2V5Olwib25PcGVuXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ldmVudHMucGlwZShDKChmdW5jdGlvbihlKXtyZXR1cm5cIm9wZW5cIj09PWUubmFtZX0pKSxnZSgpKX19LHtrZXk6XCJvbk1lc3NhZ2VcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmV2ZW50cy5waXBlKEMoKGZ1bmN0aW9uKGUpe3JldHVyblwibWVzc2FnZVwiPT09ZS5uYW1lfSkpLGdlKCkpfX0se2tleTpcImV4cGVjdFJlc3BvbnNlXCIsdmFsdWU6KHQ9cyhnKCkubWFyaygoZnVuY3Rpb24gZSgpe3ZhciB0LHIsbixpPXRoaXMscz1hcmd1bWVudHM7cmV0dXJuIGcoKS53cmFwKChmdW5jdGlvbihlKXtmb3IoOzspc3dpdGNoKGUucHJldj1lLm5leHQpe2Nhc2UgMDpmb3IodD1zLmxlbmd0aCxyPW5ldyBBcnJheSh0KSxuPTA7bjx0O24rKylyW25dPXNbbl07aWYoci5mb3JFYWNoKChmdW5jdGlvbihlKXtlIGluIGkuZXhwZWN0X3Jlc3BvbnNlX3R5cGVzfHwoaS5leHBlY3RfcmVzcG9uc2VfdHlwZXNbZV09VmUoaS5jYWNoZS5nZXRCeU1zZ1R5cGUoZSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIXQmJmkuc3RvcmFnZT9pLnN0b3JhZ2UuZ2V0QnlNc2dUeXBlKGUpOnR9KSkpKX0pKSwxIT09ci5sZW5ndGgpe2UubmV4dD00O2JyZWFrfXJldHVybiBlLmFicnVwdChcInJldHVyblwiLHRoaXMuZXhwZWN0X3Jlc3BvbnNlX3R5cGVzW3JbMF1dKTtjYXNlIDQ6cmV0dXJuIGUuYWJydXB0KFwicmV0dXJuXCIsUHJvbWlzZS5hbGwoci5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBpLmV4cGVjdF9yZXNwb25zZV90eXBlc1tlXX0pKSkpO2Nhc2UgNTpjYXNlXCJlbmRcIjpyZXR1cm4gZS5zdG9wKCl9fSksZSx0aGlzKX0pKSksZnVuY3Rpb24oKXtyZXR1cm4gdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KX0se2tleTpcImRlbGV0ZUZyb21FeHBlY3RSZXNwb25zZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PU9iamVjdC5rZXlzKHRoaXMuZXhwZWN0X3Jlc3BvbnNlX3R5cGVzKS5maW5kKChmdW5jdGlvbih0KXtyZXR1cm4gdCBpbiBlfSkpO3RoaXMuZXhwZWN0X3Jlc3BvbnNlX3R5cGVzW3RdJiYhdGhpcy5leHBlY3RfcmVzcG9uc2VfdHlwZXNbdF0uaXNQZW5kaW5nKCkmJmRlbGV0ZSB0aGlzLmV4cGVjdF9yZXNwb25zZV90eXBlc1t0XX19XSksZn0oX2UpO2Z1bmN0aW9uIFVlKHIpe2lmKFwic3RyaW5nXCIhPXR5cGVvZiByKXRocm93IG5ldyBSZShcIkVuZHBvaW50IG11c3QgYmUgYSBzdHJpbmcsIHBhc3NlZDogXCIuY29uY2F0KHQocikpKTt2YXIgbixpLHM7dHJ5e3ZhciBvPShpPXIubWF0Y2goLygoPzpcXHcqOlxcL1xcLykqKSguKikvKSxzPTMsZnVuY3Rpb24oZSl7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZX0oaSl8fGZ1bmN0aW9uKGUsdCl7dmFyIHI9bnVsbD09ZT9udWxsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJmVbU3ltYm9sLml0ZXJhdG9yXXx8ZVtcIkBAaXRlcmF0b3JcIl07aWYobnVsbCE9cil7dmFyIG4saSxzPVtdLG89ITAsdT0hMTt0cnl7Zm9yKHI9ci5jYWxsKGUpOyEobz0obj1yLm5leHQoKSkuZG9uZSkmJihzLnB1c2gobi52YWx1ZSksIXR8fHMubGVuZ3RoIT09dCk7bz0hMCk7fWNhdGNoKGUpe3U9ITAsaT1lfWZpbmFsbHl7dHJ5e298fG51bGw9PXIucmV0dXJufHxyLnJldHVybigpfWZpbmFsbHl7aWYodSl0aHJvdyBpfX1yZXR1cm4gc319KGkscyl8fGZ1bmN0aW9uKHQscil7aWYodCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpcmV0dXJuIGUodCxyKTt2YXIgbj1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkuc2xpY2UoOCwtMSk7cmV0dXJuXCJPYmplY3RcIj09PW4mJnQuY29uc3RydWN0b3ImJihuPXQuY29uc3RydWN0b3IubmFtZSksXCJNYXBcIj09PW58fFwiU2V0XCI9PT1uP0FycmF5LmZyb20odCk6XCJBcmd1bWVudHNcIj09PW58fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pP2UodCxyKTp2b2lkIDB9fShpLHMpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9KCkpLHU9KG9bMF0sb1sxXSksYz1vWzJdO249bmV3IFVSTChcIlwiLmNvbmNhdChcIndzOi8vXCI9PT11P3U6XCJ3c3M6Ly9cIikuY29uY2F0KGMpKX1jYXRjaChlKXt0aHJvdyBuZXcgUmUoXCJJbnZhbGlkIFVSTDogXCIuY29uY2F0KHIpKX1yZXR1cm4gbn1mdW5jdGlvbiBWZShlKXtyZXR1cm4gUGUud3JhcChlLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBlfHxuZXcgUGV9KSkpfX0pKCksbi5kZWZhdWx0fSkoKX0pKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/@deriv/deriv-api/dist/DerivAPIBasic.js\n");

/***/ }),

/***/ "./Components/address-details/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ Components_address_details)\n});\n\n// EXTERNAL MODULE: external \"react\"\nvar external_react_ = __webpack_require__(\"react\");\nvar external_react_default = /*#__PURE__*/__webpack_require__.n(external_react_);\n// EXTERNAL MODULE: ../../../node_modules/classnames/index.js\nvar classnames = __webpack_require__(\"../../../node_modules/classnames/index.js\");\nvar classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);\n;// CONCATENATED MODULE: ../../../node_modules/formik/node_modules/deepmerge/dist/es.js\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tObject.keys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tObject.keys(source).forEach(function(key) {\n\t\tif (!options.isMergeableObject(source[key]) || !target[key]) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = deepmerge(target[key], source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\n/* harmony default export */ const es = (deepmerge_1);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_freeGlobal.js\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/* harmony default export */ const _freeGlobal = (freeGlobal);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_root.js\n\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = _freeGlobal || freeSelf || Function('return this')();\n\n/* harmony default export */ const _root = (root);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_Symbol.js\n\n\n/** Built-in value references. */\nvar _Symbol_Symbol = _root.Symbol;\n\n/* harmony default export */ const _Symbol = (_Symbol_Symbol);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_getRawTag.js\n\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar _getRawTag_hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = _getRawTag_hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/* harmony default export */ const _getRawTag = (getRawTag);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_objectToString.js\n/** Used for built-in method references. */\nvar _objectToString_objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar _objectToString_nativeObjectToString = _objectToString_objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return _objectToString_nativeObjectToString.call(value);\n}\n\n/* harmony default export */ const _objectToString = (objectToString);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseGetTag.js\n\n\n\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar _baseGetTag_symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (_baseGetTag_symToStringTag && _baseGetTag_symToStringTag in Object(value))\n    ? _getRawTag(value)\n    : _objectToString(value);\n}\n\n/* harmony default export */ const _baseGetTag = (baseGetTag);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_overArg.js\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/* harmony default export */ const _overArg = (overArg);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_getPrototype.js\n\n\n/** Built-in value references. */\nvar getPrototype = _overArg(Object.getPrototypeOf, Object);\n\n/* harmony default export */ const _getPrototype = (getPrototype);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isObjectLike.js\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/* harmony default export */ const lodash_es_isObjectLike = (isObjectLike);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isPlainObject.js\n\n\n\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    isPlainObject_objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar isPlainObject_hasOwnProperty = isPlainObject_objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!lodash_es_isObjectLike(value) || _baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = _getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = isPlainObject_hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\n/* harmony default export */ const lodash_es_isPlainObject = (isPlainObject);\n\n// EXTERNAL MODULE: ../../../node_modules/react-fast-compare/index.js\nvar react_fast_compare = __webpack_require__(\"../../../node_modules/react-fast-compare/index.js\");\nvar react_fast_compare_default = /*#__PURE__*/__webpack_require__.n(react_fast_compare);\n;// CONCATENATED MODULE: ../../../node_modules/tiny-warning/dist/tiny-warning.esm.js\nvar isProduction = \"production\" === 'production';\nfunction warning(condition, message) {\n  if (!isProduction) {\n    if (condition) {\n      return;\n    }\n\n    var text = \"Warning: \" + message;\n\n    if (typeof console !== 'undefined') {\n      console.warn(text);\n    }\n\n    try {\n      throw Error(text);\n    } catch (x) {}\n  }\n}\n\n/* harmony default export */ const tiny_warning_esm = (warning);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_listCacheClear.js\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/* harmony default export */ const _listCacheClear = (listCacheClear);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/eq.js\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/* harmony default export */ const lodash_es_eq = (eq);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_assocIndexOf.js\n\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (lodash_es_eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/* harmony default export */ const _assocIndexOf = (assocIndexOf);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_listCacheDelete.js\n\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = _assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/* harmony default export */ const _listCacheDelete = (listCacheDelete);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_listCacheGet.js\n\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = _assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/* harmony default export */ const _listCacheGet = (listCacheGet);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_listCacheHas.js\n\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return _assocIndexOf(this.__data__, key) > -1;\n}\n\n/* harmony default export */ const _listCacheHas = (listCacheHas);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_listCacheSet.js\n\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = _assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n/* harmony default export */ const _listCacheSet = (listCacheSet);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_ListCache.js\n\n\n\n\n\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = _listCacheClear;\nListCache.prototype['delete'] = _listCacheDelete;\nListCache.prototype.get = _listCacheGet;\nListCache.prototype.has = _listCacheHas;\nListCache.prototype.set = _listCacheSet;\n\n/* harmony default export */ const _ListCache = (ListCache);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_stackClear.js\n\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new _ListCache;\n  this.size = 0;\n}\n\n/* harmony default export */ const _stackClear = (stackClear);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_stackDelete.js\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/* harmony default export */ const _stackDelete = (stackDelete);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_stackGet.js\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/* harmony default export */ const _stackGet = (stackGet);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_stackHas.js\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/* harmony default export */ const _stackHas = (stackHas);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isObject.js\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/* harmony default export */ const lodash_es_isObject = (isObject);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isFunction.js\n\n\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!lodash_es_isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = _baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/* harmony default export */ const lodash_es_isFunction = (isFunction);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_coreJsData.js\n\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = _root[\"__core-js_shared__\"];\n\n/* harmony default export */ const _coreJsData = (coreJsData);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_isMasked.js\n\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/* harmony default export */ const _isMasked = (isMasked);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_toSource.js\n/** Used for built-in method references. */\nvar _toSource_funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar _toSource_funcToString = _toSource_funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return _toSource_funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/* harmony default export */ const _toSource = (toSource);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseIsNative.js\n\n\n\n\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar _baseIsNative_funcProto = Function.prototype,\n    _baseIsNative_objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar _baseIsNative_funcToString = _baseIsNative_funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar _baseIsNative_hasOwnProperty = _baseIsNative_objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  _baseIsNative_funcToString.call(_baseIsNative_hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!lodash_es_isObject(value) || _isMasked(value)) {\n    return false;\n  }\n  var pattern = lodash_es_isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(_toSource(value));\n}\n\n/* harmony default export */ const _baseIsNative = (baseIsNative);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_getValue.js\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/* harmony default export */ const _getValue = (getValue);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_getNative.js\n\n\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = _getValue(object, key);\n  return _baseIsNative(value) ? value : undefined;\n}\n\n/* harmony default export */ const _getNative = (getNative);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_Map.js\n\n\n\n/* Built-in method references that are verified to be native. */\nvar _Map_Map = _getNative(_root, 'Map');\n\n/* harmony default export */ const _Map = (_Map_Map);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_nativeCreate.js\n\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = _getNative(Object, 'create');\n\n/* harmony default export */ const _nativeCreate = (nativeCreate);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_hashClear.js\n\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/* harmony default export */ const _hashClear = (hashClear);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_hashDelete.js\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/* harmony default export */ const _hashDelete = (hashDelete);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_hashGet.js\n\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar _hashGet_objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar _hashGet_hasOwnProperty = _hashGet_objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (_nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return _hashGet_hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/* harmony default export */ const _hashGet = (hashGet);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_hashHas.js\n\n\n/** Used for built-in method references. */\nvar _hashHas_objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar _hashHas_hasOwnProperty = _hashHas_objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return _nativeCreate ? (data[key] !== undefined) : _hashHas_hasOwnProperty.call(data, key);\n}\n\n/* harmony default export */ const _hashHas = (hashHas);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_hashSet.js\n\n\n/** Used to stand-in for `undefined` hash values. */\nvar _hashSet_HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (_nativeCreate && value === undefined) ? _hashSet_HASH_UNDEFINED : value;\n  return this;\n}\n\n/* harmony default export */ const _hashSet = (hashSet);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_Hash.js\n\n\n\n\n\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = _hashClear;\nHash.prototype['delete'] = _hashDelete;\nHash.prototype.get = _hashGet;\nHash.prototype.has = _hashHas;\nHash.prototype.set = _hashSet;\n\n/* harmony default export */ const _Hash = (Hash);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_mapCacheClear.js\n\n\n\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new _Hash,\n    'map': new (_Map || _ListCache),\n    'string': new _Hash\n  };\n}\n\n/* harmony default export */ const _mapCacheClear = (mapCacheClear);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_isKeyable.js\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/* harmony default export */ const _isKeyable = (isKeyable);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_getMapData.js\n\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return _isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/* harmony default export */ const _getMapData = (getMapData);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_mapCacheDelete.js\n\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = _getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/* harmony default export */ const _mapCacheDelete = (mapCacheDelete);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_mapCacheGet.js\n\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return _getMapData(this, key).get(key);\n}\n\n/* harmony default export */ const _mapCacheGet = (mapCacheGet);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_mapCacheHas.js\n\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return _getMapData(this, key).has(key);\n}\n\n/* harmony default export */ const _mapCacheHas = (mapCacheHas);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_mapCacheSet.js\n\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = _getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n/* harmony default export */ const _mapCacheSet = (mapCacheSet);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_MapCache.js\n\n\n\n\n\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = _mapCacheClear;\nMapCache.prototype['delete'] = _mapCacheDelete;\nMapCache.prototype.get = _mapCacheGet;\nMapCache.prototype.has = _mapCacheHas;\nMapCache.prototype.set = _mapCacheSet;\n\n/* harmony default export */ const _MapCache = (MapCache);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_stackSet.js\n\n\n\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof _ListCache) {\n    var pairs = data.__data__;\n    if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new _MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n/* harmony default export */ const _stackSet = (stackSet);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_Stack.js\n\n\n\n\n\n\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new _ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = _stackClear;\nStack.prototype['delete'] = _stackDelete;\nStack.prototype.get = _stackGet;\nStack.prototype.has = _stackHas;\nStack.prototype.set = _stackSet;\n\n/* harmony default export */ const _Stack = (Stack);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_arrayEach.js\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/* harmony default export */ const _arrayEach = (arrayEach);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_defineProperty.js\n\n\nvar defineProperty = (function() {\n  try {\n    var func = _getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\n/* harmony default export */ const _defineProperty = (defineProperty);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseAssignValue.js\n\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && _defineProperty) {\n    _defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\n/* harmony default export */ const _baseAssignValue = (baseAssignValue);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_assignValue.js\n\n\n\n/** Used for built-in method references. */\nvar _assignValue_objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar _assignValue_hasOwnProperty = _assignValue_objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(_assignValue_hasOwnProperty.call(object, key) && lodash_es_eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    _baseAssignValue(object, key, value);\n  }\n}\n\n/* harmony default export */ const _assignValue = (assignValue);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_copyObject.js\n\n\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      _baseAssignValue(object, key, newValue);\n    } else {\n      _assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\n/* harmony default export */ const _copyObject = (copyObject);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseTimes.js\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/* harmony default export */ const _baseTimes = (baseTimes);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseIsArguments.js\n\n\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return lodash_es_isObjectLike(value) && _baseGetTag(value) == argsTag;\n}\n\n/* harmony default export */ const _baseIsArguments = (baseIsArguments);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isArguments.js\n\n\n\n/** Used for built-in method references. */\nvar isArguments_objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar isArguments_hasOwnProperty = isArguments_objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = isArguments_objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {\n  return lodash_es_isObjectLike(value) && isArguments_hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/* harmony default export */ const lodash_es_isArguments = (isArguments);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isArray.js\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/* harmony default export */ const lodash_es_isArray = (isArray);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/stubFalse.js\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\n/* harmony default export */ const lodash_es_stubFalse = (stubFalse);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isBuffer.js\n\n\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? _root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || lodash_es_stubFalse;\n\n/* harmony default export */ const lodash_es_isBuffer = (isBuffer);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_isIndex.js\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/* harmony default export */ const _isIndex = (isIndex);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isLength.js\n/** Used as references for various `Number` constants. */\nvar isLength_MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= isLength_MAX_SAFE_INTEGER;\n}\n\n/* harmony default export */ const lodash_es_isLength = (isLength);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseIsTypedArray.js\n\n\n\n\n/** `Object#toString` result references. */\nvar _baseIsTypedArray_argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    _baseIsTypedArray_funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    _baseIsTypedArray_objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[_baseIsTypedArray_argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[_baseIsTypedArray_funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[_baseIsTypedArray_objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return lodash_es_isObjectLike(value) &&\n    lodash_es_isLength(value.length) && !!typedArrayTags[_baseGetTag(value)];\n}\n\n/* harmony default export */ const _baseIsTypedArray = (baseIsTypedArray);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseUnary.js\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/* harmony default export */ const _baseUnary = (baseUnary);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_nodeUtil.js\n\n\n/** Detect free variable `exports`. */\nvar _nodeUtil_freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar _nodeUtil_freeModule = _nodeUtil_freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar _nodeUtil_moduleExports = _nodeUtil_freeModule && _nodeUtil_freeModule.exports === _nodeUtil_freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = _nodeUtil_moduleExports && _freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = _nodeUtil_freeModule && _nodeUtil_freeModule.require && _nodeUtil_freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* harmony default export */ const _nodeUtil = (nodeUtil);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isTypedArray.js\n\n\n\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;\n\n/* harmony default export */ const lodash_es_isTypedArray = (isTypedArray);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_arrayLikeKeys.js\n\n\n\n\n\n\n\n/** Used for built-in method references. */\nvar _arrayLikeKeys_objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar _arrayLikeKeys_hasOwnProperty = _arrayLikeKeys_objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = lodash_es_isArray(value),\n      isArg = !isArr && lodash_es_isArguments(value),\n      isBuff = !isArr && !isArg && lodash_es_isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && lodash_es_isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? _baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || _arrayLikeKeys_hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           _isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/* harmony default export */ const _arrayLikeKeys = (arrayLikeKeys);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_isPrototype.js\n/** Used for built-in method references. */\nvar _isPrototype_objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || _isPrototype_objectProto;\n\n  return value === proto;\n}\n\n/* harmony default export */ const _isPrototype = (isPrototype);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_nativeKeys.js\n\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = _overArg(Object.keys, Object);\n\n/* harmony default export */ const _nativeKeys = (nativeKeys);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseKeys.js\n\n\n\n/** Used for built-in method references. */\nvar _baseKeys_objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar _baseKeys_hasOwnProperty = _baseKeys_objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!_isPrototype(object)) {\n    return _nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (_baseKeys_hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/* harmony default export */ const _baseKeys = (baseKeys);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isArrayLike.js\n\n\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && lodash_es_isLength(value.length) && !lodash_es_isFunction(value);\n}\n\n/* harmony default export */ const lodash_es_isArrayLike = (isArrayLike);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/keys.js\n\n\n\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return lodash_es_isArrayLike(object) ? _arrayLikeKeys(object) : _baseKeys(object);\n}\n\n/* harmony default export */ const lodash_es_keys = (keys);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseAssign.js\n\n\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && _copyObject(source, lodash_es_keys(source), object);\n}\n\n/* harmony default export */ const _baseAssign = (baseAssign);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_nativeKeysIn.js\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/* harmony default export */ const _nativeKeysIn = (nativeKeysIn);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseKeysIn.js\n\n\n\n\n/** Used for built-in method references. */\nvar _baseKeysIn_objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar _baseKeysIn_hasOwnProperty = _baseKeysIn_objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!lodash_es_isObject(object)) {\n    return _nativeKeysIn(object);\n  }\n  var isProto = _isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !_baseKeysIn_hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/* harmony default export */ const _baseKeysIn = (baseKeysIn);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/keysIn.js\n\n\n\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return lodash_es_isArrayLike(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);\n}\n\n/* harmony default export */ const lodash_es_keysIn = (keysIn);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseAssignIn.js\n\n\n\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssignIn(object, source) {\n  return object && _copyObject(source, lodash_es_keysIn(source), object);\n}\n\n/* harmony default export */ const _baseAssignIn = (baseAssignIn);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_cloneBuffer.js\n\n\n/** Detect free variable `exports`. */\nvar _cloneBuffer_freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar _cloneBuffer_freeModule = _cloneBuffer_freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar _cloneBuffer_moduleExports = _cloneBuffer_freeModule && _cloneBuffer_freeModule.exports === _cloneBuffer_freeExports;\n\n/** Built-in value references. */\nvar _cloneBuffer_Buffer = _cloneBuffer_moduleExports ? _root.Buffer : undefined,\n    allocUnsafe = _cloneBuffer_Buffer ? _cloneBuffer_Buffer.allocUnsafe : undefined;\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\n/* harmony default export */ const _cloneBuffer = (cloneBuffer);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_copyArray.js\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/* harmony default export */ const _copyArray = (copyArray);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_arrayFilter.js\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/* harmony default export */ const _arrayFilter = (arrayFilter);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/stubArray.js\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/* harmony default export */ const lodash_es_stubArray = (stubArray);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_getSymbols.js\n\n\n\n/** Used for built-in method references. */\nvar _getSymbols_objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar _getSymbols_propertyIsEnumerable = _getSymbols_objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? lodash_es_stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return _arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return _getSymbols_propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/* harmony default export */ const _getSymbols = (getSymbols);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_copySymbols.js\n\n\n\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return _copyObject(source, _getSymbols(source), object);\n}\n\n/* harmony default export */ const _copySymbols = (copySymbols);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_arrayPush.js\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/* harmony default export */ const _arrayPush = (arrayPush);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_getSymbolsIn.js\n\n\n\n\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar _getSymbolsIn_nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !_getSymbolsIn_nativeGetSymbols ? lodash_es_stubArray : function(object) {\n  var result = [];\n  while (object) {\n    _arrayPush(result, _getSymbols(object));\n    object = _getPrototype(object);\n  }\n  return result;\n};\n\n/* harmony default export */ const _getSymbolsIn = (getSymbolsIn);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_copySymbolsIn.js\n\n\n\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbolsIn(source, object) {\n  return _copyObject(source, _getSymbolsIn(source), object);\n}\n\n/* harmony default export */ const _copySymbolsIn = (copySymbolsIn);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseGetAllKeys.js\n\n\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return lodash_es_isArray(object) ? result : _arrayPush(result, symbolsFunc(object));\n}\n\n/* harmony default export */ const _baseGetAllKeys = (baseGetAllKeys);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_getAllKeys.js\n\n\n\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return _baseGetAllKeys(object, lodash_es_keys, _getSymbols);\n}\n\n/* harmony default export */ const _getAllKeys = (getAllKeys);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_getAllKeysIn.js\n\n\n\n\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n  return _baseGetAllKeys(object, lodash_es_keysIn, _getSymbolsIn);\n}\n\n/* harmony default export */ const _getAllKeysIn = (getAllKeysIn);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_DataView.js\n\n\n\n/* Built-in method references that are verified to be native. */\nvar DataView = _getNative(_root, 'DataView');\n\n/* harmony default export */ const _DataView = (DataView);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_Promise.js\n\n\n\n/* Built-in method references that are verified to be native. */\nvar _Promise_Promise = _getNative(_root, 'Promise');\n\n/* harmony default export */ const _Promise = (_Promise_Promise);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_Set.js\n\n\n\n/* Built-in method references that are verified to be native. */\nvar _Set_Set = _getNative(_root, 'Set');\n\n/* harmony default export */ const _Set = (_Set_Set);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_WeakMap.js\n\n\n\n/* Built-in method references that are verified to be native. */\nvar _WeakMap_WeakMap = _getNative(_root, 'WeakMap');\n\n/* harmony default export */ const _WeakMap = (_WeakMap_WeakMap);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_getTag.js\n\n\n\n\n\n\n\n\n/** `Object#toString` result references. */\nvar _getTag_mapTag = '[object Map]',\n    _getTag_objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    _getTag_setTag = '[object Set]',\n    _getTag_weakMapTag = '[object WeakMap]';\n\nvar _getTag_dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = _toSource(_DataView),\n    mapCtorString = _toSource(_Map),\n    promiseCtorString = _toSource(_Promise),\n    setCtorString = _toSource(_Set),\n    weakMapCtorString = _toSource(_WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = _baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != _getTag_dataViewTag) ||\n    (_Map && getTag(new _Map) != _getTag_mapTag) ||\n    (_Promise && getTag(_Promise.resolve()) != promiseTag) ||\n    (_Set && getTag(new _Set) != _getTag_setTag) ||\n    (_WeakMap && getTag(new _WeakMap) != _getTag_weakMapTag)) {\n  getTag = function(value) {\n    var result = _baseGetTag(value),\n        Ctor = result == _getTag_objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? _toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return _getTag_dataViewTag;\n        case mapCtorString: return _getTag_mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return _getTag_setTag;\n        case weakMapCtorString: return _getTag_weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/* harmony default export */ const _getTag = (getTag);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_initCloneArray.js\n/** Used for built-in method references. */\nvar _initCloneArray_objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar _initCloneArray_hasOwnProperty = _initCloneArray_objectProto.hasOwnProperty;\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = new array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && _initCloneArray_hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\n/* harmony default export */ const _initCloneArray = (initCloneArray);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_Uint8Array.js\n\n\n/** Built-in value references. */\nvar Uint8Array = _root.Uint8Array;\n\n/* harmony default export */ const _Uint8Array = (Uint8Array);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_cloneArrayBuffer.js\n\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));\n  return result;\n}\n\n/* harmony default export */ const _cloneArrayBuffer = (cloneArrayBuffer);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_cloneDataView.js\n\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? _cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\n/* harmony default export */ const _cloneDataView = (cloneDataView);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_cloneRegExp.js\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\n/* harmony default export */ const _cloneRegExp = (cloneRegExp);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_cloneSymbol.js\n\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = _Symbol ? _Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\n/* harmony default export */ const _cloneSymbol = (cloneSymbol);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_cloneTypedArray.js\n\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/* harmony default export */ const _cloneTypedArray = (cloneTypedArray);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_initCloneByTag.js\n\n\n\n\n\n\n/** `Object#toString` result references. */\nvar _initCloneByTag_boolTag = '[object Boolean]',\n    _initCloneByTag_dateTag = '[object Date]',\n    _initCloneByTag_mapTag = '[object Map]',\n    _initCloneByTag_numberTag = '[object Number]',\n    _initCloneByTag_regexpTag = '[object RegExp]',\n    _initCloneByTag_setTag = '[object Set]',\n    _initCloneByTag_stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar _initCloneByTag_arrayBufferTag = '[object ArrayBuffer]',\n    _initCloneByTag_dataViewTag = '[object DataView]',\n    _initCloneByTag_float32Tag = '[object Float32Array]',\n    _initCloneByTag_float64Tag = '[object Float64Array]',\n    _initCloneByTag_int8Tag = '[object Int8Array]',\n    _initCloneByTag_int16Tag = '[object Int16Array]',\n    _initCloneByTag_int32Tag = '[object Int32Array]',\n    _initCloneByTag_uint8Tag = '[object Uint8Array]',\n    _initCloneByTag_uint8ClampedTag = '[object Uint8ClampedArray]',\n    _initCloneByTag_uint16Tag = '[object Uint16Array]',\n    _initCloneByTag_uint32Tag = '[object Uint32Array]';\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case _initCloneByTag_arrayBufferTag:\n      return _cloneArrayBuffer(object);\n\n    case _initCloneByTag_boolTag:\n    case _initCloneByTag_dateTag:\n      return new Ctor(+object);\n\n    case _initCloneByTag_dataViewTag:\n      return _cloneDataView(object, isDeep);\n\n    case _initCloneByTag_float32Tag: case _initCloneByTag_float64Tag:\n    case _initCloneByTag_int8Tag: case _initCloneByTag_int16Tag: case _initCloneByTag_int32Tag:\n    case _initCloneByTag_uint8Tag: case _initCloneByTag_uint8ClampedTag: case _initCloneByTag_uint16Tag: case _initCloneByTag_uint32Tag:\n      return _cloneTypedArray(object, isDeep);\n\n    case _initCloneByTag_mapTag:\n      return new Ctor;\n\n    case _initCloneByTag_numberTag:\n    case _initCloneByTag_stringTag:\n      return new Ctor(object);\n\n    case _initCloneByTag_regexpTag:\n      return _cloneRegExp(object);\n\n    case _initCloneByTag_setTag:\n      return new Ctor;\n\n    case symbolTag:\n      return _cloneSymbol(object);\n  }\n}\n\n/* harmony default export */ const _initCloneByTag = (initCloneByTag);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseCreate.js\n\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!lodash_es_isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\n/* harmony default export */ const _baseCreate = (baseCreate);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_initCloneObject.js\n\n\n\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !_isPrototype(object))\n    ? _baseCreate(_getPrototype(object))\n    : {};\n}\n\n/* harmony default export */ const _initCloneObject = (initCloneObject);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseIsMap.js\n\n\n\n/** `Object#toString` result references. */\nvar _baseIsMap_mapTag = '[object Map]';\n\n/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */\nfunction baseIsMap(value) {\n  return lodash_es_isObjectLike(value) && _getTag(value) == _baseIsMap_mapTag;\n}\n\n/* harmony default export */ const _baseIsMap = (baseIsMap);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isMap.js\n\n\n\n\n/* Node.js helper references. */\nvar nodeIsMap = _nodeUtil && _nodeUtil.isMap;\n\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */\nvar isMap = nodeIsMap ? _baseUnary(nodeIsMap) : _baseIsMap;\n\n/* harmony default export */ const lodash_es_isMap = (isMap);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseIsSet.js\n\n\n\n/** `Object#toString` result references. */\nvar _baseIsSet_setTag = '[object Set]';\n\n/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */\nfunction baseIsSet(value) {\n  return lodash_es_isObjectLike(value) && _getTag(value) == _baseIsSet_setTag;\n}\n\n/* harmony default export */ const _baseIsSet = (baseIsSet);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isSet.js\n\n\n\n\n/* Node.js helper references. */\nvar nodeIsSet = _nodeUtil && _nodeUtil.isSet;\n\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */\nvar isSet = nodeIsSet ? _baseUnary(nodeIsSet) : _baseIsSet;\n\n/* harmony default export */ const lodash_es_isSet = (isSet);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseClone.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/** `Object#toString` result references. */\nvar _baseClone_argsTag = '[object Arguments]',\n    _baseClone_arrayTag = '[object Array]',\n    _baseClone_boolTag = '[object Boolean]',\n    _baseClone_dateTag = '[object Date]',\n    _baseClone_errorTag = '[object Error]',\n    _baseClone_funcTag = '[object Function]',\n    _baseClone_genTag = '[object GeneratorFunction]',\n    _baseClone_mapTag = '[object Map]',\n    _baseClone_numberTag = '[object Number]',\n    _baseClone_objectTag = '[object Object]',\n    _baseClone_regexpTag = '[object RegExp]',\n    _baseClone_setTag = '[object Set]',\n    _baseClone_stringTag = '[object String]',\n    _baseClone_symbolTag = '[object Symbol]',\n    _baseClone_weakMapTag = '[object WeakMap]';\n\nvar _baseClone_arrayBufferTag = '[object ArrayBuffer]',\n    _baseClone_dataViewTag = '[object DataView]',\n    _baseClone_float32Tag = '[object Float32Array]',\n    _baseClone_float64Tag = '[object Float64Array]',\n    _baseClone_int8Tag = '[object Int8Array]',\n    _baseClone_int16Tag = '[object Int16Array]',\n    _baseClone_int32Tag = '[object Int32Array]',\n    _baseClone_uint8Tag = '[object Uint8Array]',\n    _baseClone_uint8ClampedTag = '[object Uint8ClampedArray]',\n    _baseClone_uint16Tag = '[object Uint16Array]',\n    _baseClone_uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[_baseClone_argsTag] = cloneableTags[_baseClone_arrayTag] =\ncloneableTags[_baseClone_arrayBufferTag] = cloneableTags[_baseClone_dataViewTag] =\ncloneableTags[_baseClone_boolTag] = cloneableTags[_baseClone_dateTag] =\ncloneableTags[_baseClone_float32Tag] = cloneableTags[_baseClone_float64Tag] =\ncloneableTags[_baseClone_int8Tag] = cloneableTags[_baseClone_int16Tag] =\ncloneableTags[_baseClone_int32Tag] = cloneableTags[_baseClone_mapTag] =\ncloneableTags[_baseClone_numberTag] = cloneableTags[_baseClone_objectTag] =\ncloneableTags[_baseClone_regexpTag] = cloneableTags[_baseClone_setTag] =\ncloneableTags[_baseClone_stringTag] = cloneableTags[_baseClone_symbolTag] =\ncloneableTags[_baseClone_uint8Tag] = cloneableTags[_baseClone_uint8ClampedTag] =\ncloneableTags[_baseClone_uint16Tag] = cloneableTags[_baseClone_uint32Tag] = true;\ncloneableTags[_baseClone_errorTag] = cloneableTags[_baseClone_funcTag] =\ncloneableTags[_baseClone_weakMapTag] = false;\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!lodash_es_isObject(value)) {\n    return value;\n  }\n  var isArr = lodash_es_isArray(value);\n  if (isArr) {\n    result = _initCloneArray(value);\n    if (!isDeep) {\n      return _copyArray(value, result);\n    }\n  } else {\n    var tag = _getTag(value),\n        isFunc = tag == _baseClone_funcTag || tag == _baseClone_genTag;\n\n    if (lodash_es_isBuffer(value)) {\n      return _cloneBuffer(value, isDeep);\n    }\n    if (tag == _baseClone_objectTag || tag == _baseClone_argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : _initCloneObject(value);\n      if (!isDeep) {\n        return isFlat\n          ? _copySymbolsIn(value, _baseAssignIn(result, value))\n          : _copySymbols(value, _baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = _initCloneByTag(value, tag, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new _Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (lodash_es_isSet(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n    });\n  } else if (lodash_es_isMap(value)) {\n    value.forEach(function(subValue, key) {\n      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n    });\n  }\n\n  var keysFunc = isFull\n    ? (isFlat ? _getAllKeysIn : _getAllKeys)\n    : (isFlat ? lodash_es_keysIn : lodash_es_keys);\n\n  var props = isArr ? undefined : keysFunc(value);\n  _arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    _assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n\n/* harmony default export */ const _baseClone = (baseClone);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/clone.js\n\n\n/** Used to compose bitmasks for cloning. */\nvar clone_CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * Creates a shallow clone of `value`.\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n * and supports cloning arrays, array buffers, booleans, date objects, maps,\n * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n * arrays. The own enumerable properties of `arguments` objects are cloned\n * as plain objects. An empty object is returned for uncloneable values such\n * as error objects, functions, DOM nodes, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to clone.\n * @returns {*} Returns the cloned value.\n * @see _.cloneDeep\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var shallow = _.clone(objects);\n * console.log(shallow[0] === objects[0]);\n * // => true\n */\nfunction clone(value) {\n  return _baseClone(value, clone_CLONE_SYMBOLS_FLAG);\n}\n\n/* harmony default export */ const lodash_es_clone = (clone);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_arrayMap.js\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/* harmony default export */ const _arrayMap = (arrayMap);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isSymbol.js\n\n\n\n/** `Object#toString` result references. */\nvar isSymbol_symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (lodash_es_isObjectLike(value) && _baseGetTag(value) == isSymbol_symbolTag);\n}\n\n/* harmony default export */ const lodash_es_isSymbol = (isSymbol);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/memoize.js\n\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || _MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = _MapCache;\n\n/* harmony default export */ const lodash_es_memoize = (memoize);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_memoizeCapped.js\n\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = lodash_es_memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\n/* harmony default export */ const _memoizeCapped = (memoizeCapped);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_stringToPath.js\n\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = _memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/* harmony default export */ const _stringToPath = (stringToPath);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_toKey.js\n\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || lodash_es_isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/* harmony default export */ const _toKey = (toKey);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseToString.js\n\n\n\n\n\n/** Used as references for various `Number` constants. */\nvar _baseToString_INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar _baseToString_symbolProto = _Symbol ? _Symbol.prototype : undefined,\n    symbolToString = _baseToString_symbolProto ? _baseToString_symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (lodash_es_isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return _arrayMap(value, baseToString) + '';\n  }\n  if (lodash_es_isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -_baseToString_INFINITY) ? '-0' : result;\n}\n\n/* harmony default export */ const _baseToString = (baseToString);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/toString.js\n\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString_toString(value) {\n  return value == null ? '' : _baseToString(value);\n}\n\n/* harmony default export */ const lodash_es_toString = (toString_toString);\n\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/toPath.js\n\n\n\n\n\n\n\n\n/**\n * Converts `value` to a property path array.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Util\n * @param {*} value The value to convert.\n * @returns {Array} Returns the new property path array.\n * @example\n *\n * _.toPath('a.b.c');\n * // => ['a', 'b', 'c']\n *\n * _.toPath('a[0].b.c');\n * // => ['a', '0', 'b', 'c']\n */\nfunction toPath(value) {\n  if (lodash_es_isArray(value)) {\n    return _arrayMap(value, _toKey);\n  }\n  return lodash_es_isSymbol(value) ? [value] : _copyArray(_stringToPath(lodash_es_toString(value)));\n}\n\n/* harmony default export */ const lodash_es_toPath = (toPath);\n\n// EXTERNAL MODULE: ../../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\nvar hoist_non_react_statics_cjs = __webpack_require__(\"../../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\");\n;// CONCATENATED MODULE: ../../../node_modules/lodash-es/cloneDeep.js\n\n\n/** Used to compose bitmasks for cloning. */\nvar cloneDeep_CLONE_DEEP_FLAG = 1,\n    cloneDeep_CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return _baseClone(value, cloneDeep_CLONE_DEEP_FLAG | cloneDeep_CLONE_SYMBOLS_FLAG);\n}\n\n/* harmony default export */ const lodash_es_cloneDeep = (cloneDeep);\n\n;// CONCATENATED MODULE: ../../../node_modules/formik/dist/formik.esm.js\n\n\n\n\n\n\n\n\n\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nvar FormikContext = /*#__PURE__*/(0,external_react_.createContext)(undefined);\nFormikContext.displayName = 'FormikContext';\nvar FormikProvider = FormikContext.Provider;\nvar FormikConsumer = FormikContext.Consumer;\nfunction useFormikContext() {\n  var formik = (0,external_react_.useContext)(FormikContext);\n  !!!formik ?  false ? 0 : tiny_warning_esm(false) : void 0;\n  return formik;\n}\n\n/** @private is the value an empty array? */\n\nvar isEmptyArray = function isEmptyArray(value) {\n  return Array.isArray(value) && value.length === 0;\n};\n/** @private is the given object a Function? */\n\nvar formik_esm_isFunction = function isFunction(obj) {\n  return typeof obj === 'function';\n};\n/** @private is the given object an Object? */\n\nvar formik_esm_isObject = function isObject(obj) {\n  return obj !== null && typeof obj === 'object';\n};\n/** @private is the given object an integer? */\n\nvar isInteger = function isInteger(obj) {\n  return String(Math.floor(Number(obj))) === obj;\n};\n/** @private is the given object a string? */\n\nvar isString = function isString(obj) {\n  return Object.prototype.toString.call(obj) === '[object String]';\n};\n/** @private is the given object a NaN? */\n// eslint-disable-next-line no-self-compare\n\nvar isNaN$1 = function isNaN(obj) {\n  return obj !== obj;\n};\n/** @private Does a React component have exactly 0 children? */\n\nvar isEmptyChildren = function isEmptyChildren(children) {\n  return external_react_.Children.count(children) === 0;\n};\n/** @private is the given object/value a promise? */\n\nvar isPromise = function isPromise(value) {\n  return formik_esm_isObject(value) && formik_esm_isFunction(value.then);\n};\n/** @private is the given object/value a type of synthetic event? */\n\nvar isInputEvent = function isInputEvent(value) {\n  return value && formik_esm_isObject(value) && formik_esm_isObject(value.target);\n};\n/**\r\n * Same as document.activeElement but wraps in a try-catch block. In IE it is\r\n * not safe to call document.activeElement if there is nothing focused.\r\n *\r\n * The activeElement will be null only if the document or document body is not\r\n * yet defined.\r\n *\r\n * @param {?Document} doc Defaults to current document.\r\n * @return {Element | null}\r\n * @see https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/dom/getActiveElement.js\r\n */\n\nfunction getActiveElement(doc) {\n  doc = doc || (typeof document !== 'undefined' ? document : undefined);\n\n  if (typeof doc === 'undefined') {\n    return null;\n  }\n\n  try {\n    return doc.activeElement || doc.body;\n  } catch (e) {\n    return doc.body;\n  }\n}\n/**\r\n * Deeply get a value from an object via its path.\r\n */\n\nfunction getIn(obj, key, def, p) {\n  if (p === void 0) {\n    p = 0;\n  }\n\n  var path = lodash_es_toPath(key);\n\n  while (obj && p < path.length) {\n    obj = obj[path[p++]];\n  } // check if path is not in the end\n\n\n  if (p !== path.length && !obj) {\n    return def;\n  }\n\n  return obj === undefined ? def : obj;\n}\n/**\r\n * Deeply set a value from in object via it's path. If the value at `path`\r\n * has changed, return a shallow copy of obj with `value` set at `path`.\r\n * If `value` has not changed, return the original `obj`.\r\n *\r\n * Existing objects / arrays along `path` are also shallow copied. Sibling\r\n * objects along path retain the same internal js reference. Since new\r\n * objects / arrays are only created along `path`, we can test if anything\r\n * changed in a nested structure by comparing the object's reference in\r\n * the old and new object, similar to how russian doll cache invalidation\r\n * works.\r\n *\r\n * In earlier versions of this function, which used cloneDeep, there were\r\n * issues whereby settings a nested value would mutate the parent\r\n * instead of creating a new object. `clone` avoids that bug making a\r\n * shallow copy of the objects along the update path\r\n * so no object is mutated in place.\r\n *\r\n * Before changing this function, please read through the following\r\n * discussions.\r\n *\r\n * @see https://github.com/developit/linkstate\r\n * @see https://github.com/jaredpalmer/formik/pull/123\r\n */\n\nfunction setIn(obj, path, value) {\n  var res = lodash_es_clone(obj); // this keeps inheritance when obj is a class\n\n  var resVal = res;\n  var i = 0;\n  var pathArray = lodash_es_toPath(path);\n\n  for (; i < pathArray.length - 1; i++) {\n    var currentPath = pathArray[i];\n    var currentObj = getIn(obj, pathArray.slice(0, i + 1));\n\n    if (currentObj && (formik_esm_isObject(currentObj) || Array.isArray(currentObj))) {\n      resVal = resVal[currentPath] = lodash_es_clone(currentObj);\n    } else {\n      var nextPath = pathArray[i + 1];\n      resVal = resVal[currentPath] = isInteger(nextPath) && Number(nextPath) >= 0 ? [] : {};\n    }\n  } // Return original object if new value is the same as current\n\n\n  if ((i === 0 ? obj : resVal)[pathArray[i]] === value) {\n    return obj;\n  }\n\n  if (value === undefined) {\n    delete resVal[pathArray[i]];\n  } else {\n    resVal[pathArray[i]] = value;\n  } // If the path array has a single element, the loop did not run.\n  // Deleting on `resVal` had no effect in this scenario, so we delete on the result instead.\n\n\n  if (i === 0 && value === undefined) {\n    delete res[pathArray[i]];\n  }\n\n  return res;\n}\n/**\r\n * Recursively a set the same value for all keys and arrays nested object, cloning\r\n * @param object\r\n * @param value\r\n * @param visited\r\n * @param response\r\n */\n\nfunction setNestedObjectValues(object, value, visited, response) {\n  if (visited === void 0) {\n    visited = new WeakMap();\n  }\n\n  if (response === void 0) {\n    response = {};\n  }\n\n  for (var _i = 0, _Object$keys = Object.keys(object); _i < _Object$keys.length; _i++) {\n    var k = _Object$keys[_i];\n    var val = object[k];\n\n    if (formik_esm_isObject(val)) {\n      if (!visited.get(val)) {\n        visited.set(val, true); // In order to keep array values consistent for both dot path  and\n        // bracket syntax, we need to check if this is an array so that\n        // this will output  { friends: [true] } and not { friends: { \"0\": true } }\n\n        response[k] = Array.isArray(val) ? [] : {};\n        setNestedObjectValues(val, value, visited, response[k]);\n      }\n    } else {\n      response[k] = value;\n    }\n  }\n\n  return response;\n}\n\nfunction formikReducer(state, msg) {\n  switch (msg.type) {\n    case 'SET_VALUES':\n      return _extends({}, state, {\n        values: msg.payload\n      });\n\n    case 'SET_TOUCHED':\n      return _extends({}, state, {\n        touched: msg.payload\n      });\n\n    case 'SET_ERRORS':\n      if (react_fast_compare_default()(state.errors, msg.payload)) {\n        return state;\n      }\n\n      return _extends({}, state, {\n        errors: msg.payload\n      });\n\n    case 'SET_STATUS':\n      return _extends({}, state, {\n        status: msg.payload\n      });\n\n    case 'SET_ISSUBMITTING':\n      return _extends({}, state, {\n        isSubmitting: msg.payload\n      });\n\n    case 'SET_ISVALIDATING':\n      return _extends({}, state, {\n        isValidating: msg.payload\n      });\n\n    case 'SET_FIELD_VALUE':\n      return _extends({}, state, {\n        values: setIn(state.values, msg.payload.field, msg.payload.value)\n      });\n\n    case 'SET_FIELD_TOUCHED':\n      return _extends({}, state, {\n        touched: setIn(state.touched, msg.payload.field, msg.payload.value)\n      });\n\n    case 'SET_FIELD_ERROR':\n      return _extends({}, state, {\n        errors: setIn(state.errors, msg.payload.field, msg.payload.value)\n      });\n\n    case 'RESET_FORM':\n      return _extends({}, state, msg.payload);\n\n    case 'SET_FORMIK_STATE':\n      return msg.payload(state);\n\n    case 'SUBMIT_ATTEMPT':\n      return _extends({}, state, {\n        touched: setNestedObjectValues(state.values, true),\n        isSubmitting: true,\n        submitCount: state.submitCount + 1\n      });\n\n    case 'SUBMIT_FAILURE':\n      return _extends({}, state, {\n        isSubmitting: false\n      });\n\n    case 'SUBMIT_SUCCESS':\n      return _extends({}, state, {\n        isSubmitting: false\n      });\n\n    default:\n      return state;\n  }\n} // Initial empty states // objects\n\n\nvar emptyErrors = {};\nvar emptyTouched = {};\nfunction useFormik(_ref) {\n  var _ref$validateOnChange = _ref.validateOnChange,\n      validateOnChange = _ref$validateOnChange === void 0 ? true : _ref$validateOnChange,\n      _ref$validateOnBlur = _ref.validateOnBlur,\n      validateOnBlur = _ref$validateOnBlur === void 0 ? true : _ref$validateOnBlur,\n      _ref$validateOnMount = _ref.validateOnMount,\n      validateOnMount = _ref$validateOnMount === void 0 ? false : _ref$validateOnMount,\n      isInitialValid = _ref.isInitialValid,\n      _ref$enableReinitiali = _ref.enableReinitialize,\n      enableReinitialize = _ref$enableReinitiali === void 0 ? false : _ref$enableReinitiali,\n      onSubmit = _ref.onSubmit,\n      rest = _objectWithoutPropertiesLoose(_ref, [\"validateOnChange\", \"validateOnBlur\", \"validateOnMount\", \"isInitialValid\", \"enableReinitialize\", \"onSubmit\"]);\n\n  var props = _extends({\n    validateOnChange: validateOnChange,\n    validateOnBlur: validateOnBlur,\n    validateOnMount: validateOnMount,\n    onSubmit: onSubmit\n  }, rest);\n\n  var initialValues = (0,external_react_.useRef)(props.initialValues);\n  var initialErrors = (0,external_react_.useRef)(props.initialErrors || emptyErrors);\n  var initialTouched = (0,external_react_.useRef)(props.initialTouched || emptyTouched);\n  var initialStatus = (0,external_react_.useRef)(props.initialStatus);\n  var isMounted = (0,external_react_.useRef)(false);\n  var fieldRegistry = (0,external_react_.useRef)({});\n\n  if (false) {}\n\n  (0,external_react_.useEffect)(function () {\n    isMounted.current = true;\n    return function () {\n      isMounted.current = false;\n    };\n  }, []);\n\n  var _React$useState = (0,external_react_.useState)(0),\n      setIteration = _React$useState[1];\n\n  var stateRef = (0,external_react_.useRef)({\n    values: props.initialValues,\n    errors: props.initialErrors || emptyErrors,\n    touched: props.initialTouched || emptyTouched,\n    status: props.initialStatus,\n    isSubmitting: false,\n    isValidating: false,\n    submitCount: 0\n  });\n  var state = stateRef.current;\n  var dispatch = (0,external_react_.useCallback)(function (action) {\n    var prev = stateRef.current;\n    stateRef.current = formikReducer(prev, action); // force rerender\n\n    if (prev !== stateRef.current) setIteration(function (x) {\n      return x + 1;\n    });\n  }, []);\n  var runValidateHandler = (0,external_react_.useCallback)(function (values, field) {\n    return new Promise(function (resolve, reject) {\n      var maybePromisedErrors = props.validate(values, field);\n\n      if (maybePromisedErrors == null) {\n        // use loose null check here on purpose\n        resolve(emptyErrors);\n      } else if (isPromise(maybePromisedErrors)) {\n        maybePromisedErrors.then(function (errors) {\n          resolve(errors || emptyErrors);\n        }, function (actualException) {\n          if (false) {}\n\n          reject(actualException);\n        });\n      } else {\n        resolve(maybePromisedErrors);\n      }\n    });\n  }, [props.validate]);\n  /**\r\n   * Run validation against a Yup schema and optionally run a function if successful\r\n   */\n\n  var runValidationSchema = (0,external_react_.useCallback)(function (values, field) {\n    var validationSchema = props.validationSchema;\n    var schema = formik_esm_isFunction(validationSchema) ? validationSchema(field) : validationSchema;\n    var promise = field && schema.validateAt ? schema.validateAt(field, values) : validateYupSchema(values, schema);\n    return new Promise(function (resolve, reject) {\n      promise.then(function () {\n        resolve(emptyErrors);\n      }, function (err) {\n        // Yup will throw a validation error if validation fails. We catch those and\n        // resolve them into Formik errors. We can sniff if something is a Yup error\n        // by checking error.name.\n        // @see https://github.com/jquense/yup#validationerrorerrors-string--arraystring-value-any-path-string\n        if (err.name === 'ValidationError') {\n          resolve(yupToFormErrors(err));\n        } else {\n          // We throw any other errors\n          if (false) {}\n\n          reject(err);\n        }\n      });\n    });\n  }, [props.validationSchema]);\n  var runSingleFieldLevelValidation = (0,external_react_.useCallback)(function (field, value) {\n    return new Promise(function (resolve) {\n      return resolve(fieldRegistry.current[field].validate(value));\n    });\n  }, []);\n  var runFieldLevelValidations = (0,external_react_.useCallback)(function (values) {\n    var fieldKeysWithValidation = Object.keys(fieldRegistry.current).filter(function (f) {\n      return formik_esm_isFunction(fieldRegistry.current[f].validate);\n    }); // Construct an array with all of the field validation functions\n\n    var fieldValidations = fieldKeysWithValidation.length > 0 ? fieldKeysWithValidation.map(function (f) {\n      return runSingleFieldLevelValidation(f, getIn(values, f));\n    }) : [Promise.resolve('DO_NOT_DELETE_YOU_WILL_BE_FIRED')]; // use special case ;)\n\n    return Promise.all(fieldValidations).then(function (fieldErrorsList) {\n      return fieldErrorsList.reduce(function (prev, curr, index) {\n        if (curr === 'DO_NOT_DELETE_YOU_WILL_BE_FIRED') {\n          return prev;\n        }\n\n        if (curr) {\n          prev = setIn(prev, fieldKeysWithValidation[index], curr);\n        }\n\n        return prev;\n      }, {});\n    });\n  }, [runSingleFieldLevelValidation]); // Run all validations and return the result\n\n  var runAllValidations = (0,external_react_.useCallback)(function (values) {\n    return Promise.all([runFieldLevelValidations(values), props.validationSchema ? runValidationSchema(values) : {}, props.validate ? runValidateHandler(values) : {}]).then(function (_ref2) {\n      var fieldErrors = _ref2[0],\n          schemaErrors = _ref2[1],\n          validateErrors = _ref2[2];\n      var combinedErrors = es.all([fieldErrors, schemaErrors, validateErrors], {\n        arrayMerge: arrayMerge\n      });\n      return combinedErrors;\n    });\n  }, [props.validate, props.validationSchema, runFieldLevelValidations, runValidateHandler, runValidationSchema]); // Run all validations methods and update state accordingly\n\n  var validateFormWithHighPriority = useEventCallback(function (values) {\n    if (values === void 0) {\n      values = state.values;\n    }\n\n    dispatch({\n      type: 'SET_ISVALIDATING',\n      payload: true\n    });\n    return runAllValidations(values).then(function (combinedErrors) {\n      if (!!isMounted.current) {\n        dispatch({\n          type: 'SET_ISVALIDATING',\n          payload: false\n        });\n        dispatch({\n          type: 'SET_ERRORS',\n          payload: combinedErrors\n        });\n      }\n\n      return combinedErrors;\n    });\n  });\n  (0,external_react_.useEffect)(function () {\n    if (validateOnMount && isMounted.current === true && react_fast_compare_default()(initialValues.current, props.initialValues)) {\n      validateFormWithHighPriority(initialValues.current);\n    }\n  }, [validateOnMount, validateFormWithHighPriority]);\n  var resetForm = (0,external_react_.useCallback)(function (nextState) {\n    var values = nextState && nextState.values ? nextState.values : initialValues.current;\n    var errors = nextState && nextState.errors ? nextState.errors : initialErrors.current ? initialErrors.current : props.initialErrors || {};\n    var touched = nextState && nextState.touched ? nextState.touched : initialTouched.current ? initialTouched.current : props.initialTouched || {};\n    var status = nextState && nextState.status ? nextState.status : initialStatus.current ? initialStatus.current : props.initialStatus;\n    initialValues.current = values;\n    initialErrors.current = errors;\n    initialTouched.current = touched;\n    initialStatus.current = status;\n\n    var dispatchFn = function dispatchFn() {\n      dispatch({\n        type: 'RESET_FORM',\n        payload: {\n          isSubmitting: !!nextState && !!nextState.isSubmitting,\n          errors: errors,\n          touched: touched,\n          status: status,\n          values: values,\n          isValidating: !!nextState && !!nextState.isValidating,\n          submitCount: !!nextState && !!nextState.submitCount && typeof nextState.submitCount === 'number' ? nextState.submitCount : 0\n        }\n      });\n    };\n\n    if (props.onReset) {\n      var maybePromisedOnReset = props.onReset(state.values, imperativeMethods);\n\n      if (isPromise(maybePromisedOnReset)) {\n        maybePromisedOnReset.then(dispatchFn);\n      } else {\n        dispatchFn();\n      }\n    } else {\n      dispatchFn();\n    }\n  }, [props.initialErrors, props.initialStatus, props.initialTouched, props.onReset]);\n  (0,external_react_.useEffect)(function () {\n    if (isMounted.current === true && !react_fast_compare_default()(initialValues.current, props.initialValues)) {\n      if (enableReinitialize) {\n        initialValues.current = props.initialValues;\n        resetForm();\n\n        if (validateOnMount) {\n          validateFormWithHighPriority(initialValues.current);\n        }\n      }\n    }\n  }, [enableReinitialize, props.initialValues, resetForm, validateOnMount, validateFormWithHighPriority]);\n  (0,external_react_.useEffect)(function () {\n    if (enableReinitialize && isMounted.current === true && !react_fast_compare_default()(initialErrors.current, props.initialErrors)) {\n      initialErrors.current = props.initialErrors || emptyErrors;\n      dispatch({\n        type: 'SET_ERRORS',\n        payload: props.initialErrors || emptyErrors\n      });\n    }\n  }, [enableReinitialize, props.initialErrors]);\n  (0,external_react_.useEffect)(function () {\n    if (enableReinitialize && isMounted.current === true && !react_fast_compare_default()(initialTouched.current, props.initialTouched)) {\n      initialTouched.current = props.initialTouched || emptyTouched;\n      dispatch({\n        type: 'SET_TOUCHED',\n        payload: props.initialTouched || emptyTouched\n      });\n    }\n  }, [enableReinitialize, props.initialTouched]);\n  (0,external_react_.useEffect)(function () {\n    if (enableReinitialize && isMounted.current === true && !react_fast_compare_default()(initialStatus.current, props.initialStatus)) {\n      initialStatus.current = props.initialStatus;\n      dispatch({\n        type: 'SET_STATUS',\n        payload: props.initialStatus\n      });\n    }\n  }, [enableReinitialize, props.initialStatus, props.initialTouched]);\n  var validateField = useEventCallback(function (name) {\n    // This will efficiently validate a single field by avoiding state\n    // changes if the validation function is synchronous. It's different from\n    // what is called when using validateForm.\n    if (fieldRegistry.current[name] && formik_esm_isFunction(fieldRegistry.current[name].validate)) {\n      var value = getIn(state.values, name);\n      var maybePromise = fieldRegistry.current[name].validate(value);\n\n      if (isPromise(maybePromise)) {\n        // Only flip isValidating if the function is async.\n        dispatch({\n          type: 'SET_ISVALIDATING',\n          payload: true\n        });\n        return maybePromise.then(function (x) {\n          return x;\n        }).then(function (error) {\n          dispatch({\n            type: 'SET_FIELD_ERROR',\n            payload: {\n              field: name,\n              value: error\n            }\n          });\n          dispatch({\n            type: 'SET_ISVALIDATING',\n            payload: false\n          });\n        });\n      } else {\n        dispatch({\n          type: 'SET_FIELD_ERROR',\n          payload: {\n            field: name,\n            value: maybePromise\n          }\n        });\n        return Promise.resolve(maybePromise);\n      }\n    } else if (props.validationSchema) {\n      dispatch({\n        type: 'SET_ISVALIDATING',\n        payload: true\n      });\n      return runValidationSchema(state.values, name).then(function (x) {\n        return x;\n      }).then(function (error) {\n        dispatch({\n          type: 'SET_FIELD_ERROR',\n          payload: {\n            field: name,\n            value: getIn(error, name)\n          }\n        });\n        dispatch({\n          type: 'SET_ISVALIDATING',\n          payload: false\n        });\n      });\n    }\n\n    return Promise.resolve();\n  });\n  var registerField = (0,external_react_.useCallback)(function (name, _ref3) {\n    var validate = _ref3.validate;\n    fieldRegistry.current[name] = {\n      validate: validate\n    };\n  }, []);\n  var unregisterField = (0,external_react_.useCallback)(function (name) {\n    delete fieldRegistry.current[name];\n  }, []);\n  var setTouched = useEventCallback(function (touched, shouldValidate) {\n    dispatch({\n      type: 'SET_TOUCHED',\n      payload: touched\n    });\n    var willValidate = shouldValidate === undefined ? validateOnBlur : shouldValidate;\n    return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();\n  });\n  var setErrors = (0,external_react_.useCallback)(function (errors) {\n    dispatch({\n      type: 'SET_ERRORS',\n      payload: errors\n    });\n  }, []);\n  var setValues = useEventCallback(function (values, shouldValidate) {\n    var resolvedValues = formik_esm_isFunction(values) ? values(state.values) : values;\n    dispatch({\n      type: 'SET_VALUES',\n      payload: resolvedValues\n    });\n    var willValidate = shouldValidate === undefined ? validateOnChange : shouldValidate;\n    return willValidate ? validateFormWithHighPriority(resolvedValues) : Promise.resolve();\n  });\n  var setFieldError = (0,external_react_.useCallback)(function (field, value) {\n    dispatch({\n      type: 'SET_FIELD_ERROR',\n      payload: {\n        field: field,\n        value: value\n      }\n    });\n  }, []);\n  var setFieldValue = useEventCallback(function (field, value, shouldValidate) {\n    dispatch({\n      type: 'SET_FIELD_VALUE',\n      payload: {\n        field: field,\n        value: value\n      }\n    });\n    var willValidate = shouldValidate === undefined ? validateOnChange : shouldValidate;\n    return willValidate ? validateFormWithHighPriority(setIn(state.values, field, value)) : Promise.resolve();\n  });\n  var executeChange = (0,external_react_.useCallback)(function (eventOrTextValue, maybePath) {\n    // By default, assume that the first argument is a string. This allows us to use\n    // handleChange with React Native and React Native Web's onChangeText prop which\n    // provides just the value of the input.\n    var field = maybePath;\n    var val = eventOrTextValue;\n    var parsed; // If the first argument is not a string though, it has to be a synthetic React Event (or a fake one),\n    // so we handle like we would a normal HTML change event.\n\n    if (!isString(eventOrTextValue)) {\n      // If we can, persist the event\n      // @see https://reactjs.org/docs/events.html#event-pooling\n      if (eventOrTextValue.persist) {\n        eventOrTextValue.persist();\n      }\n\n      var target = eventOrTextValue.target ? eventOrTextValue.target : eventOrTextValue.currentTarget;\n      var type = target.type,\n          name = target.name,\n          id = target.id,\n          value = target.value,\n          checked = target.checked,\n          outerHTML = target.outerHTML,\n          options = target.options,\n          multiple = target.multiple;\n      field = maybePath ? maybePath : name ? name : id;\n\n      if (!field && \"production\" !== \"production\") {}\n\n      val = /number|range/.test(type) ? (parsed = parseFloat(value), isNaN(parsed) ? '' : parsed) : /checkbox/.test(type) // checkboxes\n      ? getValueForCheckbox(getIn(state.values, field), checked, value) : options && multiple // <select multiple>\n      ? getSelectedValues(options) : value;\n    }\n\n    if (field) {\n      // Set form fields by name\n      setFieldValue(field, val);\n    }\n  }, [setFieldValue, state.values]);\n  var handleChange = useEventCallback(function (eventOrPath) {\n    if (isString(eventOrPath)) {\n      return function (event) {\n        return executeChange(event, eventOrPath);\n      };\n    } else {\n      executeChange(eventOrPath);\n    }\n  });\n  var setFieldTouched = useEventCallback(function (field, touched, shouldValidate) {\n    if (touched === void 0) {\n      touched = true;\n    }\n\n    dispatch({\n      type: 'SET_FIELD_TOUCHED',\n      payload: {\n        field: field,\n        value: touched\n      }\n    });\n    var willValidate = shouldValidate === undefined ? validateOnBlur : shouldValidate;\n    return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();\n  });\n  var executeBlur = (0,external_react_.useCallback)(function (e, path) {\n    if (e.persist) {\n      e.persist();\n    }\n\n    var _e$target = e.target,\n        name = _e$target.name,\n        id = _e$target.id,\n        outerHTML = _e$target.outerHTML;\n    var field = path ? path : name ? name : id;\n\n    if (!field && \"production\" !== \"production\") {}\n\n    setFieldTouched(field, true);\n  }, [setFieldTouched]);\n  var handleBlur = useEventCallback(function (eventOrString) {\n    if (isString(eventOrString)) {\n      return function (event) {\n        return executeBlur(event, eventOrString);\n      };\n    } else {\n      executeBlur(eventOrString);\n    }\n  });\n  var setFormikState = (0,external_react_.useCallback)(function (stateOrCb) {\n    if (formik_esm_isFunction(stateOrCb)) {\n      dispatch({\n        type: 'SET_FORMIK_STATE',\n        payload: stateOrCb\n      });\n    } else {\n      dispatch({\n        type: 'SET_FORMIK_STATE',\n        payload: function payload() {\n          return stateOrCb;\n        }\n      });\n    }\n  }, []);\n  var setStatus = (0,external_react_.useCallback)(function (status) {\n    dispatch({\n      type: 'SET_STATUS',\n      payload: status\n    });\n  }, []);\n  var setSubmitting = (0,external_react_.useCallback)(function (isSubmitting) {\n    dispatch({\n      type: 'SET_ISSUBMITTING',\n      payload: isSubmitting\n    });\n  }, []);\n  var submitForm = useEventCallback(function () {\n    dispatch({\n      type: 'SUBMIT_ATTEMPT'\n    });\n    return validateFormWithHighPriority().then(function (combinedErrors) {\n      // In case an error was thrown and passed to the resolved Promise,\n      // `combinedErrors` can be an instance of an Error. We need to check\n      // that and abort the submit.\n      // If we don't do that, calling `Object.keys(new Error())` yields an\n      // empty array, which causes the validation to pass and the form\n      // to be submitted.\n      var isInstanceOfError = combinedErrors instanceof Error;\n      var isActuallyValid = !isInstanceOfError && Object.keys(combinedErrors).length === 0;\n\n      if (isActuallyValid) {\n        // Proceed with submit...\n        //\n        // To respect sync submit fns, we can't simply wrap executeSubmit in a promise and\n        // _always_ dispatch SUBMIT_SUCCESS because isSubmitting would then always be false.\n        // This would be fine in simple cases, but make it impossible to disable submit\n        // buttons where people use callbacks or promises as side effects (which is basically\n        // all of v1 Formik code). Instead, recall that we are inside of a promise chain already,\n        //  so we can try/catch executeSubmit(), if it returns undefined, then just bail.\n        // If there are errors, throw em. Otherwise, wrap executeSubmit in a promise and handle\n        // cleanup of isSubmitting on behalf of the consumer.\n        var promiseOrUndefined;\n\n        try {\n          promiseOrUndefined = executeSubmit(); // Bail if it's sync, consumer is responsible for cleaning up\n          // via setSubmitting(false)\n\n          if (promiseOrUndefined === undefined) {\n            return;\n          }\n        } catch (error) {\n          throw error;\n        }\n\n        return Promise.resolve(promiseOrUndefined).then(function (result) {\n          if (!!isMounted.current) {\n            dispatch({\n              type: 'SUBMIT_SUCCESS'\n            });\n          }\n\n          return result;\n        })[\"catch\"](function (_errors) {\n          if (!!isMounted.current) {\n            dispatch({\n              type: 'SUBMIT_FAILURE'\n            }); // This is a legit error rejected by the onSubmit fn\n            // so we don't want to break the promise chain\n\n            throw _errors;\n          }\n        });\n      } else if (!!isMounted.current) {\n        // ^^^ Make sure Formik is still mounted before updating state\n        dispatch({\n          type: 'SUBMIT_FAILURE'\n        }); // throw combinedErrors;\n\n        if (isInstanceOfError) {\n          throw combinedErrors;\n        }\n      }\n\n      return;\n    });\n  });\n  var handleSubmit = useEventCallback(function (e) {\n    if (e && e.preventDefault && formik_esm_isFunction(e.preventDefault)) {\n      e.preventDefault();\n    }\n\n    if (e && e.stopPropagation && formik_esm_isFunction(e.stopPropagation)) {\n      e.stopPropagation();\n    } // Warn if form submission is triggered by a <button> without a\n    // specified `type` attribute during development. This mitigates\n    // a common gotcha in forms with both reset and submit buttons,\n    // where the dev forgets to add type=\"button\" to the reset button.\n\n\n    if (false) { var activeElement; }\n\n    submitForm()[\"catch\"](function (reason) {\n      console.warn(\"Warning: An unhandled error was caught from submitForm()\", reason);\n    });\n  });\n  var imperativeMethods = {\n    resetForm: resetForm,\n    validateForm: validateFormWithHighPriority,\n    validateField: validateField,\n    setErrors: setErrors,\n    setFieldError: setFieldError,\n    setFieldTouched: setFieldTouched,\n    setFieldValue: setFieldValue,\n    setStatus: setStatus,\n    setSubmitting: setSubmitting,\n    setTouched: setTouched,\n    setValues: setValues,\n    setFormikState: setFormikState,\n    submitForm: submitForm\n  };\n  var executeSubmit = useEventCallback(function () {\n    return onSubmit(state.values, imperativeMethods);\n  });\n  var handleReset = useEventCallback(function (e) {\n    if (e && e.preventDefault && formik_esm_isFunction(e.preventDefault)) {\n      e.preventDefault();\n    }\n\n    if (e && e.stopPropagation && formik_esm_isFunction(e.stopPropagation)) {\n      e.stopPropagation();\n    }\n\n    resetForm();\n  });\n  var getFieldMeta = (0,external_react_.useCallback)(function (name) {\n    return {\n      value: getIn(state.values, name),\n      error: getIn(state.errors, name),\n      touched: !!getIn(state.touched, name),\n      initialValue: getIn(initialValues.current, name),\n      initialTouched: !!getIn(initialTouched.current, name),\n      initialError: getIn(initialErrors.current, name)\n    };\n  }, [state.errors, state.touched, state.values]);\n  var getFieldHelpers = (0,external_react_.useCallback)(function (name) {\n    return {\n      setValue: function setValue(value, shouldValidate) {\n        return setFieldValue(name, value, shouldValidate);\n      },\n      setTouched: function setTouched(value, shouldValidate) {\n        return setFieldTouched(name, value, shouldValidate);\n      },\n      setError: function setError(value) {\n        return setFieldError(name, value);\n      }\n    };\n  }, [setFieldValue, setFieldTouched, setFieldError]);\n  var getFieldProps = (0,external_react_.useCallback)(function (nameOrOptions) {\n    var isAnObject = formik_esm_isObject(nameOrOptions);\n    var name = isAnObject ? nameOrOptions.name : nameOrOptions;\n    var valueState = getIn(state.values, name);\n    var field = {\n      name: name,\n      value: valueState,\n      onChange: handleChange,\n      onBlur: handleBlur\n    };\n\n    if (isAnObject) {\n      var type = nameOrOptions.type,\n          valueProp = nameOrOptions.value,\n          is = nameOrOptions.as,\n          multiple = nameOrOptions.multiple;\n\n      if (type === 'checkbox') {\n        if (valueProp === undefined) {\n          field.checked = !!valueState;\n        } else {\n          field.checked = !!(Array.isArray(valueState) && ~valueState.indexOf(valueProp));\n          field.value = valueProp;\n        }\n      } else if (type === 'radio') {\n        field.checked = valueState === valueProp;\n        field.value = valueProp;\n      } else if (is === 'select' && multiple) {\n        field.value = field.value || [];\n        field.multiple = true;\n      }\n    }\n\n    return field;\n  }, [handleBlur, handleChange, state.values]);\n  var dirty = (0,external_react_.useMemo)(function () {\n    return !react_fast_compare_default()(initialValues.current, state.values);\n  }, [initialValues.current, state.values]);\n  var isValid = (0,external_react_.useMemo)(function () {\n    return typeof isInitialValid !== 'undefined' ? dirty ? state.errors && Object.keys(state.errors).length === 0 : isInitialValid !== false && formik_esm_isFunction(isInitialValid) ? isInitialValid(props) : isInitialValid : state.errors && Object.keys(state.errors).length === 0;\n  }, [isInitialValid, dirty, state.errors, props]);\n\n  var ctx = _extends({}, state, {\n    initialValues: initialValues.current,\n    initialErrors: initialErrors.current,\n    initialTouched: initialTouched.current,\n    initialStatus: initialStatus.current,\n    handleBlur: handleBlur,\n    handleChange: handleChange,\n    handleReset: handleReset,\n    handleSubmit: handleSubmit,\n    resetForm: resetForm,\n    setErrors: setErrors,\n    setFormikState: setFormikState,\n    setFieldTouched: setFieldTouched,\n    setFieldValue: setFieldValue,\n    setFieldError: setFieldError,\n    setStatus: setStatus,\n    setSubmitting: setSubmitting,\n    setTouched: setTouched,\n    setValues: setValues,\n    submitForm: submitForm,\n    validateForm: validateFormWithHighPriority,\n    validateField: validateField,\n    isValid: isValid,\n    dirty: dirty,\n    unregisterField: unregisterField,\n    registerField: registerField,\n    getFieldProps: getFieldProps,\n    getFieldMeta: getFieldMeta,\n    getFieldHelpers: getFieldHelpers,\n    validateOnBlur: validateOnBlur,\n    validateOnChange: validateOnChange,\n    validateOnMount: validateOnMount\n  });\n\n  return ctx;\n}\nfunction Formik(props) {\n  var formikbag = useFormik(props);\n  var component = props.component,\n      children = props.children,\n      render = props.render,\n      innerRef = props.innerRef; // This allows folks to pass a ref to <Formik />\n\n  (0,external_react_.useImperativeHandle)(innerRef, function () {\n    return formikbag;\n  });\n\n  if (false) {}\n\n  return (0,external_react_.createElement)(FormikProvider, {\n    value: formikbag\n  }, component ? (0,external_react_.createElement)(component, formikbag) : render ? render(formikbag) : children // children come last, always called\n  ? formik_esm_isFunction(children) ? children(formikbag) : !isEmptyChildren(children) ? external_react_.Children.only(children) : null : null);\n}\n\nfunction warnAboutMissingIdentifier(_ref4) {\n  var htmlContent = _ref4.htmlContent,\n      documentationAnchorLink = _ref4.documentationAnchorLink,\n      handlerName = _ref4.handlerName;\n  console.warn(\"Warning: Formik called `\" + handlerName + \"`, but you forgot to pass an `id` or `name` attribute to your input:\\n    \" + htmlContent + \"\\n    Formik cannot determine which value to update. For more info see https://formik.org/docs/api/formik#\" + documentationAnchorLink + \"\\n  \");\n}\n/**\r\n * Transform Yup ValidationError to a more usable object\r\n */\n\n\nfunction yupToFormErrors(yupError) {\n  var errors = {};\n\n  if (yupError.inner) {\n    if (yupError.inner.length === 0) {\n      return setIn(errors, yupError.path, yupError.message);\n    }\n\n    for (var _iterator = yupError.inner, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref5;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref5 = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref5 = _i.value;\n      }\n\n      var err = _ref5;\n\n      if (!getIn(errors, err.path)) {\n        errors = setIn(errors, err.path, err.message);\n      }\n    }\n  }\n\n  return errors;\n}\n/**\r\n * Validate a yup schema.\r\n */\n\nfunction validateYupSchema(values, schema, sync, context) {\n  if (sync === void 0) {\n    sync = false;\n  }\n\n  var normalizedValues = prepareDataForValidation(values);\n  return schema[sync ? 'validateSync' : 'validate'](normalizedValues, {\n    abortEarly: false,\n    context: context || normalizedValues\n  });\n}\n/**\r\n * Recursively prepare values.\r\n */\n\nfunction prepareDataForValidation(values) {\n  var data = Array.isArray(values) ? [] : {};\n\n  for (var k in values) {\n    if (Object.prototype.hasOwnProperty.call(values, k)) {\n      var key = String(k);\n\n      if (Array.isArray(values[key]) === true) {\n        data[key] = values[key].map(function (value) {\n          if (Array.isArray(value) === true || lodash_es_isPlainObject(value)) {\n            return prepareDataForValidation(value);\n          } else {\n            return value !== '' ? value : undefined;\n          }\n        });\n      } else if (lodash_es_isPlainObject(values[key])) {\n        data[key] = prepareDataForValidation(values[key]);\n      } else {\n        data[key] = values[key] !== '' ? values[key] : undefined;\n      }\n    }\n  }\n\n  return data;\n}\n/**\r\n * deepmerge array merging algorithm\r\n * https://github.com/KyleAMathews/deepmerge#combine-array\r\n */\n\nfunction arrayMerge(target, source, options) {\n  var destination = target.slice();\n  source.forEach(function merge(e, i) {\n    if (typeof destination[i] === 'undefined') {\n      var cloneRequested = options.clone !== false;\n      var shouldClone = cloneRequested && options.isMergeableObject(e);\n      destination[i] = shouldClone ? es(Array.isArray(e) ? [] : {}, e, options) : e;\n    } else if (options.isMergeableObject(e)) {\n      destination[i] = es(target[i], e, options);\n    } else if (target.indexOf(e) === -1) {\n      destination.push(e);\n    }\n  });\n  return destination;\n}\n/** Return multi select values based on an array of options */\n\n\nfunction getSelectedValues(options) {\n  return Array.from(options).filter(function (el) {\n    return el.selected;\n  }).map(function (el) {\n    return el.value;\n  });\n}\n/** Return the next value for a checkbox */\n\n\nfunction getValueForCheckbox(currentValue, checked, valueProp) {\n  // If the current value was a boolean, return a boolean\n  if (typeof currentValue === 'boolean') {\n    return Boolean(checked);\n  } // If the currentValue was not a boolean we want to return an array\n\n\n  var currentArrayOfValues = [];\n  var isValueInArray = false;\n  var index = -1;\n\n  if (!Array.isArray(currentValue)) {\n    // eslint-disable-next-line eqeqeq\n    if (!valueProp || valueProp == 'true' || valueProp == 'false') {\n      return Boolean(checked);\n    }\n  } else {\n    // If the current value is already an array, use it\n    currentArrayOfValues = currentValue;\n    index = currentValue.indexOf(valueProp);\n    isValueInArray = index >= 0;\n  } // If the checkbox was checked and the value is not already present in the aray we want to add the new value to the array of values\n\n\n  if (checked && valueProp && !isValueInArray) {\n    return currentArrayOfValues.concat(valueProp);\n  } // If the checkbox was unchecked and the value is not in the array, simply return the already existing array of values\n\n\n  if (!isValueInArray) {\n    return currentArrayOfValues;\n  } // If the checkbox was unchecked and the value is in the array, remove the value and return the array\n\n\n  return currentArrayOfValues.slice(0, index).concat(currentArrayOfValues.slice(index + 1));\n} // React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\n// @see https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85\n\n\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? external_react_.useLayoutEffect : external_react_.useEffect;\n\nfunction useEventCallback(fn) {\n  var ref = (0,external_react_.useRef)(fn); // we copy a ref to the callback scoped to the current state/props on each render\n\n  useIsomorphicLayoutEffect(function () {\n    ref.current = fn;\n  });\n  return (0,external_react_.useCallback)(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return ref.current.apply(void 0, args);\n  }, []);\n}\n\nfunction useField(propsOrFieldName) {\n  var formik = useFormikContext();\n  var getFieldProps = formik.getFieldProps,\n      getFieldMeta = formik.getFieldMeta,\n      getFieldHelpers = formik.getFieldHelpers,\n      registerField = formik.registerField,\n      unregisterField = formik.unregisterField;\n  var isAnObject = formik_esm_isObject(propsOrFieldName); // Normalize propsOrFieldName to FieldHookConfig<Val>\n\n  var props = isAnObject ? propsOrFieldName : {\n    name: propsOrFieldName\n  };\n  var fieldName = props.name,\n      validateFn = props.validate;\n  useEffect(function () {\n    if (fieldName) {\n      registerField(fieldName, {\n        validate: validateFn\n      });\n    }\n\n    return function () {\n      if (fieldName) {\n        unregisterField(fieldName);\n      }\n    };\n  }, [registerField, unregisterField, fieldName, validateFn]);\n\n  if (false) {}\n\n  !fieldName ?  false ? 0 : invariant(false) : void 0;\n  var fieldHelpers = useMemo(function () {\n    return getFieldHelpers(fieldName);\n  }, [getFieldHelpers, fieldName]);\n  return [getFieldProps(props), getFieldMeta(fieldName), fieldHelpers];\n}\nfunction formik_esm_Field(_ref) {\n  var validate = _ref.validate,\n      name = _ref.name,\n      render = _ref.render,\n      children = _ref.children,\n      is = _ref.as,\n      component = _ref.component,\n      className = _ref.className,\n      props = _objectWithoutPropertiesLoose(_ref, [\"validate\", \"name\", \"render\", \"children\", \"as\", \"component\", \"className\"]);\n\n  var _useFormikContext = useFormikContext(),\n      formik = _objectWithoutPropertiesLoose(_useFormikContext, [\"validate\", \"validationSchema\"]);\n\n  if (false) {} // Register field and field-level validation with parent <Formik>\n\n\n  var registerField = formik.registerField,\n      unregisterField = formik.unregisterField;\n  (0,external_react_.useEffect)(function () {\n    registerField(name, {\n      validate: validate\n    });\n    return function () {\n      unregisterField(name);\n    };\n  }, [registerField, unregisterField, name, validate]);\n  var field = formik.getFieldProps(_extends({\n    name: name\n  }, props));\n  var meta = formik.getFieldMeta(name);\n  var legacyBag = {\n    field: field,\n    form: formik\n  };\n\n  if (render) {\n    return render(_extends({}, legacyBag, {\n      meta: meta\n    }));\n  }\n\n  if (formik_esm_isFunction(children)) {\n    return children(_extends({}, legacyBag, {\n      meta: meta\n    }));\n  }\n\n  if (component) {\n    // This behavior is backwards compat with earlier Formik 0.9 to 1.x\n    if (typeof component === 'string') {\n      var innerRef = props.innerRef,\n          rest = _objectWithoutPropertiesLoose(props, [\"innerRef\"]);\n\n      return (0,external_react_.createElement)(component, _extends({\n        ref: innerRef\n      }, field, rest, {\n        className: className\n      }), children);\n    } // We don't pass `meta` for backwards compat\n\n\n    return (0,external_react_.createElement)(component, _extends({\n      field: field,\n      form: formik\n    }, props, {\n      className: className\n    }), children);\n  } // default to input here so we can check for both `as` and `children` above\n\n\n  var asElement = is || 'input';\n\n  if (typeof asElement === 'string') {\n    var _innerRef = props.innerRef,\n        _rest = _objectWithoutPropertiesLoose(props, [\"innerRef\"]);\n\n    return (0,external_react_.createElement)(asElement, _extends({\n      ref: _innerRef\n    }, field, _rest, {\n      className: className\n    }), children);\n  }\n\n  return (0,external_react_.createElement)(asElement, _extends({}, field, props, {\n    className: className\n  }), children);\n}\n\nvar Form = /*#__PURE__*/(0,external_react_.forwardRef)(function (props, ref) {\n  // iOS needs an \"action\" attribute for nice input: https://stackoverflow.com/a/39485162/406725\n  // We default the action to \"#\" in case the preventDefault fails (just updates the URL hash)\n  var action = props.action,\n      rest = _objectWithoutPropertiesLoose(props, [\"action\"]);\n\n  var _action = action != null ? action : '#';\n\n  var _useFormikContext = useFormikContext(),\n      handleReset = _useFormikContext.handleReset,\n      handleSubmit = _useFormikContext.handleSubmit;\n\n  return (0,external_react_.createElement)(\"form\", _extends({\n    onSubmit: handleSubmit,\n    ref: ref,\n    onReset: handleReset,\n    action: _action\n  }, rest));\n});\nForm.displayName = 'Form';\n\n/**\r\n * A public higher-order component to access the imperative API\r\n */\n\nfunction withFormik(_ref) {\n  var _ref$mapPropsToValues = _ref.mapPropsToValues,\n      mapPropsToValues = _ref$mapPropsToValues === void 0 ? function (vanillaProps) {\n    var val = {};\n\n    for (var k in vanillaProps) {\n      if (vanillaProps.hasOwnProperty(k) && typeof vanillaProps[k] !== 'function') {\n        // @todo TypeScript fix\n        val[k] = vanillaProps[k];\n      }\n    }\n\n    return val;\n  } : _ref$mapPropsToValues,\n      config = _objectWithoutPropertiesLoose(_ref, [\"mapPropsToValues\"]);\n\n  return function createFormik(Component$1) {\n    var componentDisplayName = Component$1.displayName || Component$1.name || Component$1.constructor && Component$1.constructor.name || 'Component';\n    /**\r\n     * We need to use closures here for to provide the wrapped component's props to\r\n     * the respective withFormik config methods.\r\n     */\n\n    var C = /*#__PURE__*/function (_React$Component) {\n      _inheritsLoose(C, _React$Component);\n\n      function C() {\n        var _this;\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n\n        _this.validate = function (values) {\n          return config.validate(values, _this.props);\n        };\n\n        _this.validationSchema = function () {\n          return formik_esm_isFunction(config.validationSchema) ? config.validationSchema(_this.props) : config.validationSchema;\n        };\n\n        _this.handleSubmit = function (values, actions) {\n          return config.handleSubmit(values, _extends({}, actions, {\n            props: _this.props\n          }));\n        };\n\n        _this.renderFormComponent = function (formikProps) {\n          return createElement(Component$1, _extends({}, _this.props, formikProps));\n        };\n\n        return _this;\n      }\n\n      var _proto = C.prototype;\n\n      _proto.render = function render() {\n        var _this$props = this.props,\n            props = _objectWithoutPropertiesLoose(_this$props, [\"children\"]);\n\n        return createElement(Formik, _extends({}, props, config, {\n          validate: config.validate && this.validate,\n          validationSchema: config.validationSchema && this.validationSchema,\n          initialValues: mapPropsToValues(this.props),\n          initialStatus: config.mapPropsToStatus && config.mapPropsToStatus(this.props),\n          initialErrors: config.mapPropsToErrors && config.mapPropsToErrors(this.props),\n          initialTouched: config.mapPropsToTouched && config.mapPropsToTouched(this.props),\n          onSubmit: this.handleSubmit,\n          children: this.renderFormComponent\n        }));\n      };\n\n      return C;\n    }(Component);\n\n    C.displayName = \"WithFormik(\" + componentDisplayName + \")\";\n    return hoistNonReactStatics(C, Component$1 // cast type to ComponentClass (even if SFC)\n    );\n  };\n}\n\n/**\r\n * Connect any component to Formik context, and inject as a prop called `formik`;\r\n * @param Comp React Component\r\n */\n\nfunction connect(Comp) {\n  var C = function C(props) {\n    return createElement(FormikConsumer, null, function (formik) {\n      !!!formik ?  false ? 0 : invariant(false) : void 0;\n      return createElement(Comp, _extends({}, props, {\n        formik: formik\n      }));\n    });\n  };\n\n  var componentDisplayName = Comp.displayName || Comp.name || Comp.constructor && Comp.constructor.name || 'Component'; // Assign Comp to C.WrappedComponent so we can access the inner component in tests\n  // For example, <Field.WrappedComponent /> gets us <FieldInner/>\n\n  C.WrappedComponent = Comp;\n  C.displayName = \"FormikConnect(\" + componentDisplayName + \")\";\n  return hoistNonReactStatics(C, Comp // cast type to ComponentClass (even if SFC)\n  );\n}\n\n/**\r\n * Some array helpers!\r\n */\n\nvar move = function move(array, from, to) {\n  var copy = copyArrayLike(array);\n  var value = copy[from];\n  copy.splice(from, 1);\n  copy.splice(to, 0, value);\n  return copy;\n};\nvar swap = function swap(arrayLike, indexA, indexB) {\n  var copy = copyArrayLike(arrayLike);\n  var a = copy[indexA];\n  copy[indexA] = copy[indexB];\n  copy[indexB] = a;\n  return copy;\n};\nvar insert = function insert(arrayLike, index, value) {\n  var copy = copyArrayLike(arrayLike);\n  copy.splice(index, 0, value);\n  return copy;\n};\nvar replace = function replace(arrayLike, index, value) {\n  var copy = copyArrayLike(arrayLike);\n  copy[index] = value;\n  return copy;\n};\n\nvar copyArrayLike = function copyArrayLike(arrayLike) {\n  if (!arrayLike) {\n    return [];\n  } else if (Array.isArray(arrayLike)) {\n    return [].concat(arrayLike);\n  } else {\n    var maxIndex = Object.keys(arrayLike).map(function (key) {\n      return parseInt(key);\n    }).reduce(function (max, el) {\n      return el > max ? el : max;\n    }, 0);\n    return Array.from(_extends({}, arrayLike, {\n      length: maxIndex + 1\n    }));\n  }\n};\n\nvar createAlterationHandler = function createAlterationHandler(alteration, defaultFunction) {\n  var fn = typeof alteration === 'function' ? alteration : defaultFunction;\n  return function (data) {\n    if (Array.isArray(data) || formik_esm_isObject(data)) {\n      var clone = copyArrayLike(data);\n      return fn(clone);\n    } // This can be assumed to be a primitive, which\n    // is a case for top level validation errors\n\n\n    return data;\n  };\n};\n\nvar FieldArrayInner = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(FieldArrayInner, _React$Component);\n\n  function FieldArrayInner(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this; // We need TypeScript generics on these, so we'll bind them in the constructor\n    // @todo Fix TS 3.2.1\n\n    _this.updateArrayField = function (fn, alterTouched, alterErrors) {\n      var _this$props = _this.props,\n          name = _this$props.name,\n          setFormikState = _this$props.formik.setFormikState;\n      setFormikState(function (prevState) {\n        var updateErrors = createAlterationHandler(alterErrors, fn);\n        var updateTouched = createAlterationHandler(alterTouched, fn); // values fn should be executed before updateErrors and updateTouched,\n        // otherwise it causes an error with unshift.\n\n        var values = setIn(prevState.values, name, fn(getIn(prevState.values, name)));\n        var fieldError = alterErrors ? updateErrors(getIn(prevState.errors, name)) : undefined;\n        var fieldTouched = alterTouched ? updateTouched(getIn(prevState.touched, name)) : undefined;\n\n        if (isEmptyArray(fieldError)) {\n          fieldError = undefined;\n        }\n\n        if (isEmptyArray(fieldTouched)) {\n          fieldTouched = undefined;\n        }\n\n        return _extends({}, prevState, {\n          values: values,\n          errors: alterErrors ? setIn(prevState.errors, name, fieldError) : prevState.errors,\n          touched: alterTouched ? setIn(prevState.touched, name, fieldTouched) : prevState.touched\n        });\n      });\n    };\n\n    _this.push = function (value) {\n      return _this.updateArrayField(function (arrayLike) {\n        return [].concat(copyArrayLike(arrayLike), [lodash_es_cloneDeep(value)]);\n      }, false, false);\n    };\n\n    _this.handlePush = function (value) {\n      return function () {\n        return _this.push(value);\n      };\n    };\n\n    _this.swap = function (indexA, indexB) {\n      return _this.updateArrayField(function (array) {\n        return swap(array, indexA, indexB);\n      }, true, true);\n    };\n\n    _this.handleSwap = function (indexA, indexB) {\n      return function () {\n        return _this.swap(indexA, indexB);\n      };\n    };\n\n    _this.move = function (from, to) {\n      return _this.updateArrayField(function (array) {\n        return move(array, from, to);\n      }, true, true);\n    };\n\n    _this.handleMove = function (from, to) {\n      return function () {\n        return _this.move(from, to);\n      };\n    };\n\n    _this.insert = function (index, value) {\n      return _this.updateArrayField(function (array) {\n        return insert(array, index, value);\n      }, function (array) {\n        return insert(array, index, null);\n      }, function (array) {\n        return insert(array, index, null);\n      });\n    };\n\n    _this.handleInsert = function (index, value) {\n      return function () {\n        return _this.insert(index, value);\n      };\n    };\n\n    _this.replace = function (index, value) {\n      return _this.updateArrayField(function (array) {\n        return replace(array, index, value);\n      }, false, false);\n    };\n\n    _this.handleReplace = function (index, value) {\n      return function () {\n        return _this.replace(index, value);\n      };\n    };\n\n    _this.unshift = function (value) {\n      var length = -1;\n\n      _this.updateArrayField(function (array) {\n        var arr = array ? [value].concat(array) : [value];\n        length = arr.length;\n        return arr;\n      }, function (array) {\n        return array ? [null].concat(array) : [null];\n      }, function (array) {\n        return array ? [null].concat(array) : [null];\n      });\n\n      return length;\n    };\n\n    _this.handleUnshift = function (value) {\n      return function () {\n        return _this.unshift(value);\n      };\n    };\n\n    _this.handleRemove = function (index) {\n      return function () {\n        return _this.remove(index);\n      };\n    };\n\n    _this.handlePop = function () {\n      return function () {\n        return _this.pop();\n      };\n    };\n\n    _this.remove = _this.remove.bind(_assertThisInitialized(_this));\n    _this.pop = _this.pop.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  var _proto = FieldArrayInner.prototype;\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    if (this.props.validateOnChange && this.props.formik.validateOnChange && !react_fast_compare_default()(getIn(prevProps.formik.values, prevProps.name), getIn(this.props.formik.values, this.props.name))) {\n      this.props.formik.validateForm(this.props.formik.values);\n    }\n  };\n\n  _proto.remove = function remove(index) {\n    // We need to make sure we also remove relevant pieces of `touched` and `errors`\n    var result;\n    this.updateArrayField( // so this gets call 3 times\n    function (array) {\n      var copy = array ? copyArrayLike(array) : [];\n\n      if (!result) {\n        result = copy[index];\n      }\n\n      if (formik_esm_isFunction(copy.splice)) {\n        copy.splice(index, 1);\n      } // if the array only includes undefined values we have to return an empty array\n\n\n      return formik_esm_isFunction(copy.every) ? copy.every(function (v) {\n        return v === undefined;\n      }) ? [] : copy : copy;\n    }, true, true);\n    return result;\n  };\n\n  _proto.pop = function pop() {\n    // Remove relevant pieces of `touched` and `errors` too!\n    var result;\n    this.updateArrayField( // so this gets call 3 times\n    function (array) {\n      var tmp = array.slice();\n\n      if (!result) {\n        result = tmp && tmp.pop && tmp.pop();\n      }\n\n      return tmp;\n    }, true, true);\n    return result;\n  };\n\n  _proto.render = function render() {\n    var arrayHelpers = {\n      push: this.push,\n      pop: this.pop,\n      swap: this.swap,\n      move: this.move,\n      insert: this.insert,\n      replace: this.replace,\n      unshift: this.unshift,\n      remove: this.remove,\n      handlePush: this.handlePush,\n      handlePop: this.handlePop,\n      handleSwap: this.handleSwap,\n      handleMove: this.handleMove,\n      handleInsert: this.handleInsert,\n      handleReplace: this.handleReplace,\n      handleUnshift: this.handleUnshift,\n      handleRemove: this.handleRemove\n    };\n\n    var _this$props2 = this.props,\n        component = _this$props2.component,\n        render = _this$props2.render,\n        children = _this$props2.children,\n        name = _this$props2.name,\n        _this$props2$formik = _this$props2.formik,\n        restOfFormik = _objectWithoutPropertiesLoose(_this$props2$formik, [\"validate\", \"validationSchema\"]);\n\n    var props = _extends({}, arrayHelpers, {\n      form: restOfFormik,\n      name: name\n    });\n\n    return component ? (0,external_react_.createElement)(component, props) : render ? render(props) : children // children come last, always called\n    ? typeof children === 'function' ? children(props) : !isEmptyChildren(children) ? external_react_.Children.only(children) : null : null;\n  };\n\n  return FieldArrayInner;\n}(external_react_.Component);\n\nFieldArrayInner.defaultProps = {\n  validateOnChange: true\n};\nvar FieldArray = /*#__PURE__*/(/* unused pure expression or super */ null && (connect(FieldArrayInner)));\n\nvar ErrorMessageImpl = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(ErrorMessageImpl, _React$Component);\n\n  function ErrorMessageImpl() {\n    return _React$Component.apply(this, arguments) || this;\n  }\n\n  var _proto = ErrorMessageImpl.prototype;\n\n  _proto.shouldComponentUpdate = function shouldComponentUpdate(props) {\n    if (getIn(this.props.formik.errors, this.props.name) !== getIn(props.formik.errors, this.props.name) || getIn(this.props.formik.touched, this.props.name) !== getIn(props.formik.touched, this.props.name) || Object.keys(this.props).length !== Object.keys(props).length) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        component = _this$props.component,\n        formik = _this$props.formik,\n        render = _this$props.render,\n        children = _this$props.children,\n        name = _this$props.name,\n        rest = _objectWithoutPropertiesLoose(_this$props, [\"component\", \"formik\", \"render\", \"children\", \"name\"]);\n\n    var touch = getIn(formik.touched, name);\n    var error = getIn(formik.errors, name);\n    return !!touch && !!error ? render ? formik_esm_isFunction(render) ? render(error) : null : children ? formik_esm_isFunction(children) ? children(error) : null : component ? (0,external_react_.createElement)(component, rest, error) : error : null;\n  };\n\n  return ErrorMessageImpl;\n}(external_react_.Component);\n\nvar ErrorMessage = /*#__PURE__*/(/* unused pure expression or super */ null && (connect(ErrorMessageImpl)));\n\n/**\r\n * Custom Field component for quickly hooking into Formik\r\n * context and wiring up forms.\r\n */\n\nvar FastFieldInner = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(FastFieldInner, _React$Component);\n\n  function FastFieldInner(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    var render = props.render,\n        children = props.children,\n        component = props.component,\n        is = props.as,\n        name = props.name;\n    !!render ?  false ? 0 : tiny_warning_esm(false) : void 0;\n    !!(component && render) ?  false ? 0 : tiny_warning_esm(false) : void 0;\n    !!(is && children && formik_esm_isFunction(children)) ?  false ? 0 : tiny_warning_esm(false) : void 0;\n    !!(component && children && formik_esm_isFunction(children)) ?  false ? 0 : tiny_warning_esm(false) : void 0;\n    !!(render && children && !isEmptyChildren(children)) ?  false ? 0 : tiny_warning_esm(false) : void 0;\n    return _this;\n  }\n\n  var _proto = FastFieldInner.prototype;\n\n  _proto.shouldComponentUpdate = function shouldComponentUpdate(props) {\n    if (this.props.shouldUpdate) {\n      return this.props.shouldUpdate(props, this.props);\n    } else if (props.name !== this.props.name || getIn(props.formik.values, this.props.name) !== getIn(this.props.formik.values, this.props.name) || getIn(props.formik.errors, this.props.name) !== getIn(this.props.formik.errors, this.props.name) || getIn(props.formik.touched, this.props.name) !== getIn(this.props.formik.touched, this.props.name) || Object.keys(this.props).length !== Object.keys(props).length || props.formik.isSubmitting !== this.props.formik.isSubmitting) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  _proto.componentDidMount = function componentDidMount() {\n    // Register the Field with the parent Formik. Parent will cycle through\n    // registered Field's validate fns right prior to submit\n    this.props.formik.registerField(this.props.name, {\n      validate: this.props.validate\n    });\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    if (this.props.name !== prevProps.name) {\n      this.props.formik.unregisterField(prevProps.name);\n      this.props.formik.registerField(this.props.name, {\n        validate: this.props.validate\n      });\n    }\n\n    if (this.props.validate !== prevProps.validate) {\n      this.props.formik.registerField(this.props.name, {\n        validate: this.props.validate\n      });\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.props.formik.unregisterField(this.props.name);\n  };\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        name = _this$props.name,\n        render = _this$props.render,\n        is = _this$props.as,\n        children = _this$props.children,\n        component = _this$props.component,\n        formik = _this$props.formik,\n        props = _objectWithoutPropertiesLoose(_this$props, [\"validate\", \"name\", \"render\", \"as\", \"children\", \"component\", \"shouldUpdate\", \"formik\"]);\n\n    var restOfFormik = _objectWithoutPropertiesLoose(formik, [\"validate\", \"validationSchema\"]);\n\n    var field = formik.getFieldProps(_extends({\n      name: name\n    }, props));\n    var meta = {\n      value: getIn(formik.values, name),\n      error: getIn(formik.errors, name),\n      touched: !!getIn(formik.touched, name),\n      initialValue: getIn(formik.initialValues, name),\n      initialTouched: !!getIn(formik.initialTouched, name),\n      initialError: getIn(formik.initialErrors, name)\n    };\n    var bag = {\n      field: field,\n      meta: meta,\n      form: restOfFormik\n    };\n\n    if (render) {\n      return render(bag);\n    }\n\n    if (formik_esm_isFunction(children)) {\n      return children(bag);\n    }\n\n    if (component) {\n      // This behavior is backwards compat with earlier Formik 0.9 to 1.x\n      if (typeof component === 'string') {\n        var innerRef = props.innerRef,\n            rest = _objectWithoutPropertiesLoose(props, [\"innerRef\"]);\n\n        return (0,external_react_.createElement)(component, _extends({\n          ref: innerRef\n        }, field, rest), children);\n      } // We don't pass `meta` for backwards compat\n\n\n      return (0,external_react_.createElement)(component, _extends({\n        field: field,\n        form: formik\n      }, props), children);\n    } // default to input here so we can check for both `as` and `children` above\n\n\n    var asElement = is || 'input';\n\n    if (typeof asElement === 'string') {\n      var _innerRef = props.innerRef,\n          _rest = _objectWithoutPropertiesLoose(props, [\"innerRef\"]);\n\n      return (0,external_react_.createElement)(asElement, _extends({\n        ref: _innerRef\n      }, field, _rest), children);\n    }\n\n    return (0,external_react_.createElement)(asElement, _extends({}, field, props), children);\n  };\n\n  return FastFieldInner;\n}(external_react_.Component);\n\nvar FastField = /*#__PURE__*/(/* unused pure expression or super */ null && (connect(FastFieldInner)));\n\n\n//# sourceMappingURL=formik.esm.js.map\n\n// EXTERNAL MODULE: external \"@deriv/components\"\nvar components_ = __webpack_require__(\"@deriv/components\");\n// EXTERNAL MODULE: external \"mobx\"\nvar external_mobx_ = __webpack_require__(\"mobx\");\n;// CONCATENATED MODULE: ../../../node_modules/mobx-react-lite/es/utils/assertEnvironment.js\n\n\nif (!external_react_.useState) {\n    throw new Error(\"mobx-react-lite requires React with Hooks support\");\n}\nif (!external_mobx_.makeObservable) {\n    throw new Error(\"mobx-react-lite@3 requires mobx at least version 6 to be available\");\n}\n//# sourceMappingURL=assertEnvironment.js.map\n// EXTERNAL MODULE: external \"react-dom\"\nvar external_react_dom_ = __webpack_require__(\"react-dom\");\n;// CONCATENATED MODULE: ../../../node_modules/mobx-react-lite/es/utils/reactBatchedUpdates.js\n\n//# sourceMappingURL=reactBatchedUpdates.js.map\n;// CONCATENATED MODULE: ../../../node_modules/mobx-react-lite/es/utils/observerBatching.js\n\nfunction defaultNoopBatch(callback) {\n    callback();\n}\nfunction observerBatching(reactionScheduler) {\n    if (!reactionScheduler) {\n        reactionScheduler = defaultNoopBatch;\n        if (false) {}\n    }\n    (0,external_mobx_.configure)({ reactionScheduler: reactionScheduler });\n}\nvar isObserverBatched = function () {\n    if (false) {}\n    return true;\n};\n//# sourceMappingURL=observerBatching.js.map\n;// CONCATENATED MODULE: ../../../node_modules/mobx-react-lite/es/utils/printDebugValue.js\n\nfunction printDebugValue(v) {\n    return (0,external_mobx_.getDependencyTree)(v);\n}\n//# sourceMappingURL=printDebugValue.js.map\n;// CONCATENATED MODULE: ../../../node_modules/mobx-react-lite/es/utils/UniversalFinalizationRegistry.js\nvar REGISTRY_FINALIZE_AFTER = 10000;\nvar REGISTRY_SWEEP_INTERVAL = 10000;\nvar TimerBasedFinalizationRegistry = /** @class */ (function () {\n    function TimerBasedFinalizationRegistry(finalize) {\n        var _this = this;\n        Object.defineProperty(this, \"finalize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: finalize\n        });\n        Object.defineProperty(this, \"registrations\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"sweepTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // Bound so it can be used directly as setTimeout callback.\n        Object.defineProperty(this, \"sweep\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: function (maxAge) {\n                if (maxAge === void 0) { maxAge = REGISTRY_FINALIZE_AFTER; }\n                // cancel timeout so we can force sweep anytime\n                clearTimeout(_this.sweepTimeout);\n                _this.sweepTimeout = undefined;\n                var now = Date.now();\n                _this.registrations.forEach(function (registration, token) {\n                    if (now - registration.registeredAt >= maxAge) {\n                        _this.finalize(registration.value);\n                        _this.registrations.delete(token);\n                    }\n                });\n                if (_this.registrations.size > 0) {\n                    _this.scheduleSweep();\n                }\n            }\n        });\n        // Bound so it can be exported directly as clearTimers test utility.\n        Object.defineProperty(this, \"finalizeAllImmediately\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: function () {\n                _this.sweep(0);\n            }\n        });\n    }\n    // Token is actually required with this impl\n    Object.defineProperty(TimerBasedFinalizationRegistry.prototype, \"register\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (target, value, token) {\n            this.registrations.set(token, {\n                value: value,\n                registeredAt: Date.now()\n            });\n            this.scheduleSweep();\n        }\n    });\n    Object.defineProperty(TimerBasedFinalizationRegistry.prototype, \"unregister\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (token) {\n            this.registrations.delete(token);\n        }\n    });\n    Object.defineProperty(TimerBasedFinalizationRegistry.prototype, \"scheduleSweep\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            if (this.sweepTimeout === undefined) {\n                this.sweepTimeout = setTimeout(this.sweep, REGISTRY_SWEEP_INTERVAL);\n            }\n        }\n    });\n    return TimerBasedFinalizationRegistry;\n}());\n\nvar UniversalFinalizationRegistry = typeof FinalizationRegistry !== \"undefined\"\n    ? FinalizationRegistry\n    : TimerBasedFinalizationRegistry;\n//# sourceMappingURL=UniversalFinalizationRegistry.js.map\n;// CONCATENATED MODULE: ../../../node_modules/mobx-react-lite/es/utils/observerFinalizationRegistry.js\n\nvar observerFinalizationRegistry = new UniversalFinalizationRegistry(function (adm) {\n    var _a;\n    (_a = adm.reaction) === null || _a === void 0 ? void 0 : _a.dispose();\n    adm.reaction = null;\n});\n//# sourceMappingURL=observerFinalizationRegistry.js.map\n;// CONCATENATED MODULE: ../../../node_modules/mobx-react-lite/es/staticRendering.js\nvar globalIsUsingStaticRendering = false;\nfunction staticRendering_enableStaticRendering(enable) {\n    globalIsUsingStaticRendering = enable;\n}\nfunction isUsingStaticRendering() {\n    return globalIsUsingStaticRendering;\n}\n//# sourceMappingURL=staticRendering.js.map\n;// CONCATENATED MODULE: ../../../node_modules/mobx-react-lite/es/useObserver.js\nvar __read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n\n\n\n\n\nfunction observerComponentNameFor(baseComponentName) {\n    return \"observer\".concat(baseComponentName);\n}\n/**\n * We use class to make it easier to detect in heap snapshots by name\n */\nvar ObjectToBeRetainedByReact = /** @class */ (function () {\n    function ObjectToBeRetainedByReact() {\n    }\n    return ObjectToBeRetainedByReact;\n}());\nfunction objectToBeRetainedByReactFactory() {\n    return new ObjectToBeRetainedByReact();\n}\nfunction useObserver(fn, baseComponentName) {\n    if (baseComponentName === void 0) { baseComponentName = \"observed\"; }\n    if (isUsingStaticRendering()) {\n        return fn();\n    }\n    var _a = __read(external_react_default().useState(objectToBeRetainedByReactFactory), 1), objectRetainedByReact = _a[0];\n    // Force update, see #2982\n    var _b = __read(external_react_default().useState(), 2), setState = _b[1];\n    var forceUpdate = function () { return setState([]); };\n    // StrictMode/ConcurrentMode/Suspense may mean that our component is\n    // rendered and abandoned multiple times, so we need to track leaked\n    // Reactions.\n    var admRef = external_react_default().useRef(null);\n    if (!admRef.current) {\n        // First render\n        admRef.current = {\n            reaction: null,\n            mounted: false,\n            changedBeforeMount: false\n        };\n    }\n    var adm = admRef.current;\n    if (!adm.reaction) {\n        // First render or component was not committed and reaction was disposed by registry\n        adm.reaction = new external_mobx_.Reaction(observerComponentNameFor(baseComponentName), function () {\n            // Observable has changed, meaning we want to re-render\n            // BUT if we're a component that hasn't yet got to the useEffect()\n            // stage, we might be a component that _started_ to render, but\n            // got dropped, and we don't want to make state changes then.\n            // (It triggers warnings in StrictMode, for a start.)\n            if (adm.mounted) {\n                // We have reached useEffect(), so we're mounted, and can trigger an update\n                forceUpdate();\n            }\n            else {\n                // We haven't yet reached useEffect(), so we'll need to trigger a re-render\n                // when (and if) useEffect() arrives.\n                adm.changedBeforeMount = true;\n            }\n        });\n        observerFinalizationRegistry.register(objectRetainedByReact, adm, adm);\n    }\n    external_react_default().useDebugValue(adm.reaction, printDebugValue);\n    external_react_default().useEffect(function () {\n        observerFinalizationRegistry.unregister(adm);\n        adm.mounted = true;\n        if (adm.reaction) {\n            if (adm.changedBeforeMount) {\n                // Got a change before mount, force an update\n                adm.changedBeforeMount = false;\n                forceUpdate();\n            }\n        }\n        else {\n            // The reaction we set up in our render has been disposed.\n            // This can be due to bad timings of renderings, e.g. our\n            // component was paused for a _very_ long time, and our\n            // reaction got cleaned up\n            // Re-create the reaction\n            adm.reaction = new external_mobx_.Reaction(observerComponentNameFor(baseComponentName), function () {\n                // We've definitely already been mounted at this point\n                forceUpdate();\n            });\n            forceUpdate();\n        }\n        return function () {\n            adm.reaction.dispose();\n            adm.reaction = null;\n            adm.mounted = false;\n            adm.changedBeforeMount = false;\n        };\n    }, []);\n    // render the original component, but have the\n    // reaction track the observables, so that rendering\n    // can be invalidated (see above) once a dependency changes\n    var rendering;\n    var exception;\n    adm.reaction.track(function () {\n        try {\n            rendering = fn();\n        }\n        catch (e) {\n            exception = e;\n        }\n    });\n    if (exception) {\n        throw exception; // re-throw any exceptions caught during rendering\n    }\n    return rendering;\n}\n//# sourceMappingURL=useObserver.js.map\n;// CONCATENATED MODULE: ../../../node_modules/mobx-react-lite/es/observer.js\n\n\n\nvar warnObserverOptionsDeprecated = true;\nvar hasSymbol = typeof Symbol === \"function\" && Symbol.for;\n// Using react-is had some issues (and operates on elements, not on types), see #608 / #609\nvar ReactForwardRefSymbol = hasSymbol\n    ? Symbol.for(\"react.forward_ref\")\n    : typeof external_react_.forwardRef === \"function\" && (0,external_react_.forwardRef)(function (props) { return null; })[\"$$typeof\"];\nvar ReactMemoSymbol = hasSymbol\n    ? Symbol.for(\"react.memo\")\n    : typeof external_react_.memo === \"function\" && (0,external_react_.memo)(function (props) { return null; })[\"$$typeof\"];\n// n.b. base case is not used for actual typings or exported in the typing files\nfunction observer(baseComponent, \n// TODO remove in next major\noptions) {\n    var _a;\n    if (false) {}\n    if (ReactMemoSymbol && baseComponent[\"$$typeof\"] === ReactMemoSymbol) {\n        throw new Error(\"[mobx-react-lite] You are trying to use `observer` on a function component wrapped in either another `observer` or `React.memo`. The observer already applies 'React.memo' for you.\");\n    }\n    // The working of observer is explained step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307\n    if (isUsingStaticRendering()) {\n        return baseComponent;\n    }\n    var useForwardRef = (_a = options === null || options === void 0 ? void 0 : options.forwardRef) !== null && _a !== void 0 ? _a : false;\n    var render = baseComponent;\n    var baseComponentName = baseComponent.displayName || baseComponent.name;\n    // If already wrapped with forwardRef, unwrap,\n    // so we can patch render and apply memo\n    if (ReactForwardRefSymbol && baseComponent[\"$$typeof\"] === ReactForwardRefSymbol) {\n        useForwardRef = true;\n        render = baseComponent[\"render\"];\n        if (typeof render !== \"function\") {\n            throw new Error(\"[mobx-react-lite] `render` property of ForwardRef was not a function\");\n        }\n    }\n    var observerComponent = function (props, ref) {\n        return useObserver(function () { return render(props, ref); }, baseComponentName);\n    };\n    // Don't set `displayName` for anonymous components,\n    // so the `displayName` can be customized by user, see #3192.\n    if (baseComponentName !== \"\") {\n        ;\n        observerComponent.displayName = baseComponentName;\n    }\n    // Support legacy context: `contextTypes` must be applied before `memo`\n    if (baseComponent.contextTypes) {\n        ;\n        observerComponent.contextTypes = baseComponent.contextTypes;\n    }\n    if (useForwardRef) {\n        // `forwardRef` must be applied prior `memo`\n        // `forwardRef(observer(cmp))` throws:\n        // \"forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))\"\n        observerComponent = (0,external_react_.forwardRef)(observerComponent);\n    }\n    // memo; we are not interested in deep updates\n    // in props; we assume that if deep objects are changed,\n    // this is in observables, which would have been tracked anyway\n    observerComponent = (0,external_react_.memo)(observerComponent);\n    copyStaticProperties(baseComponent, observerComponent);\n    if (false) {}\n    return observerComponent;\n}\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nvar hoistBlackList = {\n    $$typeof: true,\n    render: true,\n    compare: true,\n    type: true,\n    // Don't redefine `displayName`,\n    // it's defined as getter-setter pair on `memo` (see #3192).\n    displayName: true\n};\nfunction copyStaticProperties(base, target) {\n    Object.keys(base).forEach(function (key) {\n        if (!hoistBlackList[key]) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));\n        }\n    });\n}\n//# sourceMappingURL=observer.js.map\n;// CONCATENATED MODULE: ../../../node_modules/mobx-react-lite/es/ObserverComponent.js\n\nfunction ObserverComponent(_a) {\n    var children = _a.children, render = _a.render;\n    var component = children || render;\n    if (typeof component !== \"function\") {\n        return null;\n    }\n    return useObserver(component);\n}\nif (false) {}\nObserverComponent.displayName = \"Observer\";\n\nfunction ObserverPropsCheck(props, key, componentName, location, propFullName) {\n    var extraKey = key === \"children\" ? \"render\" : \"children\";\n    var hasProp = typeof props[key] === \"function\";\n    var hasExtraProp = typeof props[extraKey] === \"function\";\n    if (hasProp && hasExtraProp) {\n        return new Error(\"MobX Observer: Do not use children and render in the same time in`\" + componentName);\n    }\n    if (hasProp || hasExtraProp) {\n        return null;\n    }\n    return new Error(\"Invalid prop `\" +\n        propFullName +\n        \"` of type `\" +\n        typeof props[key] +\n        \"` supplied to\" +\n        \" `\" +\n        componentName +\n        \"`, expected `function`.\");\n}\n//# sourceMappingURL=ObserverComponent.js.map\n;// CONCATENATED MODULE: ../../../node_modules/mobx-react-lite/es/useLocalObservable.js\n\n\nfunction useLocalObservable(initializer, annotations) {\n    return useState(function () { return observable(initializer(), annotations, { autoBind: true }); })[0];\n}\n//# sourceMappingURL=useLocalObservable.js.map\n;// CONCATENATED MODULE: ../../../node_modules/mobx-react-lite/es/useAsObservableSource.js\nvar useAsObservableSource_read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n\n\n\nfunction useAsObservableSource_useAsObservableSource(current) {\n    if (false)\n        {}\n    var _a = useAsObservableSource_read(useState(function () { return observable(current, {}, { deep: false }); }), 1), res = _a[0];\n    runInAction(function () {\n        Object.assign(res, current);\n    });\n    return res;\n}\n//# sourceMappingURL=useAsObservableSource.js.map\n;// CONCATENATED MODULE: ../../../node_modules/mobx-react-lite/es/useLocalStore.js\n\n\n\n\nfunction useLocalStore(initializer, current) {\n    if (false)\n        {}\n    var source = current && useAsObservableSource(current);\n    return useState(function () { return observable(initializer(source), undefined, { autoBind: true }); })[0];\n}\n//# sourceMappingURL=useLocalStore.js.map\n;// CONCATENATED MODULE: ../../../node_modules/mobx-react-lite/es/index.js\nvar _a;\n\n\n\n\n\n\n\nobserverBatching(external_react_dom_.unstable_batchedUpdates);\n\n\n\n\n\n\nvar clearTimers = (_a = observerFinalizationRegistry.finalizeAllImmediately) !== null && _a !== void 0 ? _a : (function () { });\nfunction es_useObserver(fn, baseComponentName) {\n    if (baseComponentName === void 0) { baseComponentName = \"observed\"; }\n    if (false) {}\n    return useObserverOriginal(fn, baseComponentName);\n}\n\nfunction useStaticRendering(enable) {\n    if (false) {}\n    enableStaticRendering(enable);\n}\n//# sourceMappingURL=index.js.map\n// EXTERNAL MODULE: ../../../node_modules/lodash.merge/index.js\nvar lodash_merge = __webpack_require__(\"../../../node_modules/lodash.merge/index.js\");\nvar lodash_merge_default = /*#__PURE__*/__webpack_require__.n(lodash_merge);\n;// CONCATENATED MODULE: ../../stores/src/mockStore.ts\n\nvar mock = function mock() {\n  var common_store_error = {\n    app_routing_history: [],\n    header: '',\n    message: '',\n    type: '',\n    redirect_label: '',\n    redirect_to: '',\n    should_clear_error_on_click: false,\n    should_show_refresh: false,\n    redirectOnClick: jest.fn()\n  };\n  return {\n    is_mock: true,\n    client: {\n      account_settings: {},\n      account_type: 'virtual',\n      accounts: {},\n      active_account_landing_company: '',\n      trading_platform_available_accounts: [],\n      account_limits: {},\n      account_status: {\n        authentication: {\n          attempts: {\n            count: 1,\n            history: [{\n              country_code: 'id',\n              id: '8919',\n              service: 'manual',\n              status: 'verified',\n              timestamp: 1674633681\n            }],\n            latest: {\n              country_code: 'id',\n              id: '8919',\n              service: 'manual',\n              status: 'verified',\n              timestamp: 1674633681\n            }\n          },\n          document: {\n            status: 'verified'\n          },\n          identity: {\n            services: {\n              idv: {\n                last_rejected: [],\n                reported_properties: {},\n                status: 'none',\n                submissions_left: 3\n              },\n              manual: {\n                status: 'none'\n              },\n              onfido: {\n                country_code: 'IDN',\n                documents_supported: ['Driving Licence', 'National Identity Card', 'Passport', 'Residence Permit'],\n                is_country_supported: 1,\n                last_rejected: [],\n                reported_properties: {},\n                status: 'none',\n                submissions_left: 3\n              }\n            },\n            status: 'verified'\n          },\n          income: {\n            status: 'none'\n          },\n          needs_verification: [],\n          ownership: {\n            requests: [],\n            status: 'none'\n          }\n        },\n        currency_config: {\n          USD: {\n            is_deposit_suspended: 0,\n            is_withdrawal_suspended: 0\n          }\n        },\n        p2p_status: 'none',\n        prompt_client_to_authenticate: 0,\n        risk_classification: 'low',\n        status: ['age_verification', 'allow_document_upload', 'authenticated', 'dxtrade_password_not_set', 'financial_information_not_complete', 'idv_disallowed', 'mt5_password_not_set', 'trading_experience_not_complete']\n      },\n      balance: '',\n      can_change_fiat_currency: false,\n      clients_country: '',\n      country_standpoint: {\n        is_belgium: false,\n        is_france: false,\n        is_isle_of_man: false,\n        is_other_eu: false,\n        is_rest_of_eu: false,\n        is_united_kingdom: false\n      },\n      currency: '',\n      currencies_list: [{\n        text: '',\n        value: '',\n        has_tool_tip: false\n      }],\n      current_currency_type: '',\n      current_fiat_currency: '',\n      cfd_score: 0,\n      ctrader_accounts_list: [],\n      setCFDScore: jest.fn(),\n      getLimits: jest.fn(),\n      has_active_real_account: false,\n      has_fiat: false,\n      has_logged_out: false,\n      has_maltainvest_account: false,\n      has_restricted_mt5_account: false,\n      initialized_broadcast: false,\n      is_account_setting_loaded: false,\n      is_authorize: false,\n      is_deposit_lock: false,\n      is_dxtrade_allowed: false,\n      is_dxtrade_password_not_set: false,\n      is_eu: false,\n      is_eu_country: false,\n      has_residence: false,\n      is_financial_account: false,\n      is_financial_assessment_needed: false,\n      is_financial_information_incomplete: false,\n      is_low_risk: false,\n      is_identity_verification_needed: false,\n      is_landing_company_loaded: false,\n      is_logged_in: false,\n      is_logging_in: false,\n      is_mt5_password_not_set: false,\n      is_pending_proof_of_ownership: false,\n      is_populating_dxtrade_account_list: false,\n      is_social_signup: false,\n      is_single_currency: false,\n      is_switching: false,\n      is_tnc_needed: false,\n      is_high_risk: false,\n      is_trading_experience_incomplete: false,\n      is_unwelcome: false,\n      is_virtual: false,\n      is_withdrawal_lock: false,\n      is_populating_account_list: false,\n      landing_company_shortcode: '',\n      local_currency_config: {\n        currency: '',\n        decimal_places: 0\n      },\n      loginid: '',\n      pre_switch_broadcast: false,\n      residence: '',\n      is_svg: false,\n      responseMt5LoginList: jest.fn(),\n      responseTradingPlatformAccountsList: jest.fn(),\n      setFinancialAndTradingAssessment: jest.fn(),\n      standpoint: {\n        financial_company: '',\n        gaming_company: '',\n        maltainvest: false,\n        svg: false,\n        iom: false,\n        malta: false\n      },\n      switchAccount: jest.fn(),\n      verification_code: {\n        payment_agent_withdraw: '',\n        payment_withdraw: '',\n        request_email: '',\n        reset_password: '',\n        signup: '',\n        system_email_change: '',\n        trading_platform_dxtrade_password_reset: '',\n        trading_platform_mt5_password_reset: ''\n      },\n      email: '',\n      setVerificationCode: jest.fn(),\n      updateAccountStatus: jest.fn(),\n      is_authentication_needed: false,\n      authentication_status: {\n        document_status: '',\n        identity_status: ''\n      },\n      mt5_login_list: [],\n      logout: jest.fn(),\n      should_allow_authentication: false,\n      active_accounts: [],\n      account_list: [],\n      available_crypto_currencies: [],\n      selectCurrency: jest.fn(),\n      setAccountStatus: jest.fn(),\n      setBalanceOtherAccounts: jest.fn(),\n      setInitialized: jest.fn(),\n      setLogout: jest.fn(),\n      setVisibilityRealityCheck: jest.fn(),\n      setP2pAdvertiserInfo: jest.fn(),\n      setPreSwitchAccount: jest.fn(),\n      social_identity_provider: '',\n      switched: false,\n      switch_broadcast: false,\n      switchEndSignal: jest.fn(),\n      is_uk: false,\n      isEligibleForMoreRealMt5: jest.fn(),\n      isEligibleForMoreDemoMt5Svg: jest.fn(),\n      updateMT5Status: jest.fn(),\n      fetchResidenceList: jest.fn(),\n      residence_list: [],\n      should_restrict_bvi_account_creation: false,\n      should_restrict_vanuatu_account_creation: false,\n      fetchAccountSettings: jest.fn(),\n      setAccountSettings: jest.fn(),\n      upgradeable_landing_companies: [],\n      is_populating_mt5_account_list: false,\n      landing_companies: {},\n      landing_company: {},\n      upgradeable_currencies: [],\n      getChangeableFields: jest.fn(),\n      isAccountOfTypeDisabled: jest.fn(),\n      is_mt5_allowed: false,\n      mt5_disabled_signup_types: {\n        real: false,\n        demo: false\n      },\n      dxtrade_disabled_signup_types: {\n        real: false,\n        demo: false\n      },\n      dxtrade_accounts_list_error: null,\n      has_account_error_in_mt5_demo_list: false,\n      has_account_error_in_mt5_real_list: false,\n      has_account_error_in_dxtrade_demo_list: false,\n      has_account_error_in_dxtrade_real_list: false,\n      website_status: {\n        dx_trade_status: {\n          all: 0,\n          demo: 0,\n          real: 0\n        },\n        mt5_status: {\n          real: [],\n          demo: []\n        }\n      },\n      is_fully_authenticated: false,\n      states_list: [],\n      fetchStatesList: jest.fn(),\n      is_crypto: jest.fn(),\n      dxtrade_accounts_list: [],\n      derivez_accounts_list: [],\n      default_currency: 'USD',\n      resetVirtualBalance: jest.fn(),\n      has_enabled_two_fa: false,\n      setTwoFAStatus: jest.fn(),\n      has_changed_two_fa: false,\n      setTwoFAChangedStatus: jest.fn(),\n      real_account_creation_unlock_date: '',\n      has_any_real_account: false,\n      setPrevAccountType: jest.fn(),\n      prev_account_type: 'demo',\n      is_beta_chart: true,\n      setLoginInformation: jest.fn(),\n      init: jest.fn(),\n      setLoginId: jest.fn(),\n      resetLocalStorageValues: jest.fn()\n    },\n    common: {\n      error: common_store_error,\n      current_language: 'EN',\n      isCurrentLanguage: jest.fn(),\n      is_from_derivgo: false,\n      is_socket_opened: false,\n      has_error: false,\n      platform: '',\n      routeBackInApp: jest.fn(),\n      routeTo: jest.fn(),\n      changeCurrentLanguage: jest.fn(),\n      changeSelectedLanguage: jest.fn(),\n      is_network_online: false,\n      network_status: {},\n      services_error: {},\n      server_time: new Date(),\n      setError: jest.fn(),\n      setSelectedContractType: jest.fn(),\n      setServicesError: jest.fn(),\n      showError: jest.fn(),\n      is_language_changing: false,\n      setAppstorePlatform: jest.fn(),\n      app_routing_history: [],\n      getExchangeRate: jest.fn()\n    },\n    ui: {\n      advanced_duration_unit: 't',\n      account_switcher_disabled_message: '',\n      app_contents_scroll_ref: {\n        current: null\n      },\n      current_focus: null,\n      is_account_settings_visible: false,\n      is_advanced_duration: false,\n      is_loading: false,\n      is_cashier_visible: false,\n      is_wallet_modal_visible: false,\n      is_chart_layout_default: false,\n      is_closing_create_real_account_modal: false,\n      is_dark_mode_on: false,\n      is_language_settings_modal_on: false,\n      is_desktop: false,\n      is_app_disabled: false,\n      has_only_forward_starting_contracts: false,\n      header_extension: null,\n      is_link_expired_modal_visible: false,\n      is_mobile: false,\n      is_tablet: false,\n      is_mobile_language_menu_open: false,\n      is_positions_drawer_on: false,\n      is_reports_visible: false,\n      is_route_modal_on: false,\n      is_services_error_visible: false,\n      is_unsupported_contract_modal_visible: false,\n      disableApp: jest.fn(),\n      enableApp: jest.fn(),\n      setCurrentFocus: jest.fn(),\n      toggleAccountsDialog: jest.fn(),\n      toggleAccountSettings: jest.fn(),\n      toggleCashier: jest.fn(),\n      setDarkMode: jest.fn(),\n      setReportsTabIndex: jest.fn(),\n      has_real_account_signup_ended: false,\n      real_account_signup_target: '',\n      real_account_signup: {\n        active_modal_index: -1,\n        previous_currency: '',\n        current_currency: '',\n        success_message: '',\n        error_message: ''\n      },\n      resetRealAccountSignupParams: jest.fn(),\n      notification_messages_ui: jest.fn(),\n      openPositionsDrawer: jest.fn(),\n      openRealAccountSignup: jest.fn(),\n      setIsWalletModalVisible: jest.fn(),\n      setHasOnlyForwardingContracts: jest.fn(),\n      setIsClosingCreateRealAccountModal: jest.fn(),\n      setMobileLanguageMenuOpen: jest.fn(),\n      setRealAccountSignupEnd: jest.fn(),\n      setPurchaseState: jest.fn(),\n      setAppContentsScrollRef: jest.fn(),\n      shouldNavigateAfterChooseCrypto: jest.fn(),\n      toggleLanguageSettingsModal: jest.fn(),\n      togglePositionsDrawer: jest.fn(),\n      toggleLinkExpiredModal: jest.fn(),\n      toggleServicesErrorModal: jest.fn(),\n      toggleSetCurrencyModal: jest.fn(),\n      addToast: jest.fn(),\n      removeToast: jest.fn(),\n      reports_route_tab_index: 1,\n      resetPurchaseStates: jest.fn(),\n      should_show_cancellation_warning: false,\n      toggleCancellationWarning: jest.fn(),\n      toggleUnsupportedContractModal: jest.fn(),\n      toggleReports: jest.fn(),\n      setSubSectionIndex: jest.fn(),\n      sub_section_index: 0,\n      toggleReadyToDepositModal: jest.fn(),\n      is_ready_to_deposit_modal_visible: false,\n      is_real_acc_signup_on: false,\n      is_need_real_account_for_cashier_modal_visible: false,\n      toggleNeedRealAccountForCashierModal: jest.fn(),\n      is_switch_to_deriv_account_modal_visible: false,\n      openSwitchToRealAccountModal: jest.fn(),\n      is_top_up_virtual_open: false,\n      is_top_up_virtual_in_progress: false,\n      is_top_up_virtual_success: false,\n      closeTopUpModal: jest.fn(),\n      closeSuccessTopUpModal: jest.fn(),\n      is_cfd_reset_password_modal_enabled: false,\n      setCFDPasswordResetModal: jest.fn(),\n      openDerivRealAccountNeededModal: jest.fn(),\n      populateHeaderExtensions: jest.fn(),\n      populateSettingsExtensions: jest.fn(),\n      purchase_states: [],\n      setShouldShowCooldownModal: jest.fn(),\n      populateFooterExtensions: jest.fn(),\n      openAccountNeededModal: jest.fn(),\n      is_accounts_switcher_on: false,\n      openTopUpModal: jest.fn(),\n      toggleShouldShowRealAccountsList: jest.fn(),\n      is_reset_trading_password_modal_visible: false,\n      setResetTradingPasswordModalOpen: jest.fn(),\n      vanilla_trade_type: 'VANILLALONGCALL',\n      is_additional_kyc_info_modal_open: false,\n      toggleAdditionalKycInfoModal: jest.fn(),\n      is_kyc_information_submitted_modal_open: false,\n      toggleKycInformationSubmittedModal: jest.fn()\n    },\n    traders_hub: {\n      getAccount: jest.fn(),\n      closeModal: jest.fn(),\n      combined_cfd_mt5_accounts: [],\n      available_cfd_accounts: [],\n      content_flag: '',\n      CFDs_restricted_countries: false,\n      openModal: jest.fn(),\n      selected_account: {\n        login: '',\n        account_id: ''\n      },\n      is_eu_user: false,\n      is_demo: false,\n      setIsOnboardingVisited: jest.fn(),\n      is_real: false,\n      selectRegion: jest.fn(),\n      setSelectedAccount: jest.fn(),\n      is_low_risk_cr_eu_real: false,\n      is_real_wallets_upgrade_on: false,\n      toggleWalletsUpgrade: jest.fn(),\n      show_eu_related_content: false,\n      platform_real_balance: {\n        currency: '',\n        balance: 0\n      },\n      cfd_demo_balance: {\n        currency: '',\n        balance: 0\n      },\n      platform_demo_balance: {\n        currency: '',\n        balance: 0\n      },\n      cfd_real_balance: {\n        currency: '',\n        balance: 0\n      },\n      closeAccountTransferModal: jest.fn(),\n      toggleRegulatorsCompareModal: jest.fn(),\n      financial_restricted_countries: false,\n      selected_account_type: 'real',\n      no_CR_account: false,\n      no_MF_account: false,\n      modal_data: {\n        active_modal: '',\n        data: {}\n      },\n      multipliers_account_status: '',\n      openFailedVerificationModal: jest.fn(),\n      setTogglePlatformType: jest.fn(),\n      toggleAccountTransferModal: jest.fn(),\n      selectAccountType: jest.fn(),\n      is_wallet_migration_failed: false,\n      setWalletsMigrationFailedPopup: jest.fn(),\n      selected_platform_type: '',\n      available_platforms: [],\n      selected_region: 'All',\n      getExistingAccounts: jest.fn(),\n      available_dxtrade_accounts: [],\n      toggleAccountTypeModalVisibility: jest.fn(),\n      active_modal_tab: 'Deposit',\n      setWalletModalActiveTab: jest.fn(),\n      active_modal_wallet_id: '',\n      setWalletModalActiveWalletID: jest.fn(),\n      available_ctrader_accounts: [],\n      toggleIsTourOpen: jest.fn(),\n      is_demo_low_risk: false,\n      is_mt5_notification_modal_visible: false,\n      setMT5NotificationModal: jest.fn(),\n      available_derivez_accounts: [],\n      has_any_real_account: false,\n      startTrade: jest.fn(),\n      showTopUpModal: jest.fn()\n    },\n    notifications: {\n      addNotificationMessage: jest.fn(),\n      addNotificationMessageByKey: jest.fn(),\n      client_notifications: {},\n      is_notifications_empty: true,\n      is_notifications_visible: false,\n      filterNotificationMessages: jest.fn(),\n      notifications: [],\n      refreshNotifications: jest.fn(),\n      removeAllNotificationMessages: jest.fn(),\n      removeNotifications: jest.fn(),\n      removeNotificationByKey: jest.fn(),\n      removeNotificationMessage: jest.fn(),\n      removeNotificationMessageByKey: jest.fn(),\n      setP2POrderProps: jest.fn(),\n      setP2PRedirectTo: jest.fn(),\n      showAccountSwitchToRealNotification: jest.fn(),\n      setShouldShowPopups: jest.fn(),\n      toggleNotificationsModal: jest.fn()\n    },\n    portfolio: {\n      active_positions: [],\n      active_positions_count: 0,\n      all_positions: [],\n      barriers: [],\n      error: '',\n      getPositionById: jest.fn(),\n      is_loading: false,\n      is_accumulator: false,\n      is_multiplier: false,\n      is_turbos: false,\n      onHoverPosition: jest.fn(),\n      onBuyResponse: jest.fn(),\n      onClickCancel: jest.fn(),\n      onClickSell: jest.fn(),\n      onMount: jest.fn(),\n      open_accu_contract: null,\n      positions: [],\n      removePositionById: jest.fn(),\n      setContractType: jest.fn()\n    },\n    contract_trade: {\n      accountSwitchListener: jest.fn(),\n      accu_barriers_timeout_id: null,\n      accumulator_barriers_data: {},\n      accumulator_contract_barriers_data: {},\n      addContract: jest.fn(),\n      chart_type: '',\n      clearAccumulatorBarriersData: jest.fn(),\n      clearError: jest.fn(),\n      contracts: [],\n      error_message: '',\n      getContractById: jest.fn(),\n      granularity: 0,\n      has_crossed_accu_barriers: false,\n      has_error: false,\n      last_contract: {},\n      markers_array: [],\n      onUnmount: jest.fn(),\n      prev_chart_type: '',\n      prev_granularity: null,\n      removeContract: jest.fn(),\n      savePreviousChartMode: jest.fn(),\n      setNewAccumulatorBarriersData: jest.fn(),\n      updateAccumulatorBarriersData: jest.fn(),\n      updateChartType: jest.fn(),\n      updateGranularity: jest.fn(),\n      updateProposal: jest.fn()\n    },\n    modules: {},\n    exchange_rates: {\n      data: undefined,\n      update: jest.fn(),\n      unmount: jest.fn()\n    },\n    feature_flags: {\n      data: undefined,\n      update: jest.fn(),\n      unmount: jest.fn()\n    },\n    gtm: {\n      is_gtm_applicable: false,\n      visitorId: 'visitorId',\n      common_variables: {\n        language: 'en',\n        theme: 'dark',\n        platform: 'DBot',\n        loggedIn: false\n      },\n      accountSwitcherListener: jest.fn(),\n      pushDataLayer: jest.fn(),\n      pushTransactionData: jest.fn(),\n      eventHandler: jest.fn(),\n      setLoginFlag: jest.fn()\n    },\n    pushwoosh: {},\n    contract_replay: {\n      contract_store: {\n        contract_info: {},\n        digits_info: {},\n        display_status: '',\n        is_digit_contract: false,\n        is_ended: false\n      }\n    },\n    chart_barrier_store: {},\n    active_symbols: {\n      active_symbols: [],\n      setActiveSymbols: jest.fn()\n    }\n  };\n};\nvar mockStore = function mockStore(override) {\n  return merge(mock(), override);\n};\n/* harmony default export */ const src_mockStore = ((/* unused pure expression or super */ null && (mockStore)));\n;// CONCATENATED MODULE: ../../stores/src/storeContext.ts\n\nvar storeContext_StoreContext = /*#__PURE__*/(0,external_react_.createContext)(null);\n/* harmony default export */ const storeContext = (storeContext_StoreContext);\n;// CONCATENATED MODULE: ../../api/src/APIContext.ts\n\n\n// Don't need to type `deriv_api` here, We will be using these methods inside\n// the `useQuery`, `useMutation` and `useSubscription` hook to make it type-safe.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvar APIContext_APIContext = /*#__PURE__*/(0,external_react_.createContext)(null);\n/* harmony default export */ const src_APIContext = (APIContext_APIContext);\n;// CONCATENATED MODULE: ../../api/src/useAPI.ts\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { useAPI_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useAPI_defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\nvar useAPI_useAPI = function useAPI() {\n  var api = (0,external_react_.useContext)(src_APIContext);\n  var send = (0,external_react_.useCallback)( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(name, payload) {\n      var response;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return api === null || api === void 0 ? void 0 : api.send(_objectSpread(useAPI_defineProperty({}, name, 1), payload || {}));\n            case 2:\n              response = _context.sent;\n              if (!response.error) {\n                _context.next = 5;\n                break;\n              }\n              throw response.error;\n            case 5:\n              return _context.abrupt(\"return\", response);\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }(), [api]);\n  var subscribe = (0,external_react_.useCallback)(function (name, payload) {\n    var _objectSpread3;\n    return api === null || api === void 0 ? void 0 : api.subscribe(_objectSpread((_objectSpread3 = {}, useAPI_defineProperty(_objectSpread3, name, 1), useAPI_defineProperty(_objectSpread3, \"subscribe\", 1), _objectSpread3), payload || {}));\n  }, [api]);\n  return {\n    send: send,\n    subscribe: subscribe\n  };\n};\n/* harmony default export */ const src_useAPI = (useAPI_useAPI);\n;// CONCATENATED MODULE: ../../api/src/useInfiniteQuery.ts\nfunction useInfiniteQuery_typeof(obj) { \"@babel/helpers - typeof\"; return useInfiniteQuery_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useInfiniteQuery_typeof(obj); }\nfunction useInfiniteQuery_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useInfiniteQuery_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useInfiniteQuery_ownKeys(Object(source), !0).forEach(function (key) { useInfiniteQuery_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useInfiniteQuery_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useInfiniteQuery_defineProperty(obj, key, value) { key = useInfiniteQuery_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useInfiniteQuery_toPropertyKey(arg) { var key = useInfiniteQuery_toPrimitive(arg, \"string\"); return useInfiniteQuery_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useInfiniteQuery_toPrimitive(input, hint) { if (useInfiniteQuery_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useInfiniteQuery_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\nvar useInfiniteQuery_useInfiniteQuery = function useInfiniteQuery(name) {\n  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    props[_key - 1] = arguments[_key];\n  }\n  var prop = props === null || props === void 0 ? void 0 : props[0];\n  var payload = prop && 'payload' in prop ? prop.payload : undefined;\n  var options = prop && 'options' in prop ? prop.options : undefined;\n  var _useAPI = useAPI(),\n    send = _useAPI.send;\n  var initial_offset = (payload === null || payload === void 0 ? void 0 : payload.offset) || 0;\n  var limit = (payload === null || payload === void 0 ? void 0 : payload.limit) || 50;\n  return _useInfiniteQuery(getQueryKeys(name, payload), function (_ref) {\n    var _ref$pageParam = _ref.pageParam,\n      pageParam = _ref$pageParam === void 0 ? 0 : _ref$pageParam;\n    return send(name, useInfiniteQuery_objectSpread(useInfiniteQuery_objectSpread({}, payload), {}, {\n      limit: limit,\n      offset: pageParam * limit + initial_offset\n    }));\n  }, useInfiniteQuery_objectSpread(useInfiniteQuery_objectSpread({}, options), {}, {\n    getNextPageParam: options !== null && options !== void 0 && options.getNextPageParam ? options.getNextPageParam : function (_lastPage, pages) {\n      return pages.length;\n    }\n  }));\n};\n/* harmony default export */ const src_useInfiniteQuery = ((/* unused pure expression or super */ null && (useInfiniteQuery_useInfiniteQuery)));\n;// CONCATENATED MODULE: ../../api/src/useMutation.ts\nfunction useMutation_typeof(obj) { \"@babel/helpers - typeof\"; return useMutation_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useMutation_typeof(obj); }\nvar _excluded = (/* unused pure expression or super */ null && ([\"mutate\"]));\nfunction useMutation_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useMutation_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useMutation_ownKeys(Object(source), !0).forEach(function (key) { useMutation_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useMutation_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useMutation_defineProperty(obj, key, value) { key = useMutation_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useMutation_toPropertyKey(arg) { var key = useMutation_toPrimitive(arg, \"string\"); return useMutation_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useMutation_toPrimitive(input, hint) { if (useMutation_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useMutation_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useMutation_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useMutation_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\nvar useMutation_useMutation = function useMutation(name, options) {\n  var _useAPI = useAPI(),\n    send = _useAPI.send;\n  var _useMutation2 = _useMutation(function (props) {\n      var prop = props === null || props === void 0 ? void 0 : props[0];\n      var payload = prop && 'payload' in prop ? prop.payload : undefined;\n      return send(name, payload);\n    }, options),\n    _mutate = _useMutation2.mutate,\n    rest = _objectWithoutProperties(_useMutation2, _excluded);\n  var mutate = useCallback(function () {\n    for (var _len = arguments.length, payload = new Array(_len), _key = 0; _key < _len; _key++) {\n      payload[_key] = arguments[_key];\n    }\n    return _mutate(payload);\n  }, [_mutate]);\n  return useMutation_objectSpread({\n    mutate: mutate\n  }, rest);\n};\n/* harmony default export */ const src_useMutation = ((/* unused pure expression or super */ null && (useMutation_useMutation)));\n;// CONCATENATED MODULE: ../../../node_modules/@tanstack/query-core/build/lib/utils.mjs\n// TYPES\n// UTILS\nconst isServer = typeof window === 'undefined' || 'Deno' in window;\nfunction noop() {\n  return undefined;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === 'number' && value >= 0 && value !== Infinity;\n}\nfunction difference(array1, array2) {\n  return array1.filter(x => !array2.includes(x));\n}\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3,\n      queryKey: arg1,\n      queryFn: arg2\n    };\n  }\n\n  return { ...arg2,\n    queryKey: arg1\n  };\n}\nfunction parseMutationArgs(arg1, arg2, arg3) {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3,\n        mutationKey: arg1,\n        mutationFn: arg2\n      };\n    }\n\n    return { ...arg2,\n      mutationKey: arg1\n    };\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2,\n      mutationFn: arg1\n    };\n  }\n\n  return { ...arg1\n  };\n}\nfunction parseFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    queryKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction parseMutationFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    mutationKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive();\n\n    if (type === 'active' && !isActive) {\n      return false;\n    }\n\n    if (type === 'inactive' && isActive) {\n      return false;\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false;\n  }\n\n  if (typeof fetchStatus !== 'undefined' && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const {\n    exact,\n    fetching,\n    predicate,\n    mutationKey\n  } = filters;\n\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n\n    if (exact) {\n      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n\n  if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {\n    return false;\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;\n  return hashFn(queryKey);\n}\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\n\nfunction hashQueryKey(queryKey) {\n  return JSON.stringify(queryKey, (_, val) => utils_isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : val);\n}\n/**\n * Checks if key `b` partially matches with key `a`.\n */\n\nfunction partialMatchKey(a, b) {\n  return partialDeepEqual(a, b);\n}\n/**\n * Checks if `b` partially matches with `a`.\n */\n\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n\n  return false;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b);\n\n  if (array || utils_isPlainObject(a) && utils_isPlainObject(b)) {\n    const aSize = array ? a.length : Object.keys(a).length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n\n  return b;\n}\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\n\nfunction shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\nfunction utils_isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n\n  const ctor = o.constructor;\n\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n\n  const prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isQueryKey(value) {\n  return Array.isArray(value);\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\nfunction sleep(timeout) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout);\n  });\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\nfunction scheduleMicrotask(callback) {\n  sleep(0).then(callback);\n}\nfunction getAbortController() {\n  if (typeof AbortController === 'function') {\n    return new AbortController();\n  }\n\n  return;\n}\nfunction replaceData(prevData, data, options) {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {\n    return prevData;\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data);\n  }\n\n  return data;\n}\n\n\n//# sourceMappingURL=utils.mjs.map\n\n;// CONCATENATED MODULE: ../../../node_modules/@tanstack/query-core/build/lib/notifyManager.mjs\n\n\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n\n  let notifyFn = callback => {\n    callback();\n  };\n\n  let batchNotifyFn = callback => {\n    callback();\n  };\n\n  const batch = callback => {\n    let result;\n    transactions++;\n\n    try {\n      result = callback();\n    } finally {\n      transactions--;\n\n      if (!transactions) {\n        flush();\n      }\n    }\n\n    return result;\n  };\n\n  const schedule = callback => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n\n\n  const batchCalls = callback => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args);\n      });\n    };\n  };\n\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach(callback => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n\n\n  const setNotifyFunction = fn => {\n    notifyFn = fn;\n  };\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n\n\n  const setBatchNotifyFunction = fn => {\n    batchNotifyFn = fn;\n  };\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction\n  };\n} // SINGLETON\n\nconst notifyManager = createNotifyManager();\n\n\n//# sourceMappingURL=notifyManager.mjs.map\n\n;// CONCATENATED MODULE: ../../../node_modules/@tanstack/query-core/build/lib/subscribable.mjs\nclass Subscribable {\n  constructor() {\n    this.listeners = new Set();\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  subscribe(listener) {\n    const identity = {\n      listener\n    };\n    this.listeners.add(identity);\n    this.onSubscribe();\n    return () => {\n      this.listeners.delete(identity);\n      this.onUnsubscribe();\n    };\n  }\n\n  hasListeners() {\n    return this.listeners.size > 0;\n  }\n\n  onSubscribe() {// Do nothing\n  }\n\n  onUnsubscribe() {// Do nothing\n  }\n\n}\n\n\n//# sourceMappingURL=subscribable.mjs.map\n\n;// CONCATENATED MODULE: ../../../node_modules/@tanstack/query-core/build/lib/focusManager.mjs\n\n\n\nclass FocusManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onFocus => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus(); // Listen to visibillitychange and focus\n\n\n        window.addEventListener('visibilitychange', listener, false);\n        window.addEventListener('focus', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener);\n          window.removeEventListener('focus', listener);\n        };\n      }\n\n      return;\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(focused => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n\n  setFocused(focused) {\n    const changed = this.focused !== focused;\n\n    if (changed) {\n      this.focused = focused;\n      this.onFocus();\n    }\n  }\n\n  onFocus() {\n    this.listeners.forEach(({\n      listener\n    }) => {\n      listener();\n    });\n  }\n\n  isFocused() {\n    if (typeof this.focused === 'boolean') {\n      return this.focused;\n    } // document global can be unavailable in react native\n\n\n    if (typeof document === 'undefined') {\n      return true;\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(document.visibilityState);\n  }\n\n}\nconst focusManager = new FocusManager();\n\n\n//# sourceMappingURL=focusManager.mjs.map\n\n;// CONCATENATED MODULE: ../../../node_modules/@tanstack/query-core/build/lib/onlineManager.mjs\n\n\n\nconst onlineEvents = ['online', 'offline'];\nclass OnlineManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onOnline => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline(); // Listen to online\n\n\n        onlineEvents.forEach(event => {\n          window.addEventListener(event, listener, false);\n        });\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          onlineEvents.forEach(event => {\n            window.removeEventListener(event, listener);\n          });\n        };\n      }\n\n      return;\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(online => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online);\n      } else {\n        this.onOnline();\n      }\n    });\n  }\n\n  setOnline(online) {\n    const changed = this.online !== online;\n\n    if (changed) {\n      this.online = online;\n      this.onOnline();\n    }\n  }\n\n  onOnline() {\n    this.listeners.forEach(({\n      listener\n    }) => {\n      listener();\n    });\n  }\n\n  isOnline() {\n    if (typeof this.online === 'boolean') {\n      return this.online;\n    }\n\n    if (typeof navigator === 'undefined' || typeof navigator.onLine === 'undefined') {\n      return true;\n    }\n\n    return navigator.onLine;\n  }\n\n}\nconst onlineManager = new OnlineManager();\n\n\n//# sourceMappingURL=onlineManager.mjs.map\n\n;// CONCATENATED MODULE: ../../../node_modules/@tanstack/query-core/build/lib/retryer.mjs\n\n\n\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * 2 ** failureCount, 30000);\n}\n\nfunction canFetch(networkMode) {\n  return (networkMode != null ? networkMode : 'online') === 'online' ? onlineManager.isOnline() : true;\n}\nclass CancelledError {\n  constructor(options) {\n    this.revert = options == null ? void 0 : options.revert;\n    this.silent = options == null ? void 0 : options.silent;\n  }\n\n}\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort == null ? void 0 : config.abort();\n    }\n  };\n\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n\n  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();\n\n  const resolve = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  const reject = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  const pause = () => {\n    return new Promise(continueResolve => {\n      continueFn = value => {\n        const canContinue = isResolved || !shouldPause();\n\n        if (canContinue) {\n          continueResolve(value);\n        }\n\n        return canContinue;\n      };\n\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(() => {\n      continueFn = undefined;\n\n      if (!isResolved) {\n        config.onContinue == null ? void 0 : config.onContinue();\n      }\n    });\n  }; // Create loop function\n\n\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return;\n    }\n\n    let promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      const retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      const delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n      if (isRetryCancelled || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(() => {\n        if (shouldPause()) {\n          return pause();\n        }\n\n        return;\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      const didContinue = continueFn == null ? void 0 : continueFn();\n      return didContinue ? promise : Promise.resolve();\n    },\n    cancelRetry,\n    continueRetry\n  };\n}\n\n\n//# sourceMappingURL=retryer.mjs.map\n\n;// CONCATENATED MODULE: ../../../node_modules/@tanstack/query-core/build/lib/queryObserver.mjs\n\n\n\n\n\n\nclass QueryObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.options = options;\n    this.trackedProps = new Set();\n    this.selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n\n  bindMethods() {\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n  }\n\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.currentQuery.addObserver(this);\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch();\n      }\n\n      this.updateTimers();\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);\n  }\n\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\n  }\n\n  destroy() {\n    this.listeners = new Set();\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n    this.currentQuery.removeObserver(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.currentQuery;\n    this.options = this.client.defaultQueryOptions(options);\n\n    if (false) {}\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.currentQuery,\n        observer: this\n      });\n    }\n\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n      throw new Error('Expected enabled to be a boolean');\n    } // Keep previous query key if the user does not supply one\n\n\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n\n    this.updateQuery();\n    const mounted = this.hasListeners(); // Fetch if there are subscribers\n\n    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {\n      this.executeFetch();\n    } // Update result\n\n\n    this.updateResult(notifyOptions); // Update stale interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n      this.updateStaleTimeout();\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval(); // Update refetch interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {\n      this.updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n\n  getOptimisticResult(options) {\n    const query = this.client.getQueryCache().build(this.client, options);\n    const result = this.createResult(query, options);\n\n    if (shouldAssignObserverCurrentProperties(this, result, options)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult everytime\n      // an observer reads an optimistic value.\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.currentResult = result;\n      this.currentResultOptions = this.options;\n      this.currentResultState = this.currentQuery.state;\n    }\n\n    return result;\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  trackResult(result) {\n    const trackedResult = {};\n    Object.keys(result).forEach(key => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n\n  getCurrentQuery() {\n    return this.currentQuery;\n  }\n\n  remove() {\n    this.client.getQueryCache().remove(this.currentQuery);\n  }\n\n  refetch({\n    refetchPage,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        refetchPage\n      }\n    });\n  }\n\n  fetchOptimistic(options) {\n    const defaultedOptions = this.client.defaultQueryOptions(options);\n    const query = this.client.getQueryCache().build(this.client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n\n  fetch(fetchOptions) {\n    var _fetchOptions$cancelR;\n\n    return this.executeFetch({ ...fetchOptions,\n      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true\n    }).then(() => {\n      this.updateResult();\n      return this.currentResult;\n    });\n  }\n\n  executeFetch(fetchOptions) {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery(); // Fetch\n\n    let promise = this.currentQuery.fetch(this.options, fetchOptions);\n\n    if (!(fetchOptions != null && fetchOptions.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  updateStaleTimeout() {\n    this.clearStaleTimeout();\n\n    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n\n    const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n\n    const timeout = time + 1;\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n\n  computeRefetchInterval() {\n    var _this$options$refetch;\n\n    return typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;\n  }\n\n  updateRefetchInterval(nextInterval) {\n    this.clearRefetchInterval();\n    this.currentRefetchInterval = nextInterval;\n\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.executeFetch();\n      }\n    }, this.currentRefetchInterval);\n  }\n\n  updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval(this.computeRefetchInterval());\n  }\n\n  clearStaleTimeout() {\n    if (this.staleTimeoutId) {\n      clearTimeout(this.staleTimeoutId);\n      this.staleTimeoutId = undefined;\n    }\n  }\n\n  clearRefetchInterval() {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId);\n      this.refetchIntervalId = undefined;\n    }\n  }\n\n  createResult(query, options) {\n    const prevQuery = this.currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.currentResult;\n    const prevResultState = this.currentResultState;\n    const prevResultOptions = this.currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;\n    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;\n    const {\n      state\n    } = query;\n    let {\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      fetchStatus,\n      status\n    } = state;\n    let isPreviousData = false;\n    let isPlaceholderData = false;\n    let data; // Optimistically set result in fetching state if needed\n\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode) ? 'fetching' : 'paused';\n\n        if (!dataUpdatedAt) {\n          status = 'loading';\n        }\n      }\n\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle';\n      }\n    } // Keep previous data if needed\n\n\n    if (options.keepPreviousData && !state.dataUpdatedAt && prevQueryResult != null && prevQueryResult.isSuccess && status !== 'error') {\n      data = prevQueryResult.data;\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt;\n      status = prevQueryResult.status;\n      isPreviousData = true;\n    } // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {\n        data = this.selectResult;\n      } else {\n        try {\n          this.selectFn = options.select;\n          data = options.select(state.data);\n          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);\n          this.selectResult = data;\n          this.selectError = null;\n        } catch (selectError) {\n          if (false) {}\n\n          this.selectError = selectError;\n        }\n      }\n    } // Use query data\n    else {\n      data = state.data;\n    } // Show placeholder data if needed\n\n\n    if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'loading') {\n      let placeholderData; // Memoize placeholder data\n\n      if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData() : options.placeholderData;\n\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData);\n            this.selectError = null;\n          } catch (selectError) {\n            if (false) {}\n\n            this.selectError = selectError;\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success';\n        data = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);\n        isPlaceholderData = true;\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError;\n      data = this.selectResult;\n      errorUpdatedAt = Date.now();\n      status = 'error';\n    }\n\n    const isFetching = fetchStatus === 'fetching';\n    const isLoading = status === 'loading';\n    const isError = status === 'error';\n    const result = {\n      status,\n      fetchStatus,\n      isLoading,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading && isFetching,\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isLoading,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove\n    };\n    return result;\n  }\n\n  updateResult(notifyOptions) {\n    const prevResult = this.currentResult;\n    const nextResult = this.createResult(this.currentQuery, this.options);\n    this.currentResultState = this.currentQuery.state;\n    this.currentResultOptions = this.options; // Only notify and update result if something has changed\n\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n\n    this.currentResult = nextResult; // Determine which callbacks to trigger\n\n    const defaultNotifyOptions = {\n      cache: true\n    };\n\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n\n      const {\n        notifyOnChangeProps\n      } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === 'function' ? notifyOnChangeProps() : notifyOnChangeProps;\n\n      if (notifyOnChangePropsValue === 'all' || !notifyOnChangePropsValue && !this.trackedProps.size) {\n        return true;\n      }\n\n      const includedProps = new Set(notifyOnChangePropsValue != null ? notifyOnChangePropsValue : this.trackedProps);\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error');\n      }\n\n      return Object.keys(this.currentResult).some(key => {\n        const typedKey = key;\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n\n    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n\n    this.notify({ ...defaultNotifyOptions,\n      ...notifyOptions\n    });\n  }\n\n  updateQuery() {\n    const query = this.client.getQueryCache().build(this.client, this.options);\n\n    if (query === this.currentQuery) {\n      return;\n    }\n\n    const prevQuery = this.currentQuery;\n    this.currentQuery = query;\n    this.currentQueryInitialState = query.state;\n    this.previousQueryResult = this.currentResult;\n\n    if (this.hasListeners()) {\n      prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n\n  onQueryUpdate(action) {\n    const notifyOptions = {};\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual;\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true;\n    }\n\n    this.updateResult(notifyOptions);\n\n    if (this.hasListeners()) {\n      this.updateTimers();\n    }\n  }\n\n  notify(notifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;\n\n        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);\n        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);\n      } else if (notifyOptions.onError) {\n        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;\n\n        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);\n        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, undefined, this.currentResult.error);\n      } // Then trigger the listeners\n\n\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(({\n          listener\n        }) => {\n          listener(this.currentResult);\n        });\n      } // Then the cache listeners\n\n\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated'\n        });\n      }\n    });\n  }\n\n}\n\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);\n}\n\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\n\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field;\n    return value === 'always' || value !== false && isStale(query, options);\n  }\n\n  return false;\n}\n\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);\n}\n\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n} // this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\n\n\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult, options) {\n  // it is important to keep this condition like this for three reasons:\n  // 1. It will get removed in the v5\n  // 2. it reads: don't update the properties if we want to keep the previous\n  // data.\n  // 3. The opposite condition (!options.keepPreviousData) would fallthrough\n  // and will result in a bad decision\n  if (options.keepPreviousData) {\n    return false;\n  } // this means we want to put some placeholder data when pending and queryKey\n  // changed.\n\n\n  if (options.placeholderData !== undefined) {\n    // re-assign properties only if current data is placeholder data\n    // which means that data did not arrive yet, so, if there is some cached data\n    // we need to \"prepare\" to receive it\n    return optimisticResult.isPlaceholderData;\n  } // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n\n\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  } // basically, just keep previous properties if nothing changed\n\n\n  return false;\n}\n\n\n//# sourceMappingURL=queryObserver.mjs.map\n\n// EXTERNAL MODULE: ../../../node_modules/use-sync-external-store/shim/index.js\nvar shim = __webpack_require__(\"../../../node_modules/use-sync-external-store/shim/index.js\");\n;// CONCATENATED MODULE: ../../../node_modules/@tanstack/react-query/build/lib/useSyncExternalStore.mjs\n'use client';\n\n\nconst useSyncExternalStore = shim.useSyncExternalStore;\n\n\n//# sourceMappingURL=useSyncExternalStore.mjs.map\n\n;// CONCATENATED MODULE: ../../../node_modules/@tanstack/react-query/build/lib/QueryErrorResetBoundary.mjs\n'use client';\n\n\nfunction createValue() {\n  let isReset = false;\n  return {\n    clearReset: () => {\n      isReset = false;\n    },\n    reset: () => {\n      isReset = true;\n    },\n    isReset: () => {\n      return isReset;\n    }\n  };\n}\n\nconst QueryErrorResetBoundaryContext = /*#__PURE__*/external_react_.createContext(createValue()); // HOOK\n\nconst useQueryErrorResetBoundary = () => external_react_.useContext(QueryErrorResetBoundaryContext); // COMPONENT\n\nconst QueryErrorResetBoundary = ({\n  children\n}) => {\n  const [value] = React.useState(() => createValue());\n  return /*#__PURE__*/React.createElement(QueryErrorResetBoundaryContext.Provider, {\n    value: value\n  }, typeof children === 'function' ? children(value) : children);\n};\n\n\n//# sourceMappingURL=QueryErrorResetBoundary.mjs.map\n\n;// CONCATENATED MODULE: ../../../node_modules/@tanstack/react-query/build/lib/QueryClientProvider.mjs\n'use client';\n\n\nconst defaultContext = /*#__PURE__*/external_react_.createContext(undefined);\nconst QueryClientSharingContext = /*#__PURE__*/external_react_.createContext(false); // If we are given a context, we will use it.\n// Otherwise, if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\n\nfunction getQueryClientContext(context, contextSharing) {\n  if (context) {\n    return context;\n  }\n\n  if (contextSharing && typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext;\n    }\n\n    return window.ReactQueryClientContext;\n  }\n\n  return defaultContext;\n}\n\nconst QueryClientProvider_useQueryClient = ({\n  context\n} = {}) => {\n  const queryClient = external_react_.useContext(getQueryClientContext(context, external_react_.useContext(QueryClientSharingContext)));\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one');\n  }\n\n  return queryClient;\n};\nconst QueryClientProvider_QueryClientProvider = ({\n  client,\n  children,\n  context,\n  contextSharing = false\n}) => {\n  React.useEffect(() => {\n    client.mount();\n    return () => {\n      client.unmount();\n    };\n  }, [client]);\n\n  if (false) {}\n\n  const Context = getQueryClientContext(context, contextSharing);\n  return /*#__PURE__*/React.createElement(QueryClientSharingContext.Provider, {\n    value: !context && contextSharing\n  }, /*#__PURE__*/React.createElement(Context.Provider, {\n    value: client\n  }, children));\n};\n\n\n//# sourceMappingURL=QueryClientProvider.mjs.map\n\n;// CONCATENATED MODULE: ../../../node_modules/@tanstack/react-query/build/lib/isRestoring.mjs\n'use client';\n\n\nconst IsRestoringContext = /*#__PURE__*/external_react_.createContext(false);\nconst useIsRestoring = () => external_react_.useContext(IsRestoringContext);\nconst IsRestoringProvider = IsRestoringContext.Provider;\n\n\n//# sourceMappingURL=isRestoring.mjs.map\n\n;// CONCATENATED MODULE: ../../../node_modules/@tanstack/react-query/build/lib/utils.mjs\nfunction shouldThrowError(_useErrorBoundary, params) {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary(...params);\n  }\n\n  return !!_useErrorBoundary;\n}\n\n\n//# sourceMappingURL=utils.mjs.map\n\n;// CONCATENATED MODULE: ../../../node_modules/@tanstack/react-query/build/lib/errorBoundaryUtils.mjs\n'use client';\n\n\n\nconst ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {\n  if (options.suspense || options.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false;\n    }\n  }\n};\nconst useClearResetErrorBoundary = errorResetBoundary => {\n  external_react_.useEffect(() => {\n    errorResetBoundary.clearReset();\n  }, [errorResetBoundary]);\n};\nconst getHasError = ({\n  result,\n  errorResetBoundary,\n  useErrorBoundary,\n  query\n}) => {\n  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && shouldThrowError(useErrorBoundary, [result.error, query]);\n};\n\n\n//# sourceMappingURL=errorBoundaryUtils.mjs.map\n\n;// CONCATENATED MODULE: ../../../node_modules/@tanstack/react-query/build/lib/suspense.mjs\nconst ensureStaleTime = defaultedOptions => {\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000;\n    }\n  }\n};\nconst willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;\nconst shouldSuspend = (defaultedOptions, result, isRestoring) => (defaultedOptions == null ? void 0 : defaultedOptions.suspense) && willFetch(result, isRestoring);\nconst fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).then(({\n  data\n}) => {\n  defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);\n  defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);\n}).catch(error => {\n  errorResetBoundary.clearReset();\n  defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);\n  defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(undefined, error);\n});\n\n\n//# sourceMappingURL=suspense.mjs.map\n\n;// CONCATENATED MODULE: ../../../node_modules/@tanstack/react-query/build/lib/useBaseQuery.mjs\n'use client';\n\n\n\n\n\n\n\n\n\nfunction useBaseQuery(options, Observer) {\n  const queryClient = QueryClientProvider_useQueryClient({\n    context: options.context\n  });\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const defaultedOptions = queryClient.defaultQueryOptions(options); // Make sure results are optimistically set in fetching state before subscribing or updating options\n\n  defaultedOptions._optimisticResults = isRestoring ? 'isRestoring' : 'optimistic'; // Include callbacks in batch renders\n\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);\n  }\n\n  ensureStaleTime(defaultedOptions);\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);\n  useClearResetErrorBoundary(errorResetBoundary);\n  const [observer] = external_react_.useState(() => new Observer(queryClient, defaultedOptions));\n  const result = observer.getOptimisticResult(defaultedOptions);\n  useSyncExternalStore(external_react_.useCallback(onStoreChange => {\n    const unsubscribe = isRestoring ? () => undefined : observer.subscribe(notifyManager.batchCalls(onStoreChange)); // Update result to make sure we did not miss any query updates\n    // between creating the observer and subscribing to it.\n\n    observer.updateResult();\n    return unsubscribe;\n  }, [observer, isRestoring]), () => observer.getCurrentResult(), () => observer.getCurrentResult());\n  external_react_.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, {\n      listeners: false\n    });\n  }, [defaultedOptions, observer]); // Handle suspense\n\n  if (shouldSuspend(defaultedOptions, result, isRestoring)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);\n  } // Handle error boundary\n\n\n  if (getHasError({\n    result,\n    errorResetBoundary,\n    useErrorBoundary: defaultedOptions.useErrorBoundary,\n    query: observer.getCurrentQuery()\n  })) {\n    throw result.error;\n  } // Handle result property usage tracking\n\n\n  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;\n}\n\n\n//# sourceMappingURL=useBaseQuery.mjs.map\n\n;// CONCATENATED MODULE: ../../../node_modules/@tanstack/react-query/build/lib/useQuery.mjs\n'use client';\n\n\n\nfunction useQuery_useQuery(arg1, arg2, arg3) {\n  const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n  return useBaseQuery(parsedOptions, QueryObserver);\n}\n\n\n//# sourceMappingURL=useQuery.mjs.map\n\n;// CONCATENATED MODULE: ../../api/src/utils/query-utils.ts\nvar query_utils_getQueryKeys = function getQueryKeys(name, props) {\n  if (!props) return [name];\n  delete props.req_id;\n  if (name && props[name] === 1) delete props[name];\n  if (Object.keys(props).length === 0) return [name];\n  var ordered_props = Object.keys(props).sort(function (a, b) {\n    return a.localeCompare(b);\n  }).reduce(function (obj, key) {\n    obj[key] = props[key];\n    return obj;\n  }, {});\n  var query_props = JSON.stringify(ordered_props);\n  return [name, query_props];\n};\n;// CONCATENATED MODULE: ../../api/src/useQuery.ts\n\n\n\nvar src_useQuery_useQuery = function useQuery(name) {\n  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    props[_key - 1] = arguments[_key];\n  }\n  var prop = props === null || props === void 0 ? void 0 : props[0];\n  var payload = prop && 'payload' in prop ? prop.payload : undefined;\n  var options = prop && 'options' in prop ? prop.options : undefined;\n  var _useAPI = src_useAPI(),\n    send = _useAPI.send;\n  return useQuery_useQuery(query_utils_getQueryKeys(name, payload), function () {\n    return send(name, payload);\n  }, options);\n};\n/* harmony default export */ const src_useQuery = (src_useQuery_useQuery);\n// EXTERNAL MODULE: ../../../node_modules/@deriv/deriv-api/dist/DerivAPIBasic.js\nvar dist_DerivAPIBasic = __webpack_require__(\"../../../node_modules/@deriv/deriv-api/dist/DerivAPIBasic.js\");\n// EXTERNAL MODULE: external \"@deriv/shared\"\nvar shared_ = __webpack_require__(\"@deriv/shared\");\n;// CONCATENATED MODULE: ../../../node_modules/@tanstack/query-core/build/lib/logger.mjs\nconst defaultLogger = console;\n\n\n//# sourceMappingURL=logger.mjs.map\n\n;// CONCATENATED MODULE: ../../../node_modules/@tanstack/query-core/build/lib/removable.mjs\n\n\nclass Removable {\n  destroy() {\n    this.clearGcTimeout();\n  }\n\n  scheduleGc() {\n    this.clearGcTimeout();\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.cacheTime);\n    }\n  }\n\n  updateCacheTime(newCacheTime) {\n    // Default to 5 minutes (Infinity for server-side) if no cache time is set\n    this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1000);\n  }\n\n  clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout);\n      this.gcTimeout = undefined;\n    }\n  }\n\n}\n\n\n//# sourceMappingURL=removable.mjs.map\n\n;// CONCATENATED MODULE: ../../../node_modules/@tanstack/query-core/build/lib/query.mjs\n\n\n\n\n\n\n// CLASS\nclass Query extends Removable {\n  constructor(config) {\n    super();\n    this.abortSignalConsumed = false;\n    this.defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.cache = config.cache;\n    this.logger = config.logger || defaultLogger;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.initialState = config.state || getDefaultState(this.options);\n    this.state = this.initialState;\n    this.scheduleGc();\n  }\n\n  get meta() {\n    return this.options.meta;\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this);\n    }\n  }\n\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options); // Set data and mark it as cached\n\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options == null ? void 0 : options.updatedAt,\n      manual: options == null ? void 0 : options.manual\n    });\n    return data;\n  }\n\n  setState(state, setStateOptions) {\n    this.dispatch({\n      type: 'setState',\n      state,\n      setStateOptions\n    });\n  }\n\n  cancel(options) {\n    var _this$retryer;\n\n    const promise = this.promise;\n    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n\n  reset() {\n    this.destroy();\n    this.setState(this.initialState);\n  }\n\n  isActive() {\n    return this.observers.some(observer => observer.options.enabled !== false);\n  }\n\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n\n  isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(observer => observer.getCurrentResult().isStale);\n  }\n\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n\n  onFocus() {\n    var _this$retryer2;\n\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n  }\n\n  onOnline() {\n    var _this$retryer3;\n\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n  }\n\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer); // Stop the query from being garbage collected\n\n      this.clearGcTimeout();\n      this.cache.notify({\n        type: 'observerAdded',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter(x => x !== observer);\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.retryer.cancelRetry();\n          }\n        }\n\n        this.scheduleGc();\n      }\n\n      this.cache.notify({\n        type: 'observerRemoved',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  getObserversCount() {\n    return this.observers.length;\n  }\n\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: 'invalidate'\n      });\n    }\n  }\n\n  fetch(options, fetchOptions) {\n    var _this$options$behavio, _context$fetchOptions;\n\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({\n          silent: true\n        });\n      } else if (this.promise) {\n        var _this$retryer4;\n\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching\n\n        return this.promise;\n      }\n    } // Update config if passed, otherwise the config from the last execution is used\n\n\n    if (options) {\n      this.setOptions(options);\n    } // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n\n\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn);\n\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n\n    if (false) {}\n\n    const abortController = getAbortController(); // Create query function context\n\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta\n    }; // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n\n    const addSignalProperty = object => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true;\n            return abortController.signal;\n          }\n\n          return undefined;\n        }\n      });\n    };\n\n    addSignalProperty(queryFnContext); // Create fetch function\n\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject(\"Missing queryFn for queryKey '\" + this.options.queryHash + \"'\");\n      }\n\n      this.abortSignalConsumed = false;\n      return this.options.queryFn(queryFnContext);\n    }; // Trigger behavior hook\n\n\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn\n    };\n    addSignalProperty(context);\n    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted\n\n    this.revertState = this.state; // Set to fetching state if not already in it\n\n    if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n\n      this.dispatch({\n        type: 'fetch',\n        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n      });\n    }\n\n    const onError = error => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n\n      if (!isCancelledError(error)) {\n        var _this$cache$config$on, _this$cache$config, _this$cache$config$on2, _this$cache$config2;\n\n        // Notify cache callback\n        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);\n        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, this.state.data, error, this);\n\n        if (false) {}\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc();\n      }\n\n      this.isFetchingOptimistic = false;\n    }; // Try to fetch the data\n\n\n    this.retryer = createRetryer({\n      fn: context.fetchFn,\n      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),\n      onSuccess: data => {\n        var _this$cache$config$on3, _this$cache$config3, _this$cache$config$on4, _this$cache$config4;\n\n        if (typeof data === 'undefined') {\n          if (false) {}\n\n          onError(new Error(this.queryHash + \" data is undefined\"));\n          return;\n        }\n\n        this.setData(data); // Notify cache callback\n\n        (_this$cache$config$on3 = (_this$cache$config3 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on3.call(_this$cache$config3, data, this);\n        (_this$cache$config$on4 = (_this$cache$config4 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on4.call(_this$cache$config4, data, this.state.error, this);\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc();\n        }\n\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.dispatch({\n          type: 'failed',\n          failureCount,\n          error\n        });\n      },\n      onPause: () => {\n        this.dispatch({\n          type: 'pause'\n        });\n      },\n      onContinue: () => {\n        this.dispatch({\n          type: 'continue'\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode\n    });\n    this.promise = this.retryer.promise;\n    return this.promise;\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      var _action$meta, _action$dataUpdatedAt;\n\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n\n        case 'pause':\n          return { ...state,\n            fetchStatus: 'paused'\n          };\n\n        case 'continue':\n          return { ...state,\n            fetchStatus: 'fetching'\n          };\n\n        case 'fetch':\n          return { ...state,\n            fetchFailureCount: 0,\n            fetchFailureReason: null,\n            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n            fetchStatus: canFetch(this.options.networkMode) ? 'fetching' : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading'\n            })\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            })\n          };\n\n        case 'error':\n          const error = action.error;\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState,\n              fetchStatus: 'idle'\n            };\n          }\n\n          return { ...state,\n            error: error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error'\n          };\n\n        case 'invalidate':\n          return { ...state,\n            isInvalidated: true\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action);\n      });\n      this.cache.notify({\n        query: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\n\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n  const hasData = typeof data !== 'undefined';\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle'\n  };\n}\n\n\n//# sourceMappingURL=query.mjs.map\n\n;// CONCATENATED MODULE: ../../../node_modules/@tanstack/query-core/build/lib/queryCache.mjs\n\n\n\n\n\n// CLASS\nclass QueryCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.queries = [];\n    this.queriesMap = {};\n  }\n\n  build(client, options, state) {\n    var _options$queryHash;\n\n    const queryKey = options.queryKey;\n    const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);\n    let query = this.get(queryHash);\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        logger: client.getLogger(),\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey)\n      });\n      this.add(query);\n    }\n\n    return query;\n  }\n\n  add(query) {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query;\n      this.queries.push(query);\n      this.notify({\n        type: 'added',\n        query\n      });\n    }\n  }\n\n  remove(query) {\n    const queryInMap = this.queriesMap[query.queryHash];\n\n    if (queryInMap) {\n      query.destroy();\n      this.queries = this.queries.filter(x => x !== query);\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash];\n      }\n\n      this.notify({\n        type: 'removed',\n        query\n      });\n    }\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        this.remove(query);\n      });\n    });\n  }\n\n  get(queryHash) {\n    return this.queriesMap[queryHash];\n  }\n\n  getAll() {\n    return this.queries;\n  }\n\n  find(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.queries.find(query => matchQuery(filters, query));\n  }\n\n  findAll(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    return Object.keys(filters).length > 0 ? this.queries.filter(query => matchQuery(filters, query)) : this.queries;\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({\n        listener\n      }) => {\n        listener(event);\n      });\n    });\n  }\n\n  onFocus() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onFocus();\n      });\n    });\n  }\n\n  onOnline() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onOnline();\n      });\n    });\n  }\n\n}\n\n\n//# sourceMappingURL=queryCache.mjs.map\n\n;// CONCATENATED MODULE: ../../../node_modules/@tanstack/query-core/build/lib/mutation.mjs\n\n\n\n\n\n// CLASS\nclass Mutation extends Removable {\n  constructor(config) {\n    super();\n    this.defaultOptions = config.defaultOptions;\n    this.mutationId = config.mutationId;\n    this.mutationCache = config.mutationCache;\n    this.logger = config.logger || defaultLogger;\n    this.observers = [];\n    this.state = config.state || mutation_getDefaultState();\n    this.setOptions(config.options);\n    this.scheduleGc();\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  get meta() {\n    return this.options.meta;\n  }\n\n  setState(state) {\n    this.dispatch({\n      type: 'setState',\n      state\n    });\n  }\n\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer); // Stop the mutation from being garbage collected\n\n      this.clearGcTimeout();\n      this.mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    this.observers = this.observers.filter(x => x !== observer);\n    this.scheduleGc();\n    this.mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer\n    });\n  }\n\n  optionalRemove() {\n    if (!this.observers.length) {\n      if (this.state.status === 'loading') {\n        this.scheduleGc();\n      } else {\n        this.mutationCache.remove(this);\n      }\n    }\n  }\n\n  continue() {\n    var _this$retryer$continu, _this$retryer;\n\n    return (_this$retryer$continu = (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.continue()) != null ? _this$retryer$continu : this.execute();\n  }\n\n  async execute() {\n    const executeMutation = () => {\n      var _this$options$retry;\n\n      this.retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject('No mutationFn found');\n          }\n\n          return this.options.mutationFn(this.state.variables);\n        },\n        onFail: (failureCount, error) => {\n          this.dispatch({\n            type: 'failed',\n            failureCount,\n            error\n          });\n        },\n        onPause: () => {\n          this.dispatch({\n            type: 'pause'\n          });\n        },\n        onContinue: () => {\n          this.dispatch({\n            type: 'continue'\n          });\n        },\n        retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode\n      });\n      return this.retryer.promise;\n    };\n\n    const restored = this.state.status === 'loading';\n\n    try {\n      var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onSettl, _this$options3;\n\n      if (!restored) {\n        var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;\n\n        this.dispatch({\n          type: 'loading',\n          variables: this.options.variables\n        }); // Notify cache callback\n\n        await ((_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this));\n        const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));\n\n        if (context !== this.state.context) {\n          this.dispatch({\n            type: 'loading',\n            context,\n            variables: this.state.variables\n          });\n        }\n      }\n\n      const data = await executeMutation(); // Notify cache callback\n\n      await ((_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this));\n      await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context)); // Notify cache callback\n\n      await ((_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, data, null, this.state.variables, this.state.context, this));\n      await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));\n      this.dispatch({\n        type: 'success',\n        data\n      });\n      return data;\n    } catch (error) {\n      try {\n        var _this$mutationCache$c7, _this$mutationCache$c8, _this$options$onError, _this$options4, _this$mutationCache$c9, _this$mutationCache$c10, _this$options$onSettl2, _this$options5;\n\n        // Notify cache callback\n        await ((_this$mutationCache$c7 = (_this$mutationCache$c8 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c7.call(_this$mutationCache$c8, error, this.state.variables, this.state.context, this));\n\n        if (false) {}\n\n        await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context)); // Notify cache callback\n\n        await ((_this$mutationCache$c9 = (_this$mutationCache$c10 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c9.call(_this$mutationCache$c10, undefined, error, this.state.variables, this.state.context, this));\n        await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, undefined, error, this.state.variables, this.state.context));\n        throw error;\n      } finally {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n    }\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error\n          };\n\n        case 'pause':\n          return { ...state,\n            isPaused: true\n          };\n\n        case 'continue':\n          return { ...state,\n            isPaused: false\n          };\n\n        case 'loading':\n          return { ...state,\n            context: action.context,\n            data: undefined,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'loading',\n            variables: action.variables\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: 'success',\n            isPaused: false\n          };\n\n        case 'error':\n          return { ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: 'error'\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onMutationUpdate(action);\n      });\n      this.mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\nfunction mutation_getDefaultState() {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined\n  };\n}\n\n\n//# sourceMappingURL=mutation.mjs.map\n\n;// CONCATENATED MODULE: ../../../node_modules/@tanstack/query-core/build/lib/mutationCache.mjs\n\n\n\n\n\n// CLASS\nclass MutationCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.mutations = [];\n    this.mutationId = 0;\n  }\n\n  build(client, options, state) {\n    const mutation = new Mutation({\n      mutationCache: this,\n      logger: client.getLogger(),\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : undefined\n    });\n    this.add(mutation);\n    return mutation;\n  }\n\n  add(mutation) {\n    this.mutations.push(mutation);\n    this.notify({\n      type: 'added',\n      mutation\n    });\n  }\n\n  remove(mutation) {\n    this.mutations = this.mutations.filter(x => x !== mutation);\n    this.notify({\n      type: 'removed',\n      mutation\n    });\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.mutations.forEach(mutation => {\n        this.remove(mutation);\n      });\n    });\n  }\n\n  getAll() {\n    return this.mutations;\n  }\n\n  find(filters) {\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.mutations.find(mutation => matchMutation(filters, mutation));\n  }\n\n  findAll(filters) {\n    return this.mutations.filter(mutation => matchMutation(filters, mutation));\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({\n        listener\n      }) => {\n        listener(event);\n      });\n    });\n  }\n\n  resumePausedMutations() {\n    var _this$resuming;\n\n    this.resuming = ((_this$resuming = this.resuming) != null ? _this$resuming : Promise.resolve()).then(() => {\n      const pausedMutations = this.mutations.filter(x => x.state.isPaused);\n      return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop)), Promise.resolve()));\n    }).then(() => {\n      this.resuming = undefined;\n    });\n    return this.resuming;\n  }\n\n}\n\n\n//# sourceMappingURL=mutationCache.mjs.map\n\n;// CONCATENATED MODULE: ../../../node_modules/@tanstack/query-core/build/lib/infiniteQueryBehavior.mjs\nfunction infiniteQueryBehavior() {\n  return {\n    onFetch: context => {\n      context.fetchFn = () => {\n        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;\n\n        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;\n        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;\n        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\n        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\n        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n        let newPageParams = oldPageParams;\n        let cancelled = false;\n\n        const addSignalProperty = object => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              var _context$signal;\n\n              if ((_context$signal = context.signal) != null && _context$signal.aborted) {\n                cancelled = true;\n              } else {\n                var _context$signal2;\n\n                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener('abort', () => {\n                  cancelled = true;\n                });\n              }\n\n              return context.signal;\n            }\n          });\n        }; // Get query function\n\n\n        const queryFn = context.options.queryFn || (() => Promise.reject(\"Missing queryFn for queryKey '\" + context.options.queryHash + \"'\"));\n\n        const buildNewPages = (pages, param, page, previous) => {\n          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];\n          return previous ? [page, ...pages] : [...pages, page];\n        }; // Create function to fetch a page\n\n\n        const fetchPage = (pages, manual, param, previous) => {\n          if (cancelled) {\n            return Promise.reject('Cancelled');\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages);\n          }\n\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.options.meta\n          };\n          addSignalProperty(queryFnContext);\n          const queryFnResult = queryFn(queryFnContext);\n          const promise = Promise.resolve(queryFnResult).then(page => buildNewPages(pages, param, page, previous));\n          return promise;\n        };\n\n        let promise; // Fetch first page?\n\n        if (!oldPages.length) {\n          promise = fetchPage([]);\n        } // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param);\n        } // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param, true);\n        } // Refetch pages\n        else {\n          newPageParams = [];\n          const manual = typeof context.options.getNextPageParam === 'undefined';\n          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page\n\n          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages\n\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then(pages => {\n              const shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;\n\n              if (shouldFetchNextPage) {\n                const param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\n                return fetchPage(pages, manual, param);\n              }\n\n              return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));\n            });\n          }\n        }\n\n        const finalPromise = promise.then(pages => ({\n          pages,\n          pageParams: newPageParams\n        }));\n        return finalPromise;\n      };\n    }\n  };\n}\nfunction getNextPageParam(options, pages) {\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\nfunction getPreviousPageParam(options, pages) {\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasNextPage(options, pages) {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages);\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\n  }\n\n  return;\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasPreviousPage(options, pages) {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages);\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\n  }\n\n  return;\n}\n\n\n//# sourceMappingURL=infiniteQueryBehavior.mjs.map\n\n;// CONCATENATED MODULE: ../../../node_modules/@tanstack/query-core/build/lib/queryClient.mjs\n\n\n\n\n\n\n\n\n\n// CLASS\nclass QueryClient {\n  constructor(config = {}) {\n    this.queryCache = config.queryCache || new QueryCache();\n    this.mutationCache = config.mutationCache || new MutationCache();\n    this.logger = config.logger || defaultLogger;\n    this.defaultOptions = config.defaultOptions || {};\n    this.queryDefaults = [];\n    this.mutationDefaults = [];\n    this.mountCount = 0;\n\n    if (false) {}\n  }\n\n  mount() {\n    this.mountCount++;\n    if (this.mountCount !== 1) return;\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations();\n        this.queryCache.onFocus();\n      }\n    });\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations();\n        this.queryCache.onOnline();\n      }\n    });\n  }\n\n  unmount() {\n    var _this$unsubscribeFocu, _this$unsubscribeOnli;\n\n    this.mountCount--;\n    if (this.mountCount !== 0) return;\n    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);\n    this.unsubscribeFocus = undefined;\n    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);\n    this.unsubscribeOnline = undefined;\n  }\n\n  isFetching(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    filters.fetchStatus = 'fetching';\n    return this.queryCache.findAll(filters).length;\n  }\n\n  isMutating(filters) {\n    return this.mutationCache.findAll({ ...filters,\n      fetching: true\n    }).length;\n  }\n\n  getQueryData(queryKey, filters) {\n    var _this$queryCache$find;\n\n    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;\n  }\n\n  ensureQueryData(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const cachedData = this.getQueryData(parsedOptions.queryKey);\n    return cachedData ? Promise.resolve(cachedData) : this.fetchQuery(parsedOptions);\n  }\n\n  getQueriesData(queryKeyOrFilters) {\n    return this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey,\n      state\n    }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n\n  setQueryData(queryKey, updater, options) {\n    const query = this.queryCache.find(queryKey);\n    const prevData = query == null ? void 0 : query.state.data;\n    const data = functionalUpdate(updater, prevData);\n\n    if (typeof data === 'undefined') {\n      return undefined;\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions);\n    return this.queryCache.build(this, defaultedOptions).setData(data, { ...options,\n      manual: true\n    });\n  }\n\n  setQueriesData(queryKeyOrFilters, updater, options) {\n    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey\n    }) => [queryKey, this.setQueryData(queryKey, updater, options)]));\n  }\n\n  getQueryState(queryKey, filters) {\n    var _this$queryCache$find2;\n\n    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;\n  }\n\n  removeQueries(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    const queryCache = this.queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query);\n      });\n    });\n  }\n\n  resetQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const queryCache = this.queryCache;\n    const refetchFilters = {\n      type: 'active',\n      ...filters\n    };\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  cancelQueries(arg1, arg2, arg3) {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true;\n    }\n\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map(query => query.cancel(cancelOptions)));\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n\n  invalidateQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    return notifyManager.batch(() => {\n      var _ref, _filters$refetchType;\n\n      this.queryCache.findAll(filters).forEach(query => {\n        query.invalidate();\n      });\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve();\n      }\n\n      const refetchFilters = { ...filters,\n        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : 'active'\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  refetchQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter(query => !query.isDisabled()).map(query => {\n      var _options$cancelRefetc;\n\n      return query.fetch(undefined, { ...options,\n        cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,\n        meta: {\n          refetchPage: filters.refetchPage\n        }\n      });\n    }));\n    let promise = Promise.all(promises).then(noop);\n\n    if (!(options != null && options.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  fetchQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions); // https://github.com/tannerlinsley/react-query/issues/652\n\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false;\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n\n  prefetchQuery(arg1, arg2, arg3) {\n    return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  fetchInfiniteQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    parsedOptions.behavior = infiniteQueryBehavior();\n    return this.fetchQuery(parsedOptions);\n  }\n\n  prefetchInfiniteQuery(arg1, arg2, arg3) {\n    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  resumePausedMutations() {\n    return this.mutationCache.resumePausedMutations();\n  }\n\n  getQueryCache() {\n    return this.queryCache;\n  }\n\n  getMutationCache() {\n    return this.mutationCache;\n  }\n\n  getLogger() {\n    return this.logger;\n  }\n\n  getDefaultOptions() {\n    return this.defaultOptions;\n  }\n\n  setDefaultOptions(options) {\n    this.defaultOptions = options;\n  }\n\n  setQueryDefaults(queryKey, options) {\n    const result = this.queryDefaults.find(x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.queryDefaults.push({\n        queryKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getQueryDefaults(queryKey) {\n    if (!queryKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.queryDefaults.find(x => partialMatchKey(queryKey, x.queryKey)); // Additional checks and error in dev mode\n\n    if (false) {}\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  setMutationDefaults(mutationKey, options) {\n    const result = this.mutationDefaults.find(x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.mutationDefaults.push({\n        mutationKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getMutationDefaults(mutationKey) {\n    if (!mutationKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.mutationDefaults.find(x => partialMatchKey(mutationKey, x.mutationKey)); // Additional checks and error in dev mode\n\n    if (false) {}\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  defaultQueryOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    const defaultedOptions = { ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n    } // dependent default values\n\n\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';\n    }\n\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;\n    }\n\n    return defaultedOptions;\n  }\n\n  defaultMutationOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    return { ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n\n  clear() {\n    this.queryCache.clear();\n    this.mutationCache.clear();\n  }\n\n}\n\n\n//# sourceMappingURL=queryClient.mjs.map\n\n;// CONCATENATED MODULE: ../../api/src/APIProvider.tsx\n\n// @ts-expect-error `@deriv/deriv-api` is not in TypeScript, Hence we ignore the TS error.\n\n\n\n// import { ReactQueryDevtools } from '@tanstack/react-query-devtools';\n\n// This is a temporary workaround to share a single `QueryClient` instance between all the packages.\n// Later once we have each package separated we won't need this anymore and can remove this.\nvar getSharedQueryClientContext = function getSharedQueryClientContext() {\n  if (!window.ReactQueryClient) {\n    window.ReactQueryClient = new QueryClient();\n  }\n  return window.ReactQueryClient;\n};\n\n// This is a temporary workaround to share a single `DerivAPIBasic` instance for every unique URL.\n// Later once we have each package separated we won't need this anymore and can remove this.\nvar getDerivAPIInstance = function getDerivAPIInstance() {\n  var _window$DerivAPI, _window$DerivAPI2;\n  var endpoint = getSocketURL();\n  var app_id = getAppId();\n  var language = 'EN'; // Need to use the language from the app context.\n  var brand = 'deriv';\n  var wss = \"wss://\".concat(endpoint, \"/websockets/v3?app_id=\").concat(app_id, \"&l=\").concat(language, \"&brand=\").concat(brand);\n  if (!window.DerivAPI) {\n    window.DerivAPI = {};\n  }\n  if (!((_window$DerivAPI = window.DerivAPI) !== null && _window$DerivAPI !== void 0 && _window$DerivAPI[wss])) {\n    window.DerivAPI[wss] = new DerivAPIBasic({\n      connection: new WebSocket(wss)\n    });\n  }\n  return (_window$DerivAPI2 = window.DerivAPI) === null || _window$DerivAPI2 === void 0 ? void 0 : _window$DerivAPI2[wss];\n};\nvar queryClient = getSharedQueryClientContext();\nvar APIProvider_APIProvider = function APIProvider(_ref) {\n  var children = _ref.children,\n    _ref$standalone = _ref.standalone,\n    standalone = _ref$standalone === void 0 ? false : _ref$standalone;\n  var WS = useWS();\n  // Use the new API instance if the `standalone` prop is set to true,\n  // else use the legacy socket connection.\n  var active_connection = standalone ? getDerivAPIInstance() : WS;\n  return /*#__PURE__*/React.createElement(APIContext.Provider, {\n    value: active_connection\n  }, /*#__PURE__*/React.createElement(QueryClientProvider, {\n    client: queryClient\n  }, children));\n};\n/* harmony default export */ const src_APIProvider = ((/* unused pure expression or super */ null && (APIProvider_APIProvider)));\n// EXTERNAL MODULE: ../../../node_modules/lodash.groupby/index.js\nvar lodash_groupby = __webpack_require__(\"../../../node_modules/lodash.groupby/index.js\");\n// EXTERNAL MODULE: ../../../node_modules/lodash.pickby/index.js\nvar lodash_pickby = __webpack_require__(\"../../../node_modules/lodash.pickby/index.js\");\n// EXTERNAL MODULE: ../../../node_modules/moment/moment.js\nvar moment_moment = __webpack_require__(\"../../../node_modules/moment/moment.js\");\n;// CONCATENATED MODULE: ../../utils/src/groupTransactionsByDay.ts\n\n\n\nvar groupTransactionsByDay = function groupTransactionsByDay(transactions) {\n  var grouped_transactions = pickBy(groupBy(transactions, function (transaction) {\n    return transaction.transaction_time ? moment(transaction.transaction_time * 1000).startOf('day').format('DD MMM YYYY') : null;\n  }), function (value, key) {\n    return key !== null;\n  });\n  return grouped_transactions;\n};\n/* harmony default export */ const src_groupTransactionsByDay = ((/* unused pure expression or super */ null && (groupTransactionsByDay)));\n;// CONCATENATED MODULE: ../../utils/src/index.ts\n\n\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ../../api/src/useInvalidateQuery.ts\n\n\nvar useInvalidateQuery_useInvalidateQuery = function useInvalidateQuery() {\n  var queryClient = useQueryClient();\n  var invalidate = useCallback(function (name, options) {\n    return queryClient.invalidateQueries(Array.isArray(name) ? name : [name], options);\n  }, [queryClient]);\n  return invalidate;\n};\n/* harmony default export */ const src_useInvalidateQuery = ((/* unused pure expression or super */ null && (useInvalidateQuery_useInvalidateQuery)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useAuthorize.ts\nfunction useAuthorize_typeof(obj) { \"@babel/helpers - typeof\"; return useAuthorize_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useAuthorize_typeof(obj); }\nvar useAuthorize_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useAuthorize_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useAuthorize_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useAuthorize_ownKeys(Object(source), !0).forEach(function (key) { useAuthorize_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useAuthorize_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useAuthorize_defineProperty(obj, key, value) { key = useAuthorize_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useAuthorize_toPropertyKey(arg) { var key = useAuthorize_toPrimitive(arg, \"string\"); return useAuthorize_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useAuthorize_toPrimitive(input, hint) { if (useAuthorize_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useAuthorize_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useAuthorize_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useAuthorize_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useAuthorize_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n/** A custom hook that authorize the user with the given token. If no token is given,\n * it will use the current token from localStorage.\n */\nvar useAuthorize_useAuthorize = function useAuthorize() {\n  var current_token = getActiveAuthTokenIDFromLocalStorage();\n  var invalidate = useInvalidateQuery();\n  var _useQuery = useQuery('authorize', {\n      payload: {\n        authorize: current_token || ''\n      },\n      options: {\n        enabled: Boolean(current_token)\n      }\n    }),\n    data = _useQuery.data,\n    rest = useAuthorize_objectWithoutProperties(_useQuery, useAuthorize_excluded);\n\n  // Add additional information to the authorize response.\n  var modified_authorize = useMemo(function () {\n    return useAuthorize_objectSpread({}, data === null || data === void 0 ? void 0 : data.authorize);\n  }, [data === null || data === void 0 ? void 0 : data.authorize]);\n  var switchAccount = useCallback(function (loginid) {\n    var active_loginid = getActiveLoginIDFromLocalStorage();\n    if (active_loginid !== loginid) {\n      localStorage.setItem('active_loginid', loginid);\n      invalidate('authorize');\n    }\n  }, [invalidate]);\n  return useAuthorize_objectSpread({\n    /** The authorize response. */\n    data: modified_authorize,\n    /** Function to switch to another account */\n    switchAccount: switchAccount\n  }, rest);\n};\n/* harmony default export */ const hooks_useAuthorize = ((/* unused pure expression or super */ null && (useAuthorize_useAuthorize)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useAccountLimits.ts\nfunction useAccountLimits_typeof(obj) { \"@babel/helpers - typeof\"; return useAccountLimits_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useAccountLimits_typeof(obj); }\nvar useAccountLimits_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useAccountLimits_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useAccountLimits_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useAccountLimits_ownKeys(Object(source), !0).forEach(function (key) { useAccountLimits_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useAccountLimits_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useAccountLimits_defineProperty(obj, key, value) { key = useAccountLimits_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useAccountLimits_toPropertyKey(arg) { var key = useAccountLimits_toPrimitive(arg, \"string\"); return useAccountLimits_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useAccountLimits_toPrimitive(input, hint) { if (useAccountLimits_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useAccountLimits_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useAccountLimits_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useAccountLimits_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useAccountLimits_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n/** A custom hook to get account limits */\nvar useAccountLimits = function useAccountLimits() {\n  var _useAuthorize = useAuthorize(),\n    isSuccess = _useAuthorize.isSuccess;\n  var _useQuery = useQuery('get_limits', {\n      options: {\n        enabled: isSuccess\n      }\n    }),\n    data = _useQuery.data,\n    rest = useAccountLimits_objectWithoutProperties(_useQuery, useAccountLimits_excluded);\n  return useAccountLimits_objectSpread({\n    /** Account limits response */\n    data: data === null || data === void 0 ? void 0 : data.get_limits\n  }, rest);\n};\n/* harmony default export */ const hooks_useAccountLimits = ((/* unused pure expression or super */ null && (useAccountLimits)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useGetAccountStatus.ts\nfunction useGetAccountStatus_typeof(obj) { \"@babel/helpers - typeof\"; return useGetAccountStatus_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useGetAccountStatus_typeof(obj); }\nvar useGetAccountStatus_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useGetAccountStatus_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useGetAccountStatus_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useGetAccountStatus_ownKeys(Object(source), !0).forEach(function (key) { useGetAccountStatus_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useGetAccountStatus_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useGetAccountStatus_defineProperty(obj, key, value) { key = useGetAccountStatus_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useGetAccountStatus_toPropertyKey(arg) { var key = useGetAccountStatus_toPrimitive(arg, \"string\"); return useGetAccountStatus_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useGetAccountStatus_toPrimitive(input, hint) { if (useGetAccountStatus_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useGetAccountStatus_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useGetAccountStatus_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useGetAccountStatus_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useGetAccountStatus_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n/** A custom hook to retrieves the account status for the current user. */\nvar useGetAccountStatus_useGetAccountStatus = function useGetAccountStatus() {\n  var _useQuery = useQuery('get_account_status'),\n    get_account_status_data = _useQuery.data,\n    rest = useGetAccountStatus_objectWithoutProperties(_useQuery, useGetAccountStatus_excluded);\n\n  // Add additional information to the account status response.\n  var modified_account_status = useMemo(function () {\n    if (!(get_account_status_data !== null && get_account_status_data !== void 0 && get_account_status_data.get_account_status)) return;\n    return useGetAccountStatus_objectSpread(useGetAccountStatus_objectSpread({}, get_account_status_data.get_account_status), {}, {\n      /** Indicates whether the client should be prompted to authenticate their account. */\n      should_prompt_client_to_authenticate: Boolean(get_account_status_data.get_account_status.prompt_client_to_authenticate)\n    });\n  }, [get_account_status_data === null || get_account_status_data === void 0 ? void 0 : get_account_status_data.get_account_status]);\n  return useGetAccountStatus_objectSpread({\n    /** The account status response. */\n    data: modified_account_status\n  }, rest);\n};\n/* harmony default export */ const hooks_useGetAccountStatus = ((/* unused pure expression or super */ null && (useGetAccountStatus_useGetAccountStatus)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useAccountStatus.ts\nfunction useAccountStatus_typeof(obj) { \"@babel/helpers - typeof\"; return useAccountStatus_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useAccountStatus_typeof(obj); }\nvar useAccountStatus_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useAccountStatus_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useAccountStatus_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useAccountStatus_ownKeys(Object(source), !0).forEach(function (key) { useAccountStatus_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useAccountStatus_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useAccountStatus_defineProperty(obj, key, value) { key = useAccountStatus_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useAccountStatus_toPropertyKey(arg) { var key = useAccountStatus_toPrimitive(arg, \"string\"); return useAccountStatus_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useAccountStatus_toPrimitive(input, hint) { if (useAccountStatus_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useAccountStatus_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useAccountStatus_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useAccountStatus_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useAccountStatus_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n/** A custom hook to check the account status for the current user. */\nvar useAccountStatus = function useAccountStatus() {\n  var _useGetAccountStatus = useGetAccountStatus(),\n    get_account_status_data = _useGetAccountStatus.data,\n    rest = useAccountStatus_objectWithoutProperties(_useGetAccountStatus, useAccountStatus_excluded);\n\n  // Add additional information to the account status response.\n  var modified_account_status = useMemo(function () {\n    if (!(get_account_status_data !== null && get_account_status_data !== void 0 && get_account_status_data.status)) return;\n    var status = new Set(get_account_status_data === null || get_account_status_data === void 0 ? void 0 : get_account_status_data.status);\n    return {\n      /** Account status. */\n      status: get_account_status_data === null || get_account_status_data === void 0 ? void 0 : get_account_status_data.status,\n      /** client's address is verified by third party services. */\n      is_address_verified: status.has('address_verified'),\n      /** client is allowed to upload documents. */\n      is_allow_document_upload: status.has('allow_document_upload'),\n      /** client is age-verified. */\n      is_age_verification: status.has('age_verification'),\n      /** client is fully authenticated. */\n      is_authenticated: status.has('authenticated'),\n      /** cashier is locked. */\n      is_cashier_locked: status.has('cashier_locked'),\n      /** client has updated tax related information. */\n      is_crs_tin_information: status.has('crs_tin_information'),\n      /** deposit is not allowed. */\n      is_deposit_locked: status.has('deposit_locked'),\n      /** account is disabled. */\n      is_disabled: status.has('disabled'),\n      /** client's submitted proof-of-identity documents have expired. */\n      is_document_expired: status.has('document_expired'),\n      /** client's submitted proof-of-identity documents are expiring within a month. */\n      is_document_expiring_soon: status.has('document_expiring_soon'),\n      /** Deriv X password is not set. */\n      is_dxtrade_password_not_set: status.has('dxtrade_password_not_set'),\n      /** client should complete their financial assessment. */\n      is_financial_assessment_not_complete: status.has('financial_assessment_not_complete'),\n      /** client has not completed financial assessment. */\n      is_financial_information_not_complete: status.has('financial_information_not_complete'),\n      /** client has accepted financial risk disclosure. */\n      is_financial_risk_approval: status.has('financial_risk_approval'),\n      /** client has not set financial limits on their account. Applies to UK and Malta clients. */\n      is_max_turnover_limit_not_set: status.has('max_turnover_limit_not_set'),\n      /** MT5 password is not set. */\n      is_mt5_password_not_set: status.has('mt5_password_not_set'),\n      /** MT5 deposits allowed, but withdrawal is not allowed. */\n      is_mt5_withdrawal_locked: status.has('mt5_withdrawal_locked'),\n      /** user must approve the Affiliate's Code of Conduct Agreement. */\n      is_needs_affiliate_coc_approval: status.has('needs_affiliate_coc_approval'),\n      /** trading is disabled. */\n      is_no_trading: status.has('no_trading'),\n      /** client cannot trade or withdraw but can deposit. */\n      is_no_withdrawal_or_trading: status.has('no_withdrawal_or_trading'),\n      /** p2p is blocked for the current payment agent client. */\n      is_p2p_blocked_for_pa: status.has('p2p_blocked_for_pa'),\n      /** withdrawal through payment agent is allowed. */\n      is_pa_withdrawal_explicitly_allowed: status.has('pa_withdrawal_explicitly_allowed'),\n      /** this client must reset their password. */\n      is_password_reset_required: status.has('password_reset_required'),\n      /** this client has opted for a professional account. */\n      is_professional: status.has('professional'),\n      /** this client has requested for a professional account. */\n      is_professional_requested: status.has('professional_requested'),\n      /** this client's request for a professional account has been rejected. */\n      is_professional_rejected: status.has('professional_rejected'),\n      /** this client is using social signup. */\n      is_social_signup: status.has('social_signup'),\n      /** client has not completed the trading experience questionnaire. */\n      is_trading_experience_not_complete: status.has('trading_experience_not_complete'),\n      /** client has acknowledged UKGC funds protection notice. */\n      is_ukgc_funds_protection: status.has('ukgc_funds_protection'),\n      /** client cannot deposit or buy contracts, but can withdraw or sell contracts. */\n      is_unwelcome: status.has('unwelcome'),\n      /** deposits allowed but withdrawals are not allowed. */\n      is_withdrawal_locked: status.has('withdrawal_locked'),\n      /** this prevent a client from changing the account currency after deposit attempt. */\n      is_deposit_attempt: status.has('deposit_attempt'),\n      /** client POI documents name mismatch. */\n      is_poi_name_mismatch: status.has('poi_name_mismatch'),\n      /** the client can resubmit POA documents. */\n      is_allow_poa_resubmission: status.has('allow_poa_resubmission'),\n      /** the client can resubmit POI documents. */\n      is_allow_poi_resubmission: status.has('allow_poi_resubmission'),\n      /** the client has been sharing payment methods. */\n      is_shared_payment_method: status.has('shared_payment_method'),\n      /** client is not allowed to edit personal profile details. */\n      is_personal_details_locked: status.has('personal_details_locked'),\n      /** it block any transfer between two accounts. */\n      is_transfers_blocked: status.has('transfers_blocked'),\n      /** the DF deposit will be blocked until the client gets age verified. */\n      is_df_deposit_requires_poi: status.has('df_deposit_requires_poi'),\n      /** the client has been fully authenticated by IDV. */\n      is_authenticated_with_idv_photoid: status.has('authenticated_with_idv_photoid'),\n      /** the client used to be fully authenticated by IDV but it was taken away due to compliance criteria. */\n      is_idv_revoked: status.has('idv_revoked')\n    };\n  }, [get_account_status_data === null || get_account_status_data === void 0 ? void 0 : get_account_status_data.status]);\n  return useAccountStatus_objectSpread({\n    /** The account status response. */\n    data: modified_account_status\n  }, rest);\n};\n/* harmony default export */ const hooks_useAccountStatus = ((/* unused pure expression or super */ null && (useAccountStatus)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useAccountTypes.ts\nfunction useAccountTypes_typeof(obj) { \"@babel/helpers - typeof\"; return useAccountTypes_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useAccountTypes_typeof(obj); }\nvar useAccountTypes_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useAccountTypes_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useAccountTypes_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useAccountTypes_ownKeys(Object(source), !0).forEach(function (key) { useAccountTypes_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useAccountTypes_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useAccountTypes_defineProperty(obj, key, value) { key = useAccountTypes_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useAccountTypes_toPropertyKey(arg) { var key = useAccountTypes_toPrimitive(arg, \"string\"); return useAccountTypes_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useAccountTypes_toPrimitive(input, hint) { if (useAccountTypes_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useAccountTypes_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useAccountTypes_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useAccountTypes_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useAccountTypes_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n/** A custom hook to get available account types for a specific landing company. */\nvar useAccountTypes_useAccountTypes = function useAccountTypes(landing_company) {\n  var _useQuery = useQuery('get_account_types', {\n      payload: {\n        company: landing_company\n      },\n      options: {\n        enabled: Boolean(landing_company)\n      }\n    }),\n    data = _useQuery.data,\n    rest = useAccountTypes_objectWithoutProperties(_useQuery, useAccountTypes_excluded);\n\n  // Add additional information to the account types response.\n  var modified_account_types = useMemo(function () {\n    if (!(data !== null && data !== void 0 && data.get_account_types)) return;\n    return useAccountTypes_objectSpread(useAccountTypes_objectSpread({}, data.get_account_types), {}, {\n      /** Landing company for the account types */\n      landing_company: landing_company\n    });\n  }, [data === null || data === void 0 ? void 0 : data.get_account_types, landing_company]);\n  return useAccountTypes_objectSpread({\n    /** The account types response. */\n    data: modified_account_types\n  }, rest);\n};\n/* harmony default export */ const hooks_useAccountTypes = ((/* unused pure expression or super */ null && (useAccountTypes_useAccountTypes)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useBalance.ts\nfunction useBalance_typeof(obj) { \"@babel/helpers - typeof\"; return useBalance_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useBalance_typeof(obj); }\nvar useBalance_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useBalance_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useBalance_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useBalance_ownKeys(Object(source), !0).forEach(function (key) { useBalance_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useBalance_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useBalance_defineProperty(obj, key, value) { key = useBalance_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useBalance_toPropertyKey(arg) { var key = useBalance_toPrimitive(arg, \"string\"); return useBalance_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useBalance_toPrimitive(input, hint) { if (useBalance_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useBalance_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useBalance_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useBalance_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useBalance_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n/** A custom hook that gets the balance for all the user accounts. */\nvar useBalance_useBalance = function useBalance() {\n  var _useAuthorize = useAuthorize(),\n    isSuccess = _useAuthorize.isSuccess;\n  var _useQuery = useQuery('balance', {\n      payload: {\n        account: 'all'\n      },\n      options: {\n        enabled: isSuccess,\n        refetchInterval: 30000 // Refetch every 30 seconds to simulate subscription.\n      }\n    }),\n    balance_data = _useQuery.data,\n    rest = useBalance_objectWithoutProperties(_useQuery, useBalance_excluded);\n\n  // Add additional information to the balance data.\n  var modified_balance = useMemo(function () {\n    return useBalance_objectSpread({}, balance_data === null || balance_data === void 0 ? void 0 : balance_data.balance);\n  }, [balance_data === null || balance_data === void 0 ? void 0 : balance_data.balance]);\n  return useBalance_objectSpread({\n    /** The balance response. */\n    data: modified_balance\n  }, rest);\n};\n/* harmony default export */ const hooks_useBalance = ((/* unused pure expression or super */ null && (useBalance_useBalance)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useCurrencyConfig.ts\nfunction useCurrencyConfig_typeof(obj) { \"@babel/helpers - typeof\"; return useCurrencyConfig_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useCurrencyConfig_typeof(obj); }\nvar useCurrencyConfig_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useCurrencyConfig_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useCurrencyConfig_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useCurrencyConfig_ownKeys(Object(source), !0).forEach(function (key) { useCurrencyConfig_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useCurrencyConfig_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useCurrencyConfig_defineProperty(obj, key, value) { key = useCurrencyConfig_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useCurrencyConfig_toPropertyKey(arg) { var key = useCurrencyConfig_toPrimitive(arg, \"string\"); return useCurrencyConfig_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useCurrencyConfig_toPrimitive(input, hint) { if (useCurrencyConfig_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useCurrencyConfig_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useCurrencyConfig_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useCurrencyConfig_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useCurrencyConfig_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n/** A custom hook to get the currency config information from `website_status` endpoint and `crypto_config` endpoint. */\nvar useCurrencyConfig_useCurrencyConfig = function useCurrencyConfig() {\n  var _website_status_data$2, _crypto_config_data$c2;\n  var _useQuery = useQuery('website_status'),\n    website_status_data = _useQuery.data,\n    rest = useCurrencyConfig_objectWithoutProperties(_useQuery, useCurrencyConfig_excluded);\n  var _useQuery2 = useQuery('crypto_config'),\n    crypto_config_data = _useQuery2.data;\n\n  // Add additional information to the currency config.\n  var modified_currencies_config = useMemo(function () {\n    var _website_status_data$;\n    if (!(website_status_data !== null && website_status_data !== void 0 && (_website_status_data$ = website_status_data.website_status) !== null && _website_status_data$ !== void 0 && _website_status_data$.currencies_config)) return undefined;\n    var website_status_currencies_config = website_status_data.website_status.currencies_config;\n    return Object.keys(website_status_currencies_config).map(function (currency) {\n      var currency_config = website_status_currencies_config[currency];\n      return useCurrencyConfig_objectSpread(useCurrencyConfig_objectSpread({}, currency_config), {}, {\n        /** determine if the currency is a `crypto` currency */\n        is_crypto: (currency_config === null || currency_config === void 0 ? void 0 : currency_config.type) === 'crypto',\n        /** determine if the currency is a `fiat` currency */\n        is_fiat: (currency_config === null || currency_config === void 0 ? void 0 : currency_config.type) === 'fiat',\n        /** determine if the currency is `Australian Dollar` */\n        is_AUD: currency === 'AUD',\n        /** determine if the currency is `US Dollar` */\n        is_USD: currency === 'USD',\n        /** determine if the currency is `Euro` */\n        is_EUR: currency === 'EUR',\n        /** determine if the currency is `Pound Sterling` */\n        is_GBP: currency === 'GBP',\n        /** determine if the currency is `Bitcoin` */\n        is_BTC: currency === 'BTC',\n        /** determine if the currency is `Ethereum` */\n        is_ETH: currency === 'ETH',\n        /** determine if the currency is `Litecoin` */\n        is_LTC: currency === 'LTC',\n        /** determine if the currency is `Multi-Collateral DAI` */\n        is_DAI: currency === 'DAI',\n        /** determine if the currency is `IDK` */\n        is_IDK: currency === 'IDK',\n        /** determine if the currency is `Paxos Standard` */\n        is_PAX: currency === 'PAX',\n        /** determine if the currency is `Binary Coin` */\n        is_USB: currency === 'USB',\n        /** determine if the currency is `Tether Omni` */\n        is_USDT: currency === 'UST',\n        /** determine if the currency is `True USD` */\n        is_TUSD: currency === 'TUSD',\n        /** determine if the currency is `Binance USD` */\n        is_BUSD: currency === 'BUSD',\n        /** determine if the currency is `STATIS Euro` */\n        is_EURS: currency === 'EURS',\n        /** determine if the currency is `Tether ERC20` */\n        is_eUSDT: currency === 'eUSDT',\n        /** determine if the currency is `Tether TRC20` */\n        is_tUSDT: currency === 'tUSDT',\n        /** determine if the currency is `USD Coin` */\n        is_USDC: currency === 'USDC',\n        /** determine if the currency is `USDK` */\n        is_USDK: currency === 'USDK',\n        /** Currency code */\n        code: currency,\n        /** Currency display code */\n        display_code: currency === 'UST' ? 'USDT' : currency\n      });\n    });\n  }, [website_status_data === null || website_status_data === void 0 ? void 0 : (_website_status_data$2 = website_status_data.website_status) === null || _website_status_data$2 === void 0 ? void 0 : _website_status_data$2.currencies_config]);\n\n  // Add additional information to the crypto config.\n  var modified_crypto_config = useMemo(function () {\n    return modified_currencies_config === null || modified_currencies_config === void 0 ? void 0 : modified_currencies_config.map(function (currency_config) {\n      var _crypto_config_data$c;\n      return useCurrencyConfig_objectSpread(useCurrencyConfig_objectSpread({}, currency_config), crypto_config_data === null || crypto_config_data === void 0 ? void 0 : (_crypto_config_data$c = crypto_config_data.crypto_config) === null || _crypto_config_data$c === void 0 ? void 0 : _crypto_config_data$c.currencies_config[currency_config.code]);\n    });\n  }, [crypto_config_data === null || crypto_config_data === void 0 ? void 0 : (_crypto_config_data$c2 = crypto_config_data.crypto_config) === null || _crypto_config_data$c2 === void 0 ? void 0 : _crypto_config_data$c2.currencies_config, modified_currencies_config]);\n\n  // Transform the currency config array into a record object.\n  var transformed_currencies_config = useMemo(function () {\n    return modified_crypto_config === null || modified_crypto_config === void 0 ? void 0 : modified_crypto_config.reduce(function (previous, current) {\n      return useCurrencyConfig_objectSpread(useCurrencyConfig_objectSpread({}, previous), {}, useCurrencyConfig_defineProperty({}, current.code, current));\n    }, {});\n  }, [modified_crypto_config]);\n  var getConfig = useCallback(function (currency) {\n    return transformed_currencies_config === null || transformed_currencies_config === void 0 ? void 0 : transformed_currencies_config[currency];\n  }, [transformed_currencies_config]);\n  return useCurrencyConfig_objectSpread({\n    /** Available currencies and their information */\n    data: transformed_currencies_config,\n    /** Returns the currency config object for the given currency */\n    getConfig: getConfig\n  }, rest);\n};\n/* harmony default export */ const hooks_useCurrencyConfig = ((/* unused pure expression or super */ null && (useCurrencyConfig_useCurrencyConfig)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useAccountsList.ts\nfunction useAccountsList_typeof(obj) { \"@babel/helpers - typeof\"; return useAccountsList_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useAccountsList_typeof(obj); }\nvar useAccountsList_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useAccountsList_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useAccountsList_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useAccountsList_ownKeys(Object(source), !0).forEach(function (key) { useAccountsList_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useAccountsList_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useAccountsList_defineProperty(obj, key, value) { key = useAccountsList_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useAccountsList_toPropertyKey(arg) { var key = useAccountsList_toPrimitive(arg, \"string\"); return useAccountsList_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useAccountsList_toPrimitive(input, hint) { if (useAccountsList_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useAccountsList_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useAccountsList_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useAccountsList_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useAccountsList_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n/** A custom hook that returns the list of accounts for the current user. */\nvar useAccountsList_useAccountsList = function useAccountsList() {\n  var _useAuthorize = useAuthorize(),\n    authorize_data = _useAuthorize.data,\n    rest = useAccountsList_objectWithoutProperties(_useAuthorize, useAccountsList_excluded);\n  var _useBalance = useBalance(),\n    balance_data = _useBalance.data;\n  var _useCurrencyConfig = useCurrencyConfig(),\n    getConfig = _useCurrencyConfig.getConfig;\n\n  // Add additional information to the authorize response.\n  var modified_accounts = useMemo(function () {\n    var _authorize_data$accou;\n    return (_authorize_data$accou = authorize_data.account_list) === null || _authorize_data$accou === void 0 ? void 0 : _authorize_data$accou.map(function (account) {\n      return useAccountsList_objectSpread(useAccountsList_objectSpread({}, account), {}, {\n        /** Creation time of the account. */\n        created_at: account.created_at ? new Date(account.created_at) : undefined,\n        /** Date till client has excluded him/herself from the website, only present if client is self excluded. */\n        excluded_until: account.excluded_until ? new Date(account.excluded_until) : undefined,\n        /** Indicating whether the wallet is the currently active account. */\n        is_active: account.loginid === authorize_data.loginid,\n        /** indicating whether the account is a virtual-money account. */\n        is_virtual: Boolean(account.is_virtual),\n        /** indicating whether the account is marked as disabled or not. */\n        is_disabled: Boolean(account.is_disabled),\n        /** indicating whether the account is a trading account. */\n        is_trading: account.account_category === 'trading',\n        /** indicating whether the account is a wallet account. */\n        is_wallet: account.account_category === 'wallet',\n        /** The account ID of specified account. */\n        loginid: \"\".concat(account.loginid),\n        /** Account's currency config information */\n        currency_config: account.currency ? getConfig(account.currency) : undefined\n      });\n    });\n  }, [authorize_data.account_list, authorize_data.loginid, getConfig]);\n\n  // Add balance to each account\n  var modified_accounts_with_balance = useMemo(function () {\n    return modified_accounts === null || modified_accounts === void 0 ? void 0 : modified_accounts.map(function (account) {\n      var _balance_data$account, _balance_data$account2, _account$currency_con, _account$currency_con2, _account$currency_con3;\n      var balance = (balance_data === null || balance_data === void 0 ? void 0 : (_balance_data$account = balance_data.accounts) === null || _balance_data$account === void 0 ? void 0 : (_balance_data$account2 = _balance_data$account[account.loginid]) === null || _balance_data$account2 === void 0 ? void 0 : _balance_data$account2.balance) || 0;\n      return useAccountsList_objectSpread(useAccountsList_objectSpread({}, account), {}, {\n        /** The balance of the account. */\n        balance: balance,\n        /** The balance of the account in currency format. */\n        display_balance: \"\".concat(Intl.NumberFormat((authorize_data === null || authorize_data === void 0 ? void 0 : authorize_data.preferred_language) || 'en-US', {\n          minimumFractionDigits: ((_account$currency_con = account.currency_config) === null || _account$currency_con === void 0 ? void 0 : _account$currency_con.fractional_digits) || 2,\n          maximumFractionDigits: ((_account$currency_con2 = account.currency_config) === null || _account$currency_con2 === void 0 ? void 0 : _account$currency_con2.fractional_digits) || 2,\n          minimumIntegerDigits: 1\n        }).format(balance), \" \").concat(((_account$currency_con3 = account.currency_config) === null || _account$currency_con3 === void 0 ? void 0 : _account$currency_con3.display_code) || 'USD')\n      });\n    });\n  }, [balance_data === null || balance_data === void 0 ? void 0 : balance_data.accounts, modified_accounts, authorize_data === null || authorize_data === void 0 ? void 0 : authorize_data.preferred_language]);\n  return useAccountsList_objectSpread({\n    /** The list of accounts for the current user. */\n    data: modified_accounts_with_balance\n  }, rest);\n};\n/* harmony default export */ const hooks_useAccountsList = ((/* unused pure expression or super */ null && (useAccountsList_useAccountsList)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useActiveAccount.ts\nfunction useActiveAccount_typeof(obj) { \"@babel/helpers - typeof\"; return useActiveAccount_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useActiveAccount_typeof(obj); }\nvar useActiveAccount_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useActiveAccount_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useActiveAccount_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useActiveAccount_ownKeys(Object(source), !0).forEach(function (key) { useActiveAccount_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useActiveAccount_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useActiveAccount_defineProperty(obj, key, value) { key = useActiveAccount_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useActiveAccount_toPropertyKey(arg) { var key = useActiveAccount_toPrimitive(arg, \"string\"); return useActiveAccount_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useActiveAccount_toPrimitive(input, hint) { if (useActiveAccount_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useActiveAccount_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useActiveAccount_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useActiveAccount_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useActiveAccount_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n/** A custom hook that returns the account object for the current active account. */\nvar useActiveAccount_useActiveAccount = function useActiveAccount() {\n  var _useAccountsList = useAccountsList(),\n    data = _useAccountsList.data,\n    rest = useActiveAccount_objectWithoutProperties(_useAccountsList, useActiveAccount_excluded);\n  var active_account = useMemo(function () {\n    return data === null || data === void 0 ? void 0 : data.find(function (account) {\n      return account.is_active;\n    });\n  }, [data]);\n  return useActiveAccount_objectSpread({\n    /** User's current active account. */\n    data: active_account\n  }, rest);\n};\n/* harmony default export */ const hooks_useActiveAccount = ((/* unused pure expression or super */ null && (useActiveAccount_useActiveAccount)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useTradingAccountsList.ts\nfunction useTradingAccountsList_typeof(obj) { \"@babel/helpers - typeof\"; return useTradingAccountsList_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useTradingAccountsList_typeof(obj); }\nvar useTradingAccountsList_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useTradingAccountsList_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useTradingAccountsList_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useTradingAccountsList_ownKeys(Object(source), !0).forEach(function (key) { useTradingAccountsList_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useTradingAccountsList_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useTradingAccountsList_defineProperty(obj, key, value) { key = useTradingAccountsList_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useTradingAccountsList_toPropertyKey(arg) { var key = useTradingAccountsList_toPrimitive(arg, \"string\"); return useTradingAccountsList_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useTradingAccountsList_toPrimitive(input, hint) { if (useTradingAccountsList_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useTradingAccountsList_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useTradingAccountsList_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useTradingAccountsList_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useTradingAccountsList_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n/** A custom hook that gets the list of all trading accounts for the current user. */\nvar useTradingAccountsList_useTradingAccountsList = function useTradingAccountsList() {\n  var _useAccountsList = useAccountsList(),\n    account_list_data = _useAccountsList.data,\n    rest = useTradingAccountsList_objectWithoutProperties(_useAccountsList, useTradingAccountsList_excluded);\n\n  // Filter out non-trading accounts.\n  var filtered_accounts = useMemo(function () {\n    return account_list_data === null || account_list_data === void 0 ? void 0 : account_list_data.filter(function (account) {\n      return account.is_trading;\n    });\n  }, [account_list_data]);\n\n  // Add additional information to each trading account.\n  var modified_accounts = useMemo(function () {\n    return filtered_accounts === null || filtered_accounts === void 0 ? void 0 : filtered_accounts.map(function (trading) {\n      return useTradingAccountsList_objectSpread({}, trading);\n    });\n  }, [filtered_accounts]);\n  return useTradingAccountsList_objectSpread({\n    /** The list of trading accounts for the current user. */\n    data: modified_accounts\n  }, rest);\n};\n/* harmony default export */ const hooks_useTradingAccountsList = ((/* unused pure expression or super */ null && (useTradingAccountsList_useTradingAccountsList)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useActiveTradingAccount.ts\nfunction useActiveTradingAccount_typeof(obj) { \"@babel/helpers - typeof\"; return useActiveTradingAccount_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useActiveTradingAccount_typeof(obj); }\nvar useActiveTradingAccount_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useActiveTradingAccount_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useActiveTradingAccount_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useActiveTradingAccount_ownKeys(Object(source), !0).forEach(function (key) { useActiveTradingAccount_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useActiveTradingAccount_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useActiveTradingAccount_defineProperty(obj, key, value) { key = useActiveTradingAccount_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useActiveTradingAccount_toPropertyKey(arg) { var key = useActiveTradingAccount_toPrimitive(arg, \"string\"); return useActiveTradingAccount_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useActiveTradingAccount_toPrimitive(input, hint) { if (useActiveTradingAccount_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useActiveTradingAccount_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useActiveTradingAccount_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useActiveTradingAccount_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useActiveTradingAccount_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n/** A custom hook that returns the trading object for the current active trading. */\nvar useActiveTradingAccount = function useActiveTradingAccount() {\n  var _useTradingAccountsLi = useTradingAccountsList(),\n    data = _useTradingAccountsLi.data,\n    rest = useActiveTradingAccount_objectWithoutProperties(_useTradingAccountsLi, useActiveTradingAccount_excluded);\n  var active_trading = useMemo(function () {\n    return data === null || data === void 0 ? void 0 : data.find(function (trading) {\n      return trading.is_active;\n    });\n  }, [data]);\n  return useActiveTradingAccount_objectSpread({\n    /** User's current active trading. */\n    data: active_trading\n  }, rest);\n};\n/* harmony default export */ const hooks_useActiveTradingAccount = ((/* unused pure expression or super */ null && (useActiveTradingAccount)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useWalletAccountsList.ts\nfunction useWalletAccountsList_typeof(obj) { \"@babel/helpers - typeof\"; return useWalletAccountsList_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useWalletAccountsList_typeof(obj); }\nvar useWalletAccountsList_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction useWalletAccountsList_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useWalletAccountsList_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useWalletAccountsList_ownKeys(Object(source), !0).forEach(function (key) { useWalletAccountsList_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useWalletAccountsList_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useWalletAccountsList_defineProperty(obj, key, value) { key = useWalletAccountsList_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useWalletAccountsList_toPropertyKey(arg) { var key = useWalletAccountsList_toPrimitive(arg, \"string\"); return useWalletAccountsList_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useWalletAccountsList_toPrimitive(input, hint) { if (useWalletAccountsList_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useWalletAccountsList_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useWalletAccountsList_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useWalletAccountsList_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useWalletAccountsList_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n/** A custom hook that gets the list of all wallet accounts for the current user. */\nvar useWalletAccountsList_useWalletAccountsList = function useWalletAccountsList() {\n  var _useAccountsList = useAccountsList(),\n    account_list_data = _useAccountsList.data,\n    rest = useWalletAccountsList_objectWithoutProperties(_useAccountsList, useWalletAccountsList_excluded);\n\n  // Filter out non-wallet accounts.\n  var filtered_accounts = useMemo(function () {\n    return account_list_data === null || account_list_data === void 0 ? void 0 : account_list_data.filter(function (account) {\n      return account.is_wallet;\n    });\n  }, [account_list_data]);\n\n  // Add additional information to each wallet account.\n  var modified_accounts = useMemo(function () {\n    return filtered_accounts === null || filtered_accounts === void 0 ? void 0 : filtered_accounts.map(function (wallet) {\n      var _wallet$linked_to, _wallet$linked_to$fin, _wallet$landing_compa, _wallet$currency_conf;\n      var wallet_currency_type = wallet.is_virtual ? 'Demo' : wallet.currency || '';\n      var dtrade_loginid = (_wallet$linked_to = wallet.linked_to) === null || _wallet$linked_to === void 0 ? void 0 : (_wallet$linked_to$fin = _wallet$linked_to.find(function (account) {\n        return account.platform === 'dtrade';\n      })) === null || _wallet$linked_to$fin === void 0 ? void 0 : _wallet$linked_to$fin.loginid;\n      return useWalletAccountsList_objectSpread(useWalletAccountsList_objectSpread({}, wallet), {}, {\n        /** Returns the wallet's currency type. ex: `Demo`, `USD`, etc. */\n        wallet_currency_type: wallet_currency_type,\n        /** Landing company shortcode the account belongs to. */\n        landing_company_name: (_wallet$landing_compa = wallet.landing_company_name) === null || _wallet$landing_compa === void 0 ? void 0 : _wallet$landing_compa.replace('maltainvest', 'malta'),\n        /** Indicating whether the wallet is a maltainvest wallet. */\n        is_malta_wallet: wallet.landing_company_name === 'malta',\n        /** The DTrade account ID of this wallet */\n        dtrade_loginid: dtrade_loginid,\n        /** Returns if the wallet is a crypto wallet. */\n        is_crypto: (_wallet$currency_conf = wallet.currency_config) === null || _wallet$currency_conf === void 0 ? void 0 : _wallet$currency_conf.is_crypto\n      });\n    });\n  }, [filtered_accounts]);\n\n  // Sort wallet accounts alphabetically by fiat, crypto, then virtual.\n  var sorted_accounts = useMemo(function () {\n    if (!modified_accounts) return;\n    return _toConsumableArray(modified_accounts).sort(function (a, b) {\n      var _a$currency_config, _b$currency_config;\n      if (a.is_virtual !== b.is_virtual) {\n        return a.is_virtual ? 1 : -1;\n      } else if (((_a$currency_config = a.currency_config) === null || _a$currency_config === void 0 ? void 0 : _a$currency_config.is_crypto) !== ((_b$currency_config = b.currency_config) === null || _b$currency_config === void 0 ? void 0 : _b$currency_config.is_crypto)) {\n        var _a$currency_config2;\n        return (_a$currency_config2 = a.currency_config) !== null && _a$currency_config2 !== void 0 && _a$currency_config2.is_crypto ? 1 : -1;\n      }\n      return (a.currency || 'USD').localeCompare(b.currency || 'USD');\n    });\n  }, [modified_accounts]);\n  return useWalletAccountsList_objectSpread({\n    /** The list of wallet accounts for the current user. */\n    data: sorted_accounts\n  }, rest);\n};\n/* harmony default export */ const hooks_useWalletAccountsList = ((/* unused pure expression or super */ null && (useWalletAccountsList_useWalletAccountsList)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useActiveWalletAccount.ts\nfunction useActiveWalletAccount_typeof(obj) { \"@babel/helpers - typeof\"; return useActiveWalletAccount_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useActiveWalletAccount_typeof(obj); }\nvar useActiveWalletAccount_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useActiveWalletAccount_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useActiveWalletAccount_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useActiveWalletAccount_ownKeys(Object(source), !0).forEach(function (key) { useActiveWalletAccount_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useActiveWalletAccount_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useActiveWalletAccount_defineProperty(obj, key, value) { key = useActiveWalletAccount_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useActiveWalletAccount_toPropertyKey(arg) { var key = useActiveWalletAccount_toPrimitive(arg, \"string\"); return useActiveWalletAccount_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useActiveWalletAccount_toPrimitive(input, hint) { if (useActiveWalletAccount_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useActiveWalletAccount_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useActiveWalletAccount_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useActiveWalletAccount_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useActiveWalletAccount_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n/** A custom hook that returns the wallet object for the current active wallet. */\nvar useActiveWalletAccount_useActiveWalletAccount = function useActiveWalletAccount() {\n  var _useWalletAccountsLis = useWalletAccountsList(),\n    data = _useWalletAccountsLis.data,\n    rest = useActiveWalletAccount_objectWithoutProperties(_useWalletAccountsLis, useActiveWalletAccount_excluded);\n  var active_wallet = useMemo(function () {\n    return data === null || data === void 0 ? void 0 : data.find(function (wallet) {\n      return wallet.is_active;\n    });\n  }, [data]);\n  return useActiveWalletAccount_objectSpread({\n    /** User's current active wallet. */\n    data: active_wallet\n  }, rest);\n};\n/* harmony default export */ const hooks_useActiveWalletAccount = ((/* unused pure expression or super */ null && (useActiveWalletAccount_useActiveWalletAccount)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useSettings.ts\nfunction useSettings_typeof(obj) { \"@babel/helpers - typeof\"; return useSettings_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useSettings_typeof(obj); }\nvar useSettings_excluded = (/* unused pure expression or super */ null && ([\"data\"])),\n  _excluded2 = (/* unused pure expression or super */ null && ([\"mutate\"]));\nfunction useSettings_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useSettings_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useSettings_ownKeys(Object(source), !0).forEach(function (key) { useSettings_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useSettings_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useSettings_defineProperty(obj, key, value) { key = useSettings_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useSettings_toPropertyKey(arg) { var key = useSettings_toPrimitive(arg, \"string\"); return useSettings_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useSettings_toPrimitive(input, hint) { if (useSettings_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useSettings_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useSettings_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useSettings_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useSettings_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n/** A custom hook to get and update the user settings. */\nvar useSettings_useSettings = function useSettings() {\n  var _useQuery = useQuery('get_settings'),\n    data = _useQuery.data,\n    rest = useSettings_objectWithoutProperties(_useQuery, useSettings_excluded);\n  var _useMutation = useMutation('set_settings', {\n      onSuccess: function onSuccess() {\n        return invalidate('get_settings');\n      }\n    }),\n    mutate = _useMutation.mutate,\n    mutate_rest = useSettings_objectWithoutProperties(_useMutation, _excluded2);\n  var invalidate = useInvalidateQuery();\n  var update = useCallback(function (payload) {\n    return mutate({\n      payload: payload\n    });\n  }, [mutate]);\n\n  // Add additional information to the settings response.\n  var modified_settings = useMemo(function () {\n    return useSettings_objectSpread({}, data === null || data === void 0 ? void 0 : data.get_settings);\n  }, [data === null || data === void 0 ? void 0 : data.get_settings]);\n  return useSettings_objectSpread({\n    /** The settings response. */\n    data: modified_settings,\n    /** Function to update user settings */\n    update: update,\n    /** The mutation related information */\n    mutation: mutate_rest\n  }, rest);\n};\n/* harmony default export */ const hooks_useSettings = ((/* unused pure expression or super */ null && (useSettings_useSettings)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useLandingCompany.ts\nfunction useLandingCompany_typeof(obj) { \"@babel/helpers - typeof\"; return useLandingCompany_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useLandingCompany_typeof(obj); }\nvar useLandingCompany_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useLandingCompany_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useLandingCompany_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useLandingCompany_ownKeys(Object(source), !0).forEach(function (key) { useLandingCompany_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useLandingCompany_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useLandingCompany_defineProperty(obj, key, value) { key = useLandingCompany_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useLandingCompany_toPropertyKey(arg) { var key = useLandingCompany_toPrimitive(arg, \"string\"); return useLandingCompany_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useLandingCompany_toPrimitive(input, hint) { if (useLandingCompany_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useLandingCompany_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useLandingCompany_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useLandingCompany_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useLandingCompany_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n/** A custom hook that returns the available landing companies of the user's country. */\nvar useLandingCompany_useLandingCompany = function useLandingCompany() {\n  var _useSettings = useSettings(),\n    settings_data = _useSettings.data;\n  var _useQuery = useQuery('landing_company', {\n      payload: {\n        landing_company: (settings_data === null || settings_data === void 0 ? void 0 : settings_data.country_code) || ''\n      },\n      options: {\n        enabled: Boolean(settings_data === null || settings_data === void 0 ? void 0 : settings_data.country_code)\n      }\n    }),\n    data = _useQuery.data,\n    rest = useLandingCompany_objectWithoutProperties(_useQuery, useLandingCompany_excluded);\n\n  // Add additional information to the landing company response.\n  var modified_landing_company = useMemo(function () {\n    if (!(data !== null && data !== void 0 && data.landing_company)) return;\n    return useLandingCompany_objectSpread({}, data.landing_company);\n  }, [data === null || data === void 0 ? void 0 : data.landing_company]);\n  return useLandingCompany_objectSpread({\n    /** The landing company response. */\n    data: modified_landing_company\n  }, rest);\n};\n/* harmony default export */ const hooks_useLandingCompany = ((/* unused pure expression or super */ null && (useLandingCompany_useLandingCompany)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useAllAvailableAccounts.ts\nfunction useAllAvailableAccounts_typeof(obj) { \"@babel/helpers - typeof\"; return useAllAvailableAccounts_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useAllAvailableAccounts_typeof(obj); }\nvar useAllAvailableAccounts_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useAllAvailableAccounts_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useAllAvailableAccounts_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useAllAvailableAccounts_ownKeys(Object(source), !0).forEach(function (key) { useAllAvailableAccounts_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useAllAvailableAccounts_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useAllAvailableAccounts_defineProperty(obj, key, value) { key = useAllAvailableAccounts_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useAllAvailableAccounts_toPropertyKey(arg) { var key = useAllAvailableAccounts_toPrimitive(arg, \"string\"); return useAllAvailableAccounts_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useAllAvailableAccounts_toPrimitive(input, hint) { if (useAllAvailableAccounts_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useAllAvailableAccounts_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useAllAvailableAccounts_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useAllAvailableAccounts_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useAllAvailableAccounts_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n/** A custom hook to get all available accounts that user can have. */\nvar useAllAvailableAccounts_useAllAvailableAccounts = function useAllAvailableAccounts() {\n  var _landing_company_data;\n  var _useLandingCompany = useLandingCompany(),\n    landing_company_data = _useLandingCompany.data;\n  var _useAccountTypes = useAccountTypes(landing_company_data === null || landing_company_data === void 0 ? void 0 : (_landing_company_data = landing_company_data.financial_company) === null || _landing_company_data === void 0 ? void 0 : _landing_company_data.shortcode),\n    account_types_data = _useAccountTypes.data,\n    rest = useAllAvailableAccounts_objectWithoutProperties(_useAccountTypes, useAllAvailableAccounts_excluded);\n\n  // Add additional information to the account types response.\n  var modified_account_types_data = useMemo(function () {\n    if (!account_types_data) return;\n    return useAllAvailableAccounts_objectSpread({}, account_types_data);\n  }, [account_types_data]);\n  return useAllAvailableAccounts_objectSpread({\n    /** The account types response. */\n    data: modified_account_types_data\n  }, rest);\n};\n/* harmony default export */ const hooks_useAllAvailableAccounts = ((/* unused pure expression or super */ null && (useAllAvailableAccounts_useAllAvailableAccounts)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useAuthentication.ts\nfunction useAuthentication_typeof(obj) { \"@babel/helpers - typeof\"; return useAuthentication_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useAuthentication_typeof(obj); }\nvar useAuthentication_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useAuthentication_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useAuthentication_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useAuthentication_ownKeys(Object(source), !0).forEach(function (key) { useAuthentication_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useAuthentication_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useAuthentication_defineProperty(obj, key, value) { key = useAuthentication_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useAuthentication_toPropertyKey(arg) { var key = useAuthentication_toPrimitive(arg, \"string\"); return useAuthentication_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useAuthentication_toPrimitive(input, hint) { if (useAuthentication_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useAuthentication_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useAuthentication_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useAuthentication_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useAuthentication_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n/** A custom hook to get the verification status (basically any poi, poa, poinc, poo) of the current user. */\nvar useAuthentication_useAuthentication = function useAuthentication() {\n  var _useGetAccountStatus = useGetAccountStatus(),\n    get_account_status_data = _useGetAccountStatus.data,\n    rest = useAuthentication_objectWithoutProperties(_useGetAccountStatus, useAuthentication_excluded);\n  var modified_account_status = useMemo(function () {\n    var _get_account_status_d, _get_account_status_d2, _get_account_status_d3, _get_account_status_d4, _get_account_status_d5, _get_account_status_d6, _get_account_status_d7, _get_account_status_d8, _get_account_status_d9;\n    if (!get_account_status_data) return;\n    var needs_verification = new Set((_get_account_status_d = get_account_status_data.authentication) === null || _get_account_status_d === void 0 ? void 0 : _get_account_status_d.needs_verification);\n    var account_status = new Set(get_account_status_data === null || get_account_status_data === void 0 ? void 0 : get_account_status_data.status);\n    return useAuthentication_objectSpread(useAuthentication_objectSpread({}, get_account_status_data.authentication), {}, {\n      /** client is required to verify their document (proof of address) */\n      is_poa_needed: needs_verification.has('document'),\n      /** client is required to verify their identity */\n      is_poi_needed: needs_verification.has('identity'),\n      /** client has been age-verified */\n      is_age_verified: account_status.has('age_verification'),\n      /** client is prevented from verifying from idv */\n      is_idv_disallowed: account_status.has('idv_disallowed'),\n      /** client is allowed to perform POI and POA (allow uploading documents) */\n      is_allow_document_upload: account_status.has('is_allow_document_upload'),\n      /** client can resubmit POI documents */\n      is_poi_resubmission_allowed: account_status.has('allow_poi_resubmission'),\n      /** client can resubmit POA documents */\n      is_poa_resubmission_allowed: account_status.has('allow_poa_resubmission'),\n      /** client's name in POI documents does not match */\n      is_poi_name_mismatch: account_status.has('poi_name_mismatch'),\n      /** client's name in POA documents does not match */\n      is_poa_address_mismatch: account_status.has('poa_address_mismatch'),\n      /** client has attempted POI before */\n      has_poa_been_attempted: (get_account_status_data === null || get_account_status_data === void 0 ? void 0 : (_get_account_status_d2 = get_account_status_data.authentication) === null || _get_account_status_d2 === void 0 ? void 0 : (_get_account_status_d3 = _get_account_status_d2.document) === null || _get_account_status_d3 === void 0 ? void 0 : _get_account_status_d3.status) !== 'none',\n      /** client has attempted POA before */\n      has_poi_been_attempted: (get_account_status_data === null || get_account_status_data === void 0 ? void 0 : (_get_account_status_d4 = get_account_status_data.authentication) === null || _get_account_status_d4 === void 0 ? void 0 : (_get_account_status_d5 = _get_account_status_d4.identity) === null || _get_account_status_d5 === void 0 ? void 0 : _get_account_status_d5.status) !== 'none',\n      /** client's poi verification status */\n      poi_status: get_account_status_data === null || get_account_status_data === void 0 ? void 0 : (_get_account_status_d6 = get_account_status_data.authentication) === null || _get_account_status_d6 === void 0 ? void 0 : (_get_account_status_d7 = _get_account_status_d6.identity) === null || _get_account_status_d7 === void 0 ? void 0 : _get_account_status_d7.status,\n      /** client's poa verification status */\n      poa_status: get_account_status_data === null || get_account_status_data === void 0 ? void 0 : (_get_account_status_d8 = get_account_status_data.authentication) === null || _get_account_status_d8 === void 0 ? void 0 : (_get_account_status_d9 = _get_account_status_d8.document) === null || _get_account_status_d9 === void 0 ? void 0 : _get_account_status_d9.status\n    });\n  }, [get_account_status_data]);\n  return useAuthentication_objectSpread({\n    data: modified_account_status\n  }, rest);\n};\n/* harmony default export */ const hooks_useAuthentication = ((/* unused pure expression or super */ null && (useAuthentication_useAuthentication)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useAvailableMT5Accounts.ts\nfunction useAvailableMT5Accounts_typeof(obj) { \"@babel/helpers - typeof\"; return useAvailableMT5Accounts_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useAvailableMT5Accounts_typeof(obj); }\nvar useAvailableMT5Accounts_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useAvailableMT5Accounts_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useAvailableMT5Accounts_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useAvailableMT5Accounts_ownKeys(Object(source), !0).forEach(function (key) { useAvailableMT5Accounts_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useAvailableMT5Accounts_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useAvailableMT5Accounts_defineProperty(obj, key, value) { key = useAvailableMT5Accounts_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useAvailableMT5Accounts_toPropertyKey(arg) { var key = useAvailableMT5Accounts_toPrimitive(arg, \"string\"); return useAvailableMT5Accounts_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useAvailableMT5Accounts_toPrimitive(input, hint) { if (useAvailableMT5Accounts_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useAvailableMT5Accounts_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useAvailableMT5Accounts_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useAvailableMT5Accounts_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useAvailableMT5Accounts_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\nvar market_type_to_leverage_mapper = {\n  gaming: 500,\n  financial: 1000,\n  all: 100\n};\n\n/** A custom hook to get the list of available MT5 accounts. */\nvar useAvailableMT5Accounts_useAvailableMT5Accounts = function useAvailableMT5Accounts() {\n  var _useAuthorize = useAuthorize(),\n    isSuccess = _useAuthorize.isSuccess;\n  var _useQuery = useQuery('trading_platform_available_accounts', {\n      payload: {\n        platform: 'mt5'\n      },\n      options: {\n        enabled: isSuccess\n      }\n    }),\n    mt5_available_accounts = _useQuery.data,\n    rest = useAvailableMT5Accounts_objectWithoutProperties(_useQuery, useAvailableMT5Accounts_excluded);\n  var modified_mt5_available_accounts = useMemo(function () {\n    var _mt5_available_accoun;\n    return mt5_available_accounts === null || mt5_available_accounts === void 0 ? void 0 : (_mt5_available_accoun = mt5_available_accounts.trading_platform_available_accounts) === null || _mt5_available_accoun === void 0 ? void 0 : _mt5_available_accoun.map(function (account) {\n      return useAvailableMT5Accounts_objectSpread(useAvailableMT5Accounts_objectSpread({}, account), {}, {\n        /** The market type for the account */\n        market_type: account.market_type === 'gaming' ? 'synthetic' : account.market_type,\n        /** The platform for the account */\n        platform: 'mt5',\n        /** Leverage for the account */\n        leverage: market_type_to_leverage_mapper[account.market_type]\n      });\n    });\n  }, [mt5_available_accounts === null || mt5_available_accounts === void 0 ? void 0 : mt5_available_accounts.trading_platform_available_accounts]);\n  return useAvailableMT5Accounts_objectSpread({\n    /** The available MT5 accounts */\n    data: modified_mt5_available_accounts\n  }, rest);\n};\n/* harmony default export */ const hooks_useAvailableMT5Accounts = ((/* unused pure expression or super */ null && (useAvailableMT5Accounts_useAvailableMT5Accounts)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useAvailableWallets.ts\nfunction useAvailableWallets_typeof(obj) { \"@babel/helpers - typeof\"; return useAvailableWallets_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useAvailableWallets_typeof(obj); }\nvar useAvailableWallets_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useAvailableWallets_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useAvailableWallets_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useAvailableWallets_ownKeys(Object(source), !0).forEach(function (key) { useAvailableWallets_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useAvailableWallets_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useAvailableWallets_defineProperty(obj, key, value) { key = useAvailableWallets_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useAvailableWallets_toPropertyKey(arg) { var key = useAvailableWallets_toPrimitive(arg, \"string\"); return useAvailableWallets_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useAvailableWallets_toPrimitive(input, hint) { if (useAvailableWallets_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useAvailableWallets_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useAvailableWallets_toConsumableArray(arr) { return useAvailableWallets_arrayWithoutHoles(arr) || useAvailableWallets_iterableToArray(arr) || useAvailableWallets_unsupportedIterableToArray(arr) || useAvailableWallets_nonIterableSpread(); }\nfunction useAvailableWallets_nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction useAvailableWallets_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return useAvailableWallets_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return useAvailableWallets_arrayLikeToArray(o, minLen); }\nfunction useAvailableWallets_iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction useAvailableWallets_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return useAvailableWallets_arrayLikeToArray(arr); }\nfunction useAvailableWallets_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction useAvailableWallets_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useAvailableWallets_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useAvailableWallets_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n/** A custom hook that gets the list of available wallets. */\nvar useAvailableWallets = function useAvailableWallets() {\n  var _useAllAvailableAccou = useAllAvailableAccounts(),\n    account_type_data = _useAllAvailableAccou.data,\n    rest = useAvailableWallets_objectWithoutProperties(_useAllAvailableAccou, useAvailableWallets_excluded);\n  var _useWalletAccountsLis = useWalletAccountsList(),\n    added_wallets = _useWalletAccountsLis.data;\n  var _useCurrencyConfig = useCurrencyConfig(),\n    getConfig = _useCurrencyConfig.getConfig;\n\n  /** Get the available wallets for the wallet account type */\n  var modified_available_wallets = useMemo(function () {\n    if (!account_type_data) return;\n    var _ref = (account_type_data === null || account_type_data === void 0 ? void 0 : account_type_data.wallet) || {},\n      crypto = _ref.crypto,\n      doughflow = _ref.doughflow;\n    var crypto_currencies = crypto === null || crypto === void 0 ? void 0 : crypto.currencies;\n    var fiat_currencies = doughflow === null || doughflow === void 0 ? void 0 : doughflow.currencies;\n    if (!crypto_currencies || !fiat_currencies) return [];\n    var available_currencies = [].concat(useAvailableWallets_toConsumableArray(fiat_currencies), useAvailableWallets_toConsumableArray(crypto_currencies));\n    var non_virtual_wallets = added_wallets === null || added_wallets === void 0 ? void 0 : added_wallets.filter(function (wallet) {\n      return !wallet.is_virtual;\n    });\n\n    /** Compare the available wallets with the added wallets and add `is_added` flag */\n    var modified_wallets = non_virtual_wallets === null || non_virtual_wallets === void 0 ? void 0 : non_virtual_wallets.map(function (wallet) {\n      return {\n        currency: wallet.currency,\n        landing_company_name: wallet.landing_company_name,\n        is_added: true\n      };\n    });\n\n    /** Compare the available wallets with the added wallets and add `is_added` flag */\n    var available_wallets = available_currencies.filter(function (currency) {\n      return !(modified_wallets !== null && modified_wallets !== void 0 && modified_wallets.some(function (wallet) {\n        return wallet.currency === currency;\n      }));\n    }).map(function (currency) {\n      return {\n        currency: currency,\n        landing_company_name: account_type_data === null || account_type_data === void 0 ? void 0 : account_type_data.landing_company,\n        is_added: false\n      };\n    });\n    return [].concat(useAvailableWallets_toConsumableArray(available_wallets), useAvailableWallets_toConsumableArray(modified_wallets || []));\n  }, [account_type_data, added_wallets]);\n\n  /** Sort the available wallets by fiat, crypto, then virtual */\n  var sorted_available_wallets = useMemo(function () {\n    if (!modified_available_wallets) return;\n    var getConfigIsCrypto = function getConfigIsCrypto(currency) {\n      var _getConfig;\n      return (_getConfig = getConfig(currency)) === null || _getConfig === void 0 ? void 0 : _getConfig.is_crypto;\n    };\n\n    // Sort the non-added wallets alphabetically by fiat, crypto, then virtual\n    modified_available_wallets.sort(function (a, b) {\n      var a_config = getConfigIsCrypto(a.currency || 'BTC');\n      var b_config = getConfigIsCrypto(b.currency || 'BTC');\n      if (a_config !== b_config) return a.currency ? 1 : -1;\n      return (a.currency || 'USD').localeCompare(b.currency || 'USD');\n    });\n\n    // Sort the added wallets alphabetically by fiat, crypto, then virtual (if any)\n    if (Array.isArray(modified_available_wallets)) {\n      modified_available_wallets === null || modified_available_wallets === void 0 ? void 0 : modified_available_wallets.sort(function (a, b) {\n        var a_config = getConfigIsCrypto(a.currency || 'BTC');\n        var b_config = getConfigIsCrypto(b.currency || 'BTC');\n        if (a_config !== b_config) return a_config ? 1 : -1;\n        return (a.currency || 'USD').localeCompare(b.currency || 'USD');\n      });\n    }\n    return useAvailableWallets_toConsumableArray(modified_available_wallets);\n  }, [modified_available_wallets, getConfig]);\n  return useAvailableWallets_objectSpread({\n    /** Sorted available wallets */\n    data: sorted_available_wallets\n  }, rest);\n};\n/* harmony default export */ const hooks_useAvailableWallets = ((/* unused pure expression or super */ null && (useAvailableWallets)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useMT5AccountsList.ts\nfunction useMT5AccountsList_typeof(obj) { \"@babel/helpers - typeof\"; return useMT5AccountsList_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useMT5AccountsList_typeof(obj); }\nvar useMT5AccountsList_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useMT5AccountsList_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useMT5AccountsList_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useMT5AccountsList_ownKeys(Object(source), !0).forEach(function (key) { useMT5AccountsList_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useMT5AccountsList_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useMT5AccountsList_defineProperty(obj, key, value) { key = useMT5AccountsList_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useMT5AccountsList_toPropertyKey(arg) { var key = useMT5AccountsList_toPrimitive(arg, \"string\"); return useMT5AccountsList_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useMT5AccountsList_toPrimitive(input, hint) { if (useMT5AccountsList_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useMT5AccountsList_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useMT5AccountsList_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useMT5AccountsList_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useMT5AccountsList_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n/** A custom hook that gets the list created MT5 accounts of the user. */\nvar useMT5AccountsList_useMT5AccountsList = function useMT5AccountsList() {\n  var _useAuthorize = useAuthorize(),\n    authorize_data = _useAuthorize.data,\n    isSuccess = _useAuthorize.isSuccess;\n  var _useActiveWalletAccou = useActiveWalletAccount(),\n    wallet = _useActiveWalletAccou.data;\n  var _useQuery = useQuery('mt5_login_list', {\n      options: {\n        enabled: isSuccess\n      }\n    }),\n    mt5_accounts = _useQuery.data,\n    mt5_accounts_rest = useMT5AccountsList_objectWithoutProperties(_useQuery, useMT5AccountsList_excluded);\n\n  /**\n   * @description The list of created MT5 accounts\n   */\n  var modified_mt5_accounts = useMemo(function () {\n    var _mt5_accounts$mt5_log;\n    /** Adding the neccesary properties to the response */\n    var getAccountInfo = function getAccountInfo(login) {\n      var _wallet$linked_to, _wallet$linked_to$fin;\n      return {\n        /** The platform of the account linked to the wallet */\n        platform: wallet === null || wallet === void 0 ? void 0 : (_wallet$linked_to = wallet.linked_to) === null || _wallet$linked_to === void 0 ? void 0 : (_wallet$linked_to$fin = _wallet$linked_to.find(function (linked) {\n          return linked.loginid === login;\n        })) === null || _wallet$linked_to$fin === void 0 ? void 0 : _wallet$linked_to$fin.platform,\n        /** The formatted display login of the account */\n        display_login: login === null || login === void 0 ? void 0 : login.replace(/^(MT[DR]?)/, '')\n      };\n    };\n    var displayBalanceFormat = function displayBalanceFormat(balance, currency) {\n      try {\n        return \"\".concat(Intl.NumberFormat((authorize_data === null || authorize_data === void 0 ? void 0 : authorize_data.preferred_language) || 'en-US', {\n          minimumFractionDigits: 2,\n          maximumFractionDigits: 2,\n          minimumIntegerDigits: 1\n        }).format(balance), \" \").concat(currency || 'USD');\n      } catch (error) {\n        return \"\".concat(balance, \" \").concat(currency || 'USD');\n      }\n    };\n    return mt5_accounts === null || mt5_accounts === void 0 ? void 0 : (_mt5_accounts$mt5_log = mt5_accounts.mt5_login_list) === null || _mt5_accounts$mt5_log === void 0 ? void 0 : _mt5_accounts$mt5_log.map(function (account) {\n      return useMT5AccountsList_objectSpread(useMT5AccountsList_objectSpread(useMT5AccountsList_objectSpread({}, account), getAccountInfo(account.login)), {}, {\n        /** The id of the account */\n        loginid: account.login,\n        /** The platform of the account */\n        platform: 'mt5',\n        /** The balance of the account in currency format. */\n        display_balance: displayBalanceFormat(account.balance || 0, account.currency || 'USD')\n      });\n    });\n  }, [authorize_data === null || authorize_data === void 0 ? void 0 : authorize_data.preferred_language, mt5_accounts === null || mt5_accounts === void 0 ? void 0 : mt5_accounts.mt5_login_list, wallet === null || wallet === void 0 ? void 0 : wallet.linked_to]);\n  return useMT5AccountsList_objectSpread({\n    /** The list of created MT5 accounts */\n    data: modified_mt5_accounts\n  }, mt5_accounts_rest);\n};\n/* harmony default export */ const hooks_useMT5AccountsList = ((/* unused pure expression or super */ null && (useMT5AccountsList_useMT5AccountsList)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useDxtradeAccountsList.ts\nfunction useDxtradeAccountsList_typeof(obj) { \"@babel/helpers - typeof\"; return useDxtradeAccountsList_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useDxtradeAccountsList_typeof(obj); }\nvar useDxtradeAccountsList_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useDxtradeAccountsList_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useDxtradeAccountsList_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useDxtradeAccountsList_ownKeys(Object(source), !0).forEach(function (key) { useDxtradeAccountsList_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useDxtradeAccountsList_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useDxtradeAccountsList_defineProperty(obj, key, value) { key = useDxtradeAccountsList_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useDxtradeAccountsList_toPropertyKey(arg) { var key = useDxtradeAccountsList_toPrimitive(arg, \"string\"); return useDxtradeAccountsList_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useDxtradeAccountsList_toPrimitive(input, hint) { if (useDxtradeAccountsList_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useDxtradeAccountsList_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useDxtradeAccountsList_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useDxtradeAccountsList_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useDxtradeAccountsList_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n/** A custom hook that gets the list of created Deriv X accounts. */\nvar useDxtradeAccountsList_useDxtradeAccountsList = function useDxtradeAccountsList() {\n  var _useAuthorize = useAuthorize(),\n    authorize_data = _useAuthorize.data,\n    isSuccess = _useAuthorize.isSuccess;\n  var _useQuery = useQuery('trading_platform_accounts', {\n      payload: {\n        platform: 'dxtrade'\n      },\n      options: {\n        enabled: isSuccess\n      }\n    }),\n    dxtrade_accounts = _useQuery.data,\n    rest = useDxtradeAccountsList_objectWithoutProperties(_useQuery, useDxtradeAccountsList_excluded);\n\n  /** Adding necessary properties to Deriv X accounts */\n  var modified_dxtrade_accounts = useMemo(function () {\n    var _dxtrade_accounts$tra;\n    return dxtrade_accounts === null || dxtrade_accounts === void 0 ? void 0 : (_dxtrade_accounts$tra = dxtrade_accounts.trading_platform_accounts) === null || _dxtrade_accounts$tra === void 0 ? void 0 : _dxtrade_accounts$tra.map(function (account) {\n      return useDxtradeAccountsList_objectSpread(useDxtradeAccountsList_objectSpread({}, account), {}, {\n        /** The balance of the account in currency format. */\n        display_balance: \"\".concat(Intl.NumberFormat((authorize_data === null || authorize_data === void 0 ? void 0 : authorize_data.preferred_language) || 'en-US', {\n          minimumFractionDigits: 2,\n          maximumFractionDigits: 2,\n          minimumIntegerDigits: 1\n        }).format((account === null || account === void 0 ? void 0 : account.balance) || 0), \" \").concat((account === null || account === void 0 ? void 0 : account.currency) || 'USD')\n      });\n    });\n  }, [authorize_data === null || authorize_data === void 0 ? void 0 : authorize_data.preferred_language, dxtrade_accounts === null || dxtrade_accounts === void 0 ? void 0 : dxtrade_accounts.trading_platform_accounts]);\n  return useDxtradeAccountsList_objectSpread({\n    /** List of all created Deriv X accounts */\n    data: modified_dxtrade_accounts\n  }, rest);\n};\n/* harmony default export */ const hooks_useDxtradeAccountsList = ((/* unused pure expression or super */ null && (useDxtradeAccountsList_useDxtradeAccountsList)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useDerivezServiceToken.ts\nfunction useDerivezServiceToken_typeof(obj) { \"@babel/helpers - typeof\"; return useDerivezServiceToken_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useDerivezServiceToken_typeof(obj); }\nvar useDerivezServiceToken_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useDerivezServiceToken_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useDerivezServiceToken_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useDerivezServiceToken_ownKeys(Object(source), !0).forEach(function (key) { useDerivezServiceToken_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useDerivezServiceToken_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useDerivezServiceToken_defineProperty(obj, key, value) { key = useDerivezServiceToken_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useDerivezServiceToken_toPropertyKey(arg) { var key = useDerivezServiceToken_toPrimitive(arg, \"string\"); return useDerivezServiceToken_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useDerivezServiceToken_toPrimitive(input, hint) { if (useDerivezServiceToken_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useDerivezServiceToken_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useDerivezServiceToken_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useDerivezServiceToken_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useDerivezServiceToken_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n/** A custom hook that get Service Token for DerivEz Platform. */\nvar useDerivezServiceToken_useDerivezServiceToken = function useDerivezServiceToken() {\n  var _derivez_token$servic, _derivez_token$servic2;\n  var _useActiveAccount = useActiveAccount(),\n    account = _useActiveAccount.data;\n  var _useQuery = useQuery('service_token', {\n      payload: {\n        service: 'pandats',\n        server: account !== null && account !== void 0 && account.is_virtual ? 'demo' : 'real'\n      }\n    }),\n    derivez_token = _useQuery.data,\n    rest = useDerivezServiceToken_objectWithoutProperties(_useQuery, useDerivezServiceToken_excluded);\n  return useDerivezServiceToken_objectSpread({\n    /** return the DerivEz account token */\n    data: derivez_token === null || derivez_token === void 0 ? void 0 : (_derivez_token$servic = derivez_token.service_token) === null || _derivez_token$servic === void 0 ? void 0 : (_derivez_token$servic2 = _derivez_token$servic.pandats) === null || _derivez_token$servic2 === void 0 ? void 0 : _derivez_token$servic2.token\n  }, rest);\n};\n/* harmony default export */ const hooks_useDerivezServiceToken = ((/* unused pure expression or super */ null && (useDerivezServiceToken_useDerivezServiceToken)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useDerivezAccountsList.ts\nfunction useDerivezAccountsList_typeof(obj) { \"@babel/helpers - typeof\"; return useDerivezAccountsList_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useDerivezAccountsList_typeof(obj); }\nfunction useDerivezAccountsList_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useDerivezAccountsList_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useDerivezAccountsList_ownKeys(Object(source), !0).forEach(function (key) { useDerivezAccountsList_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useDerivezAccountsList_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useDerivezAccountsList_defineProperty(obj, key, value) { key = useDerivezAccountsList_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useDerivezAccountsList_toPropertyKey(arg) { var key = useDerivezAccountsList_toPrimitive(arg, \"string\"); return useDerivezAccountsList_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useDerivezAccountsList_toPrimitive(input, hint) { if (useDerivezAccountsList_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useDerivezAccountsList_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\n\n\n/** A custom hook that gets the list of created DerivEz accounts. */\nvar useDerivezAccountsList_useDerivezAccountsList = function useDerivezAccountsList() {\n  var _useAuthorize = useAuthorize(),\n    isSuccess = _useAuthorize.isSuccess;\n  var _useQuery = useQuery('trading_platform_accounts', {\n      payload: {\n        platform: 'derivez'\n      },\n      options: {\n        enabled: isSuccess\n      }\n    }),\n    derivez_accounts = _useQuery.data;\n  var _useDerivezServiceTok = useDerivezServiceToken(),\n    token = _useDerivezServiceTok.data;\n\n  /** Adding necessary properties to DerivEz accounts */\n  var modified_derivez_accounts = useMemo(function () {\n    var _derivez_accounts$tra;\n    return derivez_accounts === null || derivez_accounts === void 0 ? void 0 : (_derivez_accounts$tra = derivez_accounts.trading_platform_accounts) === null || _derivez_accounts$tra === void 0 ? void 0 : _derivez_accounts$tra.map(function (account) {\n      return useDerivezAccountsList_objectSpread(useDerivezAccountsList_objectSpread({}, account), {}, {\n        /** The id for the account */\n        loginid: account.account_id,\n        /** The token for the account */\n        token: token\n      });\n    });\n  }, [derivez_accounts === null || derivez_accounts === void 0 ? void 0 : derivez_accounts.trading_platform_accounts, token]);\n  return {\n    /** List of all created DerivEz accounts */\n    data: modified_derivez_accounts\n  };\n};\n/* harmony default export */ const hooks_useDerivezAccountsList = ((/* unused pure expression or super */ null && (useDerivezAccountsList_useDerivezAccountsList)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useCtraderAccountsList.ts\nfunction useCtraderAccountsList_typeof(obj) { \"@babel/helpers - typeof\"; return useCtraderAccountsList_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useCtraderAccountsList_typeof(obj); }\nvar useCtraderAccountsList_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useCtraderAccountsList_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useCtraderAccountsList_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useCtraderAccountsList_ownKeys(Object(source), !0).forEach(function (key) { useCtraderAccountsList_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useCtraderAccountsList_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useCtraderAccountsList_defineProperty(obj, key, value) { key = useCtraderAccountsList_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useCtraderAccountsList_toPropertyKey(arg) { var key = useCtraderAccountsList_toPrimitive(arg, \"string\"); return useCtraderAccountsList_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useCtraderAccountsList_toPrimitive(input, hint) { if (useCtraderAccountsList_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useCtraderAccountsList_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useCtraderAccountsList_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useCtraderAccountsList_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useCtraderAccountsList_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n/** A custom hook that gets the list of created cTrader accounts. */\nvar useCtraderAccountsList_useCtraderAccountsList = function useCtraderAccountsList() {\n  var _useAuthorize = useAuthorize(),\n    isSuccess = _useAuthorize.isSuccess;\n  var _useQuery = useQuery('trading_platform_accounts', {\n      payload: {\n        platform: 'ctrader'\n      },\n      options: {\n        enabled: isSuccess\n      }\n    }),\n    ctrader_accounts = _useQuery.data,\n    rest = useCtraderAccountsList_objectWithoutProperties(_useQuery, useCtraderAccountsList_excluded);\n\n  /** Adding neccesary properties to cTrader accounts */\n  var modified_ctrader_accounts = useMemo(function () {\n    var _ctrader_accounts$tra;\n    return ctrader_accounts === null || ctrader_accounts === void 0 ? void 0 : (_ctrader_accounts$tra = ctrader_accounts.trading_platform_accounts) === null || _ctrader_accounts$tra === void 0 ? void 0 : _ctrader_accounts$tra.map(function (account) {\n      return useCtraderAccountsList_objectSpread(useCtraderAccountsList_objectSpread({}, account), {}, {\n        /** The id of the cTrader account */\n        id: account.account_id\n      });\n    });\n  }, [ctrader_accounts === null || ctrader_accounts === void 0 ? void 0 : ctrader_accounts.trading_platform_accounts]);\n  return useCtraderAccountsList_objectSpread({\n    /** List of all created cTrader accounts */\n    data: modified_ctrader_accounts\n  }, rest);\n};\n/* harmony default export */ const hooks_useCtraderAccountsList = ((/* unused pure expression or super */ null && (useCtraderAccountsList_useCtraderAccountsList)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useCFDAccountsList.ts\n\n\n\n\n\n\n/** A custom hook that gets the list all created CFD accounts of the user. */\nvar useCFDAccountsList = function useCFDAccountsList() {\n  var _useMT5AccountsList = useMT5AccountsList(),\n    mt5_accounts = _useMT5AccountsList.data;\n  var _useDxtradeAccountsLi = useDxtradeAccountsList(),\n    dxtrade_accounts = _useDxtradeAccountsLi.data;\n  var _useDerivezAccountsLi = useDerivezAccountsList(),\n    derivez_accounts = _useDerivezAccountsLi.data;\n  var _useCtraderAccountsLi = useCtraderAccountsList(),\n    ctrader_accounts = _useCtraderAccountsLi.data;\n  var data = useMemo(function () {\n    if (!mt5_accounts || !dxtrade_accounts || !derivez_accounts || !ctrader_accounts) return;\n    return {\n      mt5_accounts: mt5_accounts || [],\n      dxtrade_accounts: dxtrade_accounts || [],\n      derivez_accounts: derivez_accounts || [],\n      ctrader_accounts: ctrader_accounts || []\n    };\n  }, [mt5_accounts, dxtrade_accounts, derivez_accounts, ctrader_accounts]);\n  return {\n    /** The list of created MT5 and Non-MT5 accounts */\n    data: data\n  };\n};\n/* harmony default export */ const hooks_useCFDAccountsList = ((/* unused pure expression or super */ null && (useCFDAccountsList)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useCancelCryptoTransaction.ts\nfunction useCancelCryptoTransaction_typeof(obj) { \"@babel/helpers - typeof\"; return useCancelCryptoTransaction_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useCancelCryptoTransaction_typeof(obj); }\nvar useCancelCryptoTransaction_excluded = (/* unused pure expression or super */ null && ([\"data\", \"mutate\"]));\nfunction useCancelCryptoTransaction_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useCancelCryptoTransaction_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useCancelCryptoTransaction_ownKeys(Object(source), !0).forEach(function (key) { useCancelCryptoTransaction_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useCancelCryptoTransaction_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useCancelCryptoTransaction_defineProperty(obj, key, value) { key = useCancelCryptoTransaction_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useCancelCryptoTransaction_toPropertyKey(arg) { var key = useCancelCryptoTransaction_toPrimitive(arg, \"string\"); return useCancelCryptoTransaction_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useCancelCryptoTransaction_toPrimitive(input, hint) { if (useCancelCryptoTransaction_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useCancelCryptoTransaction_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useCancelCryptoTransaction_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useCancelCryptoTransaction_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useCancelCryptoTransaction_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n/** A custom hooks for cancelling crypto transaction  */\nvar useCancelCryptoTransaction = function useCancelCryptoTransaction() {\n  var _useMutation = useMutation('cashier_withdrawal_cancel'),\n    data = _useMutation.data,\n    mutate = _useMutation.mutate,\n    rest = useCancelCryptoTransaction_objectWithoutProperties(_useMutation, useCancelCryptoTransaction_excluded);\n  return useCancelCryptoTransaction_objectSpread({\n    /** The cancel crypto transaction response */\n    data: data === null || data === void 0 ? void 0 : data.cashier_withdrawal_cancel,\n    /** Function to cancel crypto transaction */\n    mutate: mutate\n  }, rest);\n};\n/* harmony default export */ const hooks_useCancelCryptoTransaction = ((/* unused pure expression or super */ null && (useCancelCryptoTransaction)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useCashierFiatAddress.ts\nfunction useCashierFiatAddress_typeof(obj) { \"@babel/helpers - typeof\"; return useCashierFiatAddress_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useCashierFiatAddress_typeof(obj); }\nvar useCashierFiatAddress_excluded = (/* unused pure expression or super */ null && ([\"data\", \"mutate\"]));\nfunction useCashierFiatAddress_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useCashierFiatAddress_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useCashierFiatAddress_ownKeys(Object(source), !0).forEach(function (key) { useCashierFiatAddress_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useCashierFiatAddress_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useCashierFiatAddress_defineProperty(obj, key, value) { key = useCashierFiatAddress_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useCashierFiatAddress_toPropertyKey(arg) { var key = useCashierFiatAddress_toPrimitive(arg, \"string\"); return useCashierFiatAddress_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useCashierFiatAddress_toPrimitive(input, hint) { if (useCashierFiatAddress_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useCashierFiatAddress_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useCashierFiatAddress_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useCashierFiatAddress_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useCashierFiatAddress_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n/** A custom hook to get the deposit and withdrawal fiat address. */\nvar useCashierFiatAddress = function useCashierFiatAddress() {\n  var _useMutation = useMutation('cashier'),\n    data = _useMutation.data,\n    _mutate = _useMutation.mutate,\n    rest = useCashierFiatAddress_objectWithoutProperties(_useMutation, useCashierFiatAddress_excluded);\n  var iframe_url = typeof (data === null || data === void 0 ? void 0 : data.cashier) === 'string' ? data === null || data === void 0 ? void 0 : data.cashier : undefined;\n  var mutate = useCallback(function (cashier, payload) {\n    return _mutate({\n      payload: useCashierFiatAddress_objectSpread({\n        cashier: cashier,\n        provider: 'doughflow'\n      }, payload)\n    });\n  }, [_mutate]);\n  return useCashierFiatAddress_objectSpread({\n    /** The deposit/withdrawal fiat iframe */\n    data: iframe_url,\n    /** Function to get deposit/withdrawal fiat address */\n    mutate: mutate\n  }, rest);\n};\n/* harmony default export */ const hooks_useCashierFiatAddress = ((/* unused pure expression or super */ null && (useCashierFiatAddress)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useCountryConfig.ts\nfunction useCountryConfig_typeof(obj) { \"@babel/helpers - typeof\"; return useCountryConfig_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useCountryConfig_typeof(obj); }\nvar useCountryConfig_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useCountryConfig_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useCountryConfig_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useCountryConfig_ownKeys(Object(source), !0).forEach(function (key) { useCountryConfig_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useCountryConfig_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useCountryConfig_defineProperty(obj, key, value) { key = useCountryConfig_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useCountryConfig_toPropertyKey(arg) { var key = useCountryConfig_toPrimitive(arg, \"string\"); return useCountryConfig_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useCountryConfig_toPrimitive(input, hint) { if (useCountryConfig_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useCountryConfig_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useCountryConfig_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useCountryConfig_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useCountryConfig_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n/** A custom hook to get the country config information from `residence_list` endpoint. */\nvar useCountryConfig = function useCountryConfig() {\n  var _useQuery = useQuery('residence_list'),\n    residence_list_data = _useQuery.data,\n    rest = useCountryConfig_objectWithoutProperties(_useQuery, useCountryConfig_excluded);\n\n  // Add additional information to the country config.\n  var modified_residence_list = useMemo(function () {\n    var _residence_list_data$;\n    return residence_list_data === null || residence_list_data === void 0 ? void 0 : (_residence_list_data$ = residence_list_data.residence_list) === null || _residence_list_data$ === void 0 ? void 0 : _residence_list_data$.map(function (country_config) {\n      var _country_config$ident, _country_config$ident2, _country_config$ident3, _country_config$ident4, _country_config$ident5, _country_config$ident6;\n      return useCountryConfig_objectSpread(useCountryConfig_objectSpread({}, country_config), {}, {\n        /** Determine if the country is disabled */\n        is_disabled: country_config.disabled !== undefined,\n        /** 2-letter country code */\n        code: \"\".concat(country_config.value).toUpperCase(),\n        /** Country name */\n        name: \"\".concat(country_config.text),\n        /** Determine if the IDV service is supported for the country */\n        is_idv_supported: ((_country_config$ident = country_config.identity) === null || _country_config$ident === void 0 ? void 0 : (_country_config$ident2 = _country_config$ident.services) === null || _country_config$ident2 === void 0 ? void 0 : (_country_config$ident3 = _country_config$ident2.idv) === null || _country_config$ident3 === void 0 ? void 0 : _country_config$ident3.is_country_supported) === 1,\n        /** Determine if the Onfido service is supported for the country */\n        is_onfido_supported: ((_country_config$ident4 = country_config.identity) === null || _country_config$ident4 === void 0 ? void 0 : (_country_config$ident5 = _country_config$ident4.services) === null || _country_config$ident5 === void 0 ? void 0 : (_country_config$ident6 = _country_config$ident5.onfido) === null || _country_config$ident6 === void 0 ? void 0 : _country_config$ident6.is_country_supported) === 1\n      });\n    });\n  }, [residence_list_data === null || residence_list_data === void 0 ? void 0 : residence_list_data.residence_list]);\n\n  // Transform the country config array into a record object.\n  var transformed_residence_list = useMemo(function () {\n    return modified_residence_list === null || modified_residence_list === void 0 ? void 0 : modified_residence_list.reduce(function (previous, current) {\n      return useCountryConfig_objectSpread(useCountryConfig_objectSpread({}, previous), {}, useCountryConfig_defineProperty({}, current.code, current));\n    }, {});\n  }, [modified_residence_list]);\n  var getConfig = useCallback(function (currency) {\n    return transformed_residence_list === null || transformed_residence_list === void 0 ? void 0 : transformed_residence_list[currency];\n  }, [transformed_residence_list]);\n  return useCountryConfig_objectSpread({\n    /** Available countries and their information */\n    data: transformed_residence_list,\n    /** Returns the country config object for the given country code */\n    getConfig: getConfig\n  }, rest);\n};\n/* harmony default export */ const hooks_useCountryConfig = ((/* unused pure expression or super */ null && (useCountryConfig)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useCreateMT5Account.ts\nfunction useCreateMT5Account_typeof(obj) { \"@babel/helpers - typeof\"; return useCreateMT5Account_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useCreateMT5Account_typeof(obj); }\nvar useCreateMT5Account_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useCreateMT5Account_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useCreateMT5Account_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useCreateMT5Account_ownKeys(Object(source), !0).forEach(function (key) { useCreateMT5Account_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useCreateMT5Account_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useCreateMT5Account_defineProperty(obj, key, value) { key = useCreateMT5Account_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useCreateMT5Account_toPropertyKey(arg) { var key = useCreateMT5Account_toPrimitive(arg, \"string\"); return useCreateMT5Account_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useCreateMT5Account_toPrimitive(input, hint) { if (useCreateMT5Account_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useCreateMT5Account_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useCreateMT5Account_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useCreateMT5Account_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useCreateMT5Account_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n/** A custom hook to create MT5 accounts. */\nvar useCreateMT5Account = function useCreateMT5Account() {\n  var invalidate = useInvalidateQuery();\n  var _useMutation = useMutation('mt5_new_account', {\n      onSuccess: function onSuccess() {\n        invalidate('mt5_login_list');\n      }\n    }),\n    data = _useMutation.data,\n    rest = useCreateMT5Account_objectWithoutProperties(_useMutation, useCreateMT5Account_excluded);\n\n  // Add additional information to the create MT5 account response.\n  var modified_data = useMemo(function () {\n    if (!(data !== null && data !== void 0 && data.mt5_new_account)) return undefined;\n    return useCreateMT5Account_objectSpread({}, data === null || data === void 0 ? void 0 : data.mt5_new_account);\n  }, [data]);\n  return useCreateMT5Account_objectSpread({\n    /** The response and the mutation of the create MT5 account API request */\n    data: modified_data\n  }, rest);\n};\n/* harmony default export */ const hooks_useCreateMT5Account = ((/* unused pure expression or super */ null && (useCreateMT5Account)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useCreateNewRealAccount.ts\nfunction useCreateNewRealAccount_typeof(obj) { \"@babel/helpers - typeof\"; return useCreateNewRealAccount_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useCreateNewRealAccount_typeof(obj); }\nvar useCreateNewRealAccount_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useCreateNewRealAccount_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useCreateNewRealAccount_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useCreateNewRealAccount_ownKeys(Object(source), !0).forEach(function (key) { useCreateNewRealAccount_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useCreateNewRealAccount_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useCreateNewRealAccount_defineProperty(obj, key, value) { key = useCreateNewRealAccount_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useCreateNewRealAccount_toPropertyKey(arg) { var key = useCreateNewRealAccount_toPrimitive(arg, \"string\"); return useCreateNewRealAccount_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useCreateNewRealAccount_toPrimitive(input, hint) { if (useCreateNewRealAccount_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useCreateNewRealAccount_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useCreateNewRealAccount_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useCreateNewRealAccount_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useCreateNewRealAccount_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n/** A custom hook that creates a new real trading account. */\nvar useCreateNewRealAccount = function useCreateNewRealAccount() {\n  var invalidate = useInvalidateQuery();\n  var _useMutation = useMutation('new_account_real', {\n      onSuccess: function onSuccess() {\n        invalidate('authorize');\n      }\n    }),\n    data = _useMutation.data,\n    rest = useCreateNewRealAccount_objectWithoutProperties(_useMutation, useCreateNewRealAccount_excluded);\n\n  // Add additional information to the new real trading account response.\n  var modified_data = useMemo(function () {\n    if (!(data !== null && data !== void 0 && data.new_account_real)) return;\n    return useCreateNewRealAccount_objectSpread({}, data === null || data === void 0 ? void 0 : data.new_account_real);\n  }, [data]);\n  return useCreateNewRealAccount_objectSpread({\n    /** The response and the mutation of the new account real API request */\n    data: modified_data\n  }, rest);\n};\n/* harmony default export */ const hooks_useCreateNewRealAccount = ((/* unused pure expression or super */ null && (useCreateNewRealAccount)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useCreateOtherCFDAccount.ts\nfunction useCreateOtherCFDAccount_typeof(obj) { \"@babel/helpers - typeof\"; return useCreateOtherCFDAccount_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useCreateOtherCFDAccount_typeof(obj); }\nvar useCreateOtherCFDAccount_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useCreateOtherCFDAccount_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useCreateOtherCFDAccount_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useCreateOtherCFDAccount_ownKeys(Object(source), !0).forEach(function (key) { useCreateOtherCFDAccount_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useCreateOtherCFDAccount_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useCreateOtherCFDAccount_defineProperty(obj, key, value) { key = useCreateOtherCFDAccount_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useCreateOtherCFDAccount_toPropertyKey(arg) { var key = useCreateOtherCFDAccount_toPrimitive(arg, \"string\"); return useCreateOtherCFDAccount_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useCreateOtherCFDAccount_toPrimitive(input, hint) { if (useCreateOtherCFDAccount_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useCreateOtherCFDAccount_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useCreateOtherCFDAccount_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useCreateOtherCFDAccount_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useCreateOtherCFDAccount_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n/** A custom hook to create third party CFD accounts. */\nvar useCreateOtherCFDAccount = function useCreateOtherCFDAccount() {\n  var invalidate = useInvalidateQuery();\n  var _useMutation = useMutation('trading_platform_new_account', {\n      onSuccess: function onSuccess() {\n        invalidate('trading_platform_accounts');\n      }\n    }),\n    data = _useMutation.data,\n    rest = useCreateOtherCFDAccount_objectWithoutProperties(_useMutation, useCreateOtherCFDAccount_excluded);\n\n  // Add additional information to the create Other CFD account response.\n  var modified_data = useMemo(function () {\n    if (!data) return undefined;\n    return useCreateOtherCFDAccount_objectSpread({}, data);\n  }, [data]);\n  return useCreateOtherCFDAccount_objectSpread({\n    /** The response and the mutation of the create third party CFDs API request */\n    data: modified_data\n  }, rest);\n};\n/* harmony default export */ const hooks_useCreateOtherCFDAccount = ((/* unused pure expression or super */ null && (useCreateOtherCFDAccount)));\n;// CONCATENATED MODULE: ../../api/src/useSubscription.ts\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || useSubscription_unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction useSubscription_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return useSubscription_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return useSubscription_arrayLikeToArray(o, minLen); }\nfunction useSubscription_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\nvar useSubscription_useSubscription = function useSubscription(name) {\n  var _useState = (0,external_react_.useState)(false),\n    _useState2 = _slicedToArray(_useState, 2),\n    isLoading = _useState2[0],\n    setIsLoading = _useState2[1];\n  var _useState3 = (0,external_react_.useState)(false),\n    _useState4 = _slicedToArray(_useState3, 2),\n    isSubscribed = _useState4[0],\n    setSubscribed = _useState4[1];\n  var _useState5 = (0,external_react_.useState)(),\n    _useState6 = _slicedToArray(_useState5, 2),\n    error = _useState6[0],\n    setError = _useState6[1];\n  var _useState7 = (0,external_react_.useState)(),\n    _useState8 = _slicedToArray(_useState7, 2),\n    data = _useState8[0],\n    setData = _useState8[1];\n  var subscriber = (0,external_react_.useRef)();\n  var _useAPI = src_useAPI(),\n    _subscribe = _useAPI.subscribe;\n  var subscribe = (0,external_react_.useCallback)(function () {\n    for (var _len = arguments.length, props = new Array(_len), _key = 0; _key < _len; _key++) {\n      props[_key] = arguments[_key];\n    }\n    var prop = props === null || props === void 0 ? void 0 : props[0];\n    var payload = prop && 'payload' in prop ? prop.payload : undefined;\n    setIsLoading(true);\n    setSubscribed(true);\n    try {\n      subscriber.current = _subscribe(name, payload).subscribe(function (response) {\n        setData(response);\n        setIsLoading(false);\n      }, function (response) {\n        setError(response.error);\n        setIsLoading(false);\n      });\n    } catch (e) {\n      setError(e);\n    }\n  }, [_subscribe, name]);\n  var unsubscribe = (0,external_react_.useCallback)(function () {\n    var _subscriber$current, _subscriber$current$u;\n    (_subscriber$current = subscriber.current) === null || _subscriber$current === void 0 ? void 0 : (_subscriber$current$u = _subscriber$current.unsubscribe) === null || _subscriber$current$u === void 0 ? void 0 : _subscriber$current$u.call(_subscriber$current);\n    setSubscribed(false);\n  }, []);\n  (0,external_react_.useEffect)(function () {\n    return function () {\n      unsubscribe();\n    };\n  }, [unsubscribe]);\n  return {\n    subscribe: subscribe,\n    unsubscribe: unsubscribe,\n    isLoading: isLoading,\n    isSubscribed: isSubscribed,\n    error: error,\n    data: data\n  };\n};\n/* harmony default export */ const src_useSubscription = (useSubscription_useSubscription);\n;// CONCATENATED MODULE: ../../api/src/hooks/useCryptoTransactions.ts\nfunction useCryptoTransactions_typeof(obj) { \"@babel/helpers - typeof\"; return useCryptoTransactions_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useCryptoTransactions_typeof(obj); }\nvar useCryptoTransactions_excluded = (/* unused pure expression or super */ null && ([\"subscribe\", \"data\"]));\nfunction useCryptoTransactions_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useCryptoTransactions_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useCryptoTransactions_ownKeys(Object(source), !0).forEach(function (key) { useCryptoTransactions_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useCryptoTransactions_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useCryptoTransactions_defineProperty(obj, key, value) { key = useCryptoTransactions_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useCryptoTransactions_toPropertyKey(arg) { var key = useCryptoTransactions_toPrimitive(arg, \"string\"); return useCryptoTransactions_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useCryptoTransactions_toPrimitive(input, hint) { if (useCryptoTransactions_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useCryptoTransactions_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useCryptoTransactions_toConsumableArray(arr) { return useCryptoTransactions_arrayWithoutHoles(arr) || useCryptoTransactions_iterableToArray(arr) || useCryptoTransactions_unsupportedIterableToArray(arr) || useCryptoTransactions_nonIterableSpread(); }\nfunction useCryptoTransactions_nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction useCryptoTransactions_iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction useCryptoTransactions_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return useCryptoTransactions_arrayLikeToArray(arr); }\nfunction useCryptoTransactions_slicedToArray(arr, i) { return useCryptoTransactions_arrayWithHoles(arr) || useCryptoTransactions_iterableToArrayLimit(arr, i) || useCryptoTransactions_unsupportedIterableToArray(arr, i) || useCryptoTransactions_nonIterableRest(); }\nfunction useCryptoTransactions_nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction useCryptoTransactions_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return useCryptoTransactions_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return useCryptoTransactions_arrayLikeToArray(o, minLen); }\nfunction useCryptoTransactions_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction useCryptoTransactions_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction useCryptoTransactions_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction useCryptoTransactions_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useCryptoTransactions_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useCryptoTransactions_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n/** A custom hook that returns the list of pending crypto transactions for the current user. */\nvar useCryptoTransactions = function useCryptoTransactions() {\n  var _data$cashier_payment2;\n  var _useSubscription = useSubscription('cashier_payments'),\n    subscribe = _useSubscription.subscribe,\n    data = _useSubscription.data,\n    rest = useCryptoTransactions_objectWithoutProperties(_useSubscription, useCryptoTransactions_excluded);\n  var _useState = useState(),\n    _useState2 = useCryptoTransactions_slicedToArray(_useState, 2),\n    transactions = _useState2[0],\n    setTransactions = _useState2[1];\n\n  // Reset transactions data\n  var resetData = useCallback(function () {\n    return setTransactions(undefined);\n  }, []);\n  useEffect(function () {\n    setTransactions(function (old_transactions) {\n      var _data$cashier_payment;\n      var new_transactions = data === null || data === void 0 ? void 0 : (_data$cashier_payment = data.cashier_payments) === null || _data$cashier_payment === void 0 ? void 0 : _data$cashier_payment.crypto;\n      if (!new_transactions) return old_transactions;\n      if (!old_transactions) return new_transactions;\n      var updated_transactions = useCryptoTransactions_toConsumableArray(old_transactions);\n\n      // For each new transaction, check if it exists in the old transactions.\n      new_transactions.forEach(function (new_transaction) {\n        // Find the index of the new transaction in the old transactions if exists.\n        var index = updated_transactions.findIndex(function (old_transaction) {\n          return old_transaction.id === new_transaction.id;\n        });\n\n        // If the new transaction does not exist in the old transactions, add it, otherwise update it.\n        if (index === -1) {\n          updated_transactions.push(new_transaction);\n        } else {\n          updated_transactions[index] = new_transaction;\n        }\n      });\n      return updated_transactions;\n    });\n  }, [data === null || data === void 0 ? void 0 : (_data$cashier_payment2 = data.cashier_payments) === null || _data$cashier_payment2 === void 0 ? void 0 : _data$cashier_payment2.crypto]);\n\n  // Add additional information to each transaction.\n  var modified_transactions = useMemo(function () {\n    if (!transactions || !transactions.length) return undefined;\n    return transactions.map(function (transaction) {\n      return useCryptoTransactions_objectSpread(useCryptoTransactions_objectSpread({}, transaction), {}, {\n        /** Formatted transaction hash */\n        formatted_transaction_hash: transaction.transaction_hash ? getTruncatedString(transaction.transaction_hash, {\n          type: 'middle'\n        }) : 'NA',\n        /** Formatted address hash */\n        formatted_address_hash: transaction.address_hash ? getTruncatedString(transaction.address_hash, {\n          type: 'middle'\n        }) : 'NA',\n        /** Formatted confirmations status */\n        formatted_confirmations: transaction.status_code === 'CONFIRMED' ? 'Confirmed' : transaction.confirmations || 'Pending',\n        /** Determine if the transaction is a deposit or not. */\n        is_deposit: transaction.transaction_type === 'deposit',\n        /** Determine if the transaction is a withdrawal or not. */\n        is_withdrawal: transaction.transaction_type === 'withdrawal'\n      });\n    });\n  }, [transactions]);\n\n  // Sort transactions by submit time.\n  var sorted_transactions = useMemo(function () {\n    return modified_transactions === null || modified_transactions === void 0 ? void 0 : modified_transactions.sort(function (a, b) {\n      return b.submit_date - a.submit_date;\n    });\n  }, [modified_transactions]);\n  // Get the last transaction if exists.\n  var last_transaction = modified_transactions === null || modified_transactions === void 0 ? void 0 : modified_transactions[0];\n  return useCryptoTransactions_objectSpread({\n    /** List of user transactions sorted by submit time. */\n    data: sorted_transactions,\n    /** Returns the last transaction if exists. */\n    last_transaction: last_transaction,\n    /** Reset transactions data */\n    resetData: resetData,\n    subscribe: subscribe\n  }, rest);\n};\n/* harmony default export */ const hooks_useCryptoTransactions = ((/* unused pure expression or super */ null && (useCryptoTransactions)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useCryptoWithdrawal.ts\nfunction useCryptoWithdrawal_typeof(obj) { \"@babel/helpers - typeof\"; return useCryptoWithdrawal_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useCryptoWithdrawal_typeof(obj); }\nvar useCryptoWithdrawal_excluded = (/* unused pure expression or super */ null && ([\"mutate\"]));\nfunction useCryptoWithdrawal_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useCryptoWithdrawal_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useCryptoWithdrawal_ownKeys(Object(source), !0).forEach(function (key) { useCryptoWithdrawal_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useCryptoWithdrawal_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useCryptoWithdrawal_defineProperty(obj, key, value) { key = useCryptoWithdrawal_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useCryptoWithdrawal_toPropertyKey(arg) { var key = useCryptoWithdrawal_toPrimitive(arg, \"string\"); return useCryptoWithdrawal_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useCryptoWithdrawal_toPrimitive(input, hint) { if (useCryptoWithdrawal_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useCryptoWithdrawal_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useCryptoWithdrawal_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useCryptoWithdrawal_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useCryptoWithdrawal_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n/** A custom hook that used for crypto withdrawal */\nvar useCryptoWithdrawal = function useCryptoWithdrawal() {\n  var _useMutation = useMutation('cashier'),\n    _mutate = _useMutation.mutate,\n    rest = useCryptoWithdrawal_objectWithoutProperties(_useMutation, useCryptoWithdrawal_excluded);\n  var mutate = useCallback(function (payload) {\n    return _mutate({\n      payload: useCryptoWithdrawal_objectSpread({\n        cashier: 'withdraw',\n        provider: 'crypto',\n        type: 'api'\n      }, payload)\n    });\n  }, [_mutate]);\n  return useCryptoWithdrawal_objectSpread({\n    /** Function to request for crypto withdrawal */\n    mutate: mutate\n  }, rest);\n};\n/* harmony default export */ const hooks_useCryptoWithdrawal = ((/* unused pure expression or super */ null && (useCryptoWithdrawal)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useCtraderServiceToken.ts\nfunction useCtraderServiceToken_typeof(obj) { \"@babel/helpers - typeof\"; return useCtraderServiceToken_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useCtraderServiceToken_typeof(obj); }\nvar useCtraderServiceToken_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useCtraderServiceToken_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useCtraderServiceToken_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useCtraderServiceToken_ownKeys(Object(source), !0).forEach(function (key) { useCtraderServiceToken_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useCtraderServiceToken_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useCtraderServiceToken_defineProperty(obj, key, value) { key = useCtraderServiceToken_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useCtraderServiceToken_toPropertyKey(arg) { var key = useCtraderServiceToken_toPrimitive(arg, \"string\"); return useCtraderServiceToken_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useCtraderServiceToken_toPrimitive(input, hint) { if (useCtraderServiceToken_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useCtraderServiceToken_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useCtraderServiceToken_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useCtraderServiceToken_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useCtraderServiceToken_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n/** A custom hook that get Service Token for CTrader Platform. */\nvar useCtraderServiceToken = function useCtraderServiceToken() {\n  var _ctrader_token$servic, _ctrader_token$servic2;\n  var _useActiveAccount = useActiveAccount(),\n    account = _useActiveAccount.data;\n  var _useQuery = useQuery('service_token', {\n      payload: {\n        service: 'ctrader',\n        server: account !== null && account !== void 0 && account.is_virtual ? 'demo' : 'real'\n      }\n    }),\n    ctrader_token = _useQuery.data,\n    rest = useCtraderServiceToken_objectWithoutProperties(_useQuery, useCtraderServiceToken_excluded);\n  return useCtraderServiceToken_objectSpread({\n    /** return the ctrader account token */\n    data: ctrader_token === null || ctrader_token === void 0 ? void 0 : (_ctrader_token$servic = ctrader_token.service_token) === null || _ctrader_token$servic === void 0 ? void 0 : (_ctrader_token$servic2 = _ctrader_token$servic.ctrader) === null || _ctrader_token$servic2 === void 0 ? void 0 : _ctrader_token$servic2.token\n  }, rest);\n};\n/* harmony default export */ const hooks_useCtraderServiceToken = ((/* unused pure expression or super */ null && (useCtraderServiceToken)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useDepositCryptoAddress.ts\nfunction useDepositCryptoAddress_typeof(obj) { \"@babel/helpers - typeof\"; return useDepositCryptoAddress_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useDepositCryptoAddress_typeof(obj); }\nvar useDepositCryptoAddress_excluded = (/* unused pure expression or super */ null && ([\"data\", \"mutate\"]));\nfunction useDepositCryptoAddress_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useDepositCryptoAddress_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useDepositCryptoAddress_ownKeys(Object(source), !0).forEach(function (key) { useDepositCryptoAddress_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useDepositCryptoAddress_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useDepositCryptoAddress_defineProperty(obj, key, value) { key = useDepositCryptoAddress_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useDepositCryptoAddress_toPropertyKey(arg) { var key = useDepositCryptoAddress_toPrimitive(arg, \"string\"); return useDepositCryptoAddress_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useDepositCryptoAddress_toPrimitive(input, hint) { if (useDepositCryptoAddress_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useDepositCryptoAddress_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useDepositCryptoAddress_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useDepositCryptoAddress_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useDepositCryptoAddress_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n/** A custom hook to get the deposit crypto address. */\nvar useDepositCryptoAddress = function useDepositCryptoAddress() {\n  var _data$cashier, _data$cashier$deposit;\n  var _useMutation = useMutation('cashier'),\n    data = _useMutation.data,\n    _mutate = _useMutation.mutate,\n    rest = useDepositCryptoAddress_objectWithoutProperties(_useMutation, useDepositCryptoAddress_excluded);\n  var deposit_address = typeof (data === null || data === void 0 ? void 0 : data.cashier) !== 'string' ? data === null || data === void 0 ? void 0 : (_data$cashier = data.cashier) === null || _data$cashier === void 0 ? void 0 : (_data$cashier$deposit = _data$cashier.deposit) === null || _data$cashier$deposit === void 0 ? void 0 : _data$cashier$deposit.address : undefined;\n  var mutate = useCallback(function () {\n    return _mutate({\n      payload: {\n        cashier: 'deposit',\n        provider: 'crypto',\n        type: 'api'\n      }\n    });\n  }, [_mutate]);\n  return useDepositCryptoAddress_objectSpread(useDepositCryptoAddress_objectSpread({}, rest), {}, {\n    mutate: mutate,\n    data: deposit_address\n  });\n};\n/* harmony default export */ const hooks_useDepositCryptoAddress = ((/* unused pure expression or super */ null && (useDepositCryptoAddress)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useDynamicLeverage.ts\n// TODO: hardcoded dynamic leverage values, to be replaced with API call\nvar dynamic_leverages = [{\n  key: 'forex',\n  title: 'Forex majors',\n  description: '',\n  leverage: 'Up to 1:1500',\n  data: [{\n    from: 0.01,\n    to: 1,\n    leverage: 1500\n  }, {\n    from: 1.01,\n    to: 5,\n    leverage: 1000\n  }, {\n    from: 5.01,\n    to: 10,\n    leverage: 500\n  }, {\n    from: 10.01,\n    to: 15,\n    leverage: 100\n  }]\n}, {\n  key: 'metals',\n  title: 'Metals',\n  description: '(XAUUSD, XAGUSD)',\n  leverage: 'Up to 1:1000',\n  data: [{\n    from: 0.01,\n    to: 1,\n    leverage: 1000\n  }, {\n    from: 1.01,\n    to: 5,\n    leverage: 500\n  }, {\n    from: 5.01,\n    to: 10,\n    leverage: 100\n  }, {\n    from: 10.01,\n    to: 15,\n    leverage: 50\n  }]\n}, {\n  key: 'cryptocurrencies',\n  title: 'Cryptocurrencies',\n  description: '(BTCUSD, ETHUSD)',\n  leverage: 'Up to 1:300',\n  data: [{\n    from: 0.01,\n    to: 1,\n    leverage: 300\n  }, {\n    from: 1.01,\n    to: 3,\n    leverage: 200\n  }, {\n    from: 3.01,\n    to: 5,\n    leverage: 100\n  }, {\n    from: 5.01,\n    to: 10,\n    leverage: 50\n  }]\n}, {\n  key: 'stock_indices',\n  title: 'Stock indices',\n  description: '(US_30, US_100, US_500)',\n  leverage: 'Up to 1:300',\n  data: [{\n    from: 0.1,\n    to: 5,\n    leverage: 300\n  }, {\n    from: 5.1,\n    to: 50,\n    leverage: 200\n  }, {\n    from: 50.1,\n    to: 5,\n    leverage: 100\n  }]\n}];\n\n/** A custom hook that gets dynamic leverage values. */\nvar useDynamicLeverage = function useDynamicLeverage() {\n  // TODO: replace with API call once the endpoint is ready.\n\n  return {\n    data: dynamic_leverages\n  };\n};\n/* harmony default export */ const hooks_useDynamicLeverage = ((/* unused pure expression or super */ null && (useDynamicLeverage)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useExchangeRate.ts\nfunction useExchangeRate_typeof(obj) { \"@babel/helpers - typeof\"; return useExchangeRate_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useExchangeRate_typeof(obj); }\nvar useExchangeRate_excluded = (/* unused pure expression or super */ null && ([\"data\", \"subscribe\"]));\nfunction useExchangeRate_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useExchangeRate_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useExchangeRate_ownKeys(Object(source), !0).forEach(function (key) { useExchangeRate_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useExchangeRate_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useExchangeRate_defineProperty(obj, key, value) { key = useExchangeRate_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useExchangeRate_toPropertyKey(arg) { var key = useExchangeRate_toPrimitive(arg, \"string\"); return useExchangeRate_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useExchangeRate_toPrimitive(input, hint) { if (useExchangeRate_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useExchangeRate_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useExchangeRate_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useExchangeRate_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useExchangeRate_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n/** A custom hook that gets exchange rates from base currency to target currency */\nvar useExchangeRate_useExchangeRate = function useExchangeRate() {\n  var _useSubscription = useSubscription('exchange_rates'),\n    data = _useSubscription.data,\n    _subscribe = _useSubscription.subscribe,\n    rest = useExchangeRate_objectWithoutProperties(_useSubscription, useExchangeRate_excluded);\n  var subscribe = useCallback(function (payload) {\n    _subscribe({\n      payload: payload\n    });\n  }, [_subscribe]);\n  return useExchangeRate_objectSpread({\n    /** The exchange rates response */\n    data: data === null || data === void 0 ? void 0 : data.exchange_rates,\n    /** Function to subscribe to exchange rates */\n    subscribe: subscribe\n  }, rest);\n};\n/* harmony default export */ const hooks_useExchangeRate = ((/* unused pure expression or super */ null && (useExchangeRate_useExchangeRate)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useResidenceList.ts\nfunction useResidenceList_typeof(obj) { \"@babel/helpers - typeof\"; return useResidenceList_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useResidenceList_typeof(obj); }\nvar useResidenceList_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useResidenceList_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useResidenceList_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useResidenceList_ownKeys(Object(source), !0).forEach(function (key) { useResidenceList_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useResidenceList_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useResidenceList_defineProperty(obj, key, value) { key = useResidenceList_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useResidenceList_toPropertyKey(arg) { var key = useResidenceList_toPrimitive(arg, \"string\"); return useResidenceList_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useResidenceList_toPrimitive(input, hint) { if (useResidenceList_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useResidenceList_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useResidenceList_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useResidenceList_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useResidenceList_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n/** A custom hook that gets the residence list. */\nvar useResidenceList_useResidenceList = function useResidenceList() {\n  var _useQuery = useQuery('residence_list'),\n    data = _useQuery.data,\n    residence_list_rest = useResidenceList_objectWithoutProperties(_useQuery, useResidenceList_excluded);\n\n  /** Modify the residence list data. */\n  var modified_residence_list = useMemo(function () {\n    if (!data || !data.residence_list) return [];\n    return data.residence_list.map(function (residence) {\n      return useResidenceList_objectSpread({}, residence);\n    });\n  }, [data]);\n  return useResidenceList_objectSpread({\n    /** The residence list */\n    data: modified_residence_list\n  }, residence_list_rest);\n};\n/* harmony default export */ const hooks_useResidenceList = ((/* unused pure expression or super */ null && (useResidenceList_useResidenceList)));\n;// CONCATENATED MODULE: ../../api/src/hooks/usePOI.ts\nfunction usePOI_typeof(obj) { \"@babel/helpers - typeof\"; return usePOI_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, usePOI_typeof(obj); }\nvar usePOI_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction usePOI_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction usePOI_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? usePOI_ownKeys(Object(source), !0).forEach(function (key) { usePOI_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : usePOI_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction usePOI_defineProperty(obj, key, value) { key = usePOI_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction usePOI_toPropertyKey(arg) { var key = usePOI_toPrimitive(arg, \"string\"); return usePOI_typeof(key) === \"symbol\" ? key : String(key); }\nfunction usePOI_toPrimitive(input, hint) { if (usePOI_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (usePOI_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction usePOI_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = usePOI_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction usePOI_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n/** A custom hook to get the proof of identity verification info of the current user. */\nvar usePOI = function usePOI() {\n  var _authentication_data$2, _authentication_data$4, _authentication_data$6;\n  var _useAuthentication = useAuthentication(),\n    authentication_data = _useAuthentication.data,\n    rest = usePOI_objectWithoutProperties(_useAuthentication, usePOI_excluded);\n  var _useResidenceList = useResidenceList(),\n    residence_list_data = _useResidenceList.data;\n  var _useSettings = useSettings(),\n    get_settings_data = _useSettings.data;\n  var previous_service = useMemo(function () {\n    var _authentication_data$;\n    var latest_poi_attempt = authentication_data === null || authentication_data === void 0 ? void 0 : (_authentication_data$ = authentication_data.attempts) === null || _authentication_data$ === void 0 ? void 0 : _authentication_data$.latest;\n    return latest_poi_attempt === null || latest_poi_attempt === void 0 ? void 0 : latest_poi_attempt.service;\n  }, [authentication_data === null || authentication_data === void 0 ? void 0 : (_authentication_data$2 = authentication_data.attempts) === null || _authentication_data$2 === void 0 ? void 0 : _authentication_data$2.latest]);\n\n  /**\n   * @description Get the previous POI attempts details (if any)\n   */\n  var previous_poi = useMemo(function () {\n    var _authentication_data$3;\n    if (!previous_service) {\n      return null;\n    }\n    var services = authentication_data === null || authentication_data === void 0 ? void 0 : (_authentication_data$3 = authentication_data.identity) === null || _authentication_data$3 === void 0 ? void 0 : _authentication_data$3.services;\n    if (services && services.manual) {\n      return {\n        service: previous_service,\n        status: services.manual.status\n      };\n    }\n    var current_service = services === null || services === void 0 ? void 0 : services[previous_service];\n    return {\n      service: previous_service,\n      status: current_service === null || current_service === void 0 ? void 0 : current_service.status,\n      reported_properties: current_service === null || current_service === void 0 ? void 0 : current_service.reported_properties,\n      last_rejected: current_service === null || current_service === void 0 ? void 0 : current_service.last_rejected,\n      submissions_left: (current_service === null || current_service === void 0 ? void 0 : current_service.submissions_left) || 0\n    };\n  }, [previous_service, authentication_data === null || authentication_data === void 0 ? void 0 : (_authentication_data$4 = authentication_data.identity) === null || _authentication_data$4 === void 0 ? void 0 : _authentication_data$4.services]);\n\n  /**\n   * @description Get the next step based on a few check. Returns configuration for document validation as well\n   */\n  var next_poi = useMemo(function () {\n    var _matching_residence_d, _matching_residence_d2, _matching_residence_d3, _matching_residence_d4, _matching_residence_d5, _matching_residence_d6, _authentication_data$5, _services$idv$submiss, _services$idv, _services$onfido$subm, _services$onfido;\n    var user_country_code = (get_settings_data === null || get_settings_data === void 0 ? void 0 : get_settings_data.citizen) || (get_settings_data === null || get_settings_data === void 0 ? void 0 : get_settings_data.country_code);\n    var matching_residence_data = residence_list_data === null || residence_list_data === void 0 ? void 0 : residence_list_data.find(function (r) {\n      return r.value === user_country_code;\n    });\n    var is_idv_supported = matching_residence_data === null || matching_residence_data === void 0 ? void 0 : (_matching_residence_d = matching_residence_data.identity) === null || _matching_residence_d === void 0 ? void 0 : (_matching_residence_d2 = _matching_residence_d.services) === null || _matching_residence_d2 === void 0 ? void 0 : (_matching_residence_d3 = _matching_residence_d2.idv) === null || _matching_residence_d3 === void 0 ? void 0 : _matching_residence_d3.is_country_supported;\n    var is_onfido_supported = matching_residence_data === null || matching_residence_data === void 0 ? void 0 : (_matching_residence_d4 = matching_residence_data.identity) === null || _matching_residence_d4 === void 0 ? void 0 : (_matching_residence_d5 = _matching_residence_d4.services) === null || _matching_residence_d5 === void 0 ? void 0 : (_matching_residence_d6 = _matching_residence_d5.onfido) === null || _matching_residence_d6 === void 0 ? void 0 : _matching_residence_d6.documents_supported;\n    var services = authentication_data === null || authentication_data === void 0 ? void 0 : (_authentication_data$5 = authentication_data.identity) === null || _authentication_data$5 === void 0 ? void 0 : _authentication_data$5.services;\n    var idv_submission_left = (_services$idv$submiss = services === null || services === void 0 ? void 0 : (_services$idv = services.idv) === null || _services$idv === void 0 ? void 0 : _services$idv.submissions_left) !== null && _services$idv$submiss !== void 0 ? _services$idv$submiss : 0;\n    var onfido_submission_left = (_services$onfido$subm = services === null || services === void 0 ? void 0 : (_services$onfido = services.onfido) === null || _services$onfido === void 0 ? void 0 : _services$onfido.submissions_left) !== null && _services$onfido$subm !== void 0 ? _services$onfido$subm : 0;\n    if (is_idv_supported && idv_submission_left && !(authentication_data !== null && authentication_data !== void 0 && authentication_data.is_idv_disallowed)) {\n      var _matching_residence_d7, _matching_residence_d8, _matching_residence_d9;\n      return {\n        service: 'idv',\n        submission_left: idv_submission_left,\n        document_supported: matching_residence_data === null || matching_residence_data === void 0 ? void 0 : (_matching_residence_d7 = matching_residence_data.identity) === null || _matching_residence_d7 === void 0 ? void 0 : (_matching_residence_d8 = _matching_residence_d7.services) === null || _matching_residence_d8 === void 0 ? void 0 : (_matching_residence_d9 = _matching_residence_d8.idv) === null || _matching_residence_d9 === void 0 ? void 0 : _matching_residence_d9.documents_supported\n      };\n    } else if (is_onfido_supported && onfido_submission_left) {\n      var _matching_residence_d10, _matching_residence_d11, _matching_residence_d12;\n      return {\n        service: 'onfido',\n        submission_left: onfido_submission_left,\n        document_supported: matching_residence_data === null || matching_residence_data === void 0 ? void 0 : (_matching_residence_d10 = matching_residence_data.identity) === null || _matching_residence_d10 === void 0 ? void 0 : (_matching_residence_d11 = _matching_residence_d10.services) === null || _matching_residence_d11 === void 0 ? void 0 : (_matching_residence_d12 = _matching_residence_d11.onfido) === null || _matching_residence_d12 === void 0 ? void 0 : _matching_residence_d12.documents_supported\n      };\n    }\n    return {\n      service: 'manual'\n    };\n  }, [get_settings_data === null || get_settings_data === void 0 ? void 0 : get_settings_data.citizen, get_settings_data === null || get_settings_data === void 0 ? void 0 : get_settings_data.country_code, residence_list_data, authentication_data === null || authentication_data === void 0 ? void 0 : (_authentication_data$6 = authentication_data.identity) === null || _authentication_data$6 === void 0 ? void 0 : _authentication_data$6.services, authentication_data === null || authentication_data === void 0 ? void 0 : authentication_data.is_idv_disallowed]);\n  var modified_verification_data = useMemo(function () {\n    if (!authentication_data) return;\n    return usePOI_objectSpread(usePOI_objectSpread({}, authentication_data === null || authentication_data === void 0 ? void 0 : authentication_data.identity), {}, {\n      previous: previous_poi,\n      next: next_poi\n    });\n  }, [authentication_data, next_poi, previous_poi]);\n  return usePOI_objectSpread({\n    data: modified_verification_data\n  }, rest);\n};\n/* harmony default export */ const hooks_usePOI = ((/* unused pure expression or super */ null && (usePOI)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useSortedMT5Accounts.ts\nfunction useSortedMT5Accounts_typeof(obj) { \"@babel/helpers - typeof\"; return useSortedMT5Accounts_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useSortedMT5Accounts_typeof(obj); }\nvar useSortedMT5Accounts_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useSortedMT5Accounts_toConsumableArray(arr) { return useSortedMT5Accounts_arrayWithoutHoles(arr) || useSortedMT5Accounts_iterableToArray(arr) || useSortedMT5Accounts_unsupportedIterableToArray(arr) || useSortedMT5Accounts_nonIterableSpread(); }\nfunction useSortedMT5Accounts_nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction useSortedMT5Accounts_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return useSortedMT5Accounts_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return useSortedMT5Accounts_arrayLikeToArray(o, minLen); }\nfunction useSortedMT5Accounts_iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction useSortedMT5Accounts_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return useSortedMT5Accounts_arrayLikeToArray(arr); }\nfunction useSortedMT5Accounts_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction useSortedMT5Accounts_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useSortedMT5Accounts_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useSortedMT5Accounts_ownKeys(Object(source), !0).forEach(function (key) { useSortedMT5Accounts_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useSortedMT5Accounts_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useSortedMT5Accounts_defineProperty(obj, key, value) { key = useSortedMT5Accounts_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useSortedMT5Accounts_toPropertyKey(arg) { var key = useSortedMT5Accounts_toPrimitive(arg, \"string\"); return useSortedMT5Accounts_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useSortedMT5Accounts_toPrimitive(input, hint) { if (useSortedMT5Accounts_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useSortedMT5Accounts_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useSortedMT5Accounts_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useSortedMT5Accounts_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useSortedMT5Accounts_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n/** A custom hook to get the sorted added and non-added MT5 accounts. */\nvar useSortedMT5Accounts = function useSortedMT5Accounts() {\n  var _useAvailableMT5Accou = useAvailableMT5Accounts(),\n    all_available_mt5_accounts = _useAvailableMT5Accou.data;\n  var _useMT5AccountsList = useMT5AccountsList(),\n    mt5_accounts = _useMT5AccountsList.data,\n    rest = useSortedMT5Accounts_objectWithoutProperties(_useMT5AccountsList, useSortedMT5Accounts_excluded);\n  var modified_data = useMemo(function () {\n    if (!all_available_mt5_accounts || !mt5_accounts) return;\n    return all_available_mt5_accounts === null || all_available_mt5_accounts === void 0 ? void 0 : all_available_mt5_accounts.map(function (available_account) {\n      var created_account = mt5_accounts === null || mt5_accounts === void 0 ? void 0 : mt5_accounts.find(function (account) {\n        return available_account.market_type === account.market_type && available_account.shortcode === account.landing_company_short;\n      });\n      if (created_account) return useSortedMT5Accounts_objectSpread(useSortedMT5Accounts_objectSpread({}, created_account), {}, {\n        /** Determine if the account is added or not */\n        is_added: true\n      });\n      return useSortedMT5Accounts_objectSpread(useSortedMT5Accounts_objectSpread({}, available_account), {}, {\n        /** Determine if the account is added or not */\n        is_added: false\n      });\n    });\n  }, [all_available_mt5_accounts, mt5_accounts]);\n\n  // // Reduce out the added and non added accounts to make sure only one of each market_type is shown for not added\n  var filtered_data = useMemo(function () {\n    if (!modified_data) return;\n    var added_accounts = modified_data.filter(function (account) {\n      return account.is_added;\n    });\n    var non_added_accounts = modified_data.filter(function (account) {\n      return !account.is_added;\n    });\n    var filtered_non_added_accounts = non_added_accounts.reduce(function (acc, account) {\n      var existing_account = acc.find(function (acc_account) {\n        return acc_account.market_type === account.market_type;\n      });\n      var added_account = added_accounts.find(function (acc_account) {\n        return acc_account.market_type === account.market_type;\n      });\n      if (existing_account || added_account) return acc;\n      return [].concat(useSortedMT5Accounts_toConsumableArray(acc), [account]);\n    }, []);\n    return [].concat(useSortedMT5Accounts_toConsumableArray(added_accounts), useSortedMT5Accounts_toConsumableArray(filtered_non_added_accounts));\n  }, [modified_data]);\n\n  // Sort the data by market_type to make sure the order is 'synthetic', 'financial', 'all'\n  var sorted_data = useMemo(function () {\n    var market_type_order = ['synthetic', 'financial', 'all'];\n    if (!filtered_data) return;\n    var sorted_data = market_type_order.reduce(function (acc, market_type) {\n      var accounts = filtered_data.filter(function (account) {\n        return account.market_type === market_type;\n      });\n      if (!accounts.length) return acc;\n      return [].concat(useSortedMT5Accounts_toConsumableArray(acc), useSortedMT5Accounts_toConsumableArray(accounts));\n    }, []);\n    return sorted_data;\n  }, [filtered_data]);\n  return useSortedMT5Accounts_objectSpread({\n    data: sorted_data\n  }, rest);\n};\n/* harmony default export */ const hooks_useSortedMT5Accounts = ((/* unused pure expression or super */ null && (useSortedMT5Accounts)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useTradingPlatformInvestorPasswordChange.ts\nfunction useTradingPlatformInvestorPasswordChange_typeof(obj) { \"@babel/helpers - typeof\"; return useTradingPlatformInvestorPasswordChange_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useTradingPlatformInvestorPasswordChange_typeof(obj); }\nvar useTradingPlatformInvestorPasswordChange_excluded = (/* unused pure expression or super */ null && ([\"mutate\"]));\nfunction useTradingPlatformInvestorPasswordChange_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useTradingPlatformInvestorPasswordChange_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useTradingPlatformInvestorPasswordChange_ownKeys(Object(source), !0).forEach(function (key) { useTradingPlatformInvestorPasswordChange_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useTradingPlatformInvestorPasswordChange_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useTradingPlatformInvestorPasswordChange_defineProperty(obj, key, value) { key = useTradingPlatformInvestorPasswordChange_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useTradingPlatformInvestorPasswordChange_toPropertyKey(arg) { var key = useTradingPlatformInvestorPasswordChange_toPrimitive(arg, \"string\"); return useTradingPlatformInvestorPasswordChange_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useTradingPlatformInvestorPasswordChange_toPrimitive(input, hint) { if (useTradingPlatformInvestorPasswordChange_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useTradingPlatformInvestorPasswordChange_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useTradingPlatformInvestorPasswordChange_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useTradingPlatformInvestorPasswordChange_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useTradingPlatformInvestorPasswordChange_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n/** A custom hook that change the Trading Platform Investor Password. */\nvar useTradingPlatformInvestorPasswordChange = function useTradingPlatformInvestorPasswordChange() {\n  var _useMutation = useMutation('trading_platform_investor_password_change'),\n    _mutate = _useMutation.mutate,\n    rest = useTradingPlatformInvestorPasswordChange_objectWithoutProperties(_useMutation, useTradingPlatformInvestorPasswordChange_excluded);\n  var mutate = useCallback(function (payload) {\n    return _mutate({\n      payload: payload\n    });\n  }, [_mutate]);\n  return useTradingPlatformInvestorPasswordChange_objectSpread({\n    /** The mutation function that accepts a payload and sends it to the server */\n    mutate: mutate\n  }, rest);\n};\n/* harmony default export */ const hooks_useTradingPlatformInvestorPasswordChange = ((/* unused pure expression or super */ null && (useTradingPlatformInvestorPasswordChange)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useTradingPlatformInvestorPasswordReset.ts\nfunction useTradingPlatformInvestorPasswordReset_typeof(obj) { \"@babel/helpers - typeof\"; return useTradingPlatformInvestorPasswordReset_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useTradingPlatformInvestorPasswordReset_typeof(obj); }\nvar useTradingPlatformInvestorPasswordReset_excluded = (/* unused pure expression or super */ null && ([\"mutate\"]));\nfunction useTradingPlatformInvestorPasswordReset_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useTradingPlatformInvestorPasswordReset_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useTradingPlatformInvestorPasswordReset_ownKeys(Object(source), !0).forEach(function (key) { useTradingPlatformInvestorPasswordReset_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useTradingPlatformInvestorPasswordReset_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useTradingPlatformInvestorPasswordReset_defineProperty(obj, key, value) { key = useTradingPlatformInvestorPasswordReset_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useTradingPlatformInvestorPasswordReset_toPropertyKey(arg) { var key = useTradingPlatformInvestorPasswordReset_toPrimitive(arg, \"string\"); return useTradingPlatformInvestorPasswordReset_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useTradingPlatformInvestorPasswordReset_toPrimitive(input, hint) { if (useTradingPlatformInvestorPasswordReset_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useTradingPlatformInvestorPasswordReset_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useTradingPlatformInvestorPasswordReset_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useTradingPlatformInvestorPasswordReset_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useTradingPlatformInvestorPasswordReset_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n/** A custom hook that reset the Trading Platform Investor Password. */\nvar useTradingPlatformInvestorPasswordReset = function useTradingPlatformInvestorPasswordReset() {\n  var _useMutation = useMutation('trading_platform_investor_password_reset'),\n    _mutate = _useMutation.mutate,\n    rest = useTradingPlatformInvestorPasswordReset_objectWithoutProperties(_useMutation, useTradingPlatformInvestorPasswordReset_excluded);\n  var mutate = useCallback(function (payload) {\n    return _mutate({\n      payload: payload\n    });\n  }, [_mutate]);\n  return useTradingPlatformInvestorPasswordReset_objectSpread({\n    /** The mutation function that accepts a payload and sends it to the server */\n    mutate: mutate\n  }, rest);\n};\n/* harmony default export */ const hooks_useTradingPlatformInvestorPasswordReset = ((/* unused pure expression or super */ null && (useTradingPlatformInvestorPasswordReset)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useTradingPlatformPasswordChange.ts\nfunction useTradingPlatformPasswordChange_typeof(obj) { \"@babel/helpers - typeof\"; return useTradingPlatformPasswordChange_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useTradingPlatformPasswordChange_typeof(obj); }\nvar useTradingPlatformPasswordChange_excluded = (/* unused pure expression or super */ null && ([\"mutate\"]));\nfunction useTradingPlatformPasswordChange_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useTradingPlatformPasswordChange_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useTradingPlatformPasswordChange_ownKeys(Object(source), !0).forEach(function (key) { useTradingPlatformPasswordChange_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useTradingPlatformPasswordChange_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useTradingPlatformPasswordChange_defineProperty(obj, key, value) { key = useTradingPlatformPasswordChange_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useTradingPlatformPasswordChange_toPropertyKey(arg) { var key = useTradingPlatformPasswordChange_toPrimitive(arg, \"string\"); return useTradingPlatformPasswordChange_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useTradingPlatformPasswordChange_toPrimitive(input, hint) { if (useTradingPlatformPasswordChange_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useTradingPlatformPasswordChange_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useTradingPlatformPasswordChange_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useTradingPlatformPasswordChange_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useTradingPlatformPasswordChange_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n/** A custom hook that change the Trading Platform Password. */\nvar useTradingPlatformPasswordChange = function useTradingPlatformPasswordChange() {\n  var _useMutation = useMutation('trading_platform_password_change'),\n    _mutate = _useMutation.mutate,\n    rest = useTradingPlatformPasswordChange_objectWithoutProperties(_useMutation, useTradingPlatformPasswordChange_excluded);\n  var mutate = useCallback(function (payload) {\n    return _mutate({\n      payload: payload\n    });\n  }, [_mutate]);\n  return useTradingPlatformPasswordChange_objectSpread({\n    /** The mutation function that accepts a payload and sends it to the server */\n    mutate: mutate\n  }, rest);\n};\n/* harmony default export */ const hooks_useTradingPlatformPasswordChange = ((/* unused pure expression or super */ null && (useTradingPlatformPasswordChange)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useTransactions.ts\nfunction useTransactions_typeof(obj) { \"@babel/helpers - typeof\"; return useTransactions_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useTransactions_typeof(obj); }\nvar useTransactions_excluded = (/* unused pure expression or super */ null && ([\"data\", \"fetchNextPage\", \"remove\"]));\nfunction useTransactions_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useTransactions_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useTransactions_ownKeys(Object(source), !0).forEach(function (key) { useTransactions_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useTransactions_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useTransactions_defineProperty(obj, key, value) { key = useTransactions_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useTransactions_toPropertyKey(arg) { var key = useTransactions_toPrimitive(arg, \"string\"); return useTransactions_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useTransactions_toPrimitive(input, hint) { if (useTransactions_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useTransactions_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useTransactions_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useTransactions_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useTransactions_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction useTransactions_slicedToArray(arr, i) { return useTransactions_arrayWithHoles(arr) || useTransactions_iterableToArrayLimit(arr, i) || useTransactions_unsupportedIterableToArray(arr, i) || useTransactions_nonIterableRest(); }\nfunction useTransactions_nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction useTransactions_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return useTransactions_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return useTransactions_arrayLikeToArray(o, minLen); }\nfunction useTransactions_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction useTransactions_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction useTransactions_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n/** A custom hook to get the summary of account transactions */\nvar useTransactions = function useTransactions() {\n  var _useAuthorize = useAuthorize(),\n    isFetching = _useAuthorize.isFetching,\n    isSuccess = _useAuthorize.isSuccess;\n  var _useState = useState(),\n    _useState2 = useTransactions_slicedToArray(_useState, 2),\n    filter = _useState2[0],\n    setFilter = _useState2[1];\n  var invalidate = useInvalidateQuery();\n  var _useInfiniteQuery = useInfiniteQuery('statement', {\n      options: {\n        enabled: !isFetching && isSuccess,\n        getNextPageParam: function getNextPageParam(lastPage, pages) {\n          var _lastPage$statement;\n          if (!(lastPage !== null && lastPage !== void 0 && (_lastPage$statement = lastPage.statement) !== null && _lastPage$statement !== void 0 && _lastPage$statement.count)) return;\n          return pages.length;\n        }\n      },\n      payload: {\n        action_type: filter\n      }\n    }),\n    data = _useInfiniteQuery.data,\n    fetchNextPage = _useInfiniteQuery.fetchNextPage,\n    remove = _useInfiniteQuery.remove,\n    rest = useTransactions_objectWithoutProperties(_useInfiniteQuery, useTransactions_excluded);\n  useEffect(function () {\n    invalidate('statement');\n  }, [filter, invalidate]);\n  useEffect(function () {\n    return function () {\n      remove();\n    };\n  }, [remove]);\n\n  // Flatten the data array.\n  var flatten_data = useMemo(function () {\n    var _data$pages, _data$pages2;\n    if (!(data !== null && data !== void 0 && (_data$pages = data.pages) !== null && _data$pages !== void 0 && _data$pages.length)) return;\n    return data === null || data === void 0 ? void 0 : (_data$pages2 = data.pages) === null || _data$pages2 === void 0 ? void 0 : _data$pages2.flatMap(function (page) {\n      var _page$statement;\n      return page === null || page === void 0 ? void 0 : (_page$statement = page.statement) === null || _page$statement === void 0 ? void 0 : _page$statement.transactions;\n    });\n  }, [data === null || data === void 0 ? void 0 : data.pages]);\n\n  // Modify the data.\n  var modified_data = useMemo(function () {\n    if (!(flatten_data !== null && flatten_data !== void 0 && flatten_data.length)) return;\n    return flatten_data === null || flatten_data === void 0 ? void 0 : flatten_data.map(function (transaction) {\n      return useTransactions_objectSpread({}, transaction);\n    });\n  }, [flatten_data]);\n  return useTransactions_objectSpread({\n    /** List of account transactions */\n    data: modified_data,\n    /** Fetch the next page of transactions */\n    fetchNextPage: fetchNextPage,\n    /** Filter the transactions by type */\n    setFilter: setFilter\n  }, rest);\n};\n/* harmony default export */ const hooks_useTransactions = ((/* unused pure expression or super */ null && (useTransactions)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useTransferBetweenAccounts.ts\nfunction useTransferBetweenAccounts_typeof(obj) { \"@babel/helpers - typeof\"; return useTransferBetweenAccounts_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useTransferBetweenAccounts_typeof(obj); }\nvar useTransferBetweenAccounts_excluded = (/* unused pure expression or super */ null && ([\"mutate\"]));\nfunction useTransferBetweenAccounts_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useTransferBetweenAccounts_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useTransferBetweenAccounts_ownKeys(Object(source), !0).forEach(function (key) { useTransferBetweenAccounts_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useTransferBetweenAccounts_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useTransferBetweenAccounts_defineProperty(obj, key, value) { key = useTransferBetweenAccounts_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useTransferBetweenAccounts_toPropertyKey(arg) { var key = useTransferBetweenAccounts_toPrimitive(arg, \"string\"); return useTransferBetweenAccounts_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useTransferBetweenAccounts_toPrimitive(input, hint) { if (useTransferBetweenAccounts_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useTransferBetweenAccounts_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useTransferBetweenAccounts_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useTransferBetweenAccounts_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useTransferBetweenAccounts_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n/** A custom hook used to transfer money between client accounts */\nvar useTransferBetweenAccounts_useTransferBetweenAccounts = function useTransferBetweenAccounts() {\n  var _useMutation = useMutation('transfer_between_accounts'),\n    _mutate = _useMutation.mutate,\n    rest = useTransferBetweenAccounts_objectWithoutProperties(_useMutation, useTransferBetweenAccounts_excluded);\n  var mutate = useCallback(function (payload) {\n    return _mutate({\n      payload: payload\n    });\n  }, [_mutate]);\n  return useTransferBetweenAccounts_objectSpread({\n    /** The mutation function that accepts a payload and sends it to the server */\n    mutate: mutate\n  }, rest);\n};\n/* harmony default export */ const hooks_useTransferBetweenAccounts = ((/* unused pure expression or super */ null && (useTransferBetweenAccounts_useTransferBetweenAccounts)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useVerifyEmail.ts\nfunction useVerifyEmail_typeof(obj) { \"@babel/helpers - typeof\"; return useVerifyEmail_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useVerifyEmail_typeof(obj); }\nvar useVerifyEmail_excluded = (/* unused pure expression or super */ null && ([\"mutate\"]));\nfunction useVerifyEmail_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useVerifyEmail_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useVerifyEmail_ownKeys(Object(source), !0).forEach(function (key) { useVerifyEmail_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useVerifyEmail_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useVerifyEmail_defineProperty(obj, key, value) { key = useVerifyEmail_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useVerifyEmail_toPropertyKey(arg) { var key = useVerifyEmail_toPrimitive(arg, \"string\"); return useVerifyEmail_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useVerifyEmail_toPrimitive(input, hint) { if (useVerifyEmail_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useVerifyEmail_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useVerifyEmail_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useVerifyEmail_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useVerifyEmail_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n/** A custom hook for verifying email address */\nvar useVerifyEmail = function useVerifyEmail() {\n  var _useMutation = useMutation('verify_email'),\n    _mutate = _useMutation.mutate,\n    rest = useVerifyEmail_objectWithoutProperties(_useMutation, useVerifyEmail_excluded);\n  var mutate = useCallback(function (payload) {\n    return _mutate({\n      payload: payload\n    });\n  }, [_mutate]);\n  return useVerifyEmail_objectSpread({\n    /** The mutation function that accepts a payload and sends it to the server */\n    mutate: mutate\n  }, rest);\n};\n/* harmony default export */ const hooks_useVerifyEmail = ((/* unused pure expression or super */ null && (useVerifyEmail)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useWalletMigration.ts\n\n\n\n\n\n\n/** A custom hook to get the status of wallet_migration API and to start/reset the migration process */\nvar useWalletMigration = function useWalletMigration() {\n  var _data$wallet_migratio;\n  var invalidate = useInvalidateQuery();\n\n  /** Make a request to wallet_migration API and onSuccess it will invalidate the cached data  */\n  var _useMutation = useMutation('wallet_migration', {\n      onSuccess: function onSuccess() {\n        return invalidate('wallet_migration');\n      }\n    }),\n    mutate = _useMutation.mutate;\n  var _useAuthorize = useAuthorize(),\n    isSuccess = _useAuthorize.isSuccess;\n\n  /** Fetch the wallet_migration API and refetch it every second if the status is in_progress */\n  var _useQuery = useQuery('wallet_migration', {\n      payload: {\n        wallet_migration: 'state'\n      },\n      options: {\n        refetchInterval: function refetchInterval(response) {\n          var _response$wallet_migr;\n          return (response === null || response === void 0 ? void 0 : (_response$wallet_migr = response.wallet_migration) === null || _response$wallet_migr === void 0 ? void 0 : _response$wallet_migr.state) === 'in_progress' ? 500 : false;\n        },\n        enabled: isSuccess\n      }\n    }),\n    data = _useQuery.data;\n  var startMigration = useCallback(function () {\n    return mutate({\n      payload: {\n        wallet_migration: 'start'\n      }\n    });\n  }, [mutate]);\n  var resetMigration = useCallback(function () {\n    return mutate({\n      payload: {\n        wallet_migration: 'reset'\n      }\n    });\n  }, [mutate]);\n  var state = data === null || data === void 0 ? void 0 : (_data$wallet_migratio = data.wallet_migration) === null || _data$wallet_migratio === void 0 ? void 0 : _data$wallet_migratio.state;\n  return {\n    /** The status of the wallet_migration API */\n    state: state,\n    /** A boolean to check if the status is not_eligible */\n    is_ineligible: state === 'ineligible',\n    /** A boolean to check if the status is eligible */\n    is_eligible: state === 'eligible',\n    /** A boolean to check if the status is in_progress */\n    is_in_progress: state === 'in_progress',\n    /** A boolean to check if the status is completed */\n    is_migrated: state === 'migrated',\n    /** A boolean to check if the status is failed */\n    is_failed: state === 'failed',\n    /** Sends a request to wallet_migration API to start the migration process */\n    startMigration: startMigration,\n    /** Sends a request to wallet_migration API to reset the migration process */\n    resetMigration: resetMigration\n  };\n};\n/* harmony default export */ const hooks_useWalletMigration = ((/* unused pure expression or super */ null && (useWalletMigration)));\n;// CONCATENATED MODULE: ../../api/src/hooks/useDxtradeServiceToken.ts\nfunction useDxtradeServiceToken_typeof(obj) { \"@babel/helpers - typeof\"; return useDxtradeServiceToken_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useDxtradeServiceToken_typeof(obj); }\nvar useDxtradeServiceToken_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useDxtradeServiceToken_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useDxtradeServiceToken_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useDxtradeServiceToken_ownKeys(Object(source), !0).forEach(function (key) { useDxtradeServiceToken_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useDxtradeServiceToken_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useDxtradeServiceToken_defineProperty(obj, key, value) { key = useDxtradeServiceToken_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useDxtradeServiceToken_toPropertyKey(arg) { var key = useDxtradeServiceToken_toPrimitive(arg, \"string\"); return useDxtradeServiceToken_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useDxtradeServiceToken_toPrimitive(input, hint) { if (useDxtradeServiceToken_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useDxtradeServiceToken_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useDxtradeServiceToken_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useDxtradeServiceToken_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useDxtradeServiceToken_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n/** A custom hook that get Service Token for Deriv X Platform. */\nvar useDxtradeServiceToken = function useDxtradeServiceToken() {\n  var _dxtrade_token$servic, _dxtrade_token$servic2;\n  var _useActiveAccount = useActiveAccount(),\n    account = _useActiveAccount.data;\n  var _useQuery = useQuery('service_token', {\n      payload: {\n        service: 'dxtrade',\n        server: account !== null && account !== void 0 && account.is_virtual ? 'demo' : 'real'\n      }\n    }),\n    dxtrade_token = _useQuery.data,\n    rest = useDxtradeServiceToken_objectWithoutProperties(_useQuery, useDxtradeServiceToken_excluded);\n  return useDxtradeServiceToken_objectSpread({\n    /** return the Deriv X account token */\n    data: dxtrade_token === null || dxtrade_token === void 0 ? void 0 : (_dxtrade_token$servic = dxtrade_token.service_token) === null || _dxtrade_token$servic === void 0 ? void 0 : (_dxtrade_token$servic2 = _dxtrade_token$servic.dxtrade) === null || _dxtrade_token$servic2 === void 0 ? void 0 : _dxtrade_token$servic2.token\n  }, rest);\n};\n/* harmony default export */ const hooks_useDxtradeServiceToken = ((/* unused pure expression or super */ null && (useDxtradeServiceToken)));\n;// CONCATENATED MODULE: ../../api/src/hooks/index.ts\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ../../api/src/usePaginatedFetch.ts\nfunction usePaginatedFetch_typeof(obj) { \"@babel/helpers - typeof\"; return usePaginatedFetch_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, usePaginatedFetch_typeof(obj); }\nvar usePaginatedFetch_excluded = (/* unused pure expression or super */ null && ([\"remove\"]));\nfunction usePaginatedFetch_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction usePaginatedFetch_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? usePaginatedFetch_ownKeys(Object(source), !0).forEach(function (key) { usePaginatedFetch_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : usePaginatedFetch_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction usePaginatedFetch_defineProperty(obj, key, value) { key = usePaginatedFetch_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction usePaginatedFetch_toPropertyKey(arg) { var key = usePaginatedFetch_toPrimitive(arg, \"string\"); return usePaginatedFetch_typeof(key) === \"symbol\" ? key : String(key); }\nfunction usePaginatedFetch_toPrimitive(input, hint) { if (usePaginatedFetch_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (usePaginatedFetch_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction usePaginatedFetch_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = usePaginatedFetch_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction usePaginatedFetch_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction usePaginatedFetch_slicedToArray(arr, i) { return usePaginatedFetch_arrayWithHoles(arr) || usePaginatedFetch_iterableToArrayLimit(arr, i) || usePaginatedFetch_unsupportedIterableToArray(arr, i) || usePaginatedFetch_nonIterableRest(); }\nfunction usePaginatedFetch_nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction usePaginatedFetch_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return usePaginatedFetch_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return usePaginatedFetch_arrayLikeToArray(o, minLen); }\nfunction usePaginatedFetch_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction usePaginatedFetch_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction usePaginatedFetch_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\nvar usePaginatedFetch_usePaginatedFetch = function usePaginatedFetch(name) {\n  var _payload$payload, _payload$payload2;\n  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    props[_key - 1] = arguments[_key];\n  }\n  var prop = props === null || props === void 0 ? void 0 : props[0];\n  var payload = prop && 'payload' in prop ? prop.payload : undefined;\n  var options = prop && 'options' in prop ? prop.options : undefined;\n  var limit = (payload === null || payload === void 0 ? void 0 : (_payload$payload = payload.payload) === null || _payload$payload === void 0 ? void 0 : _payload$payload.limit) || 10;\n  var _useState = useState((payload === null || payload === void 0 ? void 0 : (_payload$payload2 = payload.payload) === null || _payload$payload2 === void 0 ? void 0 : _payload$payload2.offset) || 0),\n    _useState2 = usePaginatedFetch_slicedToArray(_useState, 2),\n    offset = _useState2[0],\n    setOffset = _useState2[1];\n\n  // @ts-expect-error It's safe to ignore the TS error here since the\n  // exact type of the payload is not determined at this point.\n  var _useQuery = useQuery(name, {\n      payload: usePaginatedFetch_objectSpread(usePaginatedFetch_objectSpread({}, payload), {}, {\n        offset: offset,\n        limit: limit\n      }),\n      options: usePaginatedFetch_objectSpread(usePaginatedFetch_objectSpread({}, options), {}, {\n        keepPreviousData: !!offset\n      })\n    }),\n    remove = _useQuery.remove,\n    rest = usePaginatedFetch_objectWithoutProperties(_useQuery, usePaginatedFetch_excluded);\n  var loadMore = useCallback(function () {\n    return setOffset(function (prev) {\n      return prev + limit;\n    });\n  }, [limit]);\n  var reset = useCallback(function () {\n    remove();\n    setOffset(0);\n  }, [remove]);\n  return usePaginatedFetch_objectSpread(usePaginatedFetch_objectSpread({}, rest), {}, {\n    remove: remove,\n    loadMore: loadMore,\n    reset: reset\n  });\n};\n/* harmony default export */ const src_usePaginatedFetch = ((/* unused pure expression or super */ null && (usePaginatedFetch_usePaginatedFetch)));\n;// CONCATENATED MODULE: ../../api/src/index.ts\n\n\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ../../stores/src/useStore.ts\n\n\nvar useStore_useStore = function useStore() {\n  var store = (0,external_react_.useContext)(storeContext);\n  if (!store) {\n    throw new Error('useStore must be used within StoreProvider');\n  }\n  return store;\n};\n/* harmony default export */ const src_useStore = (useStore_useStore);\n;// CONCATENATED MODULE: ../../stores/src/providers/ExchangeRatesProvider.tsx\n\n\n\n\n\nvar ExchangeRatesProvider_ExchangeRatesProvider = observer(function (_ref) {\n  var children = _ref.children;\n  var _useSubscription = src_useSubscription('exchange_rates'),\n    data = _useSubscription.data,\n    subscribe = _useSubscription.subscribe;\n  var _useStore = src_useStore(),\n    update = _useStore.exchange_rates.update;\n  (0,external_react_.useEffect)(function () {\n    subscribe({\n      payload: {\n        base_currency: 'USD'\n      }\n    });\n  }, [subscribe]);\n  (0,external_react_.useEffect)(function () {\n    if (data) {\n      var exchange_rates = data.exchange_rates;\n      if (exchange_rates) update(function (prev) {\n        return lodash_merge_default()(prev, exchange_rates);\n      });\n    }\n  }, [update, data]);\n  return /*#__PURE__*/external_react_default().createElement((external_react_default()).Fragment, null, children);\n});\n/* harmony default export */ const providers_ExchangeRatesProvider = ((/* unused pure expression or super */ null && (ExchangeRatesProvider_ExchangeRatesProvider)));\n;// CONCATENATED MODULE: ../../stores/src/providers/index.ts\n\n;// CONCATENATED MODULE: ../../../node_modules/mobx-persist-store/lib/esm5/PersistStoreMap.js\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nvar PersistStoreMap_PersistStoreMap = new Map();\n\n;// CONCATENATED MODULE: ../../../node_modules/mobx-persist-store/lib/esm5/clearPersistedStore.js\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\nvar clearPersistedStore = function (target) { return __awaiter(void 0, void 0, void 0, function () {\n    var _a;\n    return __generator(this, function (_b) {\n        switch (_b.label) {\n            case 0: return [4 /*yield*/, ((_a = PersistStoreMap.get(target)) === null || _a === void 0 ? void 0 : _a.clearPersistedStore())];\n            case 1:\n                _b.sent();\n                return [2 /*return*/];\n        }\n    });\n}); };\n\n;// CONCATENATED MODULE: ../../../node_modules/mobx-persist-store/lib/esm5/configurePersistable.js\nvar mpsConfig = {};\nvar mpsReactionOptions = {};\nvar configurePersistable = function (config, reactionOptions) {\n    if (reactionOptions === void 0) { reactionOptions = {}; }\n    mpsConfig = config;\n    mpsReactionOptions = reactionOptions;\n};\n\n;// CONCATENATED MODULE: ../../../node_modules/mobx-persist-store/lib/esm5/getPersistedStore.js\nvar getPersistedStore_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar getPersistedStore_generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\nvar getPersistedStore = function (target) { return getPersistedStore_awaiter(void 0, void 0, void 0, function () {\n    var _a, _b;\n    return getPersistedStore_generator(this, function (_c) {\n        return [2 /*return*/, (_b = (_a = PersistStoreMap.get(target)) === null || _a === void 0 ? void 0 : _a.getPersistedStore()) !== null && _b !== void 0 ? _b : null];\n    });\n}); };\n\n;// CONCATENATED MODULE: ../../../node_modules/mobx-persist-store/lib/esm5/hydrateStore.js\nvar hydrateStore_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar hydrateStore_generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\nvar hydrateStore = function (target) { return hydrateStore_awaiter(void 0, void 0, void 0, function () {\n    var _a;\n    return hydrateStore_generator(this, function (_b) {\n        switch (_b.label) {\n            case 0: return [4 /*yield*/, ((_a = PersistStoreMap.get(target)) === null || _a === void 0 ? void 0 : _a.hydrateStore())];\n            case 1:\n                _b.sent();\n                return [2 /*return*/];\n        }\n    });\n}); };\n\n;// CONCATENATED MODULE: ../../../node_modules/mobx-persist-store/lib/esm5/isHydrated.js\n\nvar isHydrated = function (target) {\n    var _a, _b;\n    return (_b = (_a = PersistStoreMap.get(target)) === null || _a === void 0 ? void 0 : _a.isHydrated) !== null && _b !== void 0 ? _b : false;\n};\n\n;// CONCATENATED MODULE: ../../../node_modules/mobx-persist-store/lib/esm5/isPersisting.js\n\nvar isPersisting = function (target) {\n    var _a, _b;\n    return (_b = (_a = PersistStoreMap.get(target)) === null || _a === void 0 ? void 0 : _a.isPersisting) !== null && _b !== void 0 ? _b : false;\n};\n\n;// CONCATENATED MODULE: ../../../node_modules/mobx-persist-store/lib/esm5/utils.js\nvar buildExpireTimestamp = function (milliseconds) {\n    return new Date().getTime() + milliseconds;\n};\nvar hasTimestampExpired = function (milliseconds) {\n    var dateTimeNow = new Date().getTime();\n    var dateTimeExpiration = new Date(milliseconds).getTime();\n    return dateTimeExpiration <= dateTimeNow;\n};\nvar isDefined = function (t) { return t != null; };\n/**\n * Check if the data is an object.\n */\nvar utils_isObject = function (data) {\n    return Boolean(data) && Array.isArray(data) === false && typeof data === 'object';\n};\n/**\n * Check the data is an object with properties.\n */\nvar isObjectWithProperties = function (data) {\n    return utils_isObject(data) && Object.keys(data).length > 0;\n};\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nvar utils_isFunction = function (functionToCheck) {\n    return functionToCheck && functionToCheck instanceof Function;\n};\nvar isStorageControllerLike = function (value) {\n    // \"typeof Storage\" fixes issue with React Native\n    if (typeof Storage !== 'undefined' && value instanceof Storage) {\n        return true;\n    }\n    return [\n        value === null || value === void 0 ? void 0 : value.hasOwnProperty('getItem'),\n        value === null || value === void 0 ? void 0 : value.hasOwnProperty('removeItem'),\n        value === null || value === void 0 ? void 0 : value.hasOwnProperty('setItem'),\n        utils_isFunction(value === null || value === void 0 ? void 0 : value.getItem),\n        utils_isFunction(value === null || value === void 0 ? void 0 : value.removeItem),\n        utils_isFunction(value === null || value === void 0 ? void 0 : value.setItem),\n    ].every(Boolean);\n};\nvar isBrowser = typeof window !== 'undefined';\nvar isNotProductionBuild = \"production\" !== 'production';\nvar invalidStorageAdaptorWarningIf = function (storageAdaptor, storageName) {\n    if (isBrowser && isNotProductionBuild && !isStorageControllerLike(storageAdaptor)) {\n        console.warn(\"mobx-persist-store: \".concat(storageName, \" does not have a valid storage adaptor.\\n\\n* Make sure the storage controller has 'getItem', 'setItem' and 'removeItem' methods.\\\"\"));\n    }\n};\nvar duplicatedStoreWarningIf = function (hasPersistedStoreAlready, storageName) {\n    if (isBrowser && isNotProductionBuild && hasPersistedStoreAlready) {\n        console.warn(\"mobx-persist-store: 'makePersistable' was called was called with the same storage name \\\"\".concat(storageName, \"\\\".\\n\\n * Make sure you call \\\"stopPersisting\\\" before recreating \\\"\").concat(storageName, \"\\\" to avoid memory leaks. \\n * Or double check you did not have two stores with the same name.\"));\n    }\n};\nvar computedPersistWarningIf = function (isComputedProperty, propertyName) {\n    if (isBrowser && isNotProductionBuild && isComputedProperty) {\n        console.warn(\"mobx-persist-store: The property '\".concat(propertyName, \"' is computed and will not persist.\"));\n    }\n};\nvar actionPersistWarningIf = function (isComputedProperty, propertyName) {\n    if (isBrowser && isNotProductionBuild && isComputedProperty) {\n        console.warn(\"mobx-persist-store: The property '\".concat(propertyName, \"' is an action and will not persist.\"));\n    }\n};\nvar consoleDebug = function (isDebugMode, message, content) {\n    if (content === void 0) { content = ''; }\n    if (isDebugMode && isBrowser && isNotProductionBuild) {\n        console.info(\"%c mobx-persist-store: (Debug Mode) \".concat(message, \" \"), 'background: #4B8CC5; color: black; display: block;', content);\n    }\n};\nvar isArrayForMap = function (value) {\n    if (Array.isArray(value)) {\n        return value.every(function (v) { return Array.isArray(v); });\n    }\n    return false;\n};\n\n;// CONCATENATED MODULE: ../../../node_modules/mobx-persist-store/lib/esm5/StorageAdapter.js\nvar StorageAdapter_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar StorageAdapter_generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\nvar StorageAdapter = /** @class */ (function () {\n    function StorageAdapter(options) {\n        this.options = options;\n    }\n    StorageAdapter.prototype.setItem = function (key, item) {\n        var _a;\n        return StorageAdapter_awaiter(this, void 0, void 0, function () {\n            var _b, _c, stringify, _d, debugMode, data, content;\n            return StorageAdapter_generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0:\n                        _b = this.options, _c = _b.stringify, stringify = _c === void 0 ? true : _c, _d = _b.debugMode, debugMode = _d === void 0 ? false : _d;\n                        data = this.options.expireIn\n                            ? Object.assign({}, item, {\n                                __mps__: {\n                                    expireInTimestamp: buildExpireTimestamp(this.options.expireIn),\n                                },\n                            })\n                            : item;\n                        content = stringify ? JSON.stringify(data) : data;\n                        consoleDebug(debugMode, \"\".concat(key, \" - setItem:\"), content);\n                        return [4 /*yield*/, ((_a = this.options.storage) === null || _a === void 0 ? void 0 : _a.setItem(key, content))];\n                    case 1:\n                        _e.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    StorageAdapter.prototype.getItem = function (key) {\n        var _a, _b;\n        return StorageAdapter_awaiter(this, void 0, void 0, function () {\n            var _c, _d, removeOnExpiration, _e, debugMode, storageData, parsedData, hasExpired;\n            return StorageAdapter_generator(this, function (_f) {\n                switch (_f.label) {\n                    case 0:\n                        _c = this.options, _d = _c.removeOnExpiration, removeOnExpiration = _d === void 0 ? true : _d, _e = _c.debugMode, debugMode = _e === void 0 ? false : _e;\n                        return [4 /*yield*/, ((_a = this.options.storage) === null || _a === void 0 ? void 0 : _a.getItem(key))];\n                    case 1:\n                        storageData = _f.sent();\n                        try {\n                            parsedData = JSON.parse(storageData) || {};\n                        }\n                        catch (error) {\n                            parsedData = storageData || {};\n                        }\n                        hasExpired = hasTimestampExpired((_b = parsedData.__mps__) === null || _b === void 0 ? void 0 : _b.expireInTimestamp);\n                        consoleDebug(debugMode, \"\".concat(key, \" - hasExpired\"), hasExpired);\n                        if (!(hasExpired && removeOnExpiration)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, this.removeItem(key)];\n                    case 2:\n                        _f.sent();\n                        _f.label = 3;\n                    case 3:\n                        parsedData = hasExpired ? {} : parsedData;\n                        consoleDebug(debugMode, \"\".concat(key, \" - (getItem):\"), parsedData);\n                        return [2 /*return*/, parsedData];\n                }\n            });\n        });\n    };\n    StorageAdapter.prototype.removeItem = function (key) {\n        var _a;\n        return StorageAdapter_awaiter(this, void 0, void 0, function () {\n            var _b, debugMode;\n            return StorageAdapter_generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        _b = this.options.debugMode, debugMode = _b === void 0 ? false : _b;\n                        consoleDebug(debugMode, \"\".concat(key, \" - (removeItem): storage was removed\"));\n                        return [4 /*yield*/, ((_a = this.options.storage) === null || _a === void 0 ? void 0 : _a.removeItem(key))];\n                    case 1:\n                        _c.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return StorageAdapter;\n}());\n\n\n;// CONCATENATED MODULE: ../../../node_modules/mobx-persist-store/lib/esm5/serializableProperty.js\n\n\nvar isSerializableProperty = function (obj) {\n    var keys = ['key', 'serialize', 'deserialize'];\n    if (!utils_isObject(obj)) {\n        consoleDebug(!!mpsConfig.debugMode, 'passed value is not an object', { obj: obj });\n        return false;\n    }\n    return keys.every(function (key) {\n        if (obj.hasOwnProperty(key) && typeof key !== 'undefined') {\n            return true;\n        }\n        ;\n        consoleDebug(!!mpsConfig.debugMode, \"\".concat(key, \" not found in SerializableProperty\"), { key: key, obj: obj });\n        return false;\n    });\n};\nvar makeSerializableProperties = function (properties) {\n    return properties.reduce(function (acc, curr) {\n        if (typeof curr === 'string') {\n            acc.push({\n                key: curr,\n                serialize: function (value) { return value; },\n                deserialize: function (value) { return value; }\n            });\n            return acc;\n        }\n        if (isSerializableProperty(curr)) {\n            acc.push(curr);\n            return acc;\n        }\n        return acc;\n    }, []);\n};\n\n;// CONCATENATED MODULE: ../../../node_modules/mobx-persist-store/lib/esm5/PersistStore.js\nvar PersistStore_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar PersistStore_generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\n\n\n\nvar PersistStore = /** @class */ (function () {\n    function PersistStore(target, options, reactionOptions) {\n        if (reactionOptions === void 0) { reactionOptions = {}; }\n        var _a, _b, _c, _d, _e, _f, _g;\n        this.cancelWatch = null;\n        this.properties = [];\n        this.reactionOptions = {};\n        this.storageAdapter = null;\n        this.target = null;\n        this.debugMode = false;\n        this.isHydrated = false;\n        this.isPersisting = false;\n        this.storageName = '';\n        this.target = target;\n        this.storageName = options.name;\n        this.properties = makeSerializableProperties(options.properties);\n        this.reactionOptions = Object.assign({ fireImmediately: true }, mpsReactionOptions, reactionOptions);\n        this.debugMode = (_b = (_a = options.debugMode) !== null && _a !== void 0 ? _a : mpsConfig.debugMode) !== null && _b !== void 0 ? _b : false;\n        this.storageAdapter = new StorageAdapter({\n            expireIn: (_c = options.expireIn) !== null && _c !== void 0 ? _c : mpsConfig.expireIn,\n            removeOnExpiration: (_e = (_d = options.removeOnExpiration) !== null && _d !== void 0 ? _d : mpsConfig.removeOnExpiration) !== null && _e !== void 0 ? _e : true,\n            stringify: (_g = (_f = options.stringify) !== null && _f !== void 0 ? _f : mpsConfig.stringify) !== null && _g !== void 0 ? _g : true,\n            storage: options.storage ? options.storage : mpsConfig.storage,\n            debugMode: this.debugMode,\n        });\n        (0,external_mobx_.makeObservable)(this, {\n            clearPersistedStore: external_mobx_.action,\n            hydrateStore: external_mobx_.action,\n            isHydrated: external_mobx_.observable,\n            isPersisting: external_mobx_.observable,\n            pausePersisting: external_mobx_.action,\n            startPersisting: external_mobx_.action,\n            stopPersisting: external_mobx_.action,\n        }, { autoBind: true, deep: false });\n        invalidStorageAdaptorWarningIf(this.storageAdapter.options.storage, this.storageName);\n        consoleDebug(this.debugMode, \"\".concat(this.storageName, \" - (makePersistable)\"), {\n            properties: this.properties,\n            storageAdapter: this.storageAdapter,\n            reactionOptions: this.reactionOptions,\n        });\n    }\n    PersistStore.prototype.init = function () {\n        return PersistStore_awaiter(this, void 0, void 0, function () {\n            return PersistStore_generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.hydrateStore()];\n                    case 1:\n                        _a.sent();\n                        this.startPersisting();\n                        return [2 /*return*/, this];\n                }\n            });\n        });\n    };\n    PersistStore.prototype.hydrateStore = function () {\n        return PersistStore_awaiter(this, void 0, void 0, function () {\n            var isBeingWatched, data_1, target_1;\n            var _this = this;\n            return PersistStore_generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        isBeingWatched = Boolean(this.cancelWatch);\n                        if (this.isPersisting) {\n                            this.pausePersisting();\n                        }\n                        (0,external_mobx_.runInAction)(function () {\n                            _this.isHydrated = false;\n                            consoleDebug(_this.debugMode, \"\".concat(_this.storageName, \" - (hydrateStore) isHydrated:\"), _this.isHydrated);\n                        });\n                        if (!(this.storageAdapter && this.target)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.storageAdapter.getItem(this.storageName)];\n                    case 1:\n                        data_1 = _a.sent();\n                        target_1 = this.target;\n                        if (data_1) {\n                            (0,external_mobx_.runInAction)(function () {\n                                _this.properties.forEach(function (property) {\n                                    var allowPropertyHydration = [\n                                        target_1.hasOwnProperty(property.key),\n                                        typeof data_1[property.key] !== 'undefined',\n                                    ].every(Boolean);\n                                    if (allowPropertyHydration) {\n                                        var propertyData = data_1[property.key];\n                                        if (target_1[property.key] instanceof external_mobx_.ObservableMap && isArrayForMap(propertyData)) {\n                                            target_1[property.key] = property.deserialize(new Map(propertyData));\n                                        }\n                                        else {\n                                            target_1[property.key] = property.deserialize(propertyData);\n                                        }\n                                    }\n                                });\n                            });\n                        }\n                        _a.label = 2;\n                    case 2:\n                        (0,external_mobx_.runInAction)(function () {\n                            _this.isHydrated = true;\n                            consoleDebug(_this.debugMode, \"\".concat(_this.storageName, \" - isHydrated:\"), _this.isHydrated);\n                        });\n                        if (isBeingWatched) {\n                            this.startPersisting();\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    PersistStore.prototype.startPersisting = function () {\n        var _this = this;\n        if (!this.storageAdapter || !this.target || this.cancelWatch) {\n            return;\n        }\n        // Reassigning so TypeScript doesn't complain (Object is possibly 'null') about and this.target within reaction\n        var target = this.target;\n        this.cancelWatch = (0,external_mobx_.reaction)(function () {\n            var propertiesToWatch = {};\n            _this.properties.forEach(function (property) {\n                var isComputedProperty = (0,external_mobx_.isComputedProp)(target, property.key);\n                var isActionProperty = (0,external_mobx_.isAction)(target[property.key]);\n                computedPersistWarningIf(isComputedProperty, String(property.key));\n                actionPersistWarningIf(isActionProperty, String(property.key));\n                if (!isComputedProperty && !isActionProperty) {\n                    var propertyData = property.serialize(target[property.key]);\n                    if (propertyData instanceof external_mobx_.ObservableMap) {\n                        var mapArray_1 = [];\n                        propertyData.forEach(function (v, k) {\n                            mapArray_1.push([k, (0,external_mobx_.toJS)(v)]);\n                        });\n                        propertyData = mapArray_1;\n                    }\n                    propertiesToWatch[property.key] = (0,external_mobx_.toJS)(propertyData);\n                }\n            });\n            return propertiesToWatch;\n        }, function (dataToSave) { return PersistStore_awaiter(_this, void 0, void 0, function () {\n            return PersistStore_generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.storageAdapter) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.storageAdapter.setItem(this.storageName, dataToSave)];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2: return [2 /*return*/];\n                }\n            });\n        }); }, this.reactionOptions);\n        this.isPersisting = true;\n        consoleDebug(this.debugMode, \"\".concat(this.storageName, \" - (startPersisting) isPersisting:\"), this.isPersisting);\n    };\n    PersistStore.prototype.pausePersisting = function () {\n        this.isPersisting = false;\n        consoleDebug(this.debugMode, \"\".concat(this.storageName, \" - pausePersisting (isPersisting):\"), this.isPersisting);\n        if (this.cancelWatch) {\n            this.cancelWatch();\n            this.cancelWatch = null;\n        }\n    };\n    PersistStore.prototype.stopPersisting = function () {\n        this.pausePersisting();\n        consoleDebug(this.debugMode, \"\".concat(this.storageName, \" - (stopPersisting)\"));\n        PersistStoreMap_PersistStoreMap[\"delete\"](this.target);\n        this.cancelWatch = null;\n        this.properties = [];\n        this.reactionOptions = {};\n        this.storageAdapter = null;\n        this.target = null;\n    };\n    PersistStore.prototype.clearPersistedStore = function () {\n        return PersistStore_awaiter(this, void 0, void 0, function () {\n            return PersistStore_generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.storageAdapter) return [3 /*break*/, 2];\n                        consoleDebug(this.debugMode, \"\".concat(this.storageName, \" - (clearPersistedStore)\"));\n                        return [4 /*yield*/, this.storageAdapter.removeItem(this.storageName)];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    PersistStore.prototype.getPersistedStore = function () {\n        return PersistStore_awaiter(this, void 0, void 0, function () {\n            return PersistStore_generator(this, function (_a) {\n                if (this.storageAdapter) {\n                    consoleDebug(this.debugMode, \"\".concat(this.storageName, \" - (getPersistedStore)\"));\n                    // @ts-ignore\n                    return [2 /*return*/, this.storageAdapter.getItem(this.storageName)];\n                }\n                return [2 /*return*/, null];\n            });\n        });\n    };\n    return PersistStore;\n}());\n\n\n;// CONCATENATED MODULE: ../../../node_modules/mobx-persist-store/lib/esm5/makePersistable.js\nvar makePersistable_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar makePersistable_generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\nvar makePersistable = function (target, storageOptions, reactionOptions) { return makePersistable_awaiter(void 0, void 0, void 0, function () {\n    var mobxPersistStore, hasPersistedStoreAlready;\n    return makePersistable_generator(this, function (_a) {\n        mobxPersistStore = new PersistStore(target, storageOptions, reactionOptions);\n        hasPersistedStoreAlready = Array.from(PersistStoreMap_PersistStoreMap.values())\n            .map(function (item) { return item.storageName; })\n            .includes(mobxPersistStore.storageName);\n        duplicatedStoreWarningIf(hasPersistedStoreAlready, mobxPersistStore.storageName);\n        PersistStoreMap_PersistStoreMap.set(target, mobxPersistStore);\n        return [2 /*return*/, mobxPersistStore.init()];\n    });\n}); };\n\n;// CONCATENATED MODULE: ../../../node_modules/mobx-persist-store/lib/esm5/pausePersisting.js\n\nvar pausePersisting = function (target) {\n    var _a;\n    (_a = PersistStoreMap.get(target)) === null || _a === void 0 ? void 0 : _a.pausePersisting();\n};\n\n;// CONCATENATED MODULE: ../../../node_modules/mobx-persist-store/lib/esm5/startPersisting.js\n\nvar startPersisting = function (target) {\n    var _a;\n    (_a = PersistStoreMap.get(target)) === null || _a === void 0 ? void 0 : _a.startPersisting();\n};\n\n;// CONCATENATED MODULE: ../../../node_modules/mobx-persist-store/lib/esm5/stopPersisting.js\n\nvar stopPersisting = function (target) {\n    var _a;\n    (_a = PersistStoreMap_PersistStoreMap.get(target)) === null || _a === void 0 ? void 0 : _a.stopPersisting();\n};\n\n;// CONCATENATED MODULE: ../../../node_modules/mobx-persist-store/lib/esm5/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ../../stores/src/stores/BaseStore.ts\nfunction BaseStore_typeof(obj) { \"@babel/helpers - typeof\"; return BaseStore_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, BaseStore_typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, BaseStore_toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction BaseStore_toPropertyKey(arg) { var key = BaseStore_toPrimitive(arg, \"string\"); return BaseStore_typeof(key) === \"symbol\" ? key : String(key); }\nfunction BaseStore_toPrimitive(input, hint) { if (BaseStore_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (BaseStore_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\nvar BaseStore = /*#__PURE__*/function () {\n  function BaseStore(name, onHydrationDone) {\n    _classCallCheck(this, BaseStore);\n    this.data = undefined;\n    (0,external_mobx_.makeObservable)(this, {\n      data: external_mobx_.observable,\n      update: external_mobx_.action.bound,\n      unmount: external_mobx_.action.bound\n    });\n    makePersistable(this, {\n      name: name,\n      properties: ['data'],\n      storage: window.localStorage\n    }).then(function () {\n      return onHydrationDone === null || onHydrationDone === void 0 ? void 0 : onHydrationDone();\n    });\n  }\n  _createClass(BaseStore, [{\n    key: \"update\",\n    value: function update(data) {\n      this.data = data instanceof Function ? data(this.data) : data;\n    }\n  }, {\n    key: \"unmount\",\n    value: function unmount() {\n      stopPersisting(this);\n    }\n  }]);\n  return BaseStore;\n}();\n\n;// CONCATENATED MODULE: ../../stores/src/stores/ExchangeRatesStore.ts\nfunction ExchangeRatesStore_typeof(obj) { \"@babel/helpers - typeof\"; return ExchangeRatesStore_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, ExchangeRatesStore_typeof(obj); }\nfunction ExchangeRatesStore_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, ExchangeRatesStore_toPropertyKey(descriptor.key), descriptor); } }\nfunction ExchangeRatesStore_createClass(Constructor, protoProps, staticProps) { if (protoProps) ExchangeRatesStore_defineProperties(Constructor.prototype, protoProps); if (staticProps) ExchangeRatesStore_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction ExchangeRatesStore_toPropertyKey(arg) { var key = ExchangeRatesStore_toPrimitive(arg, \"string\"); return ExchangeRatesStore_typeof(key) === \"symbol\" ? key : String(key); }\nfunction ExchangeRatesStore_toPrimitive(input, hint) { if (ExchangeRatesStore_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (ExchangeRatesStore_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction ExchangeRatesStore_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (ExchangeRatesStore_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return ExchangeRatesStore_assertThisInitialized(self); }\nfunction ExchangeRatesStore_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar ExchangeRatesStore_ExchangeRatesStore = /*#__PURE__*/function (_BaseStore) {\n  _inherits(ExchangeRatesStore, _BaseStore);\n  var _super = _createSuper(ExchangeRatesStore);\n  function ExchangeRatesStore() {\n    ExchangeRatesStore_classCallCheck(this, ExchangeRatesStore);\n    return _super.call(this, 'ExchangeRatesStore');\n  }\n  return ExchangeRatesStore_createClass(ExchangeRatesStore);\n}(BaseStore);\n\n;// CONCATENATED MODULE: ../../stores/src/stores/FeatureFlagsStore.ts\nfunction FeatureFlagsStore_typeof(obj) { \"@babel/helpers - typeof\"; return FeatureFlagsStore_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, FeatureFlagsStore_typeof(obj); }\nfunction FeatureFlagsStore_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, FeatureFlagsStore_toPropertyKey(descriptor.key), descriptor); } }\nfunction FeatureFlagsStore_createClass(Constructor, protoProps, staticProps) { if (protoProps) FeatureFlagsStore_defineProperties(Constructor.prototype, protoProps); if (staticProps) FeatureFlagsStore_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction FeatureFlagsStore_toPropertyKey(arg) { var key = FeatureFlagsStore_toPrimitive(arg, \"string\"); return FeatureFlagsStore_typeof(key) === \"symbol\" ? key : String(key); }\nfunction FeatureFlagsStore_toPrimitive(input, hint) { if (FeatureFlagsStore_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (FeatureFlagsStore_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction FeatureFlagsStore_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction FeatureFlagsStore_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) FeatureFlagsStore_setPrototypeOf(subClass, superClass); }\nfunction FeatureFlagsStore_setPrototypeOf(o, p) { FeatureFlagsStore_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return FeatureFlagsStore_setPrototypeOf(o, p); }\nfunction FeatureFlagsStore_createSuper(Derived) { var hasNativeReflectConstruct = FeatureFlagsStore_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = FeatureFlagsStore_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = FeatureFlagsStore_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return FeatureFlagsStore_possibleConstructorReturn(this, result); }; }\nfunction FeatureFlagsStore_possibleConstructorReturn(self, call) { if (call && (FeatureFlagsStore_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return FeatureFlagsStore_assertThisInitialized(self); }\nfunction FeatureFlagsStore_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction FeatureFlagsStore_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction FeatureFlagsStore_getPrototypeOf(o) { FeatureFlagsStore_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return FeatureFlagsStore_getPrototypeOf(o); }\n\nvar FLAGS = {\n  wallet: false,\n  next_wallet: false,\n  sharkfin: false\n};\nvar FeatureFlagsStore_FeatureFlagsStore = /*#__PURE__*/function (_BaseStore) {\n  FeatureFlagsStore_inherits(FeatureFlagsStore, _BaseStore);\n  var _super = FeatureFlagsStore_createSuper(FeatureFlagsStore);\n  function FeatureFlagsStore() {\n    var _this;\n    FeatureFlagsStore_classCallCheck(this, FeatureFlagsStore);\n    _this = _super.call(this, 'FeatureFlagsStore', function () {\n      // Set the default values for the first time.\n      if (!_this.data) _this.update(FLAGS);\n\n      // Update the store data if a new flag was added or removed.\n      if (_this.data && Object.keys(_this.data).length !== Object.keys(FLAGS).length) {\n        _this.update(function (old) {\n          var data = FLAGS;\n          Object.keys(FLAGS).forEach(function (flag) {\n            // @ts-expect-error flag key is always present in the object, Hence can ignore the TS error.\n            if (old[flag] !== undefined) data[flag] = old[flag];\n          });\n          return data;\n        });\n      }\n    });\n    _this.data = FLAGS;\n    return _this;\n  }\n  return FeatureFlagsStore_createClass(FeatureFlagsStore);\n}(BaseStore);\n\n;// CONCATENATED MODULE: ../../stores/src/stores/index.ts\n\n\n;// CONCATENATED MODULE: ../../stores/src/storeProvider.tsx\nfunction storeProvider_typeof(obj) { \"@babel/helpers - typeof\"; return storeProvider_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, storeProvider_typeof(obj); }\nfunction storeProvider_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction storeProvider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? storeProvider_ownKeys(Object(source), !0).forEach(function (key) { storeProvider_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : storeProvider_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction storeProvider_defineProperty(obj, key, value) { key = storeProvider_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction storeProvider_toPropertyKey(arg) { var key = storeProvider_toPrimitive(arg, \"string\"); return storeProvider_typeof(key) === \"symbol\" ? key : String(key); }\nfunction storeProvider_toPrimitive(input, hint) { if (storeProvider_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (storeProvider_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\n\n\nvar StoreProvider = function StoreProvider(_ref) {\n  var children = _ref.children,\n    store = _ref.store;\n  var memoizedValue = useMemo(function () {\n    // If the store is mocked for testing purposes, then return the mocked value.\n    if ('is_mock' in store && store.is_mock) return store;\n\n    // Otherwise, instantiate store and return it.\n    return storeProvider_objectSpread(storeProvider_objectSpread({}, store), {}, {\n      exchange_rates: new ExchangeRatesStore(),\n      feature_flags: new FeatureFlagsStore()\n    });\n  }, [store]);\n  useEffect(function () {\n    return function () {\n      Object.values(memoizedValue).forEach(function (value) {\n        if (storeProvider_typeof(value) === 'object' && 'unmount' in value) value.unmount();\n      });\n    };\n  }, [memoizedValue]);\n  return /*#__PURE__*/React.createElement(APIProvider, null, /*#__PURE__*/React.createElement(StoreContext.Provider, {\n    value: memoizedValue\n  }, /*#__PURE__*/React.createElement(ExchangeRatesProvider, null, children)));\n};\n/* harmony default export */ const storeProvider = ((/* unused pure expression or super */ null && (StoreProvider)));\n;// CONCATENATED MODULE: ../../stores/src/index.ts\n\n\n\n\n\n;// CONCATENATED MODULE: ../../hooks/src/useHasMaltaInvestAccount.ts\n\nvar useHasMaltaInvestAccount_useHasMaltaInvestAccount = function useHasMaltaInvestAccount() {\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var active_accounts = client.active_accounts;\n  var has_malta_invest_account = active_accounts.some(function (account) {\n    return account.landing_company_shortcode === 'maltainvest';\n  });\n  return has_malta_invest_account;\n};\n/* harmony default export */ const src_useHasMaltaInvestAccount = ((/* unused pure expression or super */ null && (useHasMaltaInvestAccount_useHasMaltaInvestAccount)));\n;// CONCATENATED MODULE: ../../hooks/src/useAccountTransferVisible.ts\n\n\nvar useAccountTransferVisible = function useAccountTransferVisible() {\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var landing_company_shortcode = client.landing_company_shortcode,\n    residence = client.residence;\n  var has_malta_invest_account = useHasMaltaInvestAccount();\n  var is_account_transfer_visible = residence !== 'im' && (landing_company_shortcode !== 'malta' || has_malta_invest_account);\n  return is_account_transfer_visible;\n};\n/* harmony default export */ const src_useAccountTransferVisible = ((/* unused pure expression or super */ null && (useAccountTransferVisible)));\n;// CONCATENATED MODULE: ../../hooks/src/useAuthorize.ts\nfunction src_useAuthorize_typeof(obj) { \"@babel/helpers - typeof\"; return src_useAuthorize_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, src_useAuthorize_typeof(obj); }\nvar src_useAuthorize_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction src_useAuthorize_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction src_useAuthorize_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? src_useAuthorize_ownKeys(Object(source), !0).forEach(function (key) { src_useAuthorize_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : src_useAuthorize_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction src_useAuthorize_defineProperty(obj, key, value) { key = src_useAuthorize_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction src_useAuthorize_toPropertyKey(arg) { var key = src_useAuthorize_toPrimitive(arg, \"string\"); return src_useAuthorize_typeof(key) === \"symbol\" ? key : String(key); }\nfunction src_useAuthorize_toPrimitive(input, hint) { if (src_useAuthorize_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (src_useAuthorize_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction src_useAuthorize_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = src_useAuthorize_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction src_useAuthorize_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n/** A custom hook that authorize the user with the given token. If no token is given, it will use the current token. */\nvar src_useAuthorize_useAuthorize = function useAuthorize(token) {\n  var _accounts;\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var accounts = client.accounts,\n    _client$loginid = client.loginid,\n    loginid = _client$loginid === void 0 ? '' : _client$loginid;\n  var current_token = (_accounts = accounts[loginid || '']) === null || _accounts === void 0 ? void 0 : _accounts.token;\n  var _useFetch = useFetch('authorize', {\n      payload: {\n        authorize: token !== null && token !== void 0 ? token : current_token\n      },\n      options: {\n        enabled: Boolean(token !== null && token !== void 0 ? token : current_token)\n      }\n    }),\n    data = _useFetch.data,\n    rest = src_useAuthorize_objectWithoutProperties(_useFetch, src_useAuthorize_excluded);\n\n  // Add additional information to the authorize response.\n  var modified_authorize = useMemo(function () {\n    return src_useAuthorize_objectSpread({}, data === null || data === void 0 ? void 0 : data.authorize);\n  }, [data === null || data === void 0 ? void 0 : data.authorize]);\n  return src_useAuthorize_objectSpread({\n    /** The authorize response. */\n    data: modified_authorize\n  }, rest);\n};\n/* harmony default export */ const src_useAuthorize = ((/* unused pure expression or super */ null && (src_useAuthorize_useAuthorize)));\n;// CONCATENATED MODULE: ../../hooks/src/useCurrencyConfig.ts\nfunction src_useCurrencyConfig_typeof(obj) { \"@babel/helpers - typeof\"; return src_useCurrencyConfig_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, src_useCurrencyConfig_typeof(obj); }\nvar src_useCurrencyConfig_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction src_useCurrencyConfig_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction src_useCurrencyConfig_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? src_useCurrencyConfig_ownKeys(Object(source), !0).forEach(function (key) { src_useCurrencyConfig_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : src_useCurrencyConfig_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction src_useCurrencyConfig_defineProperty(obj, key, value) { key = src_useCurrencyConfig_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction src_useCurrencyConfig_toPropertyKey(arg) { var key = src_useCurrencyConfig_toPrimitive(arg, \"string\"); return src_useCurrencyConfig_typeof(key) === \"symbol\" ? key : String(key); }\nfunction src_useCurrencyConfig_toPrimitive(input, hint) { if (src_useCurrencyConfig_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (src_useCurrencyConfig_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction src_useCurrencyConfig_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = src_useCurrencyConfig_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction src_useCurrencyConfig_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n/** @deprecated Use `useCurrencyConfig` from `@deriv/api` package instead. */\nvar src_useCurrencyConfig_useCurrencyConfig = function useCurrencyConfig() {\n  var _crypto_config_data$c2, _website_status_data$2;\n  var _useFetch = useFetch('website_status'),\n    website_status_data = _useFetch.data;\n  var _useFetch2 = useFetch('crypto_config'),\n    crypto_config_data = _useFetch2.data,\n    rest = src_useCurrencyConfig_objectWithoutProperties(_useFetch2, src_useCurrencyConfig_excluded);\n  var currencies_config = useMemo(function () {\n    var _website_status_data$;\n    if (!(website_status_data !== null && website_status_data !== void 0 && (_website_status_data$ = website_status_data.website_status) !== null && _website_status_data$ !== void 0 && _website_status_data$.currencies_config)) return undefined;\n    var website_status_currencies_config = website_status_data.website_status.currencies_config;\n    var modified_currencies_config = Object.keys(website_status_currencies_config).map(function (currency) {\n      var _crypto_config_data$c;\n      var currency_config = website_status_currencies_config[currency];\n      var crypto_config = crypto_config_data === null || crypto_config_data === void 0 ? void 0 : (_crypto_config_data$c = crypto_config_data.crypto_config) === null || _crypto_config_data$c === void 0 ? void 0 : _crypto_config_data$c.currencies_config[currency];\n      return src_useCurrencyConfig_objectSpread(src_useCurrencyConfig_objectSpread(src_useCurrencyConfig_objectSpread({}, currency_config), crypto_config), {}, {\n        /** determine if the currency is a `crypto` currency */\n        is_crypto: (currency_config === null || currency_config === void 0 ? void 0 : currency_config.type) === 'crypto',\n        /** determine if the currency is a `fiat` currency */\n        is_fiat: (currency_config === null || currency_config === void 0 ? void 0 : currency_config.type) === 'fiat',\n        /** determine if the currency is `Australian Dollar` */\n        is_AUD: currency === 'AUD',\n        /** determine if the currency is `US Dollar` */\n        is_USD: currency === 'USD',\n        /** determine if the currency is `Euro` */\n        is_EUR: currency === 'EUR',\n        /** determine if the currency is `Pound Sterling` */\n        is_GBP: currency === 'GBP',\n        /** determine if the currency is `Bitcoin` */\n        is_BTC: currency === 'BTC',\n        /** determine if the currency is `Ethereum` */\n        is_ETH: currency === 'ETH',\n        /** determine if the currency is `Litecoin` */\n        is_LTC: currency === 'LTC',\n        /** determine if the currency is `Multi-Collateral DAI` */\n        is_DAI: currency === 'DAI',\n        /** determine if the currency is `IDK` */\n        is_IDK: currency === 'IDK',\n        /** determine if the currency is `Paxos Standard` */\n        is_PAX: currency === 'PAX',\n        /** determine if the currency is `Binary Coin` */\n        is_USB: currency === 'USB',\n        /** determine if the currency is `Tether Omni` */\n        is_USDT: currency === 'UST',\n        /** determine if the currency is `True USD` */\n        is_TUSD: currency === 'TUSD',\n        /** determine if the currency is `Binance USD` */\n        is_BUSD: currency === 'BUSD',\n        /** determine if the currency is `STATIS Euro` */\n        is_EURS: currency === 'EURS',\n        /** determine if the currency is `Tether ERC20` */\n        is_eUSDT: currency === 'eUSDT',\n        /** determine if the currency is `Tether TRC20` */\n        is_tUSDT: currency === 'tUSDT',\n        /** determine if the currency is `USD Coin` */\n        is_USDC: currency === 'USDC',\n        /** determine if the currency is `USDK` */\n        is_USDK: currency === 'USDK',\n        /** Currency code */\n        code: currency,\n        /** Currency display code */\n        display_code: currency === 'UST' ? 'USDT' : currency,\n        /** Local asset name for the currency icon. ex: `IcCurrencyUsd` for `USD` */\n        icon: \"IcCurrency\".concat(currency[0].toUpperCase() + currency.slice(1).toLowerCase())\n      });\n    });\n    return modified_currencies_config.reduce(function (previous, current) {\n      return src_useCurrencyConfig_objectSpread(src_useCurrencyConfig_objectSpread({}, previous), {}, src_useCurrencyConfig_defineProperty({}, current.code, current));\n    }, {});\n  }, [crypto_config_data === null || crypto_config_data === void 0 ? void 0 : (_crypto_config_data$c2 = crypto_config_data.crypto_config) === null || _crypto_config_data$c2 === void 0 ? void 0 : _crypto_config_data$c2.currencies_config, website_status_data === null || website_status_data === void 0 ? void 0 : (_website_status_data$2 = website_status_data.website_status) === null || _website_status_data$2 === void 0 ? void 0 : _website_status_data$2.currencies_config]);\n  var getConfig = useCallback(function (currency) {\n    return currencies_config === null || currencies_config === void 0 ? void 0 : currencies_config[currency];\n  }, [currencies_config]);\n  return src_useCurrencyConfig_objectSpread({\n    /** Returns the currency config object for the given currency */\n    getConfig: getConfig,\n    /** Available currencies and their information */\n    currencies_config: currencies_config\n  }, rest);\n};\n/* harmony default export */ const src_useCurrencyConfig = ((/* unused pure expression or super */ null && (src_useCurrencyConfig_useCurrencyConfig)));\n;// CONCATENATED MODULE: ../../hooks/src/useWalletsList.ts\nfunction useWalletsList_typeof(obj) { \"@babel/helpers - typeof\"; return useWalletsList_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useWalletsList_typeof(obj); }\nvar useWalletsList_excluded = (/* unused pure expression or super */ null && ([\"data\", \"isSuccess\"]));\nfunction useWalletsList_toConsumableArray(arr) { return useWalletsList_arrayWithoutHoles(arr) || useWalletsList_iterableToArray(arr) || useWalletsList_unsupportedIterableToArray(arr) || useWalletsList_nonIterableSpread(); }\nfunction useWalletsList_nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction useWalletsList_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return useWalletsList_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return useWalletsList_arrayLikeToArray(o, minLen); }\nfunction useWalletsList_iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction useWalletsList_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return useWalletsList_arrayLikeToArray(arr); }\nfunction useWalletsList_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction useWalletsList_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useWalletsList_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useWalletsList_ownKeys(Object(source), !0).forEach(function (key) { useWalletsList_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useWalletsList_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useWalletsList_defineProperty(obj, key, value) { key = useWalletsList_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useWalletsList_toPropertyKey(arg) { var key = useWalletsList_toPrimitive(arg, \"string\"); return useWalletsList_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useWalletsList_toPrimitive(input, hint) { if (useWalletsList_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useWalletsList_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useWalletsList_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useWalletsList_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useWalletsList_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar currency_to_icon_mapper = {\n  Demo: {\n    dark: 'IcWalletDerivDemoDark',\n    light: 'IcWalletDerivDemoLight'\n  },\n  USD: {\n    dark: 'IcWalletCurrencyUsd',\n    light: 'IcWalletCurrencyUsd'\n  },\n  EUR: {\n    dark: 'IcWalletCurrencyEur',\n    light: 'IcWalletCurrencyEur'\n  },\n  AUD: {\n    dark: 'IcWalletCurrencyAud',\n    light: 'IcWalletCurrencyAud'\n  },\n  GBP: {\n    dark: 'IcWalletCurrencyGbp',\n    light: 'IcWalletCurrencyGbp'\n  },\n  BTC: {\n    dark: 'IcWalletBitcoinDark',\n    light: 'IcWalletBitcoinLight'\n  },\n  ETH: {\n    dark: 'IcWalletEthereumDark',\n    light: 'IcWalletEthereumLight'\n  },\n  USDT: {\n    dark: 'IcWalletTetherDark',\n    light: 'IcWalletTetherLight'\n  },\n  eUSDT: {\n    dark: 'IcWalletTetherDark',\n    light: 'IcWalletTetherLight'\n  },\n  tUSDT: {\n    dark: 'IcWalletTetherDark',\n    light: 'IcWalletTetherLight'\n  },\n  UST: {\n    dark: 'IcWalletTetherDark',\n    light: 'IcWalletTetherLight'\n  },\n  LTC: {\n    dark: 'IcWalletLiteCoinDark',\n    light: 'IcWalletLiteCoinLight'\n  },\n  USDC: {\n    dark: 'IcWalletUsdCoinDark',\n    light: 'IcWalletUsdCoinLight'\n  }\n};\n\n/** A custom hook to get the list of wallets for the current user. */\nvar useWalletsList_useWalletsList = function useWalletsList() {\n  var _balance_data$balance4;\n  var _useStore = useStore(),\n    ui = _useStore.ui,\n    client = _useStore.client;\n  var is_dark_mode_on = ui.is_dark_mode_on;\n  var is_authorize = client.is_authorize;\n  var _useCurrencyConfig = useCurrencyConfig(),\n    getConfig = _useCurrencyConfig.getConfig;\n  var _useAuthorize = useAuthorize(),\n    authorize_data = _useAuthorize.data,\n    isSuccess = _useAuthorize.isSuccess,\n    rest = useWalletsList_objectWithoutProperties(_useAuthorize, useWalletsList_excluded);\n  var _useFetch = useFetch('balance', {\n      payload: {\n        account: 'all'\n      },\n      options: {\n        enabled: is_authorize && isSuccess\n      }\n    }),\n    balance_data = _useFetch.data;\n\n  // Filter out non-wallet accounts.\n  var wallets = useMemo(function () {\n    var _authorize_data$accou;\n    return authorize_data === null || authorize_data === void 0 ? void 0 : (_authorize_data$accou = authorize_data.account_list) === null || _authorize_data$accou === void 0 ? void 0 : _authorize_data$accou.filter(function (account) {\n      return account.account_category === 'wallet';\n    });\n  }, [authorize_data === null || authorize_data === void 0 ? void 0 : authorize_data.account_list]);\n\n  // Add balance to each wallet.\n  var wallets_with_balance = useMemo(function () {\n    return wallets === null || wallets === void 0 ? void 0 : wallets.map(function (wallet) {\n      var _balance_data$balance, _balance_data$balance2, _balance_data$balance3;\n      return useWalletsList_objectSpread(useWalletsList_objectSpread({}, wallet), {}, {\n        /** Wallet balance */\n        balance: (balance_data === null || balance_data === void 0 ? void 0 : (_balance_data$balance = balance_data.balance) === null || _balance_data$balance === void 0 ? void 0 : (_balance_data$balance2 = _balance_data$balance.accounts) === null || _balance_data$balance2 === void 0 ? void 0 : (_balance_data$balance3 = _balance_data$balance2[wallet.loginid || '']) === null || _balance_data$balance3 === void 0 ? void 0 : _balance_data$balance3.balance) || 0\n      });\n    });\n  }, [balance_data === null || balance_data === void 0 ? void 0 : (_balance_data$balance4 = balance_data.balance) === null || _balance_data$balance4 === void 0 ? void 0 : _balance_data$balance4.accounts, wallets]);\n\n  // Add additional information to each wallet.\n  var modified_wallets = useMemo(function () {\n    return wallets_with_balance === null || wallets_with_balance === void 0 ? void 0 : wallets_with_balance.map(function (wallet) {\n      var _wallet$landing_compa;\n      var wallet_currency_type = wallet.is_virtual === 1 ? 'Demo' : wallet.currency || '';\n      var wallet_gradient_class_name = \"\".concat(wallet_currency_type.toLowerCase(), \"-bg\").concat(is_dark_mode_on ? '--dark' : '');\n      var wallet_icon = currency_to_icon_mapper[wallet_currency_type];\n      return useWalletsList_objectSpread(useWalletsList_objectSpread({}, wallet), {}, {\n        /** Indicating whether the wallet is the currently selected wallet. */\n        is_selected: wallet.loginid === (authorize_data === null || authorize_data === void 0 ? void 0 : authorize_data.loginid),\n        /** Indicating whether the wallet is a virtual-money wallet. */\n        is_demo: wallet.is_virtual === 1,\n        /** Returns the wallet's currency type. ex: `Demo`, `USD`, etc. */\n        wallet_currency_type: wallet_currency_type,\n        /** Landing company shortcode the account belongs to. */\n        landing_company_name: (_wallet$landing_compa = wallet.landing_company_name) === null || _wallet$landing_compa === void 0 ? void 0 : _wallet$landing_compa.replace('maltainvest', 'malta'),\n        /** Indicating whether the wallet is a maltainvest wallet. */\n        is_malta_wallet: wallet.landing_company_name === 'malta',\n        /** The gradient class name for the wallet header background. */\n        gradient_header_class: \"wallet-header__\".concat(wallet_gradient_class_name),\n        /** The gradient class name for the wallet card background. */\n        gradient_card_class: \"wallet-card__\".concat(wallet_gradient_class_name),\n        /** Wallet's currency config information */\n        currency_config: wallet.currency ? getConfig(wallet.currency) : undefined,\n        /** Local asset name for the wallet icon. ex: `IcWalletCurrencyUsd` for `USD`  */\n        icon: is_dark_mode_on ? wallet_icon.dark : wallet_icon.light\n      });\n    });\n  }, [getConfig, is_dark_mode_on, authorize_data === null || authorize_data === void 0 ? void 0 : authorize_data.loginid, wallets_with_balance]);\n\n  // Sort wallets alphabetically by fiat, crypto, then virtual.\n  var sorted_wallets = useMemo(function () {\n    if (!modified_wallets) return [];\n    return useWalletsList_toConsumableArray(modified_wallets).sort(function (a, b) {\n      var _a$currency_config, _b$currency_config;\n      if (a.is_virtual !== b.is_virtual) {\n        return a.is_virtual ? 1 : -1;\n      } else if (((_a$currency_config = a.currency_config) === null || _a$currency_config === void 0 ? void 0 : _a$currency_config.is_crypto) !== ((_b$currency_config = b.currency_config) === null || _b$currency_config === void 0 ? void 0 : _b$currency_config.is_crypto)) {\n        var _a$currency_config2;\n        return (_a$currency_config2 = a.currency_config) !== null && _a$currency_config2 !== void 0 && _a$currency_config2.is_crypto ? 1 : -1;\n      }\n      return (a.currency || 'USD').localeCompare(b.currency || 'USD');\n    });\n  }, [modified_wallets]);\n  return useWalletsList_objectSpread({\n    /** List of wallets for current user. */\n    data: sorted_wallets,\n    /** Indicating whether the user has a wallet */\n    has_wallet: sorted_wallets && sorted_wallets.length > 0\n  }, rest);\n};\n/* harmony default export */ const src_useWalletsList = ((/* unused pure expression or super */ null && (useWalletsList_useWalletsList)));\n;// CONCATENATED MODULE: ../../hooks/src/useActiveWallet.ts\n\n\n\n/** A custom hook that returns the wallet object for the current active wallet. */\nvar useActiveWallet_useActiveWallet = function useActiveWallet() {\n  var _useWalletsList = useWalletsList(),\n    data = _useWalletsList.data;\n  var active_wallet = useMemo(function () {\n    return data === null || data === void 0 ? void 0 : data.find(function (wallet) {\n      return wallet.is_selected;\n    });\n  }, [data]);\n\n  /** User's current active wallet. */\n  return active_wallet;\n};\n/* harmony default export */ const src_useActiveWallet = ((/* unused pure expression or super */ null && (useActiveWallet_useActiveWallet)));\n;// CONCATENATED MODULE: ../../hooks/src/useAvailableWallets.ts\nfunction src_useAvailableWallets_typeof(obj) { \"@babel/helpers - typeof\"; return src_useAvailableWallets_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, src_useAvailableWallets_typeof(obj); }\nvar src_useAvailableWallets_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction src_useAvailableWallets_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction src_useAvailableWallets_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? src_useAvailableWallets_ownKeys(Object(source), !0).forEach(function (key) { src_useAvailableWallets_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : src_useAvailableWallets_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction src_useAvailableWallets_defineProperty(obj, key, value) { key = src_useAvailableWallets_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction src_useAvailableWallets_toPropertyKey(arg) { var key = src_useAvailableWallets_toPrimitive(arg, \"string\"); return src_useAvailableWallets_typeof(key) === \"symbol\" ? key : String(key); }\nfunction src_useAvailableWallets_toPrimitive(input, hint) { if (src_useAvailableWallets_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (src_useAvailableWallets_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction src_useAvailableWallets_toConsumableArray(arr) { return src_useAvailableWallets_arrayWithoutHoles(arr) || src_useAvailableWallets_iterableToArray(arr) || src_useAvailableWallets_unsupportedIterableToArray(arr) || src_useAvailableWallets_nonIterableSpread(); }\nfunction src_useAvailableWallets_nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction src_useAvailableWallets_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return src_useAvailableWallets_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return src_useAvailableWallets_arrayLikeToArray(o, minLen); }\nfunction src_useAvailableWallets_iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction src_useAvailableWallets_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return src_useAvailableWallets_arrayLikeToArray(arr); }\nfunction src_useAvailableWallets_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction src_useAvailableWallets_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = src_useAvailableWallets_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction src_useAvailableWallets_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\nvar useAvailableWallets_useAvailableWallets = function useAvailableWallets() {\n  var _useStore = useStore(),\n    client = _useStore.client,\n    ui = _useStore.ui;\n  var is_dark_mode_on = ui.is_dark_mode_on;\n  var is_crypto = client.is_crypto;\n  var _useAuthorize = useAuthorize(),\n    data = _useAuthorize.data;\n  var _useFetch = useFetch('get_account_types', {\n      payload: {\n        company: (data === null || data === void 0 ? void 0 : data.landing_company_name) === 'virtual' ? 'svg' : data === null || data === void 0 ? void 0 : data.landing_company_name\n      },\n      options: {\n        enabled: Boolean(data === null || data === void 0 ? void 0 : data.landing_company_name)\n      }\n    }),\n    account_type_data = _useFetch.data,\n    rest = src_useAvailableWallets_objectWithoutProperties(_useFetch, src_useAvailableWallets_excluded);\n  var _useWalletsList = useWalletsList(),\n    added_wallets = _useWalletsList.data;\n  var sortedWallets = React.useMemo(function () {\n    var _account_type_data$ge;\n    if (!account_type_data) return null;\n    var _ref = (account_type_data === null || account_type_data === void 0 ? void 0 : (_account_type_data$ge = account_type_data.get_account_types) === null || _account_type_data$ge === void 0 ? void 0 : _account_type_data$ge.wallet) || {},\n      crypto = _ref.crypto,\n      doughflow = _ref.doughflow;\n    var crypto_currencies = crypto === null || crypto === void 0 ? void 0 : crypto.currencies;\n    var fiat_currencies = doughflow === null || doughflow === void 0 ? void 0 : doughflow.currencies;\n    if (!crypto_currencies || !fiat_currencies) return null;\n    var available_currencies = [].concat(src_useAvailableWallets_toConsumableArray(fiat_currencies), src_useAvailableWallets_toConsumableArray(crypto_currencies));\n    var non_virtual_wallets = added_wallets === null || added_wallets === void 0 ? void 0 : added_wallets.filter(function (wallet) {\n      return !wallet.is_virtual;\n    });\n    var modified_wallets = non_virtual_wallets === null || non_virtual_wallets === void 0 ? void 0 : non_virtual_wallets.map(function (wallet) {\n      return {\n        currency: wallet.currency,\n        landing_company_name: wallet.landing_company_name,\n        is_added: true,\n        gradient_card_class: wallet.gradient_card_class\n      };\n    });\n    var available_wallets = available_currencies.filter(function (currency) {\n      return !(modified_wallets !== null && modified_wallets !== void 0 && modified_wallets.some(function (wallet) {\n        return wallet.currency === currency;\n      }));\n    }).map(function (currency) {\n      return {\n        currency: currency,\n        landing_company_name: (data === null || data === void 0 ? void 0 : data.landing_company_name) === 'virtual' ? 'svg' : data === null || data === void 0 ? void 0 : data.landing_company_name,\n        is_added: false,\n        gradient_card_class: \"wallet-card__\".concat(currency.toLowerCase(), \"-bg\").concat(is_dark_mode_on ? '--dark' : '')\n      };\n    });\n\n    // Sort the unadded wallets alphabetically by fiat, crypto, then virtual\n    available_wallets === null || available_wallets === void 0 ? void 0 : available_wallets.sort(function (a, b) {\n      if (is_crypto(a.currency) !== is_crypto(b.currency)) {\n        return is_crypto(a.currency) ? 1 : -1;\n      }\n      return (a.currency || 'USD').localeCompare(b.currency || 'USD');\n    });\n\n    // Sort the added wallets alphabetically by fiat, crypto, then virtual (if any)\n    if (Array.isArray(modified_wallets)) {\n      modified_wallets === null || modified_wallets === void 0 ? void 0 : modified_wallets.sort(function (a, b) {\n        if (is_crypto(a.currency) !== is_crypto(b.currency)) {\n          return is_crypto(a.currency) ? 1 : -1;\n        }\n        return (a.currency || 'USD').localeCompare(b.currency || 'USD');\n      });\n      return [].concat(src_useAvailableWallets_toConsumableArray(available_wallets), src_useAvailableWallets_toConsumableArray(modified_wallets));\n    }\n    return src_useAvailableWallets_toConsumableArray(available_wallets);\n  }, [added_wallets, account_type_data, data === null || data === void 0 ? void 0 : data.landing_company_name, is_dark_mode_on, is_crypto]);\n  return src_useAvailableWallets_objectSpread(src_useAvailableWallets_objectSpread({}, rest), {}, {\n    data: sortedWallets\n  });\n};\n/* harmony default export */ const src_useAvailableWallets = ((/* unused pure expression or super */ null && (useAvailableWallets_useAvailableWallets)));\n;// CONCATENATED MODULE: ../../hooks/src/useCFDAllAccounts.ts\nfunction useCFDAllAccounts_toConsumableArray(arr) { return useCFDAllAccounts_arrayWithoutHoles(arr) || useCFDAllAccounts_iterableToArray(arr) || useCFDAllAccounts_unsupportedIterableToArray(arr) || useCFDAllAccounts_nonIterableSpread(); }\nfunction useCFDAllAccounts_nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction useCFDAllAccounts_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return useCFDAllAccounts_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return useCFDAllAccounts_arrayLikeToArray(o, minLen); }\nfunction useCFDAllAccounts_iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction useCFDAllAccounts_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return useCFDAllAccounts_arrayLikeToArray(arr); }\nfunction useCFDAllAccounts_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n\n/** @deprecated Use `useMT5AccountsList` for MT5 accounts and `useDxtradeAccountsList` for Other CFD accounts from `@deriv/api` instead. */\nvar useCFDAllAccounts_useCFDAllAccounts = function useCFDAllAccounts() {\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var dxtrade_accounts_list = client.dxtrade_accounts_list,\n    mt5_login_list = client.mt5_login_list,\n    derivez_accounts_list = client.derivez_accounts_list,\n    ctrader_accounts_list = client.ctrader_accounts_list;\n  var cfd_accounts = [];\n  if (Array.isArray(mt5_login_list)) {\n    cfd_accounts = [].concat(useCFDAllAccounts_toConsumableArray(cfd_accounts), useCFDAllAccounts_toConsumableArray(mt5_login_list));\n  }\n  if (Array.isArray(dxtrade_accounts_list)) {\n    cfd_accounts = [].concat(useCFDAllAccounts_toConsumableArray(cfd_accounts), useCFDAllAccounts_toConsumableArray(dxtrade_accounts_list));\n  }\n  if (Array.isArray(ctrader_accounts_list)) {\n    cfd_accounts = [].concat(useCFDAllAccounts_toConsumableArray(cfd_accounts), useCFDAllAccounts_toConsumableArray(ctrader_accounts_list));\n  }\n  if (Array.isArray(derivez_accounts_list)) {\n    cfd_accounts = [].concat(useCFDAllAccounts_toConsumableArray(cfd_accounts), useCFDAllAccounts_toConsumableArray(derivez_accounts_list));\n  }\n  return cfd_accounts;\n};\n/* harmony default export */ const src_useCFDAllAccounts = ((/* unused pure expression or super */ null && (useCFDAllAccounts_useCFDAllAccounts)));\n;// CONCATENATED MODULE: ../../hooks/src/useCFDDemoAccounts.ts\n\n\n/**\n *  we can use this hook to get the CFD demo accounts.\n *  it loops through the all of user's CFD accounts, finds and returns demo accounts\n */\nvar useCFDDemoAccounts_useCFDDemoAccounts = function useCFDDemoAccounts() {\n  var cfd_accounts = useCFDAllAccounts();\n  var cfd_demo_accounts = cfd_accounts.filter(function (account) {\n    return account.account_type === 'demo';\n  });\n  return cfd_demo_accounts;\n};\n/* harmony default export */ const src_useCFDDemoAccounts = ((/* unused pure expression or super */ null && (useCFDDemoAccounts_useCFDDemoAccounts)));\n;// CONCATENATED MODULE: ../../hooks/src/useCFDRealAccounts.ts\n\n\n\n/**\n * we can use this hook to get the real CFD accounts for both Eu and Non-Eu regions.\n * it loops through the all of user's CFD accounts, finds and returns real accounts\n */\nvar useCFDRealAccounts_useCFDRealAccounts = function useCFDRealAccounts() {\n  var _useStore = useStore(),\n    traders_hub = _useStore.traders_hub;\n  var is_eu_user = traders_hub.is_eu_user;\n  var cfd_accounts = useCFDAllAccounts();\n  var cfd_real_accounts = cfd_accounts.filter(function (account) {\n    var is_demo = account.account_type === 'demo';\n    var is_maltainvest = account.landing_company_short === 'maltainvest';\n    if (is_demo) return false;\n    if (!is_eu_user) return !is_maltainvest;\n    return is_maltainvest;\n  });\n  return cfd_real_accounts;\n};\n/* harmony default export */ const src_useCFDRealAccounts = ((/* unused pure expression or super */ null && (useCFDRealAccounts_useCFDRealAccounts)));\n;// CONCATENATED MODULE: ../../hooks/src/useCFDAccounts.ts\n\n\n\n\n/**\n * this is a wrapper hook for useCFDDemoAccounts and useCFDRealAccounts\n * and it returns different cfd account types which are demo, real, and all\n */\n\nvar useCFDAccounts = function useCFDAccounts() {\n  var all_cfd_accounts = useCFDAllAccounts();\n  var cfd_demo_accounts = useCFDDemoAccounts();\n  var cfd_real_accounts = useCFDRealAccounts();\n  return {\n    all: all_cfd_accounts,\n    demo: cfd_demo_accounts,\n    real: cfd_real_accounts\n  };\n};\n/* harmony default export */ const src_useCFDAccounts = ((/* unused pure expression or super */ null && (useCFDAccounts)));\n;// CONCATENATED MODULE: ../../hooks/src/useCashierLocked.ts\n\nvar useCashierLocked = function useCashierLocked() {\n  var _account_status$statu;\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var account_status = client.account_status;\n  var is_cashier_locked = ((_account_status$statu = account_status.status) === null || _account_status$statu === void 0 ? void 0 : _account_status$statu.some(function (status) {\n    return status === 'cashier_locked';\n  })) || false;\n  return is_cashier_locked;\n};\n/* harmony default export */ const src_useCashierLocked = ((/* unused pure expression or super */ null && (useCashierLocked)));\n;// CONCATENATED MODULE: ../../hooks/src/useContentFlag.ts\n\nvar useContentFlag = function useContentFlag() {\n  var _useStore = useStore(),\n    traders_hub = _useStore.traders_hub;\n  var content_flag = traders_hub.content_flag;\n  return {\n    is_low_risk_cr_non_eu: content_flag === 'low_risk_cr_non_eu',\n    is_low_risk_cr_eu: content_flag === 'low_risk_cr_eu',\n    is_high_risk_cr: content_flag === 'high_risk_cr',\n    is_cr_demo: content_flag === 'cr_demo',\n    is_eu_demo: content_flag === 'eu_demo',\n    is_eu_real: content_flag === 'eu_real'\n  };\n};\n/* harmony default export */ const src_useContentFlag = ((/* unused pure expression or super */ null && (useContentFlag)));\n;// CONCATENATED MODULE: ../../hooks/src/useCountdown.ts\nfunction useCountdown_slicedToArray(arr, i) { return useCountdown_arrayWithHoles(arr) || useCountdown_iterableToArrayLimit(arr, i) || useCountdown_unsupportedIterableToArray(arr, i) || useCountdown_nonIterableRest(); }\nfunction useCountdown_nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction useCountdown_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return useCountdown_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return useCountdown_arrayLikeToArray(o, minLen); }\nfunction useCountdown_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction useCountdown_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction useCountdown_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar ONE_SECOND = 1000;\nvar useCountdown_useCountdown = function useCountdown(_ref) {\n  var from = _ref.from,\n    _ref$to = _ref.to,\n    to = _ref$to === void 0 ? 0 : _ref$to,\n    _ref$increment = _ref.increment,\n    increment = _ref$increment === void 0 ? false : _ref$increment;\n  var _useState = useState(from),\n    _useState2 = useCountdown_slicedToArray(_useState, 2),\n    count = _useState2[0],\n    setCount = _useState2[1];\n  var _useState3 = useState(false),\n    _useState4 = useCountdown_slicedToArray(_useState3, 2),\n    is_running = _useState4[0],\n    setIsRunning = _useState4[1];\n  useEffect(function () {\n    var timer;\n    if (is_running) {\n      timer = setTimeout(function () {\n        if (count === to) {\n          pause();\n        } else {\n          setCount(function (old) {\n            return increment ? old + 1 : old - 1;\n          });\n        }\n      }, ONE_SECOND);\n    }\n    return function () {\n      return clearTimeout(timer);\n    };\n  }, [count, is_running, to, increment]);\n  var start = function start() {\n    return setIsRunning(true);\n  };\n  var pause = function pause() {\n    return setIsRunning(false);\n  };\n  var reset = function reset() {\n    return setCount(from);\n  };\n  var stop = function stop() {\n    pause();\n    reset();\n  };\n  return {\n    count: count,\n    is_running: is_running,\n    start: start,\n    pause: pause,\n    reset: reset,\n    stop: stop\n  };\n};\n/* harmony default export */ const src_useCountdown = ((/* unused pure expression or super */ null && (useCountdown_useCountdown)));\n;// CONCATENATED MODULE: ../../hooks/src/useCryptoTransactions.ts\nfunction src_useCryptoTransactions_typeof(obj) { \"@babel/helpers - typeof\"; return src_useCryptoTransactions_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, src_useCryptoTransactions_typeof(obj); }\nvar src_useCryptoTransactions_excluded = (/* unused pure expression or super */ null && ([\"subscribe\", \"data\"]));\nfunction src_useCryptoTransactions_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction src_useCryptoTransactions_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? src_useCryptoTransactions_ownKeys(Object(source), !0).forEach(function (key) { src_useCryptoTransactions_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : src_useCryptoTransactions_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction src_useCryptoTransactions_defineProperty(obj, key, value) { key = src_useCryptoTransactions_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction src_useCryptoTransactions_toPropertyKey(arg) { var key = src_useCryptoTransactions_toPrimitive(arg, \"string\"); return src_useCryptoTransactions_typeof(key) === \"symbol\" ? key : String(key); }\nfunction src_useCryptoTransactions_toPrimitive(input, hint) { if (src_useCryptoTransactions_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (src_useCryptoTransactions_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction src_useCryptoTransactions_toConsumableArray(arr) { return src_useCryptoTransactions_arrayWithoutHoles(arr) || src_useCryptoTransactions_iterableToArray(arr) || src_useCryptoTransactions_unsupportedIterableToArray(arr) || src_useCryptoTransactions_nonIterableSpread(); }\nfunction src_useCryptoTransactions_nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction src_useCryptoTransactions_iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction src_useCryptoTransactions_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return src_useCryptoTransactions_arrayLikeToArray(arr); }\nfunction src_useCryptoTransactions_slicedToArray(arr, i) { return src_useCryptoTransactions_arrayWithHoles(arr) || src_useCryptoTransactions_iterableToArrayLimit(arr, i) || src_useCryptoTransactions_unsupportedIterableToArray(arr, i) || src_useCryptoTransactions_nonIterableRest(); }\nfunction src_useCryptoTransactions_nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction src_useCryptoTransactions_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return src_useCryptoTransactions_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return src_useCryptoTransactions_arrayLikeToArray(o, minLen); }\nfunction src_useCryptoTransactions_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction src_useCryptoTransactions_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction src_useCryptoTransactions_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction src_useCryptoTransactions_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = src_useCryptoTransactions_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction src_useCryptoTransactions_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n/** A custom hook that returns the list of pending crypto transactions for the current user. */\nvar useCryptoTransactions_useCryptoTransactions = function useCryptoTransactions() {\n  var _data$cashier_payment2;\n  var _useSubscription = useSubscription('cashier_payments'),\n    subscribe = _useSubscription.subscribe,\n    data = _useSubscription.data,\n    rest = src_useCryptoTransactions_objectWithoutProperties(_useSubscription, src_useCryptoTransactions_excluded);\n  var _useState = useState(),\n    _useState2 = src_useCryptoTransactions_slicedToArray(_useState, 2),\n    transactions = _useState2[0],\n    setTransactions = _useState2[1];\n  useEffect(function () {\n    subscribe();\n  }, [subscribe]);\n  useEffect(function () {\n    setTransactions(function (old_transactions) {\n      var _data$cashier_payment;\n      // Get the list of the crypto transactions.\n      var new_transactions = data === null || data === void 0 ? void 0 : (_data$cashier_payment = data.cashier_payments) === null || _data$cashier_payment === void 0 ? void 0 : _data$cashier_payment.crypto;\n\n      // If there are no new transactions, return the old transactions.\n      if (!new_transactions) return old_transactions;\n\n      // If there are no old transactions, return the new transactions.\n      if (!old_transactions) return new_transactions;\n\n      // Make a copy of the old transactions.\n      var updated_transactions = src_useCryptoTransactions_toConsumableArray(old_transactions);\n\n      // For each new transaction, check if it exists in the old transactions.\n      new_transactions.forEach(function (new_transaction) {\n        // Find the index of the new transaction in the old transactions if exists.\n        var index = updated_transactions.findIndex(function (old_transaction) {\n          return old_transaction.id === new_transaction.id;\n        });\n\n        // If the new transaction does not exist in the old transactions, add it, otherwise update it.\n        if (index === -1) {\n          updated_transactions.push(new_transaction);\n        } else {\n          updated_transactions[index] = new_transaction;\n        }\n      });\n\n      // Return the updated transactions.\n      return updated_transactions;\n    });\n  }, [data === null || data === void 0 ? void 0 : (_data$cashier_payment2 = data.cashier_payments) === null || _data$cashier_payment2 === void 0 ? void 0 : _data$cashier_payment2.crypto]);\n\n  // Add additional information to each transaction.\n  var modified_transactions = useMemo(function () {\n    return transactions === null || transactions === void 0 ? void 0 : transactions.map(function (transaction) {\n      return src_useCryptoTransactions_objectSpread(src_useCryptoTransactions_objectSpread({}, transaction), {}, {\n        /** Determine if the transaction is a deposit or not. */\n        is_deposit: transaction.transaction_type === 'deposit',\n        /** Determine if the transaction is a withdrawal or not. */\n        is_withdrawal: transaction.transaction_type === 'withdrawal'\n      });\n    });\n  }, [transactions]);\n\n  // Sort transactions by submit time.\n  var sorted_transactions = useMemo(function () {\n    return modified_transactions === null || modified_transactions === void 0 ? void 0 : modified_transactions.sort(function (a, b) {\n      return b.submit_date - a.submit_date;\n    });\n  }, [modified_transactions]);\n\n  // Determine if the user has any transactions or not.\n  var has_transactions = modified_transactions && modified_transactions.length > 0;\n\n  // Get the last transaction if exists.\n  var last_transaction = modified_transactions === null || modified_transactions === void 0 ? void 0 : modified_transactions[0];\n  return src_useCryptoTransactions_objectSpread({\n    /** List of user transactions sorted by submit time. */\n    data: sorted_transactions,\n    /** Returns the last transaction if exists. */\n    last_transaction: last_transaction,\n    /** Determine is the user has any transactions or not. */\n    has_transactions: has_transactions,\n    subscribe: subscribe\n  }, rest);\n};\n/* harmony default export */ const src_useCryptoTransactions = ((/* unused pure expression or super */ null && (useCryptoTransactions_useCryptoTransactions)));\n;// CONCATENATED MODULE: ../../hooks/src/useCurrentAccountDetails.ts\n\nvar useCurrentAccountDetails = function useCurrentAccountDetails() {\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var account_list = client.account_list,\n    loginid = client.loginid;\n  return account_list.find(function (account) {\n    return loginid === account.loginid;\n  });\n};\n/* harmony default export */ const src_useCurrentAccountDetails = ((/* unused pure expression or super */ null && (useCurrentAccountDetails)));\n;// CONCATENATED MODULE: ../../hooks/src/useCurrentCurrencyConfig.ts\n\n\n\n/** A custom hook to get the currency config information for the user's current currency. */\nvar useCurrentCurrencyConfig = function useCurrentCurrencyConfig() {\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var currency = client.currency;\n  var _useCurrencyConfig = useCurrencyConfig(),\n    getConfig = _useCurrencyConfig.getConfig;\n  var currency_config = getConfig(currency);\n\n  // Safe to do null assertion here because the user's currency is always\n  // available in the currency config object so it can't be null.\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  return currency_config;\n};\n/* harmony default export */ const src_useCurrentCurrencyConfig = ((/* unused pure expression or super */ null && (useCurrentCurrencyConfig)));\n;// CONCATENATED MODULE: ../../hooks/src/useDepositCryptoAddress.ts\nfunction src_useDepositCryptoAddress_typeof(obj) { \"@babel/helpers - typeof\"; return src_useDepositCryptoAddress_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, src_useDepositCryptoAddress_typeof(obj); }\nvar src_useDepositCryptoAddress_excluded = (/* unused pure expression or super */ null && ([\"data\", \"mutate\"]));\nfunction src_useDepositCryptoAddress_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction src_useDepositCryptoAddress_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? src_useDepositCryptoAddress_ownKeys(Object(source), !0).forEach(function (key) { src_useDepositCryptoAddress_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : src_useDepositCryptoAddress_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction src_useDepositCryptoAddress_defineProperty(obj, key, value) { key = src_useDepositCryptoAddress_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction src_useDepositCryptoAddress_toPropertyKey(arg) { var key = src_useDepositCryptoAddress_toPrimitive(arg, \"string\"); return src_useDepositCryptoAddress_typeof(key) === \"symbol\" ? key : String(key); }\nfunction src_useDepositCryptoAddress_toPrimitive(input, hint) { if (src_useDepositCryptoAddress_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (src_useDepositCryptoAddress_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction src_useDepositCryptoAddress_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = src_useDepositCryptoAddress_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction src_useDepositCryptoAddress_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\nvar useDepositCryptoAddress_useDepositCryptoAddress = function useDepositCryptoAddress() {\n  var _data$cashier, _data$cashier$deposit;\n  var _useRequest = useRequest('cashier'),\n    data = _useRequest.data,\n    mutate = _useRequest.mutate,\n    rest = src_useDepositCryptoAddress_objectWithoutProperties(_useRequest, src_useDepositCryptoAddress_excluded);\n  var deposit_address = typeof (data === null || data === void 0 ? void 0 : data.cashier) !== 'string' ? data === null || data === void 0 ? void 0 : (_data$cashier = data.cashier) === null || _data$cashier === void 0 ? void 0 : (_data$cashier$deposit = _data$cashier.deposit) === null || _data$cashier$deposit === void 0 ? void 0 : _data$cashier$deposit.address : undefined;\n  var send = useCallback(function () {\n    return mutate({\n      payload: {\n        cashier: 'deposit',\n        provider: 'crypto',\n        type: 'api'\n      }\n    });\n  }, [mutate]);\n  useEffect(function () {\n    send();\n  }, [send]);\n  return src_useDepositCryptoAddress_objectSpread(src_useDepositCryptoAddress_objectSpread({}, rest), {}, {\n    resend: send,\n    data: deposit_address\n  });\n};\n/* harmony default export */ const src_useDepositCryptoAddress = ((/* unused pure expression or super */ null && (useDepositCryptoAddress_useDepositCryptoAddress)));\n;// CONCATENATED MODULE: ../../hooks/src/useDepositFiatAddress.ts\nfunction useDepositFiatAddress_typeof(obj) { \"@babel/helpers - typeof\"; return useDepositFiatAddress_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useDepositFiatAddress_typeof(obj); }\nvar useDepositFiatAddress_excluded = (/* unused pure expression or super */ null && ([\"data\", \"mutate\"]));\nfunction useDepositFiatAddress_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useDepositFiatAddress_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useDepositFiatAddress_ownKeys(Object(source), !0).forEach(function (key) { useDepositFiatAddress_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useDepositFiatAddress_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useDepositFiatAddress_defineProperty(obj, key, value) { key = useDepositFiatAddress_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useDepositFiatAddress_toPropertyKey(arg) { var key = useDepositFiatAddress_toPrimitive(arg, \"string\"); return useDepositFiatAddress_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useDepositFiatAddress_toPrimitive(input, hint) { if (useDepositFiatAddress_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useDepositFiatAddress_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useDepositFiatAddress_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useDepositFiatAddress_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useDepositFiatAddress_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\nvar useDepositFiatAddress = function useDepositFiatAddress() {\n  var _useStore = useStore(),\n    ui = _useStore.ui;\n  var is_dark_mode_on = ui.is_dark_mode_on;\n  var _useRequest = useRequest('cashier'),\n    data = _useRequest.data,\n    mutate = _useRequest.mutate,\n    rest = useDepositFiatAddress_objectWithoutProperties(_useRequest, useDepositFiatAddress_excluded);\n  var deposit_iframe_url = typeof (data === null || data === void 0 ? void 0 : data.cashier) === 'string' ? \"\".concat(data === null || data === void 0 ? void 0 : data.cashier, \"&DarkMode=\").concat(is_dark_mode_on ? 'on' : 'off') : undefined;\n  var send = useCallback(function () {\n    return mutate({\n      payload: {\n        cashier: 'deposit',\n        provider: 'doughflow'\n      }\n    });\n  }, [mutate]);\n  useEffect(function () {\n    send();\n  }, [send]);\n  return useDepositFiatAddress_objectSpread(useDepositFiatAddress_objectSpread({}, rest), {}, {\n    resend: send,\n    data: deposit_iframe_url\n  });\n};\n/* harmony default export */ const src_useDepositFiatAddress = ((/* unused pure expression or super */ null && (useDepositFiatAddress)));\n;// CONCATENATED MODULE: ../../hooks/src/useNeedAuthentication.ts\n\nvar useNeedAuthentication_useNeedAuthentication = function useNeedAuthentication() {\n  var _useStore = useStore(),\n    client = _useStore.client,\n    traders_hub = _useStore.traders_hub;\n  var is_authentication_needed = client.is_authentication_needed;\n  var is_low_risk_cr_eu_real = traders_hub.is_low_risk_cr_eu_real;\n  var is_need_authentication = is_authentication_needed && is_low_risk_cr_eu_real;\n  return is_need_authentication;\n};\n/* harmony default export */ const src_useNeedAuthentication = ((/* unused pure expression or super */ null && (useNeedAuthentication_useNeedAuthentication)));\n;// CONCATENATED MODULE: ../../hooks/src/useNeedFinancialAssessment.ts\n\nvar useNeedFinancialAssessment_useNeedFinancialAssessment = function useNeedFinancialAssessment() {\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var is_financial_account = client.is_financial_account,\n    is_financial_information_incomplete = client.is_financial_information_incomplete,\n    is_trading_experience_incomplete = client.is_trading_experience_incomplete;\n  var is_need_financial_assessment = is_financial_account && (is_financial_information_incomplete || is_trading_experience_incomplete);\n  return is_need_financial_assessment;\n};\n/* harmony default export */ const src_useNeedFinancialAssessment = ((/* unused pure expression or super */ null && (useNeedFinancialAssessment_useNeedFinancialAssessment)));\n;// CONCATENATED MODULE: ../../hooks/src/useRealSTPAccount.ts\n\nvar useRealSTPAccount_useRealSTPAccount = function useRealSTPAccount() {\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var mt5_login_list = client.mt5_login_list;\n  var has_real_stp_account = mt5_login_list.some(function (item) {\n    return item.account_type === 'real' && item.sub_account_type === 'financial_stp';\n  });\n  return has_real_stp_account;\n};\n/* harmony default export */ const src_useRealSTPAccount = ((/* unused pure expression or super */ null && (useRealSTPAccount_useRealSTPAccount)));\n;// CONCATENATED MODULE: ../../hooks/src/useNeedTNC.ts\n\n\nvar useNeedTNC_useNeedTNC = function useNeedTNC() {\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var is_eu = client.is_eu,\n    is_tnc_needed = client.is_tnc_needed;\n  var has_real_stp_account = useRealSTPAccount();\n  var is_need_tnc = (is_eu || has_real_stp_account) && is_tnc_needed;\n  return is_need_tnc;\n};\n/* harmony default export */ const src_useNeedTNC = ((/* unused pure expression or super */ null && (useNeedTNC_useNeedTNC)));\n;// CONCATENATED MODULE: ../../hooks/src/useDepositLocked.ts\n\n\n\n\nvar useDepositLocked = function useDepositLocked() {\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var is_deposit_lock = client.is_deposit_lock,\n    is_trading_experience_incomplete = client.is_trading_experience_incomplete,\n    landing_company_shortcode = client.landing_company_shortcode;\n  var is_need_authentication = useNeedAuthentication();\n  var is_need_tnc = useNeedTNC();\n  var is_need_financial_assessment = useNeedFinancialAssessment();\n  var is_malta_invest = landing_company_shortcode === 'maltainvest';\n  var is_trading_experience_incomplete_or_need_financial_assessment = is_malta_invest ? is_trading_experience_incomplete : is_need_financial_assessment;\n  var is_deposit_locked = is_deposit_lock || is_need_authentication || is_need_tnc || is_trading_experience_incomplete_or_need_financial_assessment;\n  return is_deposit_locked;\n};\n/* harmony default export */ const src_useDepositLocked = ((/* unused pure expression or super */ null && (useDepositLocked)));\n;// CONCATENATED MODULE: ../../hooks/src/useExchangeRate.ts\n\n\n\n/**\n * we can use this hook to get the exchange rate for the given currency.\n * exchange_rates comes from store and includes the rates for all currencies based on USD.\n */\nvar src_useExchangeRate_useExchangeRate = function useExchangeRate() {\n  var _useStore = useStore(),\n    exchange_rates = _useStore.exchange_rates;\n  var data = exchange_rates.data;\n  var rates = data === null || data === void 0 ? void 0 : data.rates;\n  var getRate = useCallback(function (currency) {\n    return (rates === null || rates === void 0 ? void 0 : rates[currency]) || 1;\n  }, [rates]);\n  return {\n    getRate: getRate,\n    last_update: data === null || data === void 0 ? void 0 : data.date,\n    base_currency: (data === null || data === void 0 ? void 0 : data.base_currency) || 'USD'\n  };\n};\n/* harmony default export */ const src_useExchangeRate = ((/* unused pure expression or super */ null && (src_useExchangeRate_useExchangeRate)));\n;// CONCATENATED MODULE: ../../hooks/src/useExistingCFDAccounts.ts\nfunction useExistingCFDAccounts_typeof(obj) { \"@babel/helpers - typeof\"; return useExistingCFDAccounts_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useExistingCFDAccounts_typeof(obj); }\nvar useExistingCFDAccounts_excluded = (/* unused pure expression or super */ null && ([\"data\"])),\n  useExistingCFDAccounts_excluded2 = (/* unused pure expression or super */ null && ([\"data\"])),\n  _excluded3 = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useExistingCFDAccounts_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useExistingCFDAccounts_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useExistingCFDAccounts_ownKeys(Object(source), !0).forEach(function (key) { useExistingCFDAccounts_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useExistingCFDAccounts_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useExistingCFDAccounts_defineProperty(obj, key, value) { key = useExistingCFDAccounts_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useExistingCFDAccounts_toPropertyKey(arg) { var key = useExistingCFDAccounts_toPrimitive(arg, \"string\"); return useExistingCFDAccounts_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useExistingCFDAccounts_toPrimitive(input, hint) { if (useExistingCFDAccounts_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useExistingCFDAccounts_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useExistingCFDAccounts_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useExistingCFDAccounts_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useExistingCFDAccounts_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\nvar getAccountIcon = function getAccountIcon(_ref) {\n  var cfd_type = _ref.cfd_type,\n    market_type = _ref.market_type;\n  switch (cfd_type) {\n    case 'mt5':\n      {\n        switch (market_type) {\n          case 'financial':\n            return 'IcRebrandingMt5FinancialDashboard';\n          case 'synthetic':\n            return 'IcRebrandingMt5DerivedDashboard';\n          case 'all':\n            return 'IcRebrandingMt5SwapFree';\n          default:\n            return 'IcRebrandingDmt5Dashboard';\n        }\n      }\n    case 'derivez':\n      return 'IcRebrandingDerivEz';\n    case 'dxtrade':\n      return 'IcRebrandingDerivX';\n    default:\n      return '';\n  }\n};\n\n/**\n * @description This hook is used to get the created CFD accounts of the user.\n */\nvar useExistingCFDAccounts_useExistingCFDAccounts = function useExistingCFDAccounts() {\n  var _useStore = useStore(),\n    traders_hub = _useStore.traders_hub;\n  var combined_cfd_mt5_accounts = traders_hub.combined_cfd_mt5_accounts;\n  var wallet = useActiveWallet();\n  var _useFetch = useFetch('mt5_login_list'),\n    mt5 = _useFetch.data,\n    mt5_rest = useExistingCFDAccounts_objectWithoutProperties(_useFetch, useExistingCFDAccounts_excluded);\n  var _useFetch2 = useFetch('trading_platform_accounts', {\n      payload: {\n        platform: 'derivez'\n      }\n    }),\n    derivez = _useFetch2.data,\n    derivez_rest = useExistingCFDAccounts_objectWithoutProperties(_useFetch2, useExistingCFDAccounts_excluded2);\n  var _useFetch3 = useFetch('trading_platform_accounts', {\n      payload: {\n        platform: 'dxtrade'\n      }\n    }),\n    dxtrade = _useFetch3.data,\n    dxtrade_rest = useExistingCFDAccounts_objectWithoutProperties(_useFetch3, _excluded3);\n\n  /**\n   *\n   * @description This is the modified MT5 accounts that will be used in the CFD account creation.\n   */\n  var modified_mt5_accounts = useMemo(function () {\n    var _mt5$mt5_login_list;\n    var getAccountInfo = function getAccountInfo(login) {\n      var _wallet$linked_to, _wallet$linked_to$fin, _combined_cfd_mt5_acc, _combined_cfd_mt5_acc2, _combined_cfd_mt5_acc3, _combined_cfd_mt5_acc4;\n      return {\n        platform: wallet === null || wallet === void 0 ? void 0 : (_wallet$linked_to = wallet.linked_to) === null || _wallet$linked_to === void 0 ? void 0 : (_wallet$linked_to$fin = _wallet$linked_to.find(function (linked) {\n          return linked.loginid === login;\n        })) === null || _wallet$linked_to$fin === void 0 ? void 0 : _wallet$linked_to$fin.platform,\n        icon: combined_cfd_mt5_accounts === null || combined_cfd_mt5_accounts === void 0 ? void 0 : (_combined_cfd_mt5_acc = combined_cfd_mt5_accounts.find(function (cfd) {\n          return cfd.login === login;\n        })) === null || _combined_cfd_mt5_acc === void 0 ? void 0 : _combined_cfd_mt5_acc.icon,\n        description: combined_cfd_mt5_accounts === null || combined_cfd_mt5_accounts === void 0 ? void 0 : (_combined_cfd_mt5_acc2 = combined_cfd_mt5_accounts.find(function (cfd) {\n          return cfd.login === login;\n        })) === null || _combined_cfd_mt5_acc2 === void 0 ? void 0 : _combined_cfd_mt5_acc2.description,\n        name: combined_cfd_mt5_accounts === null || combined_cfd_mt5_accounts === void 0 ? void 0 : (_combined_cfd_mt5_acc3 = combined_cfd_mt5_accounts.find(function (cfd) {\n          return cfd.login === login;\n        })) === null || _combined_cfd_mt5_acc3 === void 0 ? void 0 : _combined_cfd_mt5_acc3.name,\n        sub_title: combined_cfd_mt5_accounts === null || combined_cfd_mt5_accounts === void 0 ? void 0 : (_combined_cfd_mt5_acc4 = combined_cfd_mt5_accounts.find(function (cfd) {\n          return cfd.login === login;\n        })) === null || _combined_cfd_mt5_acc4 === void 0 ? void 0 : _combined_cfd_mt5_acc4.sub_title,\n        action_type: 'multi-action'\n      };\n    };\n    return mt5 === null || mt5 === void 0 ? void 0 : (_mt5$mt5_login_list = mt5.mt5_login_list) === null || _mt5$mt5_login_list === void 0 ? void 0 : _mt5$mt5_login_list.map(function (account) {\n      return useExistingCFDAccounts_objectSpread(useExistingCFDAccounts_objectSpread(useExistingCFDAccounts_objectSpread({}, account), getAccountInfo(account.login)), {}, {\n        loginid: account.login,\n        transfer_icon: getAccountIcon(useExistingCFDAccounts_objectSpread({\n          cfd_type: 'mt5'\n        }, account))\n      });\n    });\n  }, [mt5 === null || mt5 === void 0 ? void 0 : mt5.mt5_login_list, wallet === null || wallet === void 0 ? void 0 : wallet.linked_to, combined_cfd_mt5_accounts]);\n  var modified_derivez_accounts = useMemo(function () {\n    var _derivez$trading_plat;\n    return derivez === null || derivez === void 0 ? void 0 : (_derivez$trading_plat = derivez.trading_platform_accounts) === null || _derivez$trading_plat === void 0 ? void 0 : _derivez$trading_plat.map(function (account) {\n      return useExistingCFDAccounts_objectSpread(useExistingCFDAccounts_objectSpread({}, account), {}, {\n        loginid: account.login,\n        transfer_icon: getAccountIcon({\n          cfd_type: 'derivez'\n        })\n      });\n    });\n  }, [derivez === null || derivez === void 0 ? void 0 : derivez.trading_platform_accounts]);\n  var modified_dxtrade_accounts = useMemo(function () {\n    var _dxtrade$trading_plat;\n    return dxtrade === null || dxtrade === void 0 ? void 0 : (_dxtrade$trading_plat = dxtrade.trading_platform_accounts) === null || _dxtrade$trading_plat === void 0 ? void 0 : _dxtrade$trading_plat.map(function (account) {\n      return useExistingCFDAccounts_objectSpread(useExistingCFDAccounts_objectSpread({}, account), {}, {\n        loginid: account.account_id,\n        transfer_icon: getAccountIcon({\n          cfd_type: 'dxtrade'\n        })\n      });\n    });\n  }, [dxtrade === null || dxtrade === void 0 ? void 0 : dxtrade.trading_platform_accounts]);\n  var data = useMemo(function () {\n    return {\n      mt5_accounts: modified_mt5_accounts || [],\n      dxtrade_accounts: modified_dxtrade_accounts || [],\n      derivez_accounts: modified_derivez_accounts || []\n    };\n  }, [modified_mt5_accounts, modified_dxtrade_accounts, modified_derivez_accounts]);\n  return {\n    data: data,\n    isSuccess: [mt5_rest.isSuccess, dxtrade_rest.isSuccess, derivez_rest.isSuccess].every(Boolean)\n  };\n};\n/* harmony default export */ const src_useExistingCFDAccounts = ((/* unused pure expression or super */ null && (useExistingCFDAccounts_useExistingCFDAccounts)));\n;// CONCATENATED MODULE: ../../hooks/src/useFeatureFlags.ts\nfunction useFeatureFlags_typeof(obj) { \"@babel/helpers - typeof\"; return useFeatureFlags_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useFeatureFlags_typeof(obj); }\nfunction useFeatureFlags_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useFeatureFlags_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useFeatureFlags_ownKeys(Object(source), !0).forEach(function (key) { useFeatureFlags_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useFeatureFlags_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useFeatureFlags_defineProperty(obj, key, value) { key = useFeatureFlags_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useFeatureFlags_toPropertyKey(arg) { var key = useFeatureFlags_toPrimitive(arg, \"string\"); return useFeatureFlags_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useFeatureFlags_toPrimitive(input, hint) { if (useFeatureFlags_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useFeatureFlags_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\nvar useFeatureFlags = function useFeatureFlags() {\n  var _useStore = useStore(),\n    feature_flags = _useStore.feature_flags;\n  var result = useMemo(function () {\n    // Safe to do null assertions here as we are setting default values in the store.\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    var flags = feature_flags.data;\n    return Object.keys(flags).reduce(function (previous, current) {\n      return useFeatureFlags_objectSpread(useFeatureFlags_objectSpread({}, previous), {}, useFeatureFlags_defineProperty({}, \"is_\".concat(current, \"_enabled\"), Boolean(flags[current])));\n    }, {});\n  }, [feature_flags.data]);\n  return result;\n};\n/* harmony default export */ const src_useFeatureFlags = ((/* unused pure expression or super */ null && (useFeatureFlags)));\n;// CONCATENATED MODULE: ../../hooks/src/useFiatAccountList.ts\n\nvar useFiatAccountList = function useFiatAccountList() {\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var account_list = client.account_list,\n    is_crypto = client.is_crypto;\n  var fiat_account_list = account_list.filter(function (account) {\n    return !account.is_virtual && !is_crypto(account.title || '');\n  });\n  return fiat_account_list;\n};\n/* harmony default export */ const src_useFiatAccountList = ((/* unused pure expression or super */ null && (useFiatAccountList)));\n;// CONCATENATED MODULE: ../../hooks/src/useHasActiveRealAccount.ts\n\nvar useHasActiveRealAccount_useHasActiveRealAccount = function useHasActiveRealAccount() {\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var active_accounts = client.active_accounts;\n  var has_active_real_account = active_accounts.some(function (account) {\n    return account.is_virtual === 0;\n  });\n  return has_active_real_account;\n};\n/* harmony default export */ const src_useHasActiveRealAccount = ((/* unused pure expression or super */ null && (useHasActiveRealAccount_useHasActiveRealAccount)));\n;// CONCATENATED MODULE: ../../hooks/src/useHasCryptoCurrency.ts\n\nvar useHasCryptoCurrency = function useHasCryptoCurrency() {\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var account_list = client.account_list,\n    is_crypto = client.is_crypto;\n  var has_crypto_currency = account_list.some(function (account) {\n    return is_crypto(account.title || 'USD');\n  });\n  return has_crypto_currency;\n};\n/* harmony default export */ const src_useHasCryptoCurrency = ((/* unused pure expression or super */ null && (useHasCryptoCurrency)));\n;// CONCATENATED MODULE: ../../hooks/src/useHasFiatCurrency.ts\n\n\nvar useHasFiatCurrency = function useHasFiatCurrency() {\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var account_list = client.account_list;\n  var _useCurrencyConfig = useCurrencyConfig(),\n    getConfig = _useCurrencyConfig.getConfig;\n  var has_fiat_currency = account_list.some(function (account) {\n    var _getConfig;\n    return account.title !== 'Real' && ((_getConfig = getConfig(account.title || '')) === null || _getConfig === void 0 ? void 0 : _getConfig.is_fiat);\n  });\n  return has_fiat_currency;\n};\n/* harmony default export */ const src_useHasFiatCurrency = ((/* unused pure expression or super */ null && (useHasFiatCurrency)));\n;// CONCATENATED MODULE: ../../hooks/src/useP2PConfig.ts\nfunction useP2PConfig_typeof(obj) { \"@babel/helpers - typeof\"; return useP2PConfig_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useP2PConfig_typeof(obj); }\nvar useP2PConfig_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useP2PConfig_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useP2PConfig_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useP2PConfig_ownKeys(Object(source), !0).forEach(function (key) { useP2PConfig_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useP2PConfig_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useP2PConfig_defineProperty(obj, key, value) { key = useP2PConfig_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useP2PConfig_toPropertyKey(arg) { var key = useP2PConfig_toPrimitive(arg, \"string\"); return useP2PConfig_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useP2PConfig_toPrimitive(input, hint) { if (useP2PConfig_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useP2PConfig_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useP2PConfig_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useP2PConfig_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useP2PConfig_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n/**\n * A custom hook to get the p2p_config information from `website_status` endpoint\n */\nvar useP2PConfig_useP2PConfig = function useP2PConfig() {\n  var _data$website_status2;\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var is_authorize = client.is_authorize,\n    loginid = client.loginid;\n  var _useFetch = useFetch('website_status', {\n      options: {\n        enabled: is_authorize\n      }\n    }),\n    data = _useFetch.data,\n    rest = useP2PConfig_objectWithoutProperties(_useFetch, useP2PConfig_excluded);\n  var invalidate = useInvalidateQuery();\n\n  // Add additional information to the p2p config data.\n  var modified_p2p_config = React.useMemo(function () {\n    var _data$website_status;\n    var p2p_config = data === null || data === void 0 ? void 0 : (_data$website_status = data.website_status) === null || _data$website_status === void 0 ? void 0 : _data$website_status.p2p_config;\n    if (!p2p_config) return undefined;\n    return useP2PConfig_objectSpread(useP2PConfig_objectSpread({}, p2p_config), {}, {\n      /** Indicates if the payment methods feature is enabled. */\n      is_payment_methods_enabled: Boolean(p2p_config === null || p2p_config === void 0 ? void 0 : p2p_config.payment_methods_enabled)\n    });\n  }, [data === null || data === void 0 ? void 0 : (_data$website_status2 = data.website_status) === null || _data$website_status2 === void 0 ? void 0 : _data$website_status2.p2p_config]);\n  React.useEffect(function () {\n    invalidate('website_status');\n  }, [invalidate, loginid]);\n  return useP2PConfig_objectSpread({\n    /** The p2p config response. */\n    data: modified_p2p_config\n  }, rest);\n};\n/* harmony default export */ const src_useP2PConfig = ((/* unused pure expression or super */ null && (useP2PConfig_useP2PConfig)));\n;// CONCATENATED MODULE: ../../hooks/src/useHasP2PSupportedCurrencies.ts\nfunction useHasP2PSupportedCurrencies_typeof(obj) { \"@babel/helpers - typeof\"; return useHasP2PSupportedCurrencies_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useHasP2PSupportedCurrencies_typeof(obj); }\nvar useHasP2PSupportedCurrencies_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useHasP2PSupportedCurrencies_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useHasP2PSupportedCurrencies_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useHasP2PSupportedCurrencies_ownKeys(Object(source), !0).forEach(function (key) { useHasP2PSupportedCurrencies_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useHasP2PSupportedCurrencies_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useHasP2PSupportedCurrencies_defineProperty(obj, key, value) { key = useHasP2PSupportedCurrencies_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useHasP2PSupportedCurrencies_toPropertyKey(arg) { var key = useHasP2PSupportedCurrencies_toPrimitive(arg, \"string\"); return useHasP2PSupportedCurrencies_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useHasP2PSupportedCurrencies_toPrimitive(input, hint) { if (useHasP2PSupportedCurrencies_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useHasP2PSupportedCurrencies_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useHasP2PSupportedCurrencies_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useHasP2PSupportedCurrencies_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useHasP2PSupportedCurrencies_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\nvar useHasP2PSupportedCurrencies = function useHasP2PSupportedCurrencies() {\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var active_accounts = client.active_accounts;\n  var _useP2PConfig = useP2PConfig(),\n    data = _useP2PConfig.data,\n    rest = useHasP2PSupportedCurrencies_objectWithoutProperties(_useP2PConfig, useHasP2PSupportedCurrencies_excluded);\n  var real_account_currencies_list = active_accounts.filter(function (account) {\n    return !account.is_virtual;\n  }).map(function (account) {\n    var _account$currency;\n    return (_account$currency = account.currency) === null || _account$currency === void 0 ? void 0 : _account$currency.toLowerCase();\n  });\n  var has_p2p_supported_currencies = Boolean(data === null || data === void 0 ? void 0 : data.supported_currencies.some(function (currency) {\n    return real_account_currencies_list.includes(currency);\n  }));\n  return useHasP2PSupportedCurrencies_objectSpread(useHasP2PSupportedCurrencies_objectSpread({}, rest), {}, {\n    data: has_p2p_supported_currencies\n  });\n};\n/* harmony default export */ const src_useHasP2PSupportedCurrencies = ((/* unused pure expression or super */ null && (useHasP2PSupportedCurrencies)));\n;// CONCATENATED MODULE: ../../hooks/src/useHasSetCurrency.ts\n\n\nvar useHasSetCurrency = function useHasSetCurrency() {\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var account_list = client.account_list;\n  var has_active_real_account = useHasActiveRealAccount();\n  var has_real_account = account_list.filter(function (account) {\n    return !account.is_virtual;\n  }).some(function (account) {\n    return account.title !== 'Real' && account.title !== 'Investment';\n  });\n  var has_set_currency = has_real_account || !has_active_real_account;\n  return has_set_currency;\n};\n/* harmony default export */ const src_useHasSetCurrency = ((/* unused pure expression or super */ null && (useHasSetCurrency)));\n;// CONCATENATED MODULE: ../../hooks/src/useHasSvgAccount.ts\n\nvar useHasSvgAccount_useHasSvgAccount = function useHasSvgAccount() {\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var active_accounts = client.active_accounts;\n  var has_svg_account = active_accounts.some(function (account) {\n    return account.landing_company_shortcode === 'svg';\n  });\n  return has_svg_account;\n};\n/* harmony default export */ const src_useHasSvgAccount = ((/* unused pure expression or super */ null && (useHasSvgAccount_useHasSvgAccount)));\n;// CONCATENATED MODULE: ../../hooks/src/useHasSwapFreeAccount.ts\n\n\n/**\n * This hook is used to check if the client has a Swap-Free account.\n * It checks for availability of market_type 'all' in trading_platform_available_accounts API response\n */\nvar useHasSwapFreeAccount = function useHasSwapFreeAccount() {\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var trading_platform_available_accounts = client.trading_platform_available_accounts;\n  var has_swap_free_account = trading_platform_available_accounts.some(function (available_account) {\n    return available_account.market_type === 'all';\n  });\n  return has_swap_free_account;\n};\n/* harmony default export */ const src_useHasSwapFreeAccount = ((/* unused pure expression or super */ null && (useHasSwapFreeAccount)));\n;// CONCATENATED MODULE: ../../hooks/src/useHasUSDCurrency.ts\n\nvar useHasUSDCurrency = function useHasUSDCurrency() {\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var account_list = client.account_list;\n  var has_usd_currency = account_list.some(function (account) {\n    return account.title === 'USD';\n  });\n  return has_usd_currency;\n};\n/* harmony default export */ const src_useHasUSDCurrency = ((/* unused pure expression or super */ null && (useHasUSDCurrency)));\n;// CONCATENATED MODULE: ../../hooks/src/useInputDecimalFormatter.ts\nfunction useInputDecimalFormatter_slicedToArray(arr, i) { return useInputDecimalFormatter_arrayWithHoles(arr) || useInputDecimalFormatter_iterableToArrayLimit(arr, i) || useInputDecimalFormatter_unsupportedIterableToArray(arr, i) || useInputDecimalFormatter_nonIterableRest(); }\nfunction useInputDecimalFormatter_nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction useInputDecimalFormatter_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return useInputDecimalFormatter_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return useInputDecimalFormatter_arrayLikeToArray(o, minLen); }\nfunction useInputDecimalFormatter_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction useInputDecimalFormatter_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction useInputDecimalFormatter_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar useInputDecimalFormatter_useInputDecimalFormatter = function useInputDecimalFormatter(initial, options) {\n  var _useState = useState(''),\n    _useState2 = useInputDecimalFormatter_slicedToArray(_useState, 2),\n    value = _useState2[0],\n    setValue = _useState2[1];\n  var _ref = options || {},\n    _ref$fraction_digits = _ref.fraction_digits,\n    fraction_digits = _ref$fraction_digits === void 0 ? 2 : _ref$fraction_digits,\n    _ref$with_sign = _ref.with_sign,\n    with_sign = _ref$with_sign === void 0 ? false : _ref$with_sign;\n  var onChange = useCallback(function (e) {\n    setValue(function (old_value) {\n      var _e$target;\n      var new_value = (e === null || e === void 0 ? void 0 : (_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.value) || '';\n      var isEmpty = new_value === '';\n\n      // The field has been cleared, So we return the new value.\n      if (isEmpty) return new_value;\n      var text = with_sign ? new_value : new_value.replaceAll(/[+-]/g, '');\n      var inputs = text.split('.');\n\n      // The field contains more than one dot, So we return the old value as only one dot\n      // is allowed.\n      if (inputs.length > 2) return old_value;\n      var left = inputs[0];\n      var right = inputs.length > 1 ? inputs[1] : null;\n      var has_right = right !== null && right !== '';\n\n      // The field value is positive or negative sign, So we return the new value without\n      // any calculations.\n      if ((left === '-' || left === '+') && !has_right) return new_value;\n\n      // The field value is 0, So we return the new value without any calculations.\n      if (left === '0' && !has_right) return new_value;\n      var is_number = !isNaN(Number(new_value));\n\n      // The input value is not a valid number, So we return the old value.\n      if (!is_number) return old_value;\n      var new_left = left.replaceAll(/[+-]/g, '');\n      var has_decimal = new_value.includes('.');\n\n      // The field starts with 0 but doesn't have decimal point, So we return the old value\n      // as the only valid input at this step is decimal point.\n      if (new_left.startsWith('0') && new_left.length !== 1 && !has_decimal) return old_value;\n\n      // The field have a decimal point and decimal places are already as allowed fraction\n      // digits, So we remove the extra decimal digits from the right and return the new value.\n      if (has_right && right.length > fraction_digits) {\n        var new_right = right.substring(0, fraction_digits);\n        return \"\".concat(left, \".\").concat(new_right);\n      }\n      return new_value;\n    });\n  }, [fraction_digits, with_sign]);\n  useEffect(function () {\n    if (initial) onChange({\n      target: {\n        value: \"\".concat(initial)\n      }\n    });\n  }, [initial, onChange]);\n  return {\n    value: value,\n    onChange: onChange\n  };\n};\n/* harmony default export */ const src_useInputDecimalFormatter = ((/* unused pure expression or super */ null && (useInputDecimalFormatter_useInputDecimalFormatter)));\n;// CONCATENATED MODULE: ../../hooks/src/useInputATMFormatter.ts\n\n\n\nvar useInputATMFormatter = function useInputATMFormatter(initial, options) {\n  var is_pasting = useRef(false);\n  var _useInputDecimalForma = useInputDecimalFormatter(undefined, options),\n    value = _useInputDecimalForma.value,\n    onChangeDecimal = _useInputDecimalForma.onChange;\n  var _ref = options || {},\n    locale = _ref.locale,\n    _ref$fraction_digits = _ref.fraction_digits,\n    fraction_digits = _ref$fraction_digits === void 0 ? 2 : _ref$fraction_digits;\n  var formatted_value = useMemo(function () {\n    return \"\".concat(Number(value).toLocaleString(locale, {\n      minimumFractionDigits: fraction_digits\n    }));\n  }, [fraction_digits, locale, value]);\n  var onChange = useCallback(function (e) {\n    var _e$target, _unformatted$split, _unformatted$split$;\n    var new_value = (e === null || e === void 0 ? void 0 : (_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.value) || '';\n    var unformatted = unFormatLocaleString(new_value, locale);\n    // @ts-expect-error shouldn't cast to number because we will lose the trailing zeros.\n    var shifted = Math.fround(unformatted * 10).toFixed(fraction_digits);\n    // @ts-expect-error shouldn't cast to number because we will lose the trailing zeros.\n    var un_shifted = Math.fround(unformatted / 10).toFixed(fraction_digits);\n    var unformatted_fraction = ((_unformatted$split = unformatted.split('.')) === null || _unformatted$split === void 0 ? void 0 : (_unformatted$split$ = _unformatted$split[1]) === null || _unformatted$split$ === void 0 ? void 0 : _unformatted$split$.length) || fraction_digits;\n\n    // If the user is pasting, we don't need to shift the decimal point,\n    // We just need to format the value.\n    if (is_pasting.current) {\n      is_pasting.current = false;\n      return onChangeDecimal({\n        target: {\n          value: unformatted\n        }\n      });\n    }\n\n    // The new value has one more decimal places than the fraction_digits,\n    // so we need to shift the decimal point to the left.\n    if (unformatted_fraction - 1 === fraction_digits) {\n      return onChangeDecimal({\n        target: {\n          value: shifted\n        }\n      });\n    }\n\n    // The new value has one less decimal places than the fraction_digits,\n    // so we need to shift the decimal point to the right.\n    if (unformatted_fraction + 1 === fraction_digits) {\n      return onChangeDecimal({\n        target: {\n          value: un_shifted\n        }\n      });\n    }\n\n    // The new value has the same number of decimal places as the fraction_digits,\n    // so we don't need to shift the decimal point.\n    if (unformatted_fraction === fraction_digits) {\n      return onChangeDecimal({\n        target: {\n          value: unformatted\n        }\n      });\n    }\n\n    // The new value has more decimal places than the fraction_digits,\n    // so we chop the extra decimal points.\n    if (unformatted_fraction - 1 > fraction_digits) {\n      return onChangeDecimal({\n        target: {\n          value: unformatted\n        }\n      });\n    }\n\n    // The new value has less decimal places than the fraction_digits,\n    // so we add the missing extra decimal point.\n    if (unformatted_fraction + 1 < fraction_digits) {\n      return onChangeDecimal({\n        target: {\n          value: unformatted\n        }\n      });\n    }\n    return onChangeDecimal({\n      target: {\n        value: unformatted\n      }\n    });\n  }, [locale, fraction_digits, onChangeDecimal]);\n  var onPaste = useCallback(function (e) {\n    return is_pasting.current = e.type === 'paste';\n  }, []);\n  useEffect(function () {\n    if (initial) {\n      is_pasting.current = true;\n      onChange({\n        target: {\n          value: \"\".concat(Number(initial).toLocaleString(locale, {\n            minimumFractionDigits: fraction_digits\n          }))\n        }\n      });\n    }\n  }, [fraction_digits, initial, locale, onChange]);\n  return {\n    value: formatted_value,\n    onChange: onChange,\n    onPaste: onPaste\n  };\n};\n/* harmony default export */ const src_useInputATMFormatter = ((/* unused pure expression or super */ null && (useInputATMFormatter)));\n;// CONCATENATED MODULE: ../../hooks/src/useIsAccountStatusPresent.ts\n\n\nvar AccountStatusList = (/* unused pure expression or super */ null && (['address_verified', 'age_verification', 'allow_document_upload', 'allow_poa_resubmission', 'allow_poi_resubmission', 'authenticated', 'authenticated_with_idv_photoid', 'cashier_locked', 'crs_tin_information', 'deposit_attempt', 'deposit_locked', 'df_deposit_requires_poi', 'disabled', 'document_expired', 'document_expiring_soon', 'document_under_review', 'dxtrade_password_not_set', 'financial_assessment_not_complete', 'financial_information_not_complete', 'financial_risk_approval', 'idv_revoked', 'max_turnover_limit_not_set', 'mt5_password_not_set', 'mt5_withdrawal_locked', 'needs_affiliate_coc_approval', 'no_trading', 'no_withdrawal_or_trading', 'p2p_blocked_for_pa', 'pa_withdrawal_explicitly_allowed', 'password_reset_required', 'personal_details_locked', 'poi_name_mismatch', 'professional', 'professional_requested', 'professional_rejected', 'shared_payment_method', 'social_signup', 'transfers_blocked', 'trading_experience_not_complete', 'ukgc_funds_protection', 'unwelcome', 'withdrawal_locked']));\n/**\n * Custom hook to check if a particular account status is present.\n * @name useIsAccountStatusPresent\n * @param status of the account to check\n * @returns boolean\n */\nvar useIsAccountStatusPresent = function useIsAccountStatusPresent(status) {\n  var _useStore = useStore(),\n    account_status = _useStore.client.account_status;\n  var status_list = account_status === null || account_status === void 0 ? void 0 : account_status.status;\n  return React.useMemo(function () {\n    var _status_list$includes;\n    return (_status_list$includes = status_list === null || status_list === void 0 ? void 0 : status_list.includes(status)) !== null && _status_list$includes !== void 0 ? _status_list$includes : false;\n  }, [status_list, status]);\n};\n/* harmony default export */ const src_useIsAccountStatusPresent = ((/* unused pure expression or super */ null && (useIsAccountStatusPresent)));\n;// CONCATENATED MODULE: ../../hooks/src/useIsP2PEnabled.ts\nfunction useIsP2PEnabled_typeof(obj) { \"@babel/helpers - typeof\"; return useIsP2PEnabled_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useIsP2PEnabled_typeof(obj); }\nvar useIsP2PEnabled_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useIsP2PEnabled_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useIsP2PEnabled_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useIsP2PEnabled_ownKeys(Object(source), !0).forEach(function (key) { useIsP2PEnabled_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useIsP2PEnabled_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useIsP2PEnabled_defineProperty(obj, key, value) { key = useIsP2PEnabled_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useIsP2PEnabled_toPropertyKey(arg) { var key = useIsP2PEnabled_toPrimitive(arg, \"string\"); return useIsP2PEnabled_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useIsP2PEnabled_toPrimitive(input, hint) { if (useIsP2PEnabled_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useIsP2PEnabled_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useIsP2PEnabled_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useIsP2PEnabled_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useIsP2PEnabled_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\nvar useIsP2PEnabled = function useIsP2PEnabled() {\n  var _useStore = useStore(),\n    client = _useStore.client,\n    traders_hub = _useStore.traders_hub;\n  // Todo: to replace it with useAuthorize hook\n  var currency = client.currency,\n    is_virtual = client.is_virtual;\n  var is_low_risk_cr_eu_real = traders_hub.is_low_risk_cr_eu_real;\n  var _useP2PConfig = useP2PConfig(),\n    data = _useP2PConfig.data,\n    rest = useIsP2PEnabled_objectWithoutProperties(_useP2PConfig, useIsP2PEnabled_excluded);\n  var is_p2p_supported_currency = Boolean(data === null || data === void 0 ? void 0 : data.supported_currencies.includes(currency.toLocaleLowerCase()));\n  var is_p2p_enabled = is_p2p_supported_currency && !is_virtual && !is_low_risk_cr_eu_real;\n\n  // Todo: should replace with the next line instead once BE is fixed.\n  // const is_p2p_enabled = data?.disabled === 0;\n\n  return useIsP2PEnabled_objectSpread(useIsP2PEnabled_objectSpread({}, rest), {}, {\n    data: is_p2p_enabled\n  });\n};\n/* harmony default export */ const src_useIsP2PEnabled = ((/* unused pure expression or super */ null && (useIsP2PEnabled)));\n;// CONCATENATED MODULE: ../../hooks/src/useIsRealAccountNeededForCashier.ts\n\n\n\nvar useIsRealAccountNeededForCashier = function useIsRealAccountNeededForCashier() {\n  var _useStore = useStore(),\n    traders_hub = _useStore.traders_hub;\n  var is_eu_user = traders_hub.is_eu_user,\n    is_real = traders_hub.is_real;\n  var has_svg_account = useHasSvgAccount();\n  var has_maltainvest_account = useHasMaltaInvestAccount();\n  var no_real_mf_account = has_svg_account && !has_maltainvest_account && is_eu_user;\n  var no_real_cr_account = !has_svg_account && has_maltainvest_account && !is_eu_user;\n  var is_real_account_needed = no_real_mf_account || no_real_cr_account;\n  var is_real_account_needed_for_cashier = is_real_account_needed && is_real;\n  return is_real_account_needed_for_cashier;\n};\n/* harmony default export */ const src_useIsRealAccountNeededForCashier = ((/* unused pure expression or super */ null && (useIsRealAccountNeededForCashier)));\n;// CONCATENATED MODULE: ../../hooks/src/useIsSystemMaintenance.ts\n\nvar useIsSystemMaintenance = function useIsSystemMaintenance() {\n  var _account_status$cashi;\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var account_status = client.account_status;\n  var is_system_maintenance = ((_account_status$cashi = account_status.cashier_validation) === null || _account_status$cashi === void 0 ? void 0 : _account_status$cashi.some(function (validation) {\n    return validation === 'system_maintenance';\n  })) || false;\n  return is_system_maintenance;\n};\n/* harmony default export */ const src_useIsSystemMaintenance = ((/* unused pure expression or super */ null && (useIsSystemMaintenance)));\n;// CONCATENATED MODULE: ../../hooks/src/useLocalStorageData.ts\nfunction useLocalStorageData_slicedToArray(arr, i) { return useLocalStorageData_arrayWithHoles(arr) || useLocalStorageData_iterableToArrayLimit(arr, i) || useLocalStorageData_unsupportedIterableToArray(arr, i) || useLocalStorageData_nonIterableRest(); }\nfunction useLocalStorageData_nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction useLocalStorageData_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return useLocalStorageData_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return useLocalStorageData_arrayLikeToArray(o, minLen); }\nfunction useLocalStorageData_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction useLocalStorageData_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction useLocalStorageData_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n/**\n * Hook that manages a localStorage value as a React state.\n * @template T - The generic type of the localStorage value.\n * @param {string} key - The localStorage key.\n * @param {T} [fallback_value] - Optional fallback value if the key does not exist or has no value.\n * @returns - An array containing the current value, a function to update the value, and a function to clear the value.\n */\nvar useLocalStorageData = function useLocalStorageData(key, fallback_value) {\n  var _ref, _getLocalStorage;\n  var _React$useState = React.useState((_ref = (_getLocalStorage = getLocalStorage(key)) !== null && _getLocalStorage !== void 0 ? _getLocalStorage : fallback_value) !== null && _ref !== void 0 ? _ref : null),\n    _React$useState2 = useLocalStorageData_slicedToArray(_React$useState, 2),\n    data = _React$useState2[0],\n    setData = _React$useState2[1];\n  React.useEffect(function () {\n    localStorage.setItem(key, JSON.stringify(data));\n  }, [key, data]);\n  var clearData = function clearData() {\n    localStorage.removeItem(key);\n    setData(fallback_value !== null && fallback_value !== void 0 ? fallback_value : null);\n  };\n  return [data, setData, clearData];\n};\n/* harmony default export */ const src_useLocalStorageData = ((/* unused pure expression or super */ null && (useLocalStorageData)));\n;// CONCATENATED MODULE: ../../hooks/src/useNeedPOI.ts\n\nvar useNeedPOI = function useNeedPOI() {\n  var _client$account_statu;\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var authentication = (_client$account_statu = client.account_status) === null || _client$account_statu === void 0 ? void 0 : _client$account_statu.authentication;\n  return authentication === null || authentication === void 0 ? void 0 : authentication.needs_verification.includes('identity');\n};\n/* harmony default export */ const src_useNeedPOI = ((/* unused pure expression or super */ null && (useNeedPOI)));\n;// CONCATENATED MODULE: ../../hooks/src/useOnrampVisible.ts\n\nvar useOnrampVisible = function useOnrampVisible() {\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var is_virtual = client.is_virtual,\n    is_crypto = client.is_crypto;\n  var is_onramp_visible = !is_virtual && is_crypto();\n  return is_onramp_visible;\n};\n/* harmony default export */ const src_useOnrampVisible = ((/* unused pure expression or super */ null && (useOnrampVisible)));\n;// CONCATENATED MODULE: ../../hooks/src/useP2PAdvertiserPaymentMethods.ts\nfunction useP2PAdvertiserPaymentMethods_typeof(obj) { \"@babel/helpers - typeof\"; return useP2PAdvertiserPaymentMethods_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useP2PAdvertiserPaymentMethods_typeof(obj); }\nvar useP2PAdvertiserPaymentMethods_excluded = (/* unused pure expression or super */ null && ([\"mutate\"])),\n  useP2PAdvertiserPaymentMethods_excluded2 = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useP2PAdvertiserPaymentMethods_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useP2PAdvertiserPaymentMethods_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useP2PAdvertiserPaymentMethods_ownKeys(Object(source), !0).forEach(function (key) { useP2PAdvertiserPaymentMethods_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useP2PAdvertiserPaymentMethods_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useP2PAdvertiserPaymentMethods_defineProperty(obj, key, value) { key = useP2PAdvertiserPaymentMethods_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useP2PAdvertiserPaymentMethods_toPropertyKey(arg) { var key = useP2PAdvertiserPaymentMethods_toPrimitive(arg, \"string\"); return useP2PAdvertiserPaymentMethods_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useP2PAdvertiserPaymentMethods_toPrimitive(input, hint) { if (useP2PAdvertiserPaymentMethods_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useP2PAdvertiserPaymentMethods_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useP2PAdvertiserPaymentMethods_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useP2PAdvertiserPaymentMethods_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useP2PAdvertiserPaymentMethods_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\nvar type_to_icon_mapper = {\n  bank: 'IcCashierBankTransfer',\n  other: 'IcCashierOther',\n  ewallet: 'IcCashierEwallet'\n};\n\n/** A custom hook to fetch, create, update, and delete p2p advertiser payment methods */\nvar useP2PAdvertiserPaymentMethods = function useP2PAdvertiserPaymentMethods() {\n  var invalidate = useInvalidateQuery();\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var is_authorize = client.is_authorize;\n  var _useRequest = useRequest('p2p_advertiser_payment_methods', {\n      onSuccess: function onSuccess() {\n        return invalidate('p2p_advertiser_payment_methods');\n      }\n    }),\n    mutate = _useRequest.mutate,\n    mutate_rest = useP2PAdvertiserPaymentMethods_objectWithoutProperties(_useRequest, useP2PAdvertiserPaymentMethods_excluded);\n  var _useFetch = useFetch('p2p_advertiser_payment_methods', {\n      options: {\n        enabled: is_authorize\n      }\n    }),\n    data = _useFetch.data,\n    rest = useP2PAdvertiserPaymentMethods_objectWithoutProperties(_useFetch, useP2PAdvertiserPaymentMethods_excluded2);\n\n  // Modify the response to add additional informations\n  var modified_data = useMemo(function () {\n    var p2p_advertiser_payment_methods = data === null || data === void 0 ? void 0 : data.p2p_advertiser_payment_methods;\n    if (!p2p_advertiser_payment_methods) return undefined;\n    return Object.keys(p2p_advertiser_payment_methods).map(function (key) {\n      var advertiser_payment_method = p2p_advertiser_payment_methods[key];\n      return useP2PAdvertiserPaymentMethods_objectSpread(useP2PAdvertiserPaymentMethods_objectSpread({}, advertiser_payment_method), {}, {\n        /** Icon for each payment method based on the type */\n        icon: type_to_icon_mapper[advertiser_payment_method.type],\n        /** The id of payment method */\n        id: key\n      });\n    });\n  }, [data]);\n  var create = useCallback(function (values) {\n    return mutate({\n      payload: {\n        create: [useP2PAdvertiserPaymentMethods_objectSpread({}, values)]\n      }\n    });\n  }, [mutate]);\n  var update = useCallback(function (id, values) {\n    return mutate({\n      payload: {\n        update: useP2PAdvertiserPaymentMethods_defineProperty({}, id, useP2PAdvertiserPaymentMethods_objectSpread({}, values))\n      }\n    });\n  }, [mutate]);\n  var delete_payment_method = useCallback(function (id) {\n    return mutate({\n      payload: {\n        \"delete\": [id]\n      }\n    });\n  }, [mutate]);\n  return useP2PAdvertiserPaymentMethods_objectSpread(useP2PAdvertiserPaymentMethods_objectSpread({\n    /** The list of p2p advertiser payment methods */\n    data: modified_data,\n    /** Sends a request to create new p2p advertiser payment method */\n    create: create,\n    /** Sends a request to update existing p2p advertiser payment method */\n    update: update,\n    /** Sends a request to delete existing p2p advertiser payment method */\n    \"delete\": delete_payment_method\n  }, rest), {}, {\n    mutation: mutate_rest\n  });\n};\n/* harmony default export */ const src_useP2PAdvertiserPaymentMethods = ((/* unused pure expression or super */ null && (useP2PAdvertiserPaymentMethods)));\n;// CONCATENATED MODULE: ../../hooks/src/useP2PAdvertList.ts\nfunction useP2PAdvertList_typeof(obj) { \"@babel/helpers - typeof\"; return useP2PAdvertList_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useP2PAdvertList_typeof(obj); }\nvar useP2PAdvertList_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useP2PAdvertList_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useP2PAdvertList_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useP2PAdvertList_ownKeys(Object(source), !0).forEach(function (key) { useP2PAdvertList_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useP2PAdvertList_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useP2PAdvertList_defineProperty(obj, key, value) { key = useP2PAdvertList_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useP2PAdvertList_toPropertyKey(arg) { var key = useP2PAdvertList_toPrimitive(arg, \"string\"); return useP2PAdvertList_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useP2PAdvertList_toPrimitive(input, hint) { if (useP2PAdvertList_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useP2PAdvertList_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useP2PAdvertList_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useP2PAdvertList_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useP2PAdvertList_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n/**\n * This custom hook returns available adverts for use with 'p2p_order_create' by calling 'p2p_advert_list' endpoint\n */\nvar useP2PAdvertList = function useP2PAdvertList(payload) {\n  var _data$p2p_advert_list2;\n  var _useExchangeRate = useExchangeRate(),\n    getRate = _useExchangeRate.getRate;\n  var _usePaginatedFetch = usePaginatedFetch('p2p_advert_list', {\n      payload: payload\n    }),\n    data = _usePaginatedFetch.data,\n    rest = useP2PAdvertList_objectWithoutProperties(_usePaginatedFetch, useP2PAdvertList_excluded);\n\n  // Add additional information to the 'p2p_advert_list' data\n  var modified_data = React.useMemo(function () {\n    var _data$p2p_advert_list;\n    var advert_list = data === null || data === void 0 ? void 0 : (_data$p2p_advert_list = data.p2p_advert_list) === null || _data$p2p_advert_list === void 0 ? void 0 : _data$p2p_advert_list.list;\n    if (!advert_list) return undefined;\n    return advert_list.map(function (advert) {\n      return useP2PAdvertList_objectSpread(useP2PAdvertList_objectSpread({}, advert), {}, {\n        /** Conversion rate from account currency to local currency, using current market rate if applicable. */\n        effective_rate: getRate(advert.local_currency || ''),\n        /** Determine if the rate is floating or fixed */\n        is_floating: advert.rate_type === 'float',\n        /** The advert creation time in epoch. */\n        created_time: new Date(advert.created_time)\n      });\n    });\n  }, [data === null || data === void 0 ? void 0 : (_data$p2p_advert_list2 = data.p2p_advert_list) === null || _data$p2p_advert_list2 === void 0 ? void 0 : _data$p2p_advert_list2.list, getRate]);\n  return useP2PAdvertList_objectSpread({\n    /** The 'p2p_advert_list' response. */\n    data: modified_data\n  }, rest);\n};\n/* harmony default export */ const src_useP2PAdvertList = ((/* unused pure expression or super */ null && (useP2PAdvertList)));\n;// CONCATENATED MODULE: ../../hooks/src/useP2PNotificationCount.ts\nfunction useP2PNotificationCount_slicedToArray(arr, i) { return useP2PNotificationCount_arrayWithHoles(arr) || useP2PNotificationCount_iterableToArrayLimit(arr, i) || useP2PNotificationCount_unsupportedIterableToArray(arr, i) || useP2PNotificationCount_nonIterableRest(); }\nfunction useP2PNotificationCount_nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction useP2PNotificationCount_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return useP2PNotificationCount_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return useP2PNotificationCount_arrayLikeToArray(o, minLen); }\nfunction useP2PNotificationCount_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction useP2PNotificationCount_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction useP2PNotificationCount_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\nvar useP2PNotificationCount = function useP2PNotificationCount() {\n  var _p2p_settings$loginid;\n  var _useState = useState(JSON.parse(localStorage.getItem('p2p_settings') || '{}')),\n    _useState2 = useP2PNotificationCount_slicedToArray(_useState, 2),\n    p2p_settings = _useState2[0],\n    setP2PSettings = _useState2[1];\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var loginid = client.loginid;\n  var notifications = loginid ? (_p2p_settings$loginid = p2p_settings[loginid]) === null || _p2p_settings$loginid === void 0 ? void 0 : _p2p_settings$loginid.notifications : null;\n  useEffect(function () {\n    var onStorageChanged = function onStorageChanged() {\n      var data = localStorage.getItem('p2p_settings');\n      if (data) {\n        setP2PSettings(JSON.parse(data));\n      }\n    };\n    window.addEventListener('storage', onStorageChanged);\n    return function () {\n      window.removeEventListener('storage', onStorageChanged);\n    };\n  }, []);\n  var p2p_notification_count = (notifications === null || notifications === void 0 ? void 0 : notifications.filter(function (notification) {\n    return !notification.is_seen;\n  }).length) || 0;\n  return p2p_notification_count;\n};\n/* harmony default export */ const src_useP2PNotificationCount = ((/* unused pure expression or super */ null && (useP2PNotificationCount)));\n;// CONCATENATED MODULE: ../../hooks/src/useP2PPaymentMethods.ts\nfunction useP2PPaymentMethods_typeof(obj) { \"@babel/helpers - typeof\"; return useP2PPaymentMethods_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useP2PPaymentMethods_typeof(obj); }\nvar useP2PPaymentMethods_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction useP2PPaymentMethods_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useP2PPaymentMethods_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useP2PPaymentMethods_ownKeys(Object(source), !0).forEach(function (key) { useP2PPaymentMethods_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useP2PPaymentMethods_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useP2PPaymentMethods_defineProperty(obj, key, value) { key = useP2PPaymentMethods_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useP2PPaymentMethods_toPropertyKey(arg) { var key = useP2PPaymentMethods_toPrimitive(arg, \"string\"); return useP2PPaymentMethods_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useP2PPaymentMethods_toPrimitive(input, hint) { if (useP2PPaymentMethods_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useP2PPaymentMethods_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useP2PPaymentMethods_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useP2PPaymentMethods_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useP2PPaymentMethods_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\nvar useP2PPaymentMethods_type_to_icon_mapper = {\n  bank: 'IcCashierBankTransfer',\n  other: 'IcCashierOther',\n  ewallet: 'IcCashierEwallet'\n};\n\n/** A custom hook that return the list of P2P available payment methods */\nvar useP2PPaymentMethods = function useP2PPaymentMethods() {\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var is_authorize = client.is_authorize;\n  var _useFetch = useFetch('p2p_payment_methods', {\n      options: {\n        enabled: is_authorize\n      }\n    }),\n    data = _useFetch.data,\n    rest = useP2PPaymentMethods_objectWithoutProperties(_useFetch, useP2PPaymentMethods_excluded);\n\n  // Modify the data to add additional information.\n  var modified_data = React.useMemo(function () {\n    var p2p_payment_methods = data === null || data === void 0 ? void 0 : data.p2p_payment_methods;\n    if (!p2p_payment_methods) return undefined;\n    return Object.keys(p2p_payment_methods).map(function (key) {\n      var payment_method = p2p_payment_methods[key];\n      var fields = Object.keys(payment_method.fields).map(function (field_key) {\n        return payment_method.fields[field_key];\n      });\n      return useP2PPaymentMethods_objectSpread(useP2PPaymentMethods_objectSpread({}, payment_method), {}, {\n        /** Payment method field definitions. */\n        fields: fields,\n        /** Icon for each payment method based on the type */\n        icon: useP2PPaymentMethods_type_to_icon_mapper[payment_method.type],\n        /** Payment method id */\n        id: key\n      });\n    });\n  }, [data]);\n  return useP2PPaymentMethods_objectSpread({\n    data: modified_data\n  }, rest);\n};\n/* harmony default export */ const src_useP2PPaymentMethods = ((/* unused pure expression or super */ null && (useP2PPaymentMethods)));\n;// CONCATENATED MODULE: ../../hooks/src/usePaymentAgentList.ts\nfunction usePaymentAgentList_typeof(obj) { \"@babel/helpers - typeof\"; return usePaymentAgentList_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, usePaymentAgentList_typeof(obj); }\nvar usePaymentAgentList_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction usePaymentAgentList_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction usePaymentAgentList_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? usePaymentAgentList_ownKeys(Object(source), !0).forEach(function (key) { usePaymentAgentList_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : usePaymentAgentList_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction usePaymentAgentList_defineProperty(obj, key, value) { key = usePaymentAgentList_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction usePaymentAgentList_toPropertyKey(arg) { var key = usePaymentAgentList_toPrimitive(arg, \"string\"); return usePaymentAgentList_typeof(key) === \"symbol\" ? key : String(key); }\nfunction usePaymentAgentList_toPrimitive(input, hint) { if (usePaymentAgentList_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (usePaymentAgentList_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction usePaymentAgentList_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = usePaymentAgentList_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction usePaymentAgentList_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\nvar usePaymentAgentList = function usePaymentAgentList(currency) {\n  var _data$paymentagent_li;\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var residence = client.residence;\n  var _useFetch = useFetch('paymentagent_list', {\n      payload: {\n        paymentagent_list: residence,\n        currency: currency\n      },\n      options: {\n        enabled: Boolean(residence)\n      }\n    }),\n    data = _useFetch.data,\n    rest = usePaymentAgentList_objectWithoutProperties(_useFetch, usePaymentAgentList_excluded);\n  return usePaymentAgentList_objectSpread({\n    data: data === null || data === void 0 ? void 0 : (_data$paymentagent_li = data.paymentagent_list) === null || _data$paymentagent_li === void 0 ? void 0 : _data$paymentagent_li.list\n  }, rest);\n};\n/* harmony default export */ const src_usePaymentAgentList = ((/* unused pure expression or super */ null && (usePaymentAgentList)));\n;// CONCATENATED MODULE: ../../hooks/src/usePaymentAgentTransferVisible.ts\nfunction usePaymentAgentTransferVisible_typeof(obj) { \"@babel/helpers - typeof\"; return usePaymentAgentTransferVisible_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, usePaymentAgentTransferVisible_typeof(obj); }\nvar usePaymentAgentTransferVisible_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction usePaymentAgentTransferVisible_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction usePaymentAgentTransferVisible_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? usePaymentAgentTransferVisible_ownKeys(Object(source), !0).forEach(function (key) { usePaymentAgentTransferVisible_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : usePaymentAgentTransferVisible_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction usePaymentAgentTransferVisible_defineProperty(obj, key, value) { key = usePaymentAgentTransferVisible_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction usePaymentAgentTransferVisible_toPropertyKey(arg) { var key = usePaymentAgentTransferVisible_toPrimitive(arg, \"string\"); return usePaymentAgentTransferVisible_typeof(key) === \"symbol\" ? key : String(key); }\nfunction usePaymentAgentTransferVisible_toPrimitive(input, hint) { if (usePaymentAgentTransferVisible_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (usePaymentAgentTransferVisible_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction usePaymentAgentTransferVisible_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = usePaymentAgentTransferVisible_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction usePaymentAgentTransferVisible_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\nvar usePaymentAgentTransferVisible = function usePaymentAgentTransferVisible() {\n  var _data$get_settings;\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var is_authorize = client.is_authorize;\n  var _useFetch = useFetch('get_settings', {\n      options: {\n        enabled: is_authorize\n      }\n    }),\n    data = _useFetch.data,\n    rest = usePaymentAgentTransferVisible_objectWithoutProperties(_useFetch, usePaymentAgentTransferVisible_excluded);\n  var is_payment_agent_transfer_visible = Boolean(data === null || data === void 0 ? void 0 : (_data$get_settings = data.get_settings) === null || _data$get_settings === void 0 ? void 0 : _data$get_settings.is_authenticated_payment_agent);\n  return usePaymentAgentTransferVisible_objectSpread({\n    data: is_payment_agent_transfer_visible\n  }, rest);\n};\n/* harmony default export */ const src_usePaymentAgentTransferVisible = ((/* unused pure expression or super */ null && (usePaymentAgentTransferVisible)));\n;// CONCATENATED MODULE: ../../hooks/src/usePlatformDemoAccount.ts\nfunction usePlatformDemoAccount_typeof(obj) { \"@babel/helpers - typeof\"; return usePlatformDemoAccount_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, usePlatformDemoAccount_typeof(obj); }\nfunction usePlatformDemoAccount_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction usePlatformDemoAccount_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? usePlatformDemoAccount_ownKeys(Object(source), !0).forEach(function (key) { usePlatformDemoAccount_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : usePlatformDemoAccount_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction usePlatformDemoAccount_defineProperty(obj, key, value) { key = usePlatformDemoAccount_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction usePlatformDemoAccount_toPropertyKey(arg) { var key = usePlatformDemoAccount_toPrimitive(arg, \"string\"); return usePlatformDemoAccount_typeof(key) === \"symbol\" ? key : String(key); }\nfunction usePlatformDemoAccount_toPrimitive(input, hint) { if (usePlatformDemoAccount_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (usePlatformDemoAccount_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n/**\n * we can use this hook to get the platform demo account.\n * it loops through the all of user's accounts, finds and returns demo account\n */\n\nvar usePlatformDemoAccount_usePlatformDemoAccount = function usePlatformDemoAccount() {\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var accounts = client.accounts;\n  var account_list = Object.keys(accounts).map(function (loginid) {\n    return usePlatformDemoAccount_objectSpread(usePlatformDemoAccount_objectSpread({}, accounts[loginid]), {}, {\n      loginid: loginid\n    });\n  });\n  var platform_demo_account = account_list.find(function (account) {\n    return account.is_virtual;\n  });\n  return platform_demo_account;\n};\n/* harmony default export */ const src_usePlatformDemoAccount = ((/* unused pure expression or super */ null && (usePlatformDemoAccount_usePlatformDemoAccount)));\n;// CONCATENATED MODULE: ../../hooks/src/usePlatformRealAccounts.ts\nfunction usePlatformRealAccounts_typeof(obj) { \"@babel/helpers - typeof\"; return usePlatformRealAccounts_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, usePlatformRealAccounts_typeof(obj); }\nfunction usePlatformRealAccounts_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction usePlatformRealAccounts_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? usePlatformRealAccounts_ownKeys(Object(source), !0).forEach(function (key) { usePlatformRealAccounts_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : usePlatformRealAccounts_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction usePlatformRealAccounts_defineProperty(obj, key, value) { key = usePlatformRealAccounts_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction usePlatformRealAccounts_toPropertyKey(arg) { var key = usePlatformRealAccounts_toPrimitive(arg, \"string\"); return usePlatformRealAccounts_typeof(key) === \"symbol\" ? key : String(key); }\nfunction usePlatformRealAccounts_toPrimitive(input, hint) { if (usePlatformRealAccounts_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (usePlatformRealAccounts_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n/**\n * we can use this hook to get all real accounts for both Eu and Non-Eu regions.\n * it loops through the accounts list and returns all real accounts\n */\n\nvar usePlatformRealAccounts_usePlatformRealAccounts = function usePlatformRealAccounts() {\n  var _useStore = useStore(),\n    client = _useStore.client,\n    traders_hub = _useStore.traders_hub;\n  var accounts = client.accounts;\n  var is_eu_user = traders_hub.is_eu_user;\n  var account_list = Object.keys(accounts).map(function (loginid) {\n    return usePlatformRealAccounts_objectSpread(usePlatformRealAccounts_objectSpread({}, accounts[loginid]), {}, {\n      loginid: loginid\n    });\n  });\n  var platform_real_accounts = account_list.filter(function (account) {\n    var is_maltainvest = 'landing_company_shortcode' in account && account.landing_company_shortcode === 'maltainvest';\n    if (account.is_virtual) return false;\n    if (!is_eu_user) return !is_maltainvest;\n    return is_maltainvest;\n  });\n  return platform_real_accounts;\n};\n/* harmony default export */ const src_usePlatformRealAccounts = ((/* unused pure expression or super */ null && (usePlatformRealAccounts_usePlatformRealAccounts)));\n;// CONCATENATED MODULE: ../../hooks/src/usePlatformAccounts.ts\n\n\n\n/**\n * this is a wrapper hook for usePlatformDemoAccount and usePlatformRealAccounts\n * and it returns different platform accounts which are demo, and real\n */\nvar usePlatformAccounts_usePlatformAccounts = function usePlatformAccounts() {\n  var platform_demo_account = usePlatformDemoAccount();\n  var platform_real_accounts = usePlatformRealAccounts();\n  return {\n    demo: platform_demo_account,\n    real: platform_real_accounts\n  };\n};\n/* harmony default export */ const src_usePlatformAccounts = ((/* unused pure expression or super */ null && (usePlatformAccounts_usePlatformAccounts)));\n;// CONCATENATED MODULE: ../../hooks/src/useTotalAssetCurrency.ts\n\n\nvar useTotalAssetCurrency_useRealTotalAssetCurrency = function useRealTotalAssetCurrency() {\n  var _useStore = useStore(),\n    client = _useStore.client,\n    traders_hub = _useStore.traders_hub;\n  var current_fiat_currency = client.current_fiat_currency,\n    is_crypto = client.is_crypto,\n    currency = client.currency,\n    default_currency = client.default_currency;\n  var is_eu_user = traders_hub.is_eu_user;\n  var _usePlatformAccounts = usePlatformAccounts(),\n    platform_real_accounts = _usePlatformAccounts.real;\n  if (!platform_real_accounts.length) return default_currency;\n  var non_crypto_accounts = platform_real_accounts.find(function (account) {\n    return !is_crypto(account.currency || 'USD');\n  });\n  if (non_crypto_accounts) return (non_crypto_accounts === null || non_crypto_accounts === void 0 ? void 0 : non_crypto_accounts.currency) || '';\n  var currency_if_is_crypto = is_eu_user ? current_fiat_currency || default_currency : platform_real_accounts[0].currency;\n  return is_crypto() ? currency_if_is_crypto : currency;\n};\n/* harmony default export */ const useTotalAssetCurrency = ((/* unused pure expression or super */ null && (useTotalAssetCurrency_useRealTotalAssetCurrency)));\n;// CONCATENATED MODULE: ../../hooks/src/useTotalAccountBalance.ts\n\n\n/**\n * we can use this hook to get the total balance of the given accounts list.\n * it loops through the accounts list and adds the balance of each account\n * to the total balance, it also converts the balance to the currency of the\n * first account in the list\n */\n\nvar useTotalAccountBalance = function useTotalAccountBalance(accounts) {\n  var total_assets_real_currency = useRealTotalAssetCurrency();\n  var _useExchangeRate = useExchangeRate(),\n    getRate = _useExchangeRate.getRate;\n  if (!accounts.length) return {\n    balance: 0,\n    currency: total_assets_real_currency\n  };\n  var balance = accounts.reduce(function (total, account) {\n    var base_rate = (account === null || account === void 0 ? void 0 : account.account_type) === 'demo' ? 1 : getRate(total_assets_real_currency || '');\n    var rate = getRate(account.currency || total_assets_real_currency || '');\n    var exchange_rate = base_rate / rate;\n    return total + (account.balance || 0) * exchange_rate;\n  }, 0);\n  return {\n    balance: balance,\n    currency: total_assets_real_currency\n  };\n};\n/* harmony default export */ const src_useTotalAccountBalance = ((/* unused pure expression or super */ null && (useTotalAccountBalance)));\n;// CONCATENATED MODULE: ../../hooks/src/useTransferBetweenAccounts.ts\nfunction src_useTransferBetweenAccounts_typeof(obj) { \"@babel/helpers - typeof\"; return src_useTransferBetweenAccounts_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, src_useTransferBetweenAccounts_typeof(obj); }\nvar src_useTransferBetweenAccounts_excluded = (/* unused pure expression or super */ null && ([\"data\"]));\nfunction src_useTransferBetweenAccounts_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction src_useTransferBetweenAccounts_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? src_useTransferBetweenAccounts_ownKeys(Object(source), !0).forEach(function (key) { src_useTransferBetweenAccounts_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : src_useTransferBetweenAccounts_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction src_useTransferBetweenAccounts_defineProperty(obj, key, value) { key = src_useTransferBetweenAccounts_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction src_useTransferBetweenAccounts_toPropertyKey(arg) { var key = src_useTransferBetweenAccounts_toPrimitive(arg, \"string\"); return src_useTransferBetweenAccounts_typeof(key) === \"symbol\" ? key : String(key); }\nfunction src_useTransferBetweenAccounts_toPrimitive(input, hint) { if (src_useTransferBetweenAccounts_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (src_useTransferBetweenAccounts_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useTransferBetweenAccounts_toConsumableArray(arr) { return useTransferBetweenAccounts_arrayWithoutHoles(arr) || useTransferBetweenAccounts_iterableToArray(arr) || useTransferBetweenAccounts_unsupportedIterableToArray(arr) || useTransferBetweenAccounts_nonIterableSpread(); }\nfunction useTransferBetweenAccounts_nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction useTransferBetweenAccounts_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return useTransferBetweenAccounts_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return useTransferBetweenAccounts_arrayLikeToArray(o, minLen); }\nfunction useTransferBetweenAccounts_iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction useTransferBetweenAccounts_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return useTransferBetweenAccounts_arrayLikeToArray(arr); }\nfunction useTransferBetweenAccounts_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction src_useTransferBetweenAccounts_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = src_useTransferBetweenAccounts_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction src_useTransferBetweenAccounts_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\nvar src_useTransferBetweenAccounts_useTransferBetweenAccounts = function useTransferBetweenAccounts() {\n  var _useStore = useStore(),\n    ui = _useStore.ui;\n  var is_dark_mode_on = ui.is_dark_mode_on;\n  var active_wallet = useActiveWallet();\n  var _useWalletsList = useWalletsList(),\n    wallets = _useWalletsList.data;\n  var _useCurrencyConfig = useCurrencyConfig(),\n    getConfig = _useCurrencyConfig.getConfig;\n  var trading_apps_icon = is_dark_mode_on ? 'IcWalletOptionsDark' : 'IcWalletOptionsLight';\n  var _useExistingCFDAccoun = useExistingCFDAccounts(),\n    _useExistingCFDAccoun2 = _useExistingCFDAccoun.data,\n    derivez_accounts = _useExistingCFDAccoun2.derivez_accounts,\n    dxtrade_accounts = _useExistingCFDAccoun2.dxtrade_accounts,\n    mt5_accounts = _useExistingCFDAccoun2.mt5_accounts,\n    is_cfd_accounts_loaded = _useExistingCFDAccoun.isSuccess;\n  var _useFetch = useFetch('transfer_between_accounts', {\n      payload: {\n        accounts: 'all'\n      },\n      options: {\n        enabled: is_cfd_accounts_loaded\n      }\n    }),\n    data = _useFetch.data,\n    rest = src_useTransferBetweenAccounts_objectWithoutProperties(_useFetch, src_useTransferBetweenAccounts_excluded);\n  var modified_transfer_accounts = useMemo(function () {\n    var _data$accounts;\n    var all_linked_cfd_accounts = [].concat(useTransferBetweenAccounts_toConsumableArray(derivez_accounts), useTransferBetweenAccounts_toConsumableArray(dxtrade_accounts), useTransferBetweenAccounts_toConsumableArray(mt5_accounts));\n    var getAccountType = function getAccountType(is_demo, currency) {\n      var _getConfig;\n      if (is_demo) return 'demo';\n      return (_getConfig = getConfig(currency || '')) !== null && _getConfig !== void 0 && _getConfig.is_crypto ? 'crypto' : 'fiat';\n    };\n    var accounts = data === null || data === void 0 ? void 0 : (_data$accounts = data.accounts) === null || _data$accounts === void 0 ? void 0 : _data$accounts.map(function (account) {\n      var _getConfig2, _getConfig3;\n      return src_useTransferBetweenAccounts_objectSpread(src_useTransferBetweenAccounts_objectSpread({}, account), {}, {\n        active_wallet_icon: active_wallet === null || active_wallet === void 0 ? void 0 : active_wallet.icon,\n        balance: parseFloat(Number(account.balance).toFixed((_getConfig2 = getConfig(account.currency || '')) === null || _getConfig2 === void 0 ? void 0 : _getConfig2.fractional_digits)),\n        display_currency_code: (_getConfig3 = getConfig(account.currency || '')) === null || _getConfig3 === void 0 ? void 0 : _getConfig3.display_code,\n        is_demo: Boolean(account === null || account === void 0 ? void 0 : account.demo_account),\n        shortcode: active_wallet === null || active_wallet === void 0 ? void 0 : active_wallet.landing_company_name,\n        type: getAccountType(account.demo_account, account.currency)\n      });\n    });\n    return {\n      trading_accounts: (accounts === null || accounts === void 0 ? void 0 : accounts.reduce(function (trading_accounts, account) {\n        var _all_linked_cfd_accou, _mt5_accounts$find;\n        if (account.account_type === 'wallet') return trading_accounts;\n        if (!account.loginid) return trading_accounts;\n        var cfd_icon = (_all_linked_cfd_accou = all_linked_cfd_accounts.find(function (cfd_account) {\n          var _cfd_account$loginid;\n          return account.loginid && ((_cfd_account$loginid = cfd_account.loginid) === null || _cfd_account$loginid === void 0 ? void 0 : _cfd_account$loginid.includes(account.loginid));\n        })) === null || _all_linked_cfd_accou === void 0 ? void 0 : _all_linked_cfd_accou.transfer_icon;\n        trading_accounts[account.loginid] = src_useTransferBetweenAccounts_objectSpread(src_useTransferBetweenAccounts_objectSpread({}, account), {}, {\n          gradient_class: active_wallet === null || active_wallet === void 0 ? void 0 : active_wallet.gradient_card_class,\n          icon: account.account_type === 'trading' ? trading_apps_icon : cfd_icon\n        }, account.account_type === 'mt5' && {\n          mt5_market_type: mt5_accounts === null || mt5_accounts === void 0 ? void 0 : (_mt5_accounts$find = mt5_accounts.find(function (mt5_account) {\n            var _mt5_account$loginid;\n            return account.loginid && ((_mt5_account$loginid = mt5_account.loginid) === null || _mt5_account$loginid === void 0 ? void 0 : _mt5_account$loginid.includes(account.loginid));\n          })) === null || _mt5_accounts$find === void 0 ? void 0 : _mt5_accounts$find.market_type\n        });\n        return trading_accounts;\n      }, {})) || {},\n      wallet_accounts: (accounts === null || accounts === void 0 ? void 0 : accounts.reduce(function (wallet_accounts, wallet) {\n        if (wallet.account_type !== 'wallet') return wallet_accounts;\n        if (!wallet.loginid) return wallet_accounts;\n        var available_wallet = wallets === null || wallets === void 0 ? void 0 : wallets.find(function (acc) {\n          return acc.loginid === wallet.loginid;\n        });\n        wallet_accounts[wallet.loginid] = src_useTransferBetweenAccounts_objectSpread(src_useTransferBetweenAccounts_objectSpread({}, wallet), {}, {\n          icon: available_wallet === null || available_wallet === void 0 ? void 0 : available_wallet.icon,\n          gradient_class: available_wallet === null || available_wallet === void 0 ? void 0 : available_wallet.gradient_card_class\n        });\n        return wallet_accounts;\n      }, {})) || {}\n    };\n  }, [active_wallet === null || active_wallet === void 0 ? void 0 : active_wallet.gradient_card_class, active_wallet === null || active_wallet === void 0 ? void 0 : active_wallet.icon, active_wallet === null || active_wallet === void 0 ? void 0 : active_wallet.landing_company_name, data === null || data === void 0 ? void 0 : data.accounts, derivez_accounts, dxtrade_accounts, getConfig, mt5_accounts, trading_apps_icon, wallets]);\n  var modified_active_wallet = useMemo(function () {\n    return active_wallet !== null && active_wallet !== void 0 && active_wallet.loginid ? src_useTransferBetweenAccounts_objectSpread({}, modified_transfer_accounts.wallet_accounts[active_wallet === null || active_wallet === void 0 ? void 0 : active_wallet.loginid]) : undefined;\n  }, [active_wallet === null || active_wallet === void 0 ? void 0 : active_wallet.loginid, modified_transfer_accounts.wallet_accounts]);\n  return src_useTransferBetweenAccounts_objectSpread(src_useTransferBetweenAccounts_objectSpread({}, rest), {}, {\n    active_wallet: modified_active_wallet,\n    trading_accounts: modified_transfer_accounts.trading_accounts,\n    wallet_accounts: modified_transfer_accounts.wallet_accounts\n  });\n};\n/* harmony default export */ const src_useTransferBetweenAccounts = ((/* unused pure expression or super */ null && (src_useTransferBetweenAccounts_useTransferBetweenAccounts)));\n;// CONCATENATED MODULE: ../../hooks/src/useVerifyEmail.ts\nfunction useVerifyEmail_slicedToArray(arr, i) { return useVerifyEmail_arrayWithHoles(arr) || useVerifyEmail_iterableToArrayLimit(arr, i) || useVerifyEmail_unsupportedIterableToArray(arr, i) || useVerifyEmail_nonIterableRest(); }\nfunction useVerifyEmail_nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction useVerifyEmail_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return useVerifyEmail_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return useVerifyEmail_arrayLikeToArray(o, minLen); }\nfunction useVerifyEmail_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction useVerifyEmail_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction useVerifyEmail_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\nvar RESEND_COUNTDOWN = 60;\n\n/**\n * @deprecated Please use useVerifyEmail from @deriv/api instead\n */\nvar useVerifyEmail_useVerifyEmail = function useVerifyEmail(type) {\n  var WS = useRequest('verify_email');\n  var counter = useCountdown({\n    from: RESEND_COUNTDOWN\n  });\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var _useState = useState(0),\n    _useState2 = useVerifyEmail_slicedToArray(_useState, 2),\n    sent_count = _useState2[0],\n    setSentCount = _useState2[1];\n  var send = useCallback(function (email) {\n    var request_email = email !== null && email !== void 0 ? email : client.email;\n    if (!request_email) return;\n    if (counter.is_running) return;\n    counter.reset();\n    counter.start();\n    setSentCount(function (count) {\n      return count + 1;\n    });\n    WS.mutate({\n      payload: {\n        verify_email: request_email,\n        type: type\n      }\n    });\n  }, [WS, client.email, counter, type]);\n  return {\n    is_loading: WS.isLoading,\n    error: WS.error,\n    data: WS.data,\n    counter: counter.count,\n    is_counter_running: counter.is_running,\n    sent_count: sent_count,\n    has_been_sent: sent_count !== 0,\n    send: send\n  };\n};\n/* harmony default export */ const src_useVerifyEmail = ((/* unused pure expression or super */ null && (useVerifyEmail_useVerifyEmail)));\n;// CONCATENATED MODULE: ../../hooks/src/useWalletMigration.ts\n\n\n\n\n/** A custom hook to get the status of wallet_migration API and to start/reset the migration process\n * @deprecated This hook is deprecated. Please use the hook from @deriv/api instead.\n */\nvar useWalletMigration_useWalletMigration = function useWalletMigration() {\n  var _data$wallet_migratio;\n  // TODO: delete it later, it's a temporary solution\n  // because we have to check for authorize from client store before doing API call\n  // This hook will be refactored later for subscribe when BE is ready\n  var _useStore = useStore(),\n    client = _useStore.client;\n  var is_authorize = client.is_authorize;\n  var invalidate = useInvalidateQuery();\n\n  /** Make a request to wallet_migration API and onSuccess it will invalidate the cached data  */\n  var _useRequest = useRequest('wallet_migration', {\n      onSuccess: function onSuccess() {\n        return invalidate('wallet_migration');\n      }\n    }),\n    mutate = _useRequest.mutate;\n  var _useAuthorize = useAuthorize(),\n    isSuccess = _useAuthorize.isSuccess;\n\n  /** Fetch the wallet_migration API and refetch it every second if the status is in_progress */\n  var _useFetch = useFetch('wallet_migration', {\n      payload: {\n        wallet_migration: 'state'\n      },\n      options: {\n        refetchInterval: function refetchInterval(response) {\n          var _response$wallet_migr;\n          return (response === null || response === void 0 ? void 0 : (_response$wallet_migr = response.wallet_migration) === null || _response$wallet_migr === void 0 ? void 0 : _response$wallet_migr.state) === 'in_progress' ? 500 : false;\n        },\n        // delete it later\n        enabled: is_authorize && isSuccess\n      }\n    }),\n    data = _useFetch.data;\n  var start_migration = useCallback(function () {\n    return mutate({\n      payload: {\n        wallet_migration: 'start'\n      }\n    });\n  }, [mutate]);\n  var reset_migration = useCallback(function () {\n    return mutate({\n      payload: {\n        wallet_migration: 'reset'\n      }\n    });\n  }, [mutate]);\n  var state = data === null || data === void 0 ? void 0 : (_data$wallet_migratio = data.wallet_migration) === null || _data$wallet_migratio === void 0 ? void 0 : _data$wallet_migratio.state;\n  return {\n    /** The status of the wallet_migration API */\n    state: state,\n    /** A boolean to check if the status is not_eligible */\n    is_ineligible: state === 'ineligible',\n    /** A boolean to check if the status is eligible */\n    is_eligible: state === 'eligible',\n    /** A boolean to check if the status is in_progress */\n    is_in_progress: state === 'in_progress',\n    /** A boolean to check if the status is completed */\n    is_migrated: state === 'migrated',\n    /** A boolean to check if the status is failed */\n    is_failed: state === 'failed',\n    /** Sends a request to wallet_migration API to start the migration process */\n    start_migration: start_migration,\n    /** Sends a request to wallet_migration API to reset the migration process */\n    reset_migration: reset_migration\n  };\n};\n/* harmony default export */ const src_useWalletMigration = ((/* unused pure expression or super */ null && (useWalletMigration_useWalletMigration)));\n;// CONCATENATED MODULE: ../../hooks/src/useWalletTransactions.ts\nfunction useWalletTransactions_typeof(obj) { \"@babel/helpers - typeof\"; return useWalletTransactions_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useWalletTransactions_typeof(obj); }\nfunction useWalletTransactions_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useWalletTransactions_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useWalletTransactions_ownKeys(Object(source), !0).forEach(function (key) { useWalletTransactions_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useWalletTransactions_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useWalletTransactions_defineProperty(obj, key, value) { key = useWalletTransactions_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useWalletTransactions_toPropertyKey(arg) { var key = useWalletTransactions_toPrimitive(arg, \"string\"); return useWalletTransactions_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useWalletTransactions_toPrimitive(input, hint) { if (useWalletTransactions_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useWalletTransactions_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useWalletTransactions_toConsumableArray(arr) { return useWalletTransactions_arrayWithoutHoles(arr) || useWalletTransactions_iterableToArray(arr) || useWalletTransactions_unsupportedIterableToArray(arr) || useWalletTransactions_nonIterableSpread(); }\nfunction useWalletTransactions_nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction useWalletTransactions_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return useWalletTransactions_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return useWalletTransactions_arrayLikeToArray(o, minLen); }\nfunction useWalletTransactions_iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction useWalletTransactions_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return useWalletTransactions_arrayLikeToArray(arr); }\nfunction useWalletTransactions_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n\n\n\n\n\n\nvar trading_accounts_display_prefixes = {\n  standard: 'Deriv Apps',\n  mt5: 'MT5',\n  dxtrade: 'Deriv X',\n  binary: 'Binary'\n};\nvar landing_company_display_shortcodes = {\n  svg: 'SVG',\n  malta: 'Malta'\n};\nvar useWalletTransactions = function useWalletTransactions(action_type) {\n  var _useStore = useStore(),\n    _useStore$client = _useStore.client,\n    loginid = _useStore$client.loginid,\n    shortcode = _useStore$client.landing_company_shortcode,\n    is_dark_mode_on = _useStore.ui.is_dark_mode_on;\n  var _useWalletsList = useWalletsList(),\n    wallets = _useWalletsList.data;\n  var current_wallet = useActiveWallet();\n  var _usePlatformAccounts = usePlatformAccounts(),\n    demo_platform_account = _usePlatformAccounts.demo;\n  var _usePlatformAccounts2 = usePlatformAccounts(),\n    real_platform_accounts = _usePlatformAccounts2.real;\n\n  // TODO remove these mocks when we're to switch to API data\n  demo_platform_account = {\n    account_category: 'trading',\n    account_type: 'standard',\n    currency: 'USD',\n    loginid: 'VRTCMOCK0001',\n    is_virtual: 1,\n    landing_company_shortcode: shortcode,\n    token: ''\n  };\n  real_platform_accounts.push({\n    account_category: 'trading',\n    account_type: 'standard',\n    currency: 'USD',\n    loginid: 'CRMOCK0001',\n    is_virtual: 0,\n    landing_company_shortcode: shortcode,\n    token: ''\n  });\n  if (wallets && current_wallet) wallets.push({\n    account_type: 'crypto',\n    balance: 0,\n    currency: 'BTC',\n    gradient_header_class: 'wallet-header__btc-bg',\n    gradient_card_class: \"wallet-card__btc-bg\".concat(is_dark_mode_on ? '--dark' : ''),\n    is_demo: !!current_wallet.is_virtual,\n    is_disabled: 0,\n    is_malta_wallet: false,\n    is_selected: false,\n    is_virtual: current_wallet.is_virtual,\n    landing_company_name: 'svg',\n    loginid: 'CRWMOCK00042',\n    currency_config: undefined,\n    icon: 'IcWalletCurrencyBtc',\n    wallet_currency_type: 'BTC'\n  });\n  var accounts = useMemo(function () {\n    return [demo_platform_account].concat(useWalletTransactions_toConsumableArray(real_platform_accounts));\n  }, [demo_platform_account, real_platform_accounts]);\n  var _useCurrencyConfig = useCurrencyConfig(),\n    getConfig = _useCurrencyConfig.getConfig;\n  var getTradingAccountName = useCallback(function (account_type, is_virtual, landing_company_shortcode) {\n    return \"\".concat(trading_accounts_display_prefixes[account_type], \" \").concat(is_virtual ? 'Demo' : \"(\".concat(landing_company_display_shortcodes[landing_company_shortcode], \")\"), \" account\");\n  }, []);\n\n  // TODO remove this mock when we're to switch to API data\n  var mock_transactions = current_wallet !== null && current_wallet !== void 0 && current_wallet.is_virtual ? [{\n    action_type: 'transfer',\n    amount: 5,\n    from: {\n      loginid: loginid\n    },\n    to: {\n      loginid: 'VRTCMOCK0001'\n    },\n    app_id: {},\n    balance_after: 9995,\n    transaction_id: 17494415484,\n    transaction_time: 1685942139\n  }, {\n    action_type: 'reset_balance',\n    amount: 350,\n    balance_after: 10000,\n    transaction_id: 13693003421,\n    transaction_time: 1685942138\n  }, {\n    action_type: 'transfer',\n    amount: 200,\n    from: {\n      loginid: 'VRTCMOCK0001'\n    },\n    to: {\n      loginid: loginid\n    },\n    balance_after: 9650,\n    transaction_id: 17494415483,\n    transaction_time: 1685855740\n  }, {\n    action_type: 'transfer',\n    amount: 550,\n    from: {\n      loginid: loginid\n    },\n    to: {\n      loginid: 'VRTCMOCK0001'\n    },\n    app_id: {},\n    balance_after: 9450,\n    transaction_id: 17494415482,\n    transaction_time: 1685855739\n  }, {\n    action_type: 'initial_fund',\n    amount: 10000,\n    balance_after: 10000,\n    transaction_id: 13693011401,\n    transaction_time: 1685855738\n  }] : [{\n    action_type: 'transfer',\n    amount: 5,\n    from: {\n      loginid: loginid\n    },\n    to: {\n      loginid: 'CRMOCK0001'\n    },\n    balance_after: 0,\n    transaction_id: 17494117541,\n    transaction_time: 1685942138\n  }, {\n    action_type: 'transfer',\n    amount: 20,\n    from: {\n      loginid: loginid\n    },\n    to: {\n      loginid: 'CRWMOCK00042'\n    },\n    balance_after: 5,\n    transaction_id: 17494415489,\n    transaction_time: 1685942137\n  }, {\n    action_type: 'deposit',\n    amount: 25,\n    balance_after: 25,\n    transaction_id: 17494415481,\n    transaction_time: 1685942136\n  }, {\n    action_type: 'withdrawal',\n    amount: 750,\n    balance_after: 0,\n    transaction_id: 17494415480,\n    transaction_time: 1685942135\n  }, {\n    action_type: 'transfer',\n    amount: 100,\n    from: {\n      loginid: 'CRMOCK0001'\n    },\n    to: {\n      loginid: loginid\n    },\n    balance_after: 750,\n    transaction_id: 17494415479,\n    transaction_time: 1685855738\n  }, {\n    action_type: 'transfer',\n    amount: 200,\n    from: {\n      loginid: 'CRWMOCK00042'\n    },\n    to: {\n      loginid: loginid\n    },\n    balance_after: 650,\n    transaction_id: 17494117541,\n    transaction_time: 1685855737\n  }, {\n    action_type: 'transfer',\n    amount: 550,\n    from: {\n      loginid: loginid\n    },\n    to: {\n      loginid: 'CRMOCK0001'\n    },\n    balance_after: 450,\n    transaction_id: 17494117540,\n    transaction_time: 1685855736\n  }, {\n    action_type: 'deposit',\n    amount: 1000,\n    balance_after: 1000,\n    transaction_id: 17494117539,\n    transaction_time: 1685769338\n  }];\n\n  // const { isLoading, isSuccess } = useFetch('statement', {\n  //     options: { keepPreviousData: true },\n  //     payload: { action_type: },\n  // });\n\n  // TODO: un-comment this code when we're to switch to API data\n  // const transactions = data?.statement?.transactions?.filter(\n  //     el =>\n  //         !!el.action_type &&\n  //         ['deposit', 'withdrawal', 'initial_fund', 'reset_balance', 'transfer'].includes(el.action_type)\n  // ) as TWalletTransaction[];\n\n  var transactions = useMemo(function () {\n    return mock_transactions.filter(function (el) {\n      return !action_type || el.action_type === action_type;\n    });\n  }, [action_type, mock_transactions]);\n  var getTransferAccountName = useCallback(function (other_account) {\n    if (other_account.account_category === 'wallet') {\n      var wallet = wallets === null || wallets === void 0 ? void 0 : wallets.find(function (el) {\n        return el.loginid === other_account.loginid;\n      });\n      return \"\".concat(wallet !== null && wallet !== void 0 && wallet.is_virtual ? 'Demo ' : '').concat(wallet === null || wallet === void 0 ? void 0 : wallet.currency, \" \", 'Wallet');\n    }\n    return getTradingAccountName(other_account.account_type, !!other_account.is_virtual, other_account.landing_company_shortcode);\n  }, [getTradingAccountName, wallets]);\n  var modified_transactions = useMemo(function () {\n    return wallets && current_wallet ? transactions.map(function (transaction) {\n      if (transaction.amount === undefined || transaction.balance_after === undefined || transaction.action_type === undefined) return null;\n      var account_category = 'wallet';\n      var account_type = current_wallet.account_type;\n      var account_name = \"\".concat(current_wallet.is_virtual ? 'Demo ' : '').concat(current_wallet.currency, \" \", 'Wallet');\n      var account_currency = current_wallet.currency;\n      var gradient_class = current_wallet.gradient_card_class;\n      var icon = getWalletCurrencyIcon(current_wallet.is_virtual ? 'demo' : current_wallet.currency || 'USD', is_dark_mode_on);\n      if (transaction.action_type === 'transfer') {\n        var _transaction$to, _transaction$from, _transaction$to2, _other_account$curren;\n        var other_loginid = ((_transaction$to = transaction.to) === null || _transaction$to === void 0 ? void 0 : _transaction$to.loginid) === loginid ? (_transaction$from = transaction.from) === null || _transaction$from === void 0 ? void 0 : _transaction$from.loginid : (_transaction$to2 = transaction.to) === null || _transaction$to2 === void 0 ? void 0 : _transaction$to2.loginid;\n        if (!other_loginid) return null;\n        var other_account = accounts.find(function (el) {\n          return (el === null || el === void 0 ? void 0 : el.loginid) === other_loginid;\n        });\n        if (!(other_account !== null && other_account !== void 0 && other_account.currency) || !(other_account !== null && other_account !== void 0 && other_account.account_type)) return null;\n        account_category = other_account.account_category || 'wallet';\n        account_currency = other_account.currency;\n        account_name = getTransferAccountName(other_account);\n        account_type = other_account.account_type;\n        gradient_class = \"wallet-card__\".concat(other_account.is_virtual === 1 ? 'demo' : other_account === null || other_account === void 0 ? void 0 : (_other_account$curren = other_account.currency) === null || _other_account$curren === void 0 ? void 0 : _other_account$curren.toLowerCase(), \"-bg\").concat(is_dark_mode_on ? '--dark' : '');\n        icon = getWalletCurrencyIcon(other_account.is_virtual ? 'demo' : other_account.currency || '', is_dark_mode_on, false);\n      }\n      var currency_config = getConfig(account_currency || '');\n      var is_crypto = currency_config === null || currency_config === void 0 ? void 0 : currency_config.is_crypto;\n      var icon_type = is_crypto || current_wallet.is_virtual ? 'crypto' : 'fiat';\n      return useWalletTransactions_objectSpread(useWalletTransactions_objectSpread({}, transaction), {}, {\n        account_category: account_category,\n        account_currency: account_currency,\n        account_name: account_name,\n        account_type: account_type,\n        gradient_class: gradient_class,\n        icon: icon,\n        icon_type: icon_type\n      });\n    }).filter(function (value) {\n      return value !== null;\n    }) : [];\n  }, [accounts, current_wallet, getConfig, getTransferAccountName, is_dark_mode_on, loginid, transactions, wallets]);\n  return {\n    transactions: modified_transactions,\n    isLoading: false,\n    isSuccess: true\n  };\n};\n/* harmony default export */ const src_useWalletTransactions = ((/* unused pure expression or super */ null && (useWalletTransactions)));\n;// CONCATENATED MODULE: ../../hooks/src/useWalletTransfer.ts\nfunction useWalletTransfer_typeof(obj) { \"@babel/helpers - typeof\"; return useWalletTransfer_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useWalletTransfer_typeof(obj); }\nfunction useWalletTransfer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useWalletTransfer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useWalletTransfer_ownKeys(Object(source), !0).forEach(function (key) { useWalletTransfer_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useWalletTransfer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useWalletTransfer_defineProperty(obj, key, value) { key = useWalletTransfer_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useWalletTransfer_toPropertyKey(arg) { var key = useWalletTransfer_toPrimitive(arg, \"string\"); return useWalletTransfer_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useWalletTransfer_toPrimitive(input, hint) { if (useWalletTransfer_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useWalletTransfer_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useWalletTransfer_slicedToArray(arr, i) { return useWalletTransfer_arrayWithHoles(arr) || useWalletTransfer_iterableToArrayLimit(arr, i) || useWalletTransfer_unsupportedIterableToArray(arr, i) || useWalletTransfer_nonIterableRest(); }\nfunction useWalletTransfer_nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction useWalletTransfer_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return useWalletTransfer_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return useWalletTransfer_arrayLikeToArray(o, minLen); }\nfunction useWalletTransfer_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction useWalletTransfer_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction useWalletTransfer_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\nvar useWalletTransfer = function useWalletTransfer() {\n  var _useTransferBetweenAc = useTransferBetweenAccounts(),\n    active_wallet = _useTransferBetweenAc.active_wallet,\n    trading_accounts = _useTransferBetweenAc.trading_accounts,\n    wallet_accounts = _useTransferBetweenAc.wallet_accounts,\n    is_accounts_loading = _useTransferBetweenAc.isLoading;\n  var _useState = useState(),\n    _useState2 = useWalletTransfer_slicedToArray(_useState, 2),\n    from_account = _useState2[0],\n    setFromAccount = _useState2[1];\n  var _useState3 = useState(),\n    _useState4 = useWalletTransfer_slicedToArray(_useState3, 2),\n    to_account = _useState4[0],\n    setToAccount = _useState4[1];\n  var to_account_list = useMemo(function () {\n    if (!(from_account !== null && from_account !== void 0 && from_account.loginid)) return {\n      trading_accounts: {},\n      wallet_accounts: {}\n    };\n    if (!(active_wallet !== null && active_wallet !== void 0 && active_wallet.loginid)) return {\n      trading_accounts: {},\n      wallet_accounts: {}\n    };\n    if ((from_account === null || from_account === void 0 ? void 0 : from_account.loginid) === (active_wallet === null || active_wallet === void 0 ? void 0 : active_wallet.loginid)) {\n      return {\n        trading_accounts: trading_accounts,\n        wallet_accounts: Object.fromEntries(Object.entries(wallet_accounts).filter(function (_ref) {\n          var _ref2 = useWalletTransfer_slicedToArray(_ref, 1),\n            key = _ref2[0];\n          return (active_wallet === null || active_wallet === void 0 ? void 0 : active_wallet.loginid) && !key.includes(active_wallet === null || active_wallet === void 0 ? void 0 : active_wallet.loginid);\n        }))\n      };\n    }\n    return {\n      trading_accounts: {},\n      wallet_accounts: useWalletTransfer_defineProperty({}, active_wallet === null || active_wallet === void 0 ? void 0 : active_wallet.loginid, active_wallet)\n    };\n  }, [active_wallet, from_account === null || from_account === void 0 ? void 0 : from_account.loginid, trading_accounts, wallet_accounts]);\n\n  //this useEffect populates from/to accounts with updated values, if they were updated in the background\n  useEffect(function () {\n    setFromAccount(function (acc) {\n      return acc !== null && acc !== void 0 && acc.loginid ? useWalletTransfer_objectSpread(useWalletTransfer_objectSpread({}, trading_accounts), wallet_accounts)[acc === null || acc === void 0 ? void 0 : acc.loginid] : undefined;\n    });\n    setToAccount(function (acc) {\n      return acc !== null && acc !== void 0 && acc.loginid ? useWalletTransfer_objectSpread(useWalletTransfer_objectSpread({}, trading_accounts), wallet_accounts)[acc === null || acc === void 0 ? void 0 : acc.loginid] : undefined;\n    });\n  }, [setFromAccount, setToAccount, trading_accounts, wallet_accounts]);\n  return {\n    active_wallet: active_wallet,\n    is_accounts_loading: is_accounts_loading,\n    from_account: from_account,\n    to_account: to_account,\n    to_account_list: to_account_list,\n    transfer_accounts: {\n      trading_accounts: trading_accounts,\n      wallet_accounts: wallet_accounts\n    },\n    setFromAccount: setFromAccount,\n    setToAccount: setToAccount\n  };\n};\n/* harmony default export */ const src_useWalletTransfer = ((/* unused pure expression or super */ null && (useWalletTransfer)));\n;// CONCATENATED MODULE: ../../hooks/src/useStatesList.ts\nfunction useStatesList_typeof(obj) { \"@babel/helpers - typeof\"; return useStatesList_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useStatesList_typeof(obj); }\nvar useStatesList_excluded = [\"data\"];\nfunction useStatesList_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction useStatesList_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? useStatesList_ownKeys(Object(source), !0).forEach(function (key) { useStatesList_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : useStatesList_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction useStatesList_defineProperty(obj, key, value) { key = useStatesList_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction useStatesList_toPropertyKey(arg) { var key = useStatesList_toPrimitive(arg, \"string\"); return useStatesList_typeof(key) === \"symbol\" ? key : String(key); }\nfunction useStatesList_toPrimitive(input, hint) { if (useStatesList_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (useStatesList_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction useStatesList_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = useStatesList_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction useStatesList_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/**\n * Custom hook to get states list for a particular country.\n * @returns an object with the states list and the options to manage API response.\n */\nvar useStatesList = function useStatesList(country) {\n  var _data$states_list;\n  var _useFetch = src_useQuery('states_list', {\n      // @ts-expect-error The `states_list` type from `@deriv/api-types` is not correct.\n      // The type should be `string`, but it's an alias to string type.\n      payload: {\n        states_list: country\n      }\n    }),\n    data = _useFetch.data,\n    rest = useStatesList_objectWithoutProperties(_useFetch, useStatesList_excluded);\n  return useStatesList_objectSpread(useStatesList_objectSpread({}, rest), {}, {\n    data: (_data$states_list = data === null || data === void 0 ? void 0 : data.states_list) !== null && _data$states_list !== void 0 ? _data$states_list : []\n  });\n};\n/* harmony default export */ const src_useStatesList = (useStatesList);\n;// CONCATENATED MODULE: ../../hooks/src/useIsClientHighRiskForMT5.ts\n\n\n/**\n * Checks if a client is considered high risk for MT5 trading based on their available trading accounts.\n * @returns `true` if the client is high risk for MT5 trading, `false` otherwise.\n */\nvar useIsClientHighRiskForMT5_useIsClientHighRiskForMT5 = function useIsClientHighRiskForMT5() {\n  var _useStore = useStore(),\n    trading_platform_available_accounts = _useStore.client.trading_platform_available_accounts;\n  var financial_available_accounts = trading_platform_available_accounts.filter(function (available_account) {\n    return available_account.market_type === 'financial';\n  });\n  var synthetic_available_accounts = trading_platform_available_accounts.filter(function (available_account) {\n    return available_account.market_type === 'gaming';\n  });\n  return financial_available_accounts.length === 1 && financial_available_accounts.every(function (acc) {\n    return acc.shortcode === 'svg';\n  }) && synthetic_available_accounts.length === 1 && synthetic_available_accounts.every(function (acc) {\n    return acc.shortcode === 'svg';\n  });\n};\n/* harmony default export */ const src_useIsClientHighRiskForMT5 = ((/* unused pure expression or super */ null && (useIsClientHighRiskForMT5_useIsClientHighRiskForMT5)));\n;// CONCATENATED MODULE: ../../hooks/src/useCFDCanGetMoreMT5Accounts.ts\n\n\n\nvar ACCOUNT_TYPES = (/* unused pure expression or super */ null && (['synthetic', 'financial', 'all']));\n\n/**\n * Custom hook to determine whether a client is eligible to get more MT5 CFD accounts.\n * @returns `true` if the client is eligible to get more MT5 CFD accounts, false otherwise.\n */\nvar useCFDCanGetMoreMT5Accounts = function useCFDCanGetMoreMT5Accounts() {\n  var _useStore = useStore(),\n    isEligibleForMoreRealMt5 = _useStore.client.isEligibleForMoreRealMt5,\n    _useStore$traders_hub = _useStore.traders_hub,\n    is_eu_user = _useStore$traders_hub.is_eu_user,\n    is_real = _useStore$traders_hub.is_real,\n    cfd = _useStore.modules.cfd;\n  var is_high_risk_client_for_mt5 = useIsClientHighRiskForMT5();\n\n  /**\n   * Check if the client has a specific type of MT5 CFD account.\n   */\n  var hasCFDAccount = function hasCFDAccount(type) {\n    var current_list_keys = Object.keys(cfd.current_list);\n    return current_list_keys.some(function (key) {\n      return key.startsWith(\"\".concat(CFD_PLATFORMS.MT5, \".real.\").concat(type));\n    });\n  };\n  return is_real && !is_eu_user && ACCOUNT_TYPES.some(function (type) {\n    return hasCFDAccount(type);\n  }) && ACCOUNT_TYPES.some(function (type) {\n    return isEligibleForMoreRealMt5(type);\n  }) && !is_high_risk_client_for_mt5;\n};\n/* harmony default export */ const src_useCFDCanGetMoreMT5Accounts = ((/* unused pure expression or super */ null && (useCFDCanGetMoreMT5Accounts)));\n// EXTERNAL MODULE: ../../../node_modules/@binary-com/binary-document-uploader/DocumentUploader.js\nvar binary_document_uploader_DocumentUploader = __webpack_require__(\"../../../node_modules/@binary-com/binary-document-uploader/DocumentUploader.js\");\n;// CONCATENATED MODULE: ../../hooks/src/useFileUploader.ts\nfunction useFileUploader_typeof(obj) { \"@babel/helpers - typeof\"; return useFileUploader_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, useFileUploader_typeof(obj); }\nfunction useFileUploader_regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ useFileUploader_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == useFileUploader_typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction useFileUploader_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction useFileUploader_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { useFileUploader_asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { useFileUploader_asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction useFileUploader_slicedToArray(arr, i) { return useFileUploader_arrayWithHoles(arr) || useFileUploader_iterableToArrayLimit(arr, i) || useFileUploader_unsupportedIterableToArray(arr, i) || useFileUploader_nonIterableRest(); }\nfunction useFileUploader_nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction useFileUploader_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return useFileUploader_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return useFileUploader_arrayLikeToArray(o, minLen); }\nfunction useFileUploader_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction useFileUploader_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction useFileUploader_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\nvar fileReadErrorMessage = function fileReadErrorMessage(filename) {\n  return \"Unable to read file \".concat(filename);\n};\n\n/**\n * Custom hook to handle file uploading with the binary-document-uploader package\n */\nvar useFileUploader = function useFileUploader() {\n  var _useState = useState(null),\n    _useState2 = useFileUploader_slicedToArray(_useState, 2),\n    error = _useState2[0],\n    setError = _useState2[1];\n  var uploader_instance = useMemo(function () {\n    return new DocumentUploader({\n      connection: WS.getSocket()\n    });\n  }, []);\n  var upload = useCallback( /*#__PURE__*/function () {\n    var _ref = useFileUploader_asyncToGenerator( /*#__PURE__*/useFileUploader_regeneratorRuntime().mark(function _callee2(files, settings, onError) {\n      return useFileUploader_regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (files !== null && files !== void 0 && files.length) {\n                _context2.next = 2;\n                break;\n              }\n              return _context2.abrupt(\"return\", Promise.reject(new Error('No files selected')));\n            case 2:\n              return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n                var is_any_file_error = false;\n                var file_error = null;\n                useFileUploader_asyncToGenerator( /*#__PURE__*/useFileUploader_regeneratorRuntime().mark(function _callee() {\n                  var compressed_files, processed_files, _file_error, response;\n                  return useFileUploader_regeneratorRuntime().wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          _context.prev = 0;\n                          _context.next = 3;\n                          return compressImageFiles(files);\n                        case 3:\n                          compressed_files = _context.sent;\n                          _context.next = 6;\n                          return readFiles(compressed_files, fileReadErrorMessage, settings !== null && settings !== void 0 ? settings : {});\n                        case 6:\n                          processed_files = _context.sent;\n                          processed_files.forEach(function (file) {\n                            if (file && 'message' in file) {\n                              is_any_file_error = true;\n                              file_error = file.message;\n                              reject(file.message);\n                            }\n                          });\n                          if (!(is_any_file_error || !processed_files.length)) {\n                            _context.next = 11;\n                            break;\n                          }\n                          onError === null || onError === void 0 ? void 0 : onError();\n                          return _context.abrupt(\"return\", reject(new Error((_file_error = file_error) !== null && _file_error !== void 0 ? _file_error : 'Something went wrong!')));\n                        case 11:\n                          _context.next = 13;\n                          return uploader_instance.upload(processed_files[0]);\n                        case 13:\n                          response = _context.sent;\n                          resolve(response);\n                          _context.next = 21;\n                          break;\n                        case 17:\n                          _context.prev = 17;\n                          _context.t0 = _context[\"catch\"](0);\n                          setError(_context.t0);\n                          reject(_context.t0);\n                        case 21:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee, null, [[0, 17]]);\n                }))();\n              }));\n            case 3:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n    return function (_x2, _x3, _x4) {\n      return _ref.apply(this, arguments);\n    };\n  }(), [uploader_instance]);\n  return {\n    /**\n     * Error message from the file uploader\n     */\n    error: error,\n    /**\n     * Uploads a file to the server with the binary-document-uploader package after compressing and reading the file with meta data\n     */\n    upload: upload,\n    /**\n     * Instance of the binary-document-uploader\n     */\n    uploader_instance: uploader_instance\n  };\n};\n/* harmony default export */ const src_useFileUploader = ((/* unused pure expression or super */ null && (useFileUploader)));\n;// CONCATENATED MODULE: ../../hooks/src/index.ts\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// EXTERNAL MODULE: external \"@deriv/translations\"\nvar translations_ = __webpack_require__(\"@deriv/translations\");\n;// CONCATENATED MODULE: ./Components/forms/form-fields/form-input-field.tsx\nvar form_input_field_excluded = [\"name\", \"warn\"];\nfunction form_input_field_extends() { form_input_field_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return form_input_field_extends.apply(this, arguments); }\nfunction form_input_field_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = form_input_field_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction form_input_field_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n/**\n * FormInputField is a wrapper around Input that can be used with Formik.\n * @name FormInputField\n * @param name - Name of the field\n * @param [optional] - Whether the field is optional\n * @param [warn] - Display a warning message\n * @param [props] - Other props to pass to Input\n * @returns ReactNode\n */\nvar FormInputField = function FormInputField(_ref) {\n  var name = _ref.name,\n    warn = _ref.warn,\n    rest = form_input_field_objectWithoutProperties(_ref, form_input_field_excluded);\n  return /*#__PURE__*/external_react_default().createElement(formik_esm_Field, {\n    name: name\n  }, function (_ref2) {\n    var field = _ref2.field,\n      _ref2$form = _ref2.form,\n      errors = _ref2$form.errors,\n      touched = _ref2$form.touched;\n    return /*#__PURE__*/external_react_default().createElement(components_.Input, form_input_field_extends({}, field, rest, {\n      type: \"text\",\n      autoComplete: \"off\",\n      error: touched[field.name] && errors[field.name] ? errors[field.name] : undefined,\n      warn: warn\n    }));\n  });\n};\n/* harmony default export */ const form_input_field = (FormInputField);\n;// CONCATENATED MODULE: ./Components/forms/form-fields/date-of-birth-field.tsx\nvar date_of_birth_field_excluded = (/* unused pure expression or super */ null && ([\"name\", \"portal_id\"]));\nfunction date_of_birth_field_extends() { date_of_birth_field_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return date_of_birth_field_extends.apply(this, arguments); }\nfunction date_of_birth_field_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = date_of_birth_field_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction date_of_birth_field_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n/**\n * DateOfBirthField is a wrapper around DateOfBirthPicker that can be used with Formik.\n * @name DateOfBirthField\n * @param name - Name of the field\n * @param portal_id - Portal ID\n * @param [props] - Other props to pass to DateOfBirthPicker\n * @returns {React.ReactNode}\n */\nvar DateOfBirthField = function DateOfBirthField(_ref) {\n  var name = _ref.name,\n    portal_id = _ref.portal_id,\n    rest = date_of_birth_field_objectWithoutProperties(_ref, date_of_birth_field_excluded);\n  return /*#__PURE__*/React.createElement(Field, {\n    name: name\n  }, function (_ref2) {\n    var field = _ref2.field,\n      setFieldValue = _ref2.form.setFieldValue,\n      _ref2$meta = _ref2.meta,\n      error = _ref2$meta.error,\n      touched = _ref2$meta.touched;\n    return /*#__PURE__*/React.createElement(DateOfBirthPicker, date_of_birth_field_extends({}, rest, field, {\n      error: touched ? error : undefined,\n      name: name,\n      onChange: function onChange(_ref3) {\n        var target = _ref3.target;\n        return setFieldValue(name, target !== null && target !== void 0 && target.value ? toMoment(target.value).format('YYYY-MM-DD') : '', true);\n      },\n      portal_id: portal_id\n    }));\n  });\n};\n/* harmony default export */ const date_of_birth_field = ((/* unused pure expression or super */ null && (DateOfBirthField)));\n;// CONCATENATED MODULE: ./Components/forms/form-fields/index.ts\n\n\n\n;// CONCATENATED MODULE: ./Components/forms/scroll-to-field-with-error.tsx\nfunction scroll_to_field_with_error_toConsumableArray(arr) { return scroll_to_field_with_error_arrayWithoutHoles(arr) || scroll_to_field_with_error_iterableToArray(arr) || scroll_to_field_with_error_unsupportedIterableToArray(arr) || scroll_to_field_with_error_nonIterableSpread(); }\nfunction scroll_to_field_with_error_nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction scroll_to_field_with_error_iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction scroll_to_field_with_error_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return scroll_to_field_with_error_arrayLikeToArray(arr); }\nfunction scroll_to_field_with_error_slicedToArray(arr, i) { return scroll_to_field_with_error_arrayWithHoles(arr) || scroll_to_field_with_error_iterableToArrayLimit(arr, i) || scroll_to_field_with_error_unsupportedIterableToArray(arr, i) || scroll_to_field_with_error_nonIterableRest(); }\nfunction scroll_to_field_with_error_nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction scroll_to_field_with_error_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return scroll_to_field_with_error_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return scroll_to_field_with_error_arrayLikeToArray(o, minLen); }\nfunction scroll_to_field_with_error_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction scroll_to_field_with_error_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction scroll_to_field_with_error_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\nvar ScrollToFieldWithError = function ScrollToFieldWithError(_ref) {\n  var fields_to_scroll_top = _ref.fields_to_scroll_top,\n    fields_to_scroll_bottom = _ref.fields_to_scroll_bottom,\n    _ref$should_recollect = _ref.should_recollect_inputs_names,\n    should_recollect_inputs_names = _ref$should_recollect === void 0 ? false : _ref$should_recollect;\n  var _React$useState = external_react_default().useState([]),\n    _React$useState2 = scroll_to_field_with_error_slicedToArray(_React$useState, 2),\n    all_page_inputs_names = _React$useState2[0],\n    setAllPageInputsNames = _React$useState2[1];\n  var _useFormikContext = useFormikContext(),\n    errors = _useFormikContext.errors,\n    isSubmitting = _useFormikContext.isSubmitting;\n  var scrollToElement = function scrollToElement(element_name) {\n    var _ref2, _el$parentElement;\n    var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'center';\n    if (!element_name) return;\n    var el = document.querySelector(\"[name=\\\"\".concat(element_name, \"\\\"]\"));\n    (_ref2 = (_el$parentElement = el === null || el === void 0 ? void 0 : el.parentElement) !== null && _el$parentElement !== void 0 ? _el$parentElement : el) === null || _ref2 === void 0 ? void 0 : _ref2.scrollIntoView({\n      behavior: 'smooth',\n      block: block\n    });\n    if ((el === null || el === void 0 ? void 0 : el.type) !== 'radio') el === null || el === void 0 ? void 0 : el.focus();\n  };\n  external_react_default().useEffect(function () {\n    var inputs = scroll_to_field_with_error_toConsumableArray(document.querySelectorAll('input, select'));\n    setAllPageInputsNames(inputs.map(function (input) {\n      return input.name;\n    }));\n  }, [should_recollect_inputs_names]);\n  external_react_default().useEffect(function () {\n    var current_error_field_name = all_page_inputs_names.find(function (input_name) {\n      return Object.hasOwn(errors, input_name);\n    }) || '';\n    if (fields_to_scroll_top !== null && fields_to_scroll_top !== void 0 && fields_to_scroll_top.includes(current_error_field_name)) {\n      scrollToElement(current_error_field_name, 'start');\n    } else if (fields_to_scroll_bottom !== null && fields_to_scroll_bottom !== void 0 && fields_to_scroll_bottom.includes(current_error_field_name)) {\n      scrollToElement(current_error_field_name, 'end');\n    } else {\n      scrollToElement(current_error_field_name);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isSubmitting]);\n  return null;\n};\n/* harmony default export */ const scroll_to_field_with_error = (ScrollToFieldWithError);\n;// CONCATENATED MODULE: ./Components/real-account-signup/helpers/utils.ts\n/**\n * Takes validation result of a form, sets warnings on component's state and pass errors down to the form\n *\n * @param {object} values - object containing form field values and validations\n * @return {object} object containing errors and warnings\n */\nfunction splitValidationResultTypes(values) {\n  var warnings = {};\n  var errors = {};\n  Object.keys(values).forEach(function (field) {\n    var item = values[field];\n    if (Array.isArray(item)) {\n      if (item[0] === 'warn') {\n        warnings[field] = item[1];\n      } else if (item[0] === 'error') {\n        errors[field] = item[1];\n      }\n    }\n  });\n  return {\n    warnings: warnings,\n    errors: errors\n  };\n}\n\n;// CONCATENATED MODULE: ./Components/address-details/address-details.tsx\nvar address_details_excluded = [\"getCurrentStep\", \"onSave\", \"onCancel\", \"goToNextStep\", \"goToPreviousStep\", \"validate\", \"onSubmit\", \"is_gb_residence\", \"disabled_items\", \"has_real_account\"];\nfunction address_details_extends() { address_details_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return address_details_extends.apply(this, arguments); }\nfunction address_details_slicedToArray(arr, i) { return address_details_arrayWithHoles(arr) || address_details_iterableToArrayLimit(arr, i) || address_details_unsupportedIterableToArray(arr, i) || address_details_nonIterableRest(); }\nfunction address_details_nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction address_details_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return address_details_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return address_details_arrayLikeToArray(o, minLen); }\nfunction address_details_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction address_details_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction address_details_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction address_details_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = address_details_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction address_details_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Component to display address details form\n * @name AddressDetails\n * @param getCurrentStep - function to get current step\n * @param states_list - array of states for the selected residence country\n * @param onSave - function to save form values\n * @param onCancel - function to cancel form values\n * @param goToNextStep - function to go to next step\n * @param goToPreviousStep - function to go to previous step\n * @param validate - function to validate form values\n * @param onSubmit - function to submit form values\n * @param is_gb_residence - is residence Great Britan\n * @param value - form values\n * @param disabled_items - array of disabled fields\n * @param has_real_account - has real account\n * @returns react node\n */\nvar AddressDetails = observer(function (_ref) {\n  var getCurrentStep = _ref.getCurrentStep,\n    onSave = _ref.onSave,\n    onCancel = _ref.onCancel,\n    goToNextStep = _ref.goToNextStep,\n    goToPreviousStep = _ref.goToPreviousStep,\n    validate = _ref.validate,\n    onSubmit = _ref.onSubmit,\n    is_gb_residence = _ref.is_gb_residence,\n    disabled_items = _ref.disabled_items,\n    has_real_account = _ref.has_real_account,\n    props = address_details_objectWithoutProperties(_ref, address_details_excluded);\n  var _React$useState = external_react_default().useState(''),\n    _React$useState2 = address_details_slicedToArray(_React$useState, 2),\n    address_state_to_display = _React$useState2[0],\n    setAddressStateToDisplay = _React$useState2[1];\n  var _useStore = src_useStore(),\n    ui = _useStore.ui,\n    residence = _useStore.client.residence;\n  var is_desktop = ui.is_desktop,\n    is_mobile = ui.is_mobile;\n  var _useStatesList = src_useStatesList(residence),\n    states_list = _useStatesList.data,\n    isFetched = _useStatesList.isFetched;\n  var handleCancel = function handleCancel(values) {\n    var current_step = ((getCurrentStep === null || getCurrentStep === void 0 ? void 0 : getCurrentStep()) || 1) - 1;\n    onSave(current_step, values);\n    onCancel(current_step, goToPreviousStep);\n  };\n  var handleValidate = function handleValidate(values) {\n    var _splitValidationResul = splitValidationResultTypes(validate(values)),\n      errors = _splitValidationResul.errors;\n    return errors;\n  };\n  var handleSubmitData = function handleSubmitData(values, actions) {\n    if (values.address_state && states_list.length) {\n      values.address_state = address_state_to_display ? (0,shared_.getLocation)(states_list, address_state_to_display, 'value') : (0,shared_.getLocation)(states_list, values.address_state, 'value');\n    }\n    onSubmit(((getCurrentStep === null || getCurrentStep === void 0 ? void 0 : getCurrentStep()) || 1) - 1, values, actions.setSubmitting, goToNextStep);\n  };\n  return /*#__PURE__*/external_react_default().createElement(Formik, {\n    initialValues: props.value,\n    validate: handleValidate,\n    validateOnMount: true,\n    onSubmit: handleSubmitData\n  }, function (_ref2) {\n    var handleSubmit = _ref2.handleSubmit,\n      isSubmitting = _ref2.isSubmitting,\n      values = _ref2.values,\n      setFieldValue = _ref2.setFieldValue,\n      handleChange = _ref2.handleChange,\n      setFieldTouched = _ref2.setFieldTouched;\n    return /*#__PURE__*/external_react_default().createElement(components_.AutoHeightWrapper, {\n      default_height: 350,\n      height_offset: is_desktop ? 80 : null\n    }, function (_ref3) {\n      var _props$value, _props$value2, _props$value3, _props$value6, _props$value7;\n      var setRef = _ref3.setRef,\n        height = _ref3.height;\n      return (\n        /*#__PURE__*/\n        //noValidate here is for skipping default browser validation\n        external_react_default().createElement(\"form\", {\n          ref: setRef,\n          onSubmit: handleSubmit,\n          noValidate: true\n        }, /*#__PURE__*/external_react_default().createElement(components_.Div100vhContainer, {\n          className: \"details-form\",\n          height_offset: \"90px\",\n          is_disabled: is_desktop\n        }, /*#__PURE__*/external_react_default().createElement(scroll_to_field_with_error, null), /*#__PURE__*/external_react_default().createElement(components_.Text, {\n          as: \"p\",\n          align: \"left\",\n          size: \"xxs\",\n          line_height: \"l\",\n          className: \"details-form__description\"\n        }, /*#__PURE__*/external_react_default().createElement(\"strong\", null, /*#__PURE__*/external_react_default().createElement(translations_.Localize, {\n          i18n_default_text: \"Only use an address for which you have proof of residence - \"\n        })), /*#__PURE__*/external_react_default().createElement(translations_.Localize, {\n          i18n_default_text: \"a recent utility bill (e.g. electricity, water, gas, landline, or internet), bank statement, or government-issued letter with your name and this address.\"\n        })), /*#__PURE__*/external_react_default().createElement(components_.ThemedScrollbars, {\n          height: height,\n          className: \"details-form__scrollbar\"\n        }, /*#__PURE__*/external_react_default().createElement(\"div\", {\n          className: classnames_default()('details-form__elements', 'address-details-form ')\n        }, /*#__PURE__*/external_react_default().createElement(form_input_field, {\n          name: \"address_line_1\",\n          required: true,\n          label: (0,translations_.localize)('First line of address*'),\n          maxLength: 255,\n          placeholder: (0,translations_.localize)('First line of address'),\n          disabled: disabled_items.includes('address_line_1') || !!((_props$value = props.value) !== null && _props$value !== void 0 && _props$value.address_line_1) && has_real_account\n        }), /*#__PURE__*/external_react_default().createElement(form_input_field, {\n          name: \"address_line_2\",\n          label: (0,translations_.localize)('Second line of address'),\n          maxLength: 255,\n          placeholder: (0,translations_.localize)('Second line of address'),\n          disabled: disabled_items.includes('address_line_2') || !!((_props$value2 = props.value) !== null && _props$value2 !== void 0 && _props$value2.address_line_2) && has_real_account\n        }), /*#__PURE__*/external_react_default().createElement(form_input_field, {\n          name: \"address_city\",\n          required: true,\n          label: (0,translations_.localize)('Town/City*'),\n          placeholder: (0,translations_.localize)('Town/City'),\n          disabled: disabled_items.includes('address_city') || !!((_props$value3 = props.value) !== null && _props$value3 !== void 0 && _props$value3.address_city) && has_real_account\n        }), !isFetched && /*#__PURE__*/external_react_default().createElement(\"div\", {\n          className: \"details-form__loader\"\n        }, /*#__PURE__*/external_react_default().createElement(components_.Loading, {\n          is_fullscreen: false\n        })), (states_list === null || states_list === void 0 ? void 0 : states_list.length) > 0 ? /*#__PURE__*/external_react_default().createElement(formik_esm_Field, {\n          name: \"address_state\"\n        }, function (_ref4) {\n          var _props$value4, _props$value5;\n          var field = _ref4.field;\n          return /*#__PURE__*/external_react_default().createElement((external_react_default()).Fragment, null, /*#__PURE__*/external_react_default().createElement(components_.DesktopWrapper, null, /*#__PURE__*/external_react_default().createElement(components_.Autocomplete, address_details_extends({}, field, address_state_to_display && {\n            value: address_state_to_display\n          }, {\n            \"data-lpignore\": \"true\",\n            autoComplete: \"new-password\" // prevent chrome autocomplete\n            ,\n            type: \"text\",\n            label: (0,translations_.localize)('State/Province'),\n            list_items: states_list,\n            onItemSelection: function onItemSelection(_ref5) {\n              var value = _ref5.value,\n                text = _ref5.text;\n              setFieldValue('address_state', value ? text : '', true);\n              setAddressStateToDisplay('');\n            },\n            list_portal_id: \"modal_root\",\n            disabled: disabled_items.includes('address_state') || ((_props$value4 = props.value) === null || _props$value4 === void 0 ? void 0 : _props$value4.address_state) && has_real_account\n          }))), /*#__PURE__*/external_react_default().createElement(components_.MobileWrapper, null, /*#__PURE__*/external_react_default().createElement(components_.SelectNative, {\n            placeholder: (0,translations_.localize)('Please select'),\n            label: (0,translations_.localize)('State/Province'),\n            value: address_state_to_display || values.address_state,\n            list_items: states_list,\n            use_text: true,\n            onChange: function onChange(e) {\n              setFieldValue('address_state', e.target.value, true);\n              setAddressStateToDisplay('');\n            },\n            disabled: disabled_items.includes('address_state') || !!((_props$value5 = props.value) !== null && _props$value5 !== void 0 && _props$value5.address_state) && has_real_account\n          })));\n        }) :\n        /*#__PURE__*/\n        // Fallback to input field when states list is empty / unavailable for country\n        external_react_default().createElement(form_input_field, {\n          name: \"address_state\",\n          label: (0,translations_.localize)('State/Province'),\n          placeholder: (0,translations_.localize)('State/Province'),\n          disabled: disabled_items.includes('address_state') || !!((_props$value6 = props.value) !== null && _props$value6 !== void 0 && _props$value6.address_state) && has_real_account\n        }), /*#__PURE__*/external_react_default().createElement(form_input_field, {\n          name: \"address_postcode\",\n          required: !!is_gb_residence,\n          label: (0,translations_.localize)('Postal/ZIP Code'),\n          placeholder: (0,translations_.localize)('Postal/ZIP Code'),\n          onChange: function onChange(e) {\n            setFieldTouched('address_postcode', true);\n            handleChange(e);\n          },\n          disabled: disabled_items.includes('address_postcode') || !!((_props$value7 = props.value) !== null && _props$value7 !== void 0 && _props$value7.address_postcode) && has_real_account\n        })))), /*#__PURE__*/external_react_default().createElement(components_.Modal.Footer, {\n          has_separator: true,\n          is_bypassed: is_mobile\n        }, /*#__PURE__*/external_react_default().createElement(components_.FormSubmitButton, {\n          is_disabled: isSubmitting,\n          label: (0,translations_.localize)('Next'),\n          is_absolute: is_mobile,\n          has_cancel: true,\n          cancel_label: (0,translations_.localize)('Previous'),\n          onCancel: function onCancel() {\n            return handleCancel(values);\n          }\n        })))\n      );\n    });\n  });\n});\n/* harmony default export */ const address_details = (AddressDetails);\n;// CONCATENATED MODULE: ./Components/address-details/index.js\n\n/* harmony default export */ const Components_address_details = (address_details);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9Db21wb25lbnRzL2FkZHJlc3MtZGV0YWlscy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBOzs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDcDlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNSQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7Ozs7QUM5QkE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFFQTs7QUN6bEJBO0FBR0E7QUFFQTs7QUNMQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUNOQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREE7QUFVQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFHQTtBQUFBO0FBVUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FDdERBO0FBWUE7QUFDQTtBQUVBO0FBR0E7QUFEQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUdBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUVBOzs7Ozs7Ozs7OztBQzNDQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBVEE7QUFBQTtBQVdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9UQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbmtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVkE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTs7QUNuQkE7QUFTQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUFBO0FBR0E7QUFFQTs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBOzs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBT0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFNQTtBQUVBOzs7Ozs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBRUE7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1BBO0FBQ0E7QUFLQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSEE7QUFBQTs7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFFQTs7Ozs7Ozs7Ozs7QUN4Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUVBOzs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUVBOzs7Ozs7Ozs7OztBQzNCQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7Ozs7Ozs7Ozs7O0FDNUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFIQTtBQUFBOztBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7Ozs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQUE7O0FBUUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFFQTs7Ozs7Ozs7Ozs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFFQTs7Ozs7Ozs7Ozs7QUNsRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFFQTs7Ozs7Ozs7Ozs7QUNmQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFFQTs7Ozs7Ozs7Ozs7QUN6QkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNmQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7Ozs7Ozs7Ozs7O0FDekRBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7Ozs7Ozs7Ozs7O0FDL0JBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFIQTtBQUFBOztBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBR0E7QUFFQTs7Ozs7Ozs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFIQTtBQUFBO0FBS0E7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFFQTs7Ozs7Ozs7Ozs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRkE7QUFBQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7Ozs7Ozs7Ozs7O0FDM0RBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUhBO0FBQUE7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFFQTs7Ozs7Ozs7Ozs7QUNsQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRkE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFFQTs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSEE7QUFJQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUNqQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUhBO0FBQUE7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FDOUJBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7Ozs7Ozs7Ozs7O0FDaENBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFFQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUVBOzs7Ozs7Ozs7OztBQ2xEQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQUE7O0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFFQTs7Ozs7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUFBOztBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7Ozs7Ozs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFBQTs7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUVBOzs7Ozs7OztBQzNCQTtBQUNBO0FBU0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqRUE7QUFDQTtBQUNBO0FBb0JBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7Ozs7Ozs7Ozs7O0FDdkdBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUVBOzs7Ozs7Ozs7OztBQ3pCQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFGQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUVBOzs7Ozs7Ozs7OztBQ2pCQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7O0FDcEJBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FDeEhBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFFQTs7Ozs7Ozs7Ozs7QUMzQkE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUVBOzs7Ozs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBR0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3RkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFHQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBR0E7QUFFQTs7Ozs7Ozs7Ozs7QUN6RUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUVBOzs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFBQTtBQUFBO0FBQUE7QUFjQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUVBOzs7Ozs7Ozs7OztBQ2hFQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFFQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FDbERBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUZBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlDQTtBQVNBO0FBRUE7QUFHQTtBQUFBO0FBREE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUhBO0FBQUE7QUFLQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFFQTs7QUM1Q0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDUkE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7O0FFM0JBO0FBQ0E7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUFBO0FBS0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3hCQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7OztBQ05BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUFBOzs7QUM5QkE7Ozs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFLQTtBQUVBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSEE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFFQTs7QUNaQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFIQTtBQUFBOztBQUtBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUVBOzs7Ozs7Ozs7OztBQ3pCQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBR0E7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSEE7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFFQTs7QUNwSkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSEE7QUFBQTtBQUtBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBRUE7QUFFQTs7Ozs7Ozs7QUMzRUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOztBQ3hCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBRUE7O0FDZEE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUN6QkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FDckJBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFFQTs7QUNYQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FDaEJBO0FBRUE7QUFRQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25EQTtBQUNBO0FBb0JBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUVBOztBQ3JHQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUVBOztBQ1RBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFFQTs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFFQTs7QUN4QkE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUNYQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUVBOztBQ1hBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBRUE7O0FDWkE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBTUE7QUFDQTtBQUVBOztBQ3pCQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFGQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUZBO0FBQUE7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUN6R0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7O0FDdkJBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFFQTs7QUNYQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUVBOztBQ1hBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFFQTs7QUNYQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7Ozs7Ozs7Ozs7O0FDcENBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7QUFBQTtBQUVBO0FBRUE7O0FDdEJBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUVBOztBQ2pCQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUVBOztBQ1ZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBRUE7O0FDaEJBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7O0FDWEE7QUFPQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTs7QUMxRkE7QUFDQTtBQUVBO0FBK0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQ2xFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUVBO0FBQUE7QUFFQTtBQUVBOztBQ3RCQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUVBOztBQ3RCQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7O0FDWkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOztBQzVCQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7O0FDVEE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUZBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRkE7QUFBQTs7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBRUE7QUFFQTs7Ozs7Ozs7Ozs7QUN0RUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFFQTs7Ozs7Ozs7QUNyQ0E7QUFDQTtBQWVBO0FBQUE7QUFDQTtBQUVBO0FBRkE7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQzdDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7Ozs7Ozs7Ozs7O0FDN0NBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSEE7QUFBQTtBQUtBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7Ozs7Ozs7O0FDakJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUNwQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUM3QkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUNqQkE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBRUE7QUFJQTtBQUNBO0FBRUE7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBT0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUVBO0FBQUE7QUFFQTtBQUVBO0FBR0E7QUFGQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFIQTtBQUFBO0FBS0E7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFHQTtBQUNBO0FBWUE7QUFHQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBV0E7QUFDQTtBQWFBO0FBQ0E7QUFLQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUVBOzs7Ozs7OztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUM5Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFHQTtBQUZBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFFQTtBQU1BO0FBR0E7O0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFJQTtBQUNBO0FBSUE7QUFPQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFJQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7OztBQy9VQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFKQTtBQUFBO0FBTUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTs7QUNmQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7QUFBQTtBQUVBO0FBQUE7QUFFQTtBQUVBOztBQzFCQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7Ozs7O0FDbENBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBRUE7QUFDQTtBQXNCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9BO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBSkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUlBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQy9EQTtBQUNBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUdBOzs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFFQTtBQUdBOztBQ25DQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDREE7QUFDQTtBQVFBO0FBSUE7QUFGQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUVBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFtQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYUE7QUFWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBRUE7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQUE7QUFDQTtBQUFBO0FBSUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBREE7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFLQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUlBO0FBR0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFLQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUFBO0FBRUE7QUFJQTtBQUdBOztBQ2hUQTtBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Zvcm1pay9ub2RlX21vZHVsZXMvZGVlcG1lcmdlL2Rpc3QvZXMuanM/ZGM5ZCIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19mcmVlR2xvYmFsLmpzPzZjNjciLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcm9vdC5qcz8wYjBiIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N5bWJvbC5qcz9hNDQzIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qcz9jNzY1Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX29iamVjdFRvU3RyaW5nLmpzPzViZWEiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldFRhZy5qcz9kYmVhIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJBcmcuanM/ZDMyMyIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRQcm90b3R5cGUuanM/ZTlhNiIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzT2JqZWN0TGlrZS5qcz85NmViIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNQbGFpbk9iamVjdC5qcz9lYTBhIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy90aW55LXdhcm5pbmcvZGlzdC90aW55LXdhcm5pbmcuZXNtLmpzP2VlMzciLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlQ2xlYXIuanM/Yjg4MSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2VxLmpzPzk1NjUiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXNzb2NJbmRleE9mLmpzPzBjZDEiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlRGVsZXRlLmpzPzRkNjciLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlR2V0LmpzP2ZmZmMiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlSGFzLmpzPzNkN2IiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlU2V0LmpzPzk0OGMiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTGlzdENhY2hlLmpzPzg3ODAiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RhY2tDbGVhci5qcz81NmEwIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3N0YWNrRGVsZXRlLmpzP2JkNTciLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RhY2tHZXQuanM/NTRlYyIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja0hhcy5qcz9hNzQ4Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3QuanM/N2QzOCIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRnVuY3Rpb24uanM/YmNkMyIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3JlSnNEYXRhLmpzP2IwNTMiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNNYXNrZWQuanM/ZTFmOCIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL190b1NvdXJjZS5qcz9jNDg4Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc05hdGl2ZS5qcz82NTVkIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFZhbHVlLmpzP2Q4Y2EiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0TmF0aXZlLmpzPzMyMWEiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTWFwLmpzPzE3NjYiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlQ3JlYXRlLmpzPzk2MDEiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaENsZWFyLmpzP2M1OWEiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaERlbGV0ZS5qcz8zZjg3Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hHZXQuanM/Yjc3NyIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoSGFzLmpzP2IxZGEiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaFNldC5qcz80ODk3Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX0hhc2guanM/YzViZiIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUNsZWFyLmpzP2FkNmEiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNLZXlhYmxlLmpzP2M0MWQiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0TWFwRGF0YS5qcz82NDY4Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlRGVsZXRlLmpzPzU2OTAiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWFwQ2FjaGVHZXQuanM/MWFjZiIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUhhcy5qcz9iYTIxIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlU2V0LmpzP2FjYzQiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTWFwQ2FjaGUuanM/YTRjMCIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja1NldC5qcz8yNmVkIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N0YWNrLmpzPzQ3YjYiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlFYWNoLmpzPzczZWUiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZGVmaW5lUHJvcGVydHkuanM/MmViMyIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlQXNzaWduVmFsdWUuanM/NzBkOSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hc3NpZ25WYWx1ZS5qcz8zMTYxIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlPYmplY3QuanM/MWNhYSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVGltZXMuanM/NzRkMyIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNBcmd1bWVudHMuanM/Njg1OSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJndW1lbnRzLmpzPzA3YWUiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5LmpzPzAwMzkiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zdHViRmFsc2UuanM/OWFmZiIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQnVmZmVyLmpzPzdhMTciLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJbmRleC5qcz8wNGUxIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNMZW5ndGguanM/NTM5MCIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNUeXBlZEFycmF5LmpzPzFiNTgiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVVuYXJ5LmpzP2M2MTgiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbm9kZVV0aWwuanM/ZjcwNCIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzVHlwZWRBcnJheS5qcz9kNmU0Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TGlrZUtleXMuanM/MWY0NiIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc1Byb3RvdHlwZS5qcz82YjBlIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUtleXMuanM/OTVmYiIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5cy5qcz85ZDExIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcnJheUxpa2UuanM/M2YxNiIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2tleXMuanM/YTUzMyIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlQXNzaWduLmpzPzY0ODIiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlS2V5c0luLmpzPzZhNDkiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUtleXNJbi5qcz83MDQ5Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5c0luLmpzP2I1MzEiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUFzc2lnbkluLmpzPzAzN2IiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2xvbmVCdWZmZXIuanM/MzQ4MCIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5QXJyYXkuanM/NTE5MSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUZpbHRlci5qcz9hMzgwIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvc3R1YkFycmF5LmpzPzhjOTciLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0U3ltYm9scy5qcz9kNDczIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlTeW1ib2xzLmpzP2IwZWMiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlQdXNoLmpzPzQ3YTYiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0U3ltYm9sc0luLmpzP2I2MDkiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29weVN5bWJvbHNJbi5qcz8zNzEyIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXRBbGxLZXlzLmpzPzY3MDAiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0QWxsS2V5cy5qcz8yNWM3Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldEFsbEtleXNJbi5qcz82NDk1Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX0RhdGFWaWV3LmpzPzAxYTIiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fUHJvbWlzZS5qcz9jMmVjIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1NldC5qcz8yMWRkIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1dlYWtNYXAuanM/OWIzOCIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRUYWcuanM/M2YzZSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pbml0Q2xvbmVBcnJheS5qcz8zMzBiIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1VpbnQ4QXJyYXkuanM/ZTFkOSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jbG9uZUFycmF5QnVmZmVyLmpzP2ViYzEiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2xvbmVEYXRhVmlldy5qcz9lYTkxIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lUmVnRXhwLmpzPzEyOTMiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2xvbmVTeW1ib2wuanM/NTc2ZCIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jbG9uZVR5cGVkQXJyYXkuanM/NmRmNyIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pbml0Q2xvbmVCeVRhZy5qcz9kYzhhIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VDcmVhdGUuanM/YjQ5ZiIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pbml0Q2xvbmVPYmplY3QuanM/ZjM2YyIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNNYXAuanM/MTExMiIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTWFwLmpzP2I2NDMiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzU2V0LmpzPzAzMGEiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1NldC5qcz9hMzdjIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VDbG9uZS5qcz9kMDhmIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvY2xvbmUuanM/NzRhMSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheU1hcC5qcz9kNzdiIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNTeW1ib2wuanM/NjVmMyIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL21lbW9pemUuanM/ZTE5MCIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tZW1vaXplQ2FwcGVkLmpzPzIxYzUiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RyaW5nVG9QYXRoLmpzP2Y2OGMiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdG9LZXkuanM/NTg3MCIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVG9TdHJpbmcuanM/MjA1YyIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RvU3RyaW5nLmpzPzY4OTgiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b1BhdGguanM/MzUyZSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2Nsb25lRGVlcC5qcz9jYTI0Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9mb3JtaWsvZGlzdC9mb3JtaWsuZXNtLmpzPzg3MjciLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21vYngtcmVhY3QtbGl0ZS9lcy91dGlscy9hc3NlcnRFbnZpcm9ubWVudC5qcz84YTMyIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9tb2J4LXJlYWN0LWxpdGUvZXMvdXRpbHMvcmVhY3RCYXRjaGVkVXBkYXRlcy5qcz82MmU1Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9tb2J4LXJlYWN0LWxpdGUvZXMvdXRpbHMvb2JzZXJ2ZXJCYXRjaGluZy5qcz9lZThhIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9tb2J4LXJlYWN0LWxpdGUvZXMvdXRpbHMvcHJpbnREZWJ1Z1ZhbHVlLmpzPzYzYjYiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21vYngtcmVhY3QtbGl0ZS9lcy91dGlscy9Vbml2ZXJzYWxGaW5hbGl6YXRpb25SZWdpc3RyeS5qcz85ZDlkIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9tb2J4LXJlYWN0LWxpdGUvZXMvdXRpbHMvb2JzZXJ2ZXJGaW5hbGl6YXRpb25SZWdpc3RyeS5qcz8wZmUwIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9tb2J4LXJlYWN0LWxpdGUvZXMvc3RhdGljUmVuZGVyaW5nLmpzPzg5ZjciLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21vYngtcmVhY3QtbGl0ZS9lcy91c2VPYnNlcnZlci5qcz83MWM4Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9tb2J4LXJlYWN0LWxpdGUvZXMvb2JzZXJ2ZXIuanM/YTgyYiIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL09ic2VydmVyQ29tcG9uZW50LmpzPzY3MmUiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21vYngtcmVhY3QtbGl0ZS9lcy91c2VMb2NhbE9ic2VydmFibGUuanM/NDUyYSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL3VzZUFzT2JzZXJ2YWJsZVNvdXJjZS5qcz8yYzczIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9tb2J4LXJlYWN0LWxpdGUvZXMvdXNlTG9jYWxTdG9yZS5qcz85NjE0Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9tb2J4LXJlYWN0LWxpdGUvZXMvaW5kZXguanM/YjI4MiIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9zdG9yZXMvc3JjL21vY2tTdG9yZS50cz9mYjJhIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL3N0b3Jlcy9zcmMvc3RvcmVDb250ZXh0LnRzPzQ1ZDciLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vYXBpL3NyYy9BUElDb250ZXh0LnRzP2EzMjQiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vYXBpL3NyYy91c2VBUEkudHM/NzQyNCIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9hcGkvc3JjL3VzZUluZmluaXRlUXVlcnkudHM/OGU1MyIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9hcGkvc3JjL3VzZU11dGF0aW9uLnRzPzk4Y2IiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL2xpYi91dGlscy5tanM/NzMyMCIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbGliL25vdGlmeU1hbmFnZXIubWpzPzFkNzgiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL2xpYi9zdWJzY3JpYmFibGUubWpzP2NlYjAiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL2xpYi9mb2N1c01hbmFnZXIubWpzPzVlNDgiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL2xpYi9vbmxpbmVNYW5hZ2VyLm1qcz81MmRiIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9saWIvcmV0cnllci5tanM/YmM5OSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbGliL3F1ZXJ5T2JzZXJ2ZXIubWpzP2JhODgiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9yZWFjdC1xdWVyeS9idWlsZC9saWIvdXNlU3luY0V4dGVybmFsU3RvcmUubWpzPzYxZmUiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9yZWFjdC1xdWVyeS9idWlsZC9saWIvUXVlcnlFcnJvclJlc2V0Qm91bmRhcnkubWpzPzQ0Y2QiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9yZWFjdC1xdWVyeS9idWlsZC9saWIvUXVlcnlDbGllbnRQcm92aWRlci5tanM/YjU2OSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5L2J1aWxkL2xpYi9pc1Jlc3RvcmluZy5tanM/ZTFhYSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5L2J1aWxkL2xpYi91dGlscy5tanM/ZTMwMCIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5L2J1aWxkL2xpYi9lcnJvckJvdW5kYXJ5VXRpbHMubWpzP2IyNmEiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9yZWFjdC1xdWVyeS9idWlsZC9saWIvc3VzcGVuc2UubWpzPzM2N2UiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9yZWFjdC1xdWVyeS9idWlsZC9saWIvdXNlQmFzZVF1ZXJ5Lm1qcz80NTkwIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtcXVlcnkvYnVpbGQvbGliL3VzZVF1ZXJ5Lm1qcz81MTU1Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2FwaS9zcmMvdXRpbHMvcXVlcnktdXRpbHMudHM/MWM5NSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9hcGkvc3JjL3VzZVF1ZXJ5LnRzP2I0MTUiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL2xpYi9sb2dnZXIubWpzPzJhNjQiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL2xpYi9yZW1vdmFibGUubWpzP2NlN2UiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL2xpYi9xdWVyeS5tanM/NjI1MyIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbGliL3F1ZXJ5Q2FjaGUubWpzP2Y5NGUiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL2xpYi9tdXRhdGlvbi5tanM/NDFkMSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbGliL211dGF0aW9uQ2FjaGUubWpzP2Y2ODYiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL2xpYi9pbmZpbml0ZVF1ZXJ5QmVoYXZpb3IubWpzPzNlN2UiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL2xpYi9xdWVyeUNsaWVudC5tanM/NjExOSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9hcGkvc3JjL0FQSVByb3ZpZGVyLnRzeD9hMzM2Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL3V0aWxzL3NyYy9ncm91cFRyYW5zYWN0aW9uc0J5RGF5LnRzPzA5YmQiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vdXRpbHMvc3JjL2luZGV4LnRzPzAzOGQiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vYXBpL3NyYy91c2VJbnZhbGlkYXRlUXVlcnkudHM/YjU5OSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9hcGkvc3JjL2hvb2tzL3VzZUF1dGhvcml6ZS50cz9jMDEwIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2FwaS9zcmMvaG9va3MvdXNlQWNjb3VudExpbWl0cy50cz8zZjNjIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2FwaS9zcmMvaG9va3MvdXNlR2V0QWNjb3VudFN0YXR1cy50cz9kNTNmIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2FwaS9zcmMvaG9va3MvdXNlQWNjb3VudFN0YXR1cy50cz9kMjM1Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2FwaS9zcmMvaG9va3MvdXNlQWNjb3VudFR5cGVzLnRzP2U1ZGEiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vYXBpL3NyYy9ob29rcy91c2VCYWxhbmNlLnRzP2M0YWYiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vYXBpL3NyYy9ob29rcy91c2VDdXJyZW5jeUNvbmZpZy50cz9mNjg1Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2FwaS9zcmMvaG9va3MvdXNlQWNjb3VudHNMaXN0LnRzP2IzNWUiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vYXBpL3NyYy9ob29rcy91c2VBY3RpdmVBY2NvdW50LnRzPzQwNGIiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vYXBpL3NyYy9ob29rcy91c2VUcmFkaW5nQWNjb3VudHNMaXN0LnRzP2RhYzMiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vYXBpL3NyYy9ob29rcy91c2VBY3RpdmVUcmFkaW5nQWNjb3VudC50cz8zZWY3Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2FwaS9zcmMvaG9va3MvdXNlV2FsbGV0QWNjb3VudHNMaXN0LnRzPzk1MWUiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vYXBpL3NyYy9ob29rcy91c2VBY3RpdmVXYWxsZXRBY2NvdW50LnRzPzIyYTMiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vYXBpL3NyYy9ob29rcy91c2VTZXR0aW5ncy50cz8xNDgzIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2FwaS9zcmMvaG9va3MvdXNlTGFuZGluZ0NvbXBhbnkudHM/ZjhkOSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9hcGkvc3JjL2hvb2tzL3VzZUFsbEF2YWlsYWJsZUFjY291bnRzLnRzP2Q1ODkiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vYXBpL3NyYy9ob29rcy91c2VBdXRoZW50aWNhdGlvbi50cz9kYTQ2Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2FwaS9zcmMvaG9va3MvdXNlQXZhaWxhYmxlTVQ1QWNjb3VudHMudHM/NzY5NiIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9hcGkvc3JjL2hvb2tzL3VzZUF2YWlsYWJsZVdhbGxldHMudHM/MjFmNCIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9hcGkvc3JjL2hvb2tzL3VzZU1UNUFjY291bnRzTGlzdC50cz9iNzRjIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2FwaS9zcmMvaG9va3MvdXNlRHh0cmFkZUFjY291bnRzTGlzdC50cz9lOTBhIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2FwaS9zcmMvaG9va3MvdXNlRGVyaXZlelNlcnZpY2VUb2tlbi50cz9jODBjIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2FwaS9zcmMvaG9va3MvdXNlRGVyaXZlekFjY291bnRzTGlzdC50cz8yMmY0Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2FwaS9zcmMvaG9va3MvdXNlQ3RyYWRlckFjY291bnRzTGlzdC50cz81NjExIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2FwaS9zcmMvaG9va3MvdXNlQ0ZEQWNjb3VudHNMaXN0LnRzP2M0YzciLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vYXBpL3NyYy9ob29rcy91c2VDYW5jZWxDcnlwdG9UcmFuc2FjdGlvbi50cz9lMjAyIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2FwaS9zcmMvaG9va3MvdXNlQ2FzaGllckZpYXRBZGRyZXNzLnRzP2MyMmEiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vYXBpL3NyYy9ob29rcy91c2VDb3VudHJ5Q29uZmlnLnRzP2Y2ZTQiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vYXBpL3NyYy9ob29rcy91c2VDcmVhdGVNVDVBY2NvdW50LnRzP2FjNmYiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vYXBpL3NyYy9ob29rcy91c2VDcmVhdGVOZXdSZWFsQWNjb3VudC50cz8xZWMxIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2FwaS9zcmMvaG9va3MvdXNlQ3JlYXRlT3RoZXJDRkRBY2NvdW50LnRzPzJkZDIiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vYXBpL3NyYy91c2VTdWJzY3JpcHRpb24udHM/ZjI0OCIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9hcGkvc3JjL2hvb2tzL3VzZUNyeXB0b1RyYW5zYWN0aW9ucy50cz8wNTk4Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2FwaS9zcmMvaG9va3MvdXNlQ3J5cHRvV2l0aGRyYXdhbC50cz8zODg4Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2FwaS9zcmMvaG9va3MvdXNlQ3RyYWRlclNlcnZpY2VUb2tlbi50cz9jM2YxIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2FwaS9zcmMvaG9va3MvdXNlRGVwb3NpdENyeXB0b0FkZHJlc3MudHM/YWQ3MyIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9hcGkvc3JjL2hvb2tzL3VzZUR5bmFtaWNMZXZlcmFnZS50cz85OWY2Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2FwaS9zcmMvaG9va3MvdXNlRXhjaGFuZ2VSYXRlLnRzP2M0NWIiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vYXBpL3NyYy9ob29rcy91c2VSZXNpZGVuY2VMaXN0LnRzPzM4MDQiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vYXBpL3NyYy9ob29rcy91c2VQT0kudHM/NGVlZSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9hcGkvc3JjL2hvb2tzL3VzZVNvcnRlZE1UNUFjY291bnRzLnRzPzllNWMiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vYXBpL3NyYy9ob29rcy91c2VUcmFkaW5nUGxhdGZvcm1JbnZlc3RvclBhc3N3b3JkQ2hhbmdlLnRzP2ViMDgiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vYXBpL3NyYy9ob29rcy91c2VUcmFkaW5nUGxhdGZvcm1JbnZlc3RvclBhc3N3b3JkUmVzZXQudHM/NzZhNCIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9hcGkvc3JjL2hvb2tzL3VzZVRyYWRpbmdQbGF0Zm9ybVBhc3N3b3JkQ2hhbmdlLnRzPzEwN2YiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vYXBpL3NyYy9ob29rcy91c2VUcmFuc2FjdGlvbnMudHM/OTVjYyIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9hcGkvc3JjL2hvb2tzL3VzZVRyYW5zZmVyQmV0d2VlbkFjY291bnRzLnRzP2JlNzEiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vYXBpL3NyYy9ob29rcy91c2VWZXJpZnlFbWFpbC50cz85OGNkIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2FwaS9zcmMvaG9va3MvdXNlV2FsbGV0TWlncmF0aW9uLnRzP2Y1ZWQiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vYXBpL3NyYy9ob29rcy91c2VEeHRyYWRlU2VydmljZVRva2VuLnRzPzRhNmQiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vYXBpL3NyYy9ob29rcy9pbmRleC50cz82YTg3Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2FwaS9zcmMvdXNlUGFnaW5hdGVkRmV0Y2gudHM/OTg5MSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9hcGkvc3JjL2luZGV4LnRzPzIxNDUiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vc3RvcmVzL3NyYy91c2VTdG9yZS50cz9mMDdlIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL3N0b3Jlcy9zcmMvcHJvdmlkZXJzL0V4Y2hhbmdlUmF0ZXNQcm92aWRlci50c3g/MzQ1YiIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9zdG9yZXMvc3JjL3Byb3ZpZGVycy9pbmRleC50cz9lZjIwIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9tb2J4LXBlcnNpc3Qtc3RvcmUvbGliL2VzbTUvUGVyc2lzdFN0b3JlTWFwLmpzPzk2MTkiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21vYngtcGVyc2lzdC1zdG9yZS9saWIvZXNtNS9jbGVhclBlcnNpc3RlZFN0b3JlLmpzPzkyZjUiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21vYngtcGVyc2lzdC1zdG9yZS9saWIvZXNtNS9jb25maWd1cmVQZXJzaXN0YWJsZS5qcz85NzNkIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9tb2J4LXBlcnNpc3Qtc3RvcmUvbGliL2VzbTUvZ2V0UGVyc2lzdGVkU3RvcmUuanM/MzdmYyIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbW9ieC1wZXJzaXN0LXN0b3JlL2xpYi9lc201L2h5ZHJhdGVTdG9yZS5qcz8yMDk2Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9tb2J4LXBlcnNpc3Qtc3RvcmUvbGliL2VzbTUvaXNIeWRyYXRlZC5qcz9lNzJmIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9tb2J4LXBlcnNpc3Qtc3RvcmUvbGliL2VzbTUvaXNQZXJzaXN0aW5nLmpzP2ZiMzIiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21vYngtcGVyc2lzdC1zdG9yZS9saWIvZXNtNS91dGlscy5qcz9hMThjIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9tb2J4LXBlcnNpc3Qtc3RvcmUvbGliL2VzbTUvU3RvcmFnZUFkYXB0ZXIuanM/OThlYyIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbW9ieC1wZXJzaXN0LXN0b3JlL2xpYi9lc201L3NlcmlhbGl6YWJsZVByb3BlcnR5LmpzP2RhMjIiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21vYngtcGVyc2lzdC1zdG9yZS9saWIvZXNtNS9QZXJzaXN0U3RvcmUuanM/NmNkNSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbW9ieC1wZXJzaXN0LXN0b3JlL2xpYi9lc201L21ha2VQZXJzaXN0YWJsZS5qcz81MzJkIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9tb2J4LXBlcnNpc3Qtc3RvcmUvbGliL2VzbTUvcGF1c2VQZXJzaXN0aW5nLmpzPzg2NjAiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21vYngtcGVyc2lzdC1zdG9yZS9saWIvZXNtNS9zdGFydFBlcnNpc3RpbmcuanM/NDliNSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbW9ieC1wZXJzaXN0LXN0b3JlL2xpYi9lc201L3N0b3BQZXJzaXN0aW5nLmpzP2Y5YTUiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21vYngtcGVyc2lzdC1zdG9yZS9saWIvZXNtNS9pbmRleC5qcz8xYTE5Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL3N0b3Jlcy9zcmMvc3RvcmVzL0Jhc2VTdG9yZS50cz83Zjc5Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL3N0b3Jlcy9zcmMvc3RvcmVzL0V4Y2hhbmdlUmF0ZXNTdG9yZS50cz84MzZiIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL3N0b3Jlcy9zcmMvc3RvcmVzL0ZlYXR1cmVGbGFnc1N0b3JlLnRzP2JjNzMiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vc3RvcmVzL3NyYy9zdG9yZXMvaW5kZXgudHM/OTU4NSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9zdG9yZXMvc3JjL3N0b3JlUHJvdmlkZXIudHN4PzM2ODMiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vc3RvcmVzL3NyYy9pbmRleC50cz9kNjFmIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2hvb2tzL3NyYy91c2VIYXNNYWx0YUludmVzdEFjY291bnQudHM/MDEzYSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9ob29rcy9zcmMvdXNlQWNjb3VudFRyYW5zZmVyVmlzaWJsZS50cz9lZWVlIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2hvb2tzL3NyYy91c2VBdXRob3JpemUudHM/MWIwZSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9ob29rcy9zcmMvdXNlQ3VycmVuY3lDb25maWcudHM/YTE2OCIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9ob29rcy9zcmMvdXNlV2FsbGV0c0xpc3QudHM/NjNmZSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9ob29rcy9zcmMvdXNlQWN0aXZlV2FsbGV0LnRzP2Q1NDYiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vaG9va3Mvc3JjL3VzZUF2YWlsYWJsZVdhbGxldHMudHM/YjczZiIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9ob29rcy9zcmMvdXNlQ0ZEQWxsQWNjb3VudHMudHM/NTMyMCIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9ob29rcy9zcmMvdXNlQ0ZERGVtb0FjY291bnRzLnRzPzJlMWYiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vaG9va3Mvc3JjL3VzZUNGRFJlYWxBY2NvdW50cy50cz9iZDI5Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2hvb2tzL3NyYy91c2VDRkRBY2NvdW50cy50cz85NzU3Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2hvb2tzL3NyYy91c2VDYXNoaWVyTG9ja2VkLnRzP2I0NDMiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vaG9va3Mvc3JjL3VzZUNvbnRlbnRGbGFnLnRzPzQ4ZjYiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vaG9va3Mvc3JjL3VzZUNvdW50ZG93bi50cz9iMmUyIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2hvb2tzL3NyYy91c2VDcnlwdG9UcmFuc2FjdGlvbnMudHM/NmRlZCIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9ob29rcy9zcmMvdXNlQ3VycmVudEFjY291bnREZXRhaWxzLnRzP2Q5OGMiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vaG9va3Mvc3JjL3VzZUN1cnJlbnRDdXJyZW5jeUNvbmZpZy50cz83Yjc5Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2hvb2tzL3NyYy91c2VEZXBvc2l0Q3J5cHRvQWRkcmVzcy50cz8xMmU5Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2hvb2tzL3NyYy91c2VEZXBvc2l0RmlhdEFkZHJlc3MudHM/OTVjNSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9ob29rcy9zcmMvdXNlTmVlZEF1dGhlbnRpY2F0aW9uLnRzP2U5ZTciLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vaG9va3Mvc3JjL3VzZU5lZWRGaW5hbmNpYWxBc3Nlc3NtZW50LnRzPzYyODUiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vaG9va3Mvc3JjL3VzZVJlYWxTVFBBY2NvdW50LnRzPzA5YzIiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vaG9va3Mvc3JjL3VzZU5lZWRUTkMudHM/Y2UxNyIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9ob29rcy9zcmMvdXNlRGVwb3NpdExvY2tlZC50cz80MWE1Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2hvb2tzL3NyYy91c2VFeGNoYW5nZVJhdGUudHM/YTkyNSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9ob29rcy9zcmMvdXNlRXhpc3RpbmdDRkRBY2NvdW50cy50cz8xNTY2Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2hvb2tzL3NyYy91c2VGZWF0dXJlRmxhZ3MudHM/ZTIyZSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9ob29rcy9zcmMvdXNlRmlhdEFjY291bnRMaXN0LnRzPzFmNmEiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vaG9va3Mvc3JjL3VzZUhhc0FjdGl2ZVJlYWxBY2NvdW50LnRzPzM3MDYiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vaG9va3Mvc3JjL3VzZUhhc0NyeXB0b0N1cnJlbmN5LnRzP2EwNjUiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vaG9va3Mvc3JjL3VzZUhhc0ZpYXRDdXJyZW5jeS50cz9jYmRjIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2hvb2tzL3NyYy91c2VQMlBDb25maWcudHM/MjAwMSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9ob29rcy9zcmMvdXNlSGFzUDJQU3VwcG9ydGVkQ3VycmVuY2llcy50cz9iZGYyIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2hvb2tzL3NyYy91c2VIYXNTZXRDdXJyZW5jeS50cz9jZjI0Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2hvb2tzL3NyYy91c2VIYXNTdmdBY2NvdW50LnRzP2U2OWEiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vaG9va3Mvc3JjL3VzZUhhc1N3YXBGcmVlQWNjb3VudC50cz85YjFmIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2hvb2tzL3NyYy91c2VIYXNVU0RDdXJyZW5jeS50cz85YjE2Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2hvb2tzL3NyYy91c2VJbnB1dERlY2ltYWxGb3JtYXR0ZXIudHM/ZTAwMSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9ob29rcy9zcmMvdXNlSW5wdXRBVE1Gb3JtYXR0ZXIudHM/YjNlNSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9ob29rcy9zcmMvdXNlSXNBY2NvdW50U3RhdHVzUHJlc2VudC50cz8wMWZlIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2hvb2tzL3NyYy91c2VJc1AyUEVuYWJsZWQudHM/OTNkOSIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9ob29rcy9zcmMvdXNlSXNSZWFsQWNjb3VudE5lZWRlZEZvckNhc2hpZXIudHM/MGRkNCIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9ob29rcy9zcmMvdXNlSXNTeXN0ZW1NYWludGVuYW5jZS50cz82MTc1Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2hvb2tzL3NyYy91c2VMb2NhbFN0b3JhZ2VEYXRhLnRzP2ViYWMiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vaG9va3Mvc3JjL3VzZU5lZWRQT0kudHM/ZjU4YiIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9ob29rcy9zcmMvdXNlT25yYW1wVmlzaWJsZS50cz85MWNjIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2hvb2tzL3NyYy91c2VQMlBBZHZlcnRpc2VyUGF5bWVudE1ldGhvZHMudHM/MmZmYyIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9ob29rcy9zcmMvdXNlUDJQQWR2ZXJ0TGlzdC50cz9kM2FmIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2hvb2tzL3NyYy91c2VQMlBOb3RpZmljYXRpb25Db3VudC50cz8zMzRiIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2hvb2tzL3NyYy91c2VQMlBQYXltZW50TWV0aG9kcy50cz80MjllIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2hvb2tzL3NyYy91c2VQYXltZW50QWdlbnRMaXN0LnRzPzI1MDYiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vaG9va3Mvc3JjL3VzZVBheW1lbnRBZ2VudFRyYW5zZmVyVmlzaWJsZS50cz9jMzY4Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2hvb2tzL3NyYy91c2VQbGF0Zm9ybURlbW9BY2NvdW50LnRzPzk1NDYiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vaG9va3Mvc3JjL3VzZVBsYXRmb3JtUmVhbEFjY291bnRzLnRzPzg4MmIiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vaG9va3Mvc3JjL3VzZVBsYXRmb3JtQWNjb3VudHMudHM/OGQwNiIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9ob29rcy9zcmMvdXNlVG90YWxBc3NldEN1cnJlbmN5LnRzP2Q3ZDQiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vaG9va3Mvc3JjL3VzZVRvdGFsQWNjb3VudEJhbGFuY2UudHM/MzI3ZCIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9ob29rcy9zcmMvdXNlVHJhbnNmZXJCZXR3ZWVuQWNjb3VudHMudHM/ZDY5OCIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9ob29rcy9zcmMvdXNlVmVyaWZ5RW1haWwudHM/ZGQxMyIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9ob29rcy9zcmMvdXNlV2FsbGV0TWlncmF0aW9uLnRzPzEyYjEiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vaG9va3Mvc3JjL3VzZVdhbGxldFRyYW5zYWN0aW9ucy50cz80ZGVkIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2hvb2tzL3NyYy91c2VXYWxsZXRUcmFuc2Zlci50cz82YTRkIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2hvb2tzL3NyYy91c2VTdGF0ZXNMaXN0LnRzPzI1MDAiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vaG9va3Mvc3JjL3VzZUlzQ2xpZW50SGlnaFJpc2tGb3JNVDUudHM/ZmM0OCIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi9ob29rcy9zcmMvdXNlQ0ZEQ2FuR2V0TW9yZU1UNUFjY291bnRzLnRzPzMwNmIiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vaG9va3Mvc3JjL3VzZUZpbGVVcGxvYWRlci50cz9jZjY1Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uL2hvb2tzL3NyYy9pbmRleC50cz8wZGI5Iiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4vQ29tcG9uZW50cy9mb3Jtcy9mb3JtLWZpZWxkcy9mb3JtLWlucHV0LWZpZWxkLnRzeD83MzVmIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4vQ29tcG9uZW50cy9mb3Jtcy9mb3JtLWZpZWxkcy9kYXRlLW9mLWJpcnRoLWZpZWxkLnRzeD80ZGFiIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4vQ29tcG9uZW50cy9mb3Jtcy9mb3JtLWZpZWxkcy9pbmRleC50cz80YTVhIiwid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4vQ29tcG9uZW50cy9mb3Jtcy9zY3JvbGwtdG8tZmllbGQtd2l0aC1lcnJvci50c3g/ZDBkMCIsIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uL0NvbXBvbmVudHMvcmVhbC1hY2NvdW50LXNpZ251cC9oZWxwZXJzL3V0aWxzLnRzPzk3NTIiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi9Db21wb25lbnRzL2FkZHJlc3MtZGV0YWlscy9hZGRyZXNzLWRldGFpbHMudHN4P2YxNWEiLCJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi9Db21wb25lbnRzL2FkZHJlc3MtZGV0YWlscy9pbmRleC5qcz8xMDVkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBpc01lcmdlYWJsZU9iamVjdCA9IGZ1bmN0aW9uIGlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiBpc05vbk51bGxPYmplY3QodmFsdWUpXG5cdFx0JiYgIWlzU3BlY2lhbCh2YWx1ZSlcbn07XG5cbmZ1bmN0aW9uIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG59XG5cbmZ1bmN0aW9uIGlzU3BlY2lhbCh2YWx1ZSkge1xuXHR2YXIgc3RyaW5nVmFsdWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXG5cdHJldHVybiBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcblx0XHR8fCBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgRGF0ZV0nXG5cdFx0fHwgaXNSZWFjdEVsZW1lbnQodmFsdWUpXG59XG5cbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9iNWFjOTYzZmI3OTFkMTI5OGU3ZjM5NjIzNjM4M2JjOTU1ZjkxNmMxL3NyYy9pc29tb3JwaGljL2NsYXNzaWMvZWxlbWVudC9SZWFjdEVsZW1lbnQuanMjTDIxLUwyNVxudmFyIGNhblVzZVN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBjYW5Vc2VTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG5cbmZ1bmN0aW9uIGlzUmVhY3RFbGVtZW50KHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFXG59XG5cbmZ1bmN0aW9uIGVtcHR5VGFyZ2V0KHZhbCkge1xuXHRyZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpID8gW10gOiB7fVxufVxuXG5mdW5jdGlvbiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCh2YWx1ZSwgb3B0aW9ucykge1xuXHRyZXR1cm4gKG9wdGlvbnMuY2xvbmUgIT09IGZhbHNlICYmIG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QodmFsdWUpKVxuXHRcdD8gZGVlcG1lcmdlKGVtcHR5VGFyZ2V0KHZhbHVlKSwgdmFsdWUsIG9wdGlvbnMpXG5cdFx0OiB2YWx1ZVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0QXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRyZXR1cm4gdGFyZ2V0LmNvbmNhdChzb3VyY2UpLm1hcChmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0cmV0dXJuIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKGVsZW1lbnQsIG9wdGlvbnMpXG5cdH0pXG59XG5cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdHZhciBkZXN0aW5hdGlvbiA9IHt9O1xuXHRpZiAob3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCh0YXJnZXQpKSB7XG5cdFx0T2JqZWN0LmtleXModGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHRhcmdldFtrZXldLCBvcHRpb25zKTtcblx0XHR9KTtcblx0fVxuXHRPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0aWYgKCFvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHNvdXJjZVtrZXldKSB8fCAhdGFyZ2V0W2tleV0pIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2Vba2V5XSwgb3B0aW9ucyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBkZWVwbWVyZ2UodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBvcHRpb25zKTtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZGVzdGluYXRpb25cbn1cblxuZnVuY3Rpb24gZGVlcG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRvcHRpb25zLmFycmF5TWVyZ2UgPSBvcHRpb25zLmFycmF5TWVyZ2UgfHwgZGVmYXVsdEFycmF5TWVyZ2U7XG5cdG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QgPSBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0IHx8IGlzTWVyZ2VhYmxlT2JqZWN0O1xuXG5cdHZhciBzb3VyY2VJc0FycmF5ID0gQXJyYXkuaXNBcnJheShzb3VyY2UpO1xuXHR2YXIgdGFyZ2V0SXNBcnJheSA9IEFycmF5LmlzQXJyYXkodGFyZ2V0KTtcblx0dmFyIHNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2ggPSBzb3VyY2VJc0FycmF5ID09PSB0YXJnZXRJc0FycmF5O1xuXG5cdGlmICghc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCkge1xuXHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2UsIG9wdGlvbnMpXG5cdH0gZWxzZSBpZiAoc291cmNlSXNBcnJheSkge1xuXHRcdHJldHVybiBvcHRpb25zLmFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuXHR9XG59XG5cbmRlZXBtZXJnZS5hbGwgPSBmdW5jdGlvbiBkZWVwbWVyZ2VBbGwoYXJyYXksIG9wdGlvbnMpIHtcblx0aWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGFycmF5Jylcblx0fVxuXG5cdHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgbmV4dCkge1xuXHRcdHJldHVybiBkZWVwbWVyZ2UocHJldiwgbmV4dCwgb3B0aW9ucylcblx0fSwge30pXG59O1xuXG52YXIgZGVlcG1lcmdlXzEgPSBkZWVwbWVyZ2U7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZXBtZXJnZV8xO1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuZXhwb3J0IGRlZmF1bHQgZnJlZUdsb2JhbDtcbiIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHJvb3Q7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bWJvbDtcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRSYXdUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb2JqZWN0VG9TdHJpbmc7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgZ2V0UmF3VGFnIGZyb20gJy4vX2dldFJhd1RhZy5qcyc7XG5pbXBvcnQgb2JqZWN0VG9TdHJpbmcgZnJvbSAnLi9fb2JqZWN0VG9TdHJpbmcuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldFRhZztcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBvdmVyQXJnO1xuIiwiaW1wb3J0IG92ZXJBcmcgZnJvbSAnLi9fb3ZlckFyZy5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5leHBvcnQgZGVmYXVsdCBnZXRQcm90b3R5cGU7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3RMaWtlO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgZ2V0UHJvdG90eXBlIGZyb20gJy4vX2dldFByb3RvdHlwZS5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1BsYWluT2JqZWN0O1xuIiwidmFyIGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbic7XG5mdW5jdGlvbiB3YXJuaW5nKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWlzUHJvZHVjdGlvbikge1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGV4dCA9IFwiV2FybmluZzogXCIgKyBtZXNzYWdlO1xuXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKHRleHQpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB0aHJvdyBFcnJvcih0ZXh0KTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHdhcm5pbmc7XG4iLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZUNsZWFyO1xuIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGVxO1xuIiwiaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhc3NvY0luZGV4T2Y7XG4iLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlRGVsZXRlO1xuIiwiaW1wb3J0IGFzc29jSW5kZXhPZiBmcm9tICcuL19hc3NvY0luZGV4T2YuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVHZXQ7XG4iLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVIYXM7XG4iLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlU2V0O1xuIiwiaW1wb3J0IGxpc3RDYWNoZUNsZWFyIGZyb20gJy4vX2xpc3RDYWNoZUNsZWFyLmpzJztcbmltcG9ydCBsaXN0Q2FjaGVEZWxldGUgZnJvbSAnLi9fbGlzdENhY2hlRGVsZXRlLmpzJztcbmltcG9ydCBsaXN0Q2FjaGVHZXQgZnJvbSAnLi9fbGlzdENhY2hlR2V0LmpzJztcbmltcG9ydCBsaXN0Q2FjaGVIYXMgZnJvbSAnLi9fbGlzdENhY2hlSGFzLmpzJztcbmltcG9ydCBsaXN0Q2FjaGVTZXQgZnJvbSAnLi9fbGlzdENhY2hlU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5leHBvcnQgZGVmYXVsdCBMaXN0Q2FjaGU7XG4iLCJpbXBvcnQgTGlzdENhY2hlIGZyb20gJy4vX0xpc3RDYWNoZS5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0YWNrQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0YWNrRGVsZXRlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0YWNrSGFzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0O1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzRnVuY3Rpb247XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuZXhwb3J0IGRlZmF1bHQgY29yZUpzRGF0YTtcbiIsImltcG9ydCBjb3JlSnNEYXRhIGZyb20gJy4vX2NvcmVKc0RhdGEuanMnO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9Tb3VyY2U7XG4iLCJpbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzTWFza2VkIGZyb20gJy4vX2lzTWFza2VkLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCB0b1NvdXJjZSBmcm9tICcuL190b1NvdXJjZS5qcyc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc05hdGl2ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRWYWx1ZTtcbiIsImltcG9ydCBiYXNlSXNOYXRpdmUgZnJvbSAnLi9fYmFzZUlzTmF0aXZlLmpzJztcbmltcG9ydCBnZXRWYWx1ZSBmcm9tICcuL19nZXRWYWx1ZS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE5hdGl2ZTtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxuZXhwb3J0IGRlZmF1bHQgTWFwO1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5leHBvcnQgZGVmYXVsdCBuYXRpdmVDcmVhdGU7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoRGVsZXRlO1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hHZXQ7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaEhhcztcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hTZXQ7XG4iLCJpbXBvcnQgaGFzaENsZWFyIGZyb20gJy4vX2hhc2hDbGVhci5qcyc7XG5pbXBvcnQgaGFzaERlbGV0ZSBmcm9tICcuL19oYXNoRGVsZXRlLmpzJztcbmltcG9ydCBoYXNoR2V0IGZyb20gJy4vX2hhc2hHZXQuanMnO1xuaW1wb3J0IGhhc2hIYXMgZnJvbSAnLi9faGFzaEhhcy5qcyc7XG5pbXBvcnQgaGFzaFNldCBmcm9tICcuL19oYXNoU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IEhhc2g7XG4iLCJpbXBvcnQgSGFzaCBmcm9tICcuL19IYXNoLmpzJztcbmltcG9ydCBMaXN0Q2FjaGUgZnJvbSAnLi9fTGlzdENhY2hlLmpzJztcbmltcG9ydCBNYXAgZnJvbSAnLi9fTWFwLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZUNsZWFyO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0tleWFibGU7XG4iLCJpbXBvcnQgaXNLZXlhYmxlIGZyb20gJy4vX2lzS2V5YWJsZS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0TWFwRGF0YTtcbiIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVEZWxldGU7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZUdldDtcbiIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZUhhcztcbiIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlU2V0O1xuIiwiaW1wb3J0IG1hcENhY2hlQ2xlYXIgZnJvbSAnLi9fbWFwQ2FjaGVDbGVhci5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVEZWxldGUgZnJvbSAnLi9fbWFwQ2FjaGVEZWxldGUuanMnO1xuaW1wb3J0IG1hcENhY2hlR2V0IGZyb20gJy4vX21hcENhY2hlR2V0LmpzJztcbmltcG9ydCBtYXBDYWNoZUhhcyBmcm9tICcuL19tYXBDYWNoZUhhcy5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVTZXQgZnJvbSAnLi9fbWFwQ2FjaGVTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuZXhwb3J0IGRlZmF1bHQgTWFwQ2FjaGU7XG4iLCJpbXBvcnQgTGlzdENhY2hlIGZyb20gJy4vX0xpc3RDYWNoZS5qcyc7XG5pbXBvcnQgTWFwIGZyb20gJy4vX01hcC5qcyc7XG5pbXBvcnQgTWFwQ2FjaGUgZnJvbSAnLi9fTWFwQ2FjaGUuanMnO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tTZXQ7XG4iLCJpbXBvcnQgTGlzdENhY2hlIGZyb20gJy4vX0xpc3RDYWNoZS5qcyc7XG5pbXBvcnQgc3RhY2tDbGVhciBmcm9tICcuL19zdGFja0NsZWFyLmpzJztcbmltcG9ydCBzdGFja0RlbGV0ZSBmcm9tICcuL19zdGFja0RlbGV0ZS5qcyc7XG5pbXBvcnQgc3RhY2tHZXQgZnJvbSAnLi9fc3RhY2tHZXQuanMnO1xuaW1wb3J0IHN0YWNrSGFzIGZyb20gJy4vX3N0YWNrSGFzLmpzJztcbmltcG9ydCBzdGFja1NldCBmcm9tICcuL19zdGFja1NldC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuZXhwb3J0IGRlZmF1bHQgU3RhY2s7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5RWFjaDtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZVByb3BlcnR5O1xuIiwiaW1wb3J0IGRlZmluZVByb3BlcnR5IGZyb20gJy4vX2RlZmluZVByb3BlcnR5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUFzc2lnblZhbHVlO1xuIiwiaW1wb3J0IGJhc2VBc3NpZ25WYWx1ZSBmcm9tICcuL19iYXNlQXNzaWduVmFsdWUuanMnO1xuaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBhc3NpZ25WYWx1ZTtcbiIsImltcG9ydCBhc3NpZ25WYWx1ZSBmcm9tICcuL19hc3NpZ25WYWx1ZS5qcyc7XG5pbXBvcnQgYmFzZUFzc2lnblZhbHVlIGZyb20gJy4vX2Jhc2VBc3NpZ25WYWx1ZS5qcyc7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb3B5T2JqZWN0O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVRpbWVzO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzQXJndW1lbnRzO1xuIiwiaW1wb3J0IGJhc2VJc0FyZ3VtZW50cyBmcm9tICcuL19iYXNlSXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHViRmFsc2U7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcbmltcG9ydCBzdHViRmFsc2UgZnJvbSAnLi9zdHViRmFsc2UuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbmV4cG9ydCBkZWZhdWx0IGlzQnVmZmVyO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0luZGV4O1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0xlbmd0aDtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzTGVuZ3RoIGZyb20gJy4vaXNMZW5ndGguanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzVHlwZWRBcnJheTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVVuYXJ5O1xuIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICBpZiAodHlwZXMpIHtcbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbmV4cG9ydCBkZWZhdWx0IG5vZGVVdGlsO1xuIiwiaW1wb3J0IGJhc2VJc1R5cGVkQXJyYXkgZnJvbSAnLi9fYmFzZUlzVHlwZWRBcnJheS5qcyc7XG5pbXBvcnQgYmFzZVVuYXJ5IGZyb20gJy4vX2Jhc2VVbmFyeS5qcyc7XG5pbXBvcnQgbm9kZVV0aWwgZnJvbSAnLi9fbm9kZVV0aWwuanMnO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgaXNUeXBlZEFycmF5O1xuIiwiaW1wb3J0IGJhc2VUaW1lcyBmcm9tICcuL19iYXNlVGltZXMuanMnO1xuaW1wb3J0IGlzQXJndW1lbnRzIGZyb20gJy4vaXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0J1ZmZlciBmcm9tICcuL2lzQnVmZmVyLmpzJztcbmltcG9ydCBpc0luZGV4IGZyb20gJy4vX2lzSW5kZXguanMnO1xuaW1wb3J0IGlzVHlwZWRBcnJheSBmcm9tICcuL2lzVHlwZWRBcnJheS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlMaWtlS2V5cztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQcm90b3R5cGU7XG4iLCJpbXBvcnQgb3ZlckFyZyBmcm9tICcuL19vdmVyQXJnLmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5leHBvcnQgZGVmYXVsdCBuYXRpdmVLZXlzO1xuIiwiaW1wb3J0IGlzUHJvdG90eXBlIGZyb20gJy4vX2lzUHJvdG90eXBlLmpzJztcbmltcG9ydCBuYXRpdmVLZXlzIGZyb20gJy4vX25hdGl2ZUtleXMuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VLZXlzO1xuIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXlMaWtlO1xuIiwiaW1wb3J0IGFycmF5TGlrZUtleXMgZnJvbSAnLi9fYXJyYXlMaWtlS2V5cy5qcyc7XG5pbXBvcnQgYmFzZUtleXMgZnJvbSAnLi9fYmFzZUtleXMuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQga2V5cztcbiIsImltcG9ydCBjb3B5T2JqZWN0IGZyb20gJy4vX2NvcHlPYmplY3QuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlQXNzaWduO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5hdGl2ZUtleXNJbjtcbiIsImltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5pbXBvcnQgbmF0aXZlS2V5c0luIGZyb20gJy4vX25hdGl2ZUtleXNJbi5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VLZXlzSW47XG4iLCJpbXBvcnQgYXJyYXlMaWtlS2V5cyBmcm9tICcuL19hcnJheUxpa2VLZXlzLmpzJztcbmltcG9ydCBiYXNlS2V5c0luIGZyb20gJy4vX2Jhc2VLZXlzSW4uanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQga2V5c0luO1xuIiwiaW1wb3J0IGNvcHlPYmplY3QgZnJvbSAnLi9fY29weU9iamVjdC5qcyc7XG5pbXBvcnQga2V5c0luIGZyb20gJy4va2V5c0luLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25JbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlQXNzaWduSW47XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVCdWZmZXI7XG4iLCIvKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29weUFycmF5O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUZpbHRlcjtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0dWJBcnJheTtcbiIsImltcG9ydCBhcnJheUZpbHRlciBmcm9tICcuL19hcnJheUZpbHRlci5qcyc7XG5pbXBvcnQgc3R1YkFycmF5IGZyb20gJy4vc3R1YkFycmF5LmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBnZXRTeW1ib2xzO1xuIiwiaW1wb3J0IGNvcHlPYmplY3QgZnJvbSAnLi9fY29weU9iamVjdC5qcyc7XG5pbXBvcnQgZ2V0U3ltYm9scyBmcm9tICcuL19nZXRTeW1ib2xzLmpzJztcblxuLyoqXG4gKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb3B5U3ltYm9scztcbiIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlQdXNoO1xuIiwiaW1wb3J0IGFycmF5UHVzaCBmcm9tICcuL19hcnJheVB1c2guanMnO1xuaW1wb3J0IGdldFByb3RvdHlwZSBmcm9tICcuL19nZXRQcm90b3R5cGUuanMnO1xuaW1wb3J0IGdldFN5bWJvbHMgZnJvbSAnLi9fZ2V0U3ltYm9scy5qcyc7XG5pbXBvcnQgc3R1YkFycmF5IGZyb20gJy4vc3R1YkFycmF5LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAob2JqZWN0KSB7XG4gICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0U3ltYm9sc0luO1xuIiwiaW1wb3J0IGNvcHlPYmplY3QgZnJvbSAnLi9fY29weU9iamVjdC5qcyc7XG5pbXBvcnQgZ2V0U3ltYm9sc0luIGZyb20gJy4vX2dldFN5bWJvbHNJbi5qcyc7XG5cbi8qKlxuICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29weVN5bWJvbHNJbjtcbiIsImltcG9ydCBhcnJheVB1c2ggZnJvbSAnLi9fYXJyYXlQdXNoLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldEFsbEtleXM7XG4iLCJpbXBvcnQgYmFzZUdldEFsbEtleXMgZnJvbSAnLi9fYmFzZUdldEFsbEtleXMuanMnO1xuaW1wb3J0IGdldFN5bWJvbHMgZnJvbSAnLi9fZ2V0U3ltYm9scy5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRBbGxLZXlzO1xuIiwiaW1wb3J0IGJhc2VHZXRBbGxLZXlzIGZyb20gJy4vX2Jhc2VHZXRBbGxLZXlzLmpzJztcbmltcG9ydCBnZXRTeW1ib2xzSW4gZnJvbSAnLi9fZ2V0U3ltYm9sc0luLmpzJztcbmltcG9ydCBrZXlzSW4gZnJvbSAnLi9rZXlzSW4uanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRBbGxLZXlzSW47XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5leHBvcnQgZGVmYXVsdCBEYXRhVmlldztcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpO1xuXG5leHBvcnQgZGVmYXVsdCBQcm9taXNlO1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5leHBvcnQgZGVmYXVsdCBTZXQ7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKTtcblxuZXhwb3J0IGRlZmF1bHQgV2Vha01hcDtcbiIsImltcG9ydCBEYXRhVmlldyBmcm9tICcuL19EYXRhVmlldy5qcyc7XG5pbXBvcnQgTWFwIGZyb20gJy4vX01hcC5qcyc7XG5pbXBvcnQgUHJvbWlzZSBmcm9tICcuL19Qcm9taXNlLmpzJztcbmltcG9ydCBTZXQgZnJvbSAnLi9fU2V0LmpzJztcbmltcG9ydCBXZWFrTWFwIGZyb20gJy4vX1dlYWtNYXAuanMnO1xuaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgdG9Tb3VyY2UgZnJvbSAnLi9fdG9Tb3VyY2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBpbml0Q2xvbmVBcnJheTtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBVaW50OEFycmF5O1xuIiwiaW1wb3J0IFVpbnQ4QXJyYXkgZnJvbSAnLi9fVWludDhBcnJheS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVBcnJheUJ1ZmZlcjtcbiIsImltcG9ydCBjbG9uZUFycmF5QnVmZmVyIGZyb20gJy4vX2Nsb25lQXJyYXlCdWZmZXIuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICovXG5mdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbG9uZURhdGFWaWV3O1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICovXG5mdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVSZWdFeHA7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVTeW1ib2w7XG4iLCJpbXBvcnQgY2xvbmVBcnJheUJ1ZmZlciBmcm9tICcuL19jbG9uZUFycmF5QnVmZmVyLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVUeXBlZEFycmF5O1xuIiwiaW1wb3J0IGNsb25lQXJyYXlCdWZmZXIgZnJvbSAnLi9fY2xvbmVBcnJheUJ1ZmZlci5qcyc7XG5pbXBvcnQgY2xvbmVEYXRhVmlldyBmcm9tICcuL19jbG9uZURhdGFWaWV3LmpzJztcbmltcG9ydCBjbG9uZVJlZ0V4cCBmcm9tICcuL19jbG9uZVJlZ0V4cC5qcyc7XG5pbXBvcnQgY2xvbmVTeW1ib2wgZnJvbSAnLi9fY2xvbmVTeW1ib2wuanMnO1xuaW1wb3J0IGNsb25lVHlwZWRBcnJheSBmcm9tICcuL19jbG9uZVR5cGVkQXJyYXkuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTWFwYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBgU2V0YCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgaW5pdENsb25lQnlUYWc7XG4iLCJpbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VDcmVhdGU7XG4iLCJpbXBvcnQgYmFzZUNyZWF0ZSBmcm9tICcuL19iYXNlQ3JlYXRlLmpzJztcbmltcG9ydCBnZXRQcm90b3R5cGUgZnJvbSAnLi9fZ2V0UHJvdG90eXBlLmpzJztcbmltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaW5pdENsb25lT2JqZWN0O1xuIiwiaW1wb3J0IGdldFRhZyBmcm9tICcuL19nZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWFwKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gbWFwVGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNNYXA7XG4iLCJpbXBvcnQgYmFzZUlzTWFwIGZyb20gJy4vX2Jhc2VJc01hcC5qcyc7XG5pbXBvcnQgYmFzZVVuYXJ5IGZyb20gJy4vX2Jhc2VVbmFyeS5qcyc7XG5pbXBvcnQgbm9kZVV0aWwgZnJvbSAnLi9fbm9kZVV0aWwuanMnO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc01hcCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzTWFwO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTWFwYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc01hcChuZXcgTWFwKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTWFwKG5ldyBXZWFrTWFwKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc01hcCA9IG5vZGVJc01hcCA/IGJhc2VVbmFyeShub2RlSXNNYXApIDogYmFzZUlzTWFwO1xuXG5leHBvcnQgZGVmYXVsdCBpc01hcDtcbiIsImltcG9ydCBnZXRUYWcgZnJvbSAnLi9fZ2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNTZXRgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1NldCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHNldFRhZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzU2V0O1xuIiwiaW1wb3J0IGJhc2VJc1NldCBmcm9tICcuL19iYXNlSXNTZXQuanMnO1xuaW1wb3J0IGJhc2VVbmFyeSBmcm9tICcuL19iYXNlVW5hcnkuanMnO1xuaW1wb3J0IG5vZGVVdGlsIGZyb20gJy4vX25vZGVVdGlsLmpzJztcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNTZXQgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1NldDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFNldGAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTZXQobmV3IFNldCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1NldChuZXcgV2Vha1NldCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNTZXQgPSBub2RlSXNTZXQgPyBiYXNlVW5hcnkobm9kZUlzU2V0KSA6IGJhc2VJc1NldDtcblxuZXhwb3J0IGRlZmF1bHQgaXNTZXQ7XG4iLCJpbXBvcnQgU3RhY2sgZnJvbSAnLi9fU3RhY2suanMnO1xuaW1wb3J0IGFycmF5RWFjaCBmcm9tICcuL19hcnJheUVhY2guanMnO1xuaW1wb3J0IGFzc2lnblZhbHVlIGZyb20gJy4vX2Fzc2lnblZhbHVlLmpzJztcbmltcG9ydCBiYXNlQXNzaWduIGZyb20gJy4vX2Jhc2VBc3NpZ24uanMnO1xuaW1wb3J0IGJhc2VBc3NpZ25JbiBmcm9tICcuL19iYXNlQXNzaWduSW4uanMnO1xuaW1wb3J0IGNsb25lQnVmZmVyIGZyb20gJy4vX2Nsb25lQnVmZmVyLmpzJztcbmltcG9ydCBjb3B5QXJyYXkgZnJvbSAnLi9fY29weUFycmF5LmpzJztcbmltcG9ydCBjb3B5U3ltYm9scyBmcm9tICcuL19jb3B5U3ltYm9scy5qcyc7XG5pbXBvcnQgY29weVN5bWJvbHNJbiBmcm9tICcuL19jb3B5U3ltYm9sc0luLmpzJztcbmltcG9ydCBnZXRBbGxLZXlzIGZyb20gJy4vX2dldEFsbEtleXMuanMnO1xuaW1wb3J0IGdldEFsbEtleXNJbiBmcm9tICcuL19nZXRBbGxLZXlzSW4uanMnO1xuaW1wb3J0IGdldFRhZyBmcm9tICcuL19nZXRUYWcuanMnO1xuaW1wb3J0IGluaXRDbG9uZUFycmF5IGZyb20gJy4vX2luaXRDbG9uZUFycmF5LmpzJztcbmltcG9ydCBpbml0Q2xvbmVCeVRhZyBmcm9tICcuL19pbml0Q2xvbmVCeVRhZy5qcyc7XG5pbXBvcnQgaW5pdENsb25lT2JqZWN0IGZyb20gJy4vX2luaXRDbG9uZU9iamVjdC5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gJy4vaXNCdWZmZXIuanMnO1xuaW1wb3J0IGlzTWFwIGZyb20gJy4vaXNNYXAuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IGlzU2V0IGZyb20gJy4vaXNTZXQuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcbmltcG9ydCBrZXlzSW4gZnJvbSAnLi9rZXlzSW4uanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG52YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbmNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbmNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gRGVlcCBjbG9uZVxuICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gKiAgNCAtIENsb25lIHN5bWJvbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgIHJlc3VsdC5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcbiAgICA6IChpc0ZsYXQgPyBrZXlzSW4gOiBrZXlzKTtcblxuICB2YXIgcHJvcHMgPSBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcbiAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUNsb25lO1xuIiwiaW1wb3J0IGJhc2VDbG9uZSBmcm9tICcuL19iYXNlQ2xvbmUuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYHZhbHVlYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cHM6Ly9tZG4uaW8vU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0pXG4gKiBhbmQgc3VwcG9ydHMgY2xvbmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLCBkYXRlIG9iamVjdHMsIG1hcHMsXG4gKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWRcbiAqIGFycmF5cy4gVGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhcmUgY2xvbmVkXG4gKiBhcyBwbGFpbiBvYmplY3RzLiBBbiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoXG4gKiBhcyBlcnJvciBvYmplY3RzLCBmdW5jdGlvbnMsIERPTSBub2RlcywgYW5kIFdlYWtNYXBzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKiBAc2VlIF8uY2xvbmVEZWVwXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICpcbiAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShvYmplY3RzKTtcbiAqIGNvbnNvbGUubG9nKHNoYWxsb3dbMF0gPT09IG9iamVjdHNbMF0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbG9uZTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5TWFwO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1N5bWJvbDtcbiIsImltcG9ydCBNYXBDYWNoZSBmcm9tICcuL19NYXBDYWNoZS5qcyc7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuZXhwb3J0IGRlZmF1bHQgbWVtb2l6ZTtcbiIsImltcG9ydCBtZW1vaXplIGZyb20gJy4vbWVtb2l6ZS5qcyc7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWVtb2l6ZUNhcHBlZDtcbiIsImltcG9ydCBtZW1vaXplQ2FwcGVkIGZyb20gJy4vX21lbW9pemVDYXBwZWQuanMnO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ1RvUGF0aDtcbiIsImltcG9ydCBpc1N5bWJvbCBmcm9tICcuL2lzU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvS2V5O1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VUb1N0cmluZztcbiIsImltcG9ydCBiYXNlVG9TdHJpbmcgZnJvbSAnLi9fYmFzZVRvU3RyaW5nLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b1N0cmluZztcbiIsImltcG9ydCBhcnJheU1hcCBmcm9tICcuL19hcnJheU1hcC5qcyc7XG5pbXBvcnQgY29weUFycmF5IGZyb20gJy4vX2NvcHlBcnJheS5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzU3ltYm9sIGZyb20gJy4vaXNTeW1ib2wuanMnO1xuaW1wb3J0IHN0cmluZ1RvUGF0aCBmcm9tICcuL19zdHJpbmdUb1BhdGguanMnO1xuaW1wb3J0IHRvS2V5IGZyb20gJy4vX3RvS2V5LmpzJztcbmltcG9ydCB0b1N0cmluZyBmcm9tICcuL3RvU3RyaW5nLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9QYXRoKCdhLmIuYycpO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gKlxuICogXy50b1BhdGgoJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiBbJ2EnLCAnMCcsICdiJywgJ2MnXVxuICovXG5mdW5jdGlvbiB0b1BhdGgodmFsdWUpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCB0b0tleSk7XG4gIH1cbiAgcmV0dXJuIGlzU3ltYm9sKHZhbHVlKSA/IFt2YWx1ZV0gOiBjb3B5QXJyYXkoc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b1BhdGg7XG4iLCJpbXBvcnQgYmFzZUNsb25lIGZyb20gJy4vX2Jhc2VDbG9uZS5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAqIEBzZWUgXy5jbG9uZVxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAqXG4gKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKG9iamVjdHMpO1xuICogY29uc29sZS5sb2coZGVlcFswXSA9PT0gb2JqZWN0c1swXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVEZWVwO1xuIiwiaW1wb3J0IGRlZXBtZXJnZSBmcm9tICdkZWVwbWVyZ2UnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QnO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgQ2hpbGRyZW4sIHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZU1lbW8sIHVzZUltcGVyYXRpdmVIYW5kbGUsIGNyZWF0ZUVsZW1lbnQsIHVzZUxheW91dEVmZmVjdCwgZm9yd2FyZFJlZiwgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGlzRXF1YWwgZnJvbSAncmVhY3QtZmFzdC1jb21wYXJlJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAndGlueS13YXJuaW5nJztcbmltcG9ydCBjbG9uZSBmcm9tICdsb2Rhc2gtZXMvY2xvbmUnO1xuaW1wb3J0IHRvUGF0aCBmcm9tICdsb2Rhc2gtZXMvdG9QYXRoJztcbmltcG9ydCBob2lzdE5vblJlYWN0U3RhdGljcyBmcm9tICdob2lzdC1ub24tcmVhY3Qtc3RhdGljcyc7XG5pbXBvcnQgY2xvbmVEZWVwIGZyb20gJ2xvZGFzaC1lcy9jbG9uZURlZXAnO1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG52YXIgRm9ybWlrQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG5Gb3JtaWtDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0Zvcm1pa0NvbnRleHQnO1xudmFyIEZvcm1pa1Byb3ZpZGVyID0gRm9ybWlrQ29udGV4dC5Qcm92aWRlcjtcbnZhciBGb3JtaWtDb25zdW1lciA9IEZvcm1pa0NvbnRleHQuQ29uc3VtZXI7XG5mdW5jdGlvbiB1c2VGb3JtaWtDb250ZXh0KCkge1xuICB2YXIgZm9ybWlrID0gdXNlQ29udGV4dChGb3JtaWtDb250ZXh0KTtcbiAgISEhZm9ybWlrID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIkZvcm1payBjb250ZXh0IGlzIHVuZGVmaW5lZCwgcGxlYXNlIHZlcmlmeSB5b3UgYXJlIGNhbGxpbmcgdXNlRm9ybWlrQ29udGV4dCgpIGFzIGNoaWxkIG9mIGEgPEZvcm1paz4gY29tcG9uZW50LlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBmb3JtaWs7XG59XG5cbi8qKiBAcHJpdmF0ZSBpcyB0aGUgdmFsdWUgYW4gZW1wdHkgYXJyYXk/ICovXG5cbnZhciBpc0VtcHR5QXJyYXkgPSBmdW5jdGlvbiBpc0VtcHR5QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMDtcbn07XG4vKiogQHByaXZhdGUgaXMgdGhlIGdpdmVuIG9iamVjdCBhIEZ1bmN0aW9uPyAqL1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nO1xufTtcbi8qKiBAcHJpdmF0ZSBpcyB0aGUgZ2l2ZW4gb2JqZWN0IGFuIE9iamVjdD8gKi9cblxudmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCc7XG59O1xuLyoqIEBwcml2YXRlIGlzIHRoZSBnaXZlbiBvYmplY3QgYW4gaW50ZWdlcj8gKi9cblxudmFyIGlzSW50ZWdlciA9IGZ1bmN0aW9uIGlzSW50ZWdlcihvYmopIHtcbiAgcmV0dXJuIFN0cmluZyhNYXRoLmZsb29yKE51bWJlcihvYmopKSkgPT09IG9iajtcbn07XG4vKiogQHByaXZhdGUgaXMgdGhlIGdpdmVuIG9iamVjdCBhIHN0cmluZz8gKi9cblxudmFyIGlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59O1xuLyoqIEBwcml2YXRlIGlzIHRoZSBnaXZlbiBvYmplY3QgYSBOYU4/ICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG5cbnZhciBpc05hTiQxID0gZnVuY3Rpb24gaXNOYU4ob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG9iajtcbn07XG4vKiogQHByaXZhdGUgRG9lcyBhIFJlYWN0IGNvbXBvbmVudCBoYXZlIGV4YWN0bHkgMCBjaGlsZHJlbj8gKi9cblxudmFyIGlzRW1wdHlDaGlsZHJlbiA9IGZ1bmN0aW9uIGlzRW1wdHlDaGlsZHJlbihjaGlsZHJlbikge1xuICByZXR1cm4gQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pID09PSAwO1xufTtcbi8qKiBAcHJpdmF0ZSBpcyB0aGUgZ2l2ZW4gb2JqZWN0L3ZhbHVlIGEgcHJvbWlzZT8gKi9cblxudmFyIGlzUHJvbWlzZSA9IGZ1bmN0aW9uIGlzUHJvbWlzZSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGlzRnVuY3Rpb24odmFsdWUudGhlbik7XG59O1xuLyoqIEBwcml2YXRlIGlzIHRoZSBnaXZlbiBvYmplY3QvdmFsdWUgYSB0eXBlIG9mIHN5bnRoZXRpYyBldmVudD8gKi9cblxudmFyIGlzSW5wdXRFdmVudCA9IGZ1bmN0aW9uIGlzSW5wdXRFdmVudCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgaXNPYmplY3QodmFsdWUpICYmIGlzT2JqZWN0KHZhbHVlLnRhcmdldCk7XG59O1xuLyoqXHJcbiAqIFNhbWUgYXMgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBidXQgd3JhcHMgaW4gYSB0cnktY2F0Y2ggYmxvY2suIEluIElFIGl0IGlzXHJcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXHJcbiAqXHJcbiAqIFRoZSBhY3RpdmVFbGVtZW50IHdpbGwgYmUgbnVsbCBvbmx5IGlmIHRoZSBkb2N1bWVudCBvciBkb2N1bWVudCBib2R5IGlzIG5vdFxyXG4gKiB5ZXQgZGVmaW5lZC5cclxuICpcclxuICogQHBhcmFtIHs/RG9jdW1lbnR9IGRvYyBEZWZhdWx0cyB0byBjdXJyZW50IGRvY3VtZW50LlxyXG4gKiBAcmV0dXJuIHtFbGVtZW50IHwgbnVsbH1cclxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL21hc3Rlci9wYWNrYWdlcy9mYmpzL3NyYy9jb3JlL2RvbS9nZXRBY3RpdmVFbGVtZW50LmpzXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KGRvYykge1xuICBkb2MgPSBkb2MgfHwgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IHVuZGVmaW5lZCk7XG5cbiAgaWYgKHR5cGVvZiBkb2MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBkb2MuYWN0aXZlRWxlbWVudCB8fCBkb2MuYm9keTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBkb2MuYm9keTtcbiAgfVxufVxuLyoqXHJcbiAqIERlZXBseSBnZXQgYSB2YWx1ZSBmcm9tIGFuIG9iamVjdCB2aWEgaXRzIHBhdGguXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRJbihvYmosIGtleSwgZGVmLCBwKSB7XG4gIGlmIChwID09PSB2b2lkIDApIHtcbiAgICBwID0gMDtcbiAgfVxuXG4gIHZhciBwYXRoID0gdG9QYXRoKGtleSk7XG5cbiAgd2hpbGUgKG9iaiAmJiBwIDwgcGF0aC5sZW5ndGgpIHtcbiAgICBvYmogPSBvYmpbcGF0aFtwKytdXTtcbiAgfSAvLyBjaGVjayBpZiBwYXRoIGlzIG5vdCBpbiB0aGUgZW5kXG5cblxuICBpZiAocCAhPT0gcGF0aC5sZW5ndGggJiYgIW9iaikge1xuICAgIHJldHVybiBkZWY7XG4gIH1cblxuICByZXR1cm4gb2JqID09PSB1bmRlZmluZWQgPyBkZWYgOiBvYmo7XG59XG4vKipcclxuICogRGVlcGx5IHNldCBhIHZhbHVlIGZyb20gaW4gb2JqZWN0IHZpYSBpdCdzIHBhdGguIElmIHRoZSB2YWx1ZSBhdCBgcGF0aGBcclxuICogaGFzIGNoYW5nZWQsIHJldHVybiBhIHNoYWxsb3cgY29weSBvZiBvYmogd2l0aCBgdmFsdWVgIHNldCBhdCBgcGF0aGAuXHJcbiAqIElmIGB2YWx1ZWAgaGFzIG5vdCBjaGFuZ2VkLCByZXR1cm4gdGhlIG9yaWdpbmFsIGBvYmpgLlxyXG4gKlxyXG4gKiBFeGlzdGluZyBvYmplY3RzIC8gYXJyYXlzIGFsb25nIGBwYXRoYCBhcmUgYWxzbyBzaGFsbG93IGNvcGllZC4gU2libGluZ1xyXG4gKiBvYmplY3RzIGFsb25nIHBhdGggcmV0YWluIHRoZSBzYW1lIGludGVybmFsIGpzIHJlZmVyZW5jZS4gU2luY2UgbmV3XHJcbiAqIG9iamVjdHMgLyBhcnJheXMgYXJlIG9ubHkgY3JlYXRlZCBhbG9uZyBgcGF0aGAsIHdlIGNhbiB0ZXN0IGlmIGFueXRoaW5nXHJcbiAqIGNoYW5nZWQgaW4gYSBuZXN0ZWQgc3RydWN0dXJlIGJ5IGNvbXBhcmluZyB0aGUgb2JqZWN0J3MgcmVmZXJlbmNlIGluXHJcbiAqIHRoZSBvbGQgYW5kIG5ldyBvYmplY3QsIHNpbWlsYXIgdG8gaG93IHJ1c3NpYW4gZG9sbCBjYWNoZSBpbnZhbGlkYXRpb25cclxuICogd29ya3MuXHJcbiAqXHJcbiAqIEluIGVhcmxpZXIgdmVyc2lvbnMgb2YgdGhpcyBmdW5jdGlvbiwgd2hpY2ggdXNlZCBjbG9uZURlZXAsIHRoZXJlIHdlcmVcclxuICogaXNzdWVzIHdoZXJlYnkgc2V0dGluZ3MgYSBuZXN0ZWQgdmFsdWUgd291bGQgbXV0YXRlIHRoZSBwYXJlbnRcclxuICogaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBvYmplY3QuIGBjbG9uZWAgYXZvaWRzIHRoYXQgYnVnIG1ha2luZyBhXHJcbiAqIHNoYWxsb3cgY29weSBvZiB0aGUgb2JqZWN0cyBhbG9uZyB0aGUgdXBkYXRlIHBhdGhcclxuICogc28gbm8gb2JqZWN0IGlzIG11dGF0ZWQgaW4gcGxhY2UuXHJcbiAqXHJcbiAqIEJlZm9yZSBjaGFuZ2luZyB0aGlzIGZ1bmN0aW9uLCBwbGVhc2UgcmVhZCB0aHJvdWdoIHRoZSBmb2xsb3dpbmdcclxuICogZGlzY3Vzc2lvbnMuXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2RldmVsb3BpdC9saW5rc3RhdGVcclxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vamFyZWRwYWxtZXIvZm9ybWlrL3B1bGwvMTIzXHJcbiAqL1xuXG5mdW5jdGlvbiBzZXRJbihvYmosIHBhdGgsIHZhbHVlKSB7XG4gIHZhciByZXMgPSBjbG9uZShvYmopOyAvLyB0aGlzIGtlZXBzIGluaGVyaXRhbmNlIHdoZW4gb2JqIGlzIGEgY2xhc3NcblxuICB2YXIgcmVzVmFsID0gcmVzO1xuICB2YXIgaSA9IDA7XG4gIHZhciBwYXRoQXJyYXkgPSB0b1BhdGgocGF0aCk7XG5cbiAgZm9yICg7IGkgPCBwYXRoQXJyYXkubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgdmFyIGN1cnJlbnRQYXRoID0gcGF0aEFycmF5W2ldO1xuICAgIHZhciBjdXJyZW50T2JqID0gZ2V0SW4ob2JqLCBwYXRoQXJyYXkuc2xpY2UoMCwgaSArIDEpKTtcblxuICAgIGlmIChjdXJyZW50T2JqICYmIChpc09iamVjdChjdXJyZW50T2JqKSB8fCBBcnJheS5pc0FycmF5KGN1cnJlbnRPYmopKSkge1xuICAgICAgcmVzVmFsID0gcmVzVmFsW2N1cnJlbnRQYXRoXSA9IGNsb25lKGN1cnJlbnRPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmV4dFBhdGggPSBwYXRoQXJyYXlbaSArIDFdO1xuICAgICAgcmVzVmFsID0gcmVzVmFsW2N1cnJlbnRQYXRoXSA9IGlzSW50ZWdlcihuZXh0UGF0aCkgJiYgTnVtYmVyKG5leHRQYXRoKSA+PSAwID8gW10gOiB7fTtcbiAgICB9XG4gIH0gLy8gUmV0dXJuIG9yaWdpbmFsIG9iamVjdCBpZiBuZXcgdmFsdWUgaXMgdGhlIHNhbWUgYXMgY3VycmVudFxuXG5cbiAgaWYgKChpID09PSAwID8gb2JqIDogcmVzVmFsKVtwYXRoQXJyYXlbaV1dID09PSB2YWx1ZSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIGRlbGV0ZSByZXNWYWxbcGF0aEFycmF5W2ldXTtcbiAgfSBlbHNlIHtcbiAgICByZXNWYWxbcGF0aEFycmF5W2ldXSA9IHZhbHVlO1xuICB9IC8vIElmIHRoZSBwYXRoIGFycmF5IGhhcyBhIHNpbmdsZSBlbGVtZW50LCB0aGUgbG9vcCBkaWQgbm90IHJ1bi5cbiAgLy8gRGVsZXRpbmcgb24gYHJlc1ZhbGAgaGFkIG5vIGVmZmVjdCBpbiB0aGlzIHNjZW5hcmlvLCBzbyB3ZSBkZWxldGUgb24gdGhlIHJlc3VsdCBpbnN0ZWFkLlxuXG5cbiAgaWYgKGkgPT09IDAgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIGRlbGV0ZSByZXNbcGF0aEFycmF5W2ldXTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG4vKipcclxuICogUmVjdXJzaXZlbHkgYSBzZXQgdGhlIHNhbWUgdmFsdWUgZm9yIGFsbCBrZXlzIGFuZCBhcnJheXMgbmVzdGVkIG9iamVjdCwgY2xvbmluZ1xyXG4gKiBAcGFyYW0gb2JqZWN0XHJcbiAqIEBwYXJhbSB2YWx1ZVxyXG4gKiBAcGFyYW0gdmlzaXRlZFxyXG4gKiBAcGFyYW0gcmVzcG9uc2VcclxuICovXG5cbmZ1bmN0aW9uIHNldE5lc3RlZE9iamVjdFZhbHVlcyhvYmplY3QsIHZhbHVlLCB2aXNpdGVkLCByZXNwb25zZSkge1xuICBpZiAodmlzaXRlZCA9PT0gdm9pZCAwKSB7XG4gICAgdmlzaXRlZCA9IG5ldyBXZWFrTWFwKCk7XG4gIH1cblxuICBpZiAocmVzcG9uc2UgPT09IHZvaWQgMCkge1xuICAgIHJlc3BvbnNlID0ge307XG4gIH1cblxuICBmb3IgKHZhciBfaSA9IDAsIF9PYmplY3Qka2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IF9pIDwgX09iamVjdCRrZXlzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBrID0gX09iamVjdCRrZXlzW19pXTtcbiAgICB2YXIgdmFsID0gb2JqZWN0W2tdO1xuXG4gICAgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgIGlmICghdmlzaXRlZC5nZXQodmFsKSkge1xuICAgICAgICB2aXNpdGVkLnNldCh2YWwsIHRydWUpOyAvLyBJbiBvcmRlciB0byBrZWVwIGFycmF5IHZhbHVlcyBjb25zaXN0ZW50IGZvciBib3RoIGRvdCBwYXRoICBhbmRcbiAgICAgICAgLy8gYnJhY2tldCBzeW50YXgsIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhpcyBpcyBhbiBhcnJheSBzbyB0aGF0XG4gICAgICAgIC8vIHRoaXMgd2lsbCBvdXRwdXQgIHsgZnJpZW5kczogW3RydWVdIH0gYW5kIG5vdCB7IGZyaWVuZHM6IHsgXCIwXCI6IHRydWUgfSB9XG5cbiAgICAgICAgcmVzcG9uc2Vba10gPSBBcnJheS5pc0FycmF5KHZhbCkgPyBbXSA6IHt9O1xuICAgICAgICBzZXROZXN0ZWRPYmplY3RWYWx1ZXModmFsLCB2YWx1ZSwgdmlzaXRlZCwgcmVzcG9uc2Vba10pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXNwb25zZVtrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXNwb25zZTtcbn1cblxuZnVuY3Rpb24gZm9ybWlrUmVkdWNlcihzdGF0ZSwgbXNnKSB7XG4gIHN3aXRjaCAobXNnLnR5cGUpIHtcbiAgICBjYXNlICdTRVRfVkFMVUVTJzpcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgdmFsdWVzOiBtc2cucGF5bG9hZFxuICAgICAgfSk7XG5cbiAgICBjYXNlICdTRVRfVE9VQ0hFRCc6XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHRvdWNoZWQ6IG1zZy5wYXlsb2FkXG4gICAgICB9KTtcblxuICAgIGNhc2UgJ1NFVF9FUlJPUlMnOlxuICAgICAgaWYgKGlzRXF1YWwoc3RhdGUuZXJyb3JzLCBtc2cucGF5bG9hZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGVycm9yczogbXNnLnBheWxvYWRcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnU0VUX1NUQVRVUyc6XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHN0YXR1czogbXNnLnBheWxvYWRcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnU0VUX0lTU1VCTUlUVElORyc6XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGlzU3VibWl0dGluZzogbXNnLnBheWxvYWRcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnU0VUX0lTVkFMSURBVElORyc6XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGlzVmFsaWRhdGluZzogbXNnLnBheWxvYWRcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnU0VUX0ZJRUxEX1ZBTFVFJzpcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgdmFsdWVzOiBzZXRJbihzdGF0ZS52YWx1ZXMsIG1zZy5wYXlsb2FkLmZpZWxkLCBtc2cucGF5bG9hZC52YWx1ZSlcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnU0VUX0ZJRUxEX1RPVUNIRUQnOlxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICB0b3VjaGVkOiBzZXRJbihzdGF0ZS50b3VjaGVkLCBtc2cucGF5bG9hZC5maWVsZCwgbXNnLnBheWxvYWQudmFsdWUpXG4gICAgICB9KTtcblxuICAgIGNhc2UgJ1NFVF9GSUVMRF9FUlJPUic6XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGVycm9yczogc2V0SW4oc3RhdGUuZXJyb3JzLCBtc2cucGF5bG9hZC5maWVsZCwgbXNnLnBheWxvYWQudmFsdWUpXG4gICAgICB9KTtcblxuICAgIGNhc2UgJ1JFU0VUX0ZPUk0nOlxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwgbXNnLnBheWxvYWQpO1xuXG4gICAgY2FzZSAnU0VUX0ZPUk1JS19TVEFURSc6XG4gICAgICByZXR1cm4gbXNnLnBheWxvYWQoc3RhdGUpO1xuXG4gICAgY2FzZSAnU1VCTUlUX0FUVEVNUFQnOlxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICB0b3VjaGVkOiBzZXROZXN0ZWRPYmplY3RWYWx1ZXMoc3RhdGUudmFsdWVzLCB0cnVlKSxcbiAgICAgICAgaXNTdWJtaXR0aW5nOiB0cnVlLFxuICAgICAgICBzdWJtaXRDb3VudDogc3RhdGUuc3VibWl0Q291bnQgKyAxXG4gICAgICB9KTtcblxuICAgIGNhc2UgJ1NVQk1JVF9GQUlMVVJFJzpcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgaXNTdWJtaXR0aW5nOiBmYWxzZVxuICAgICAgfSk7XG5cbiAgICBjYXNlICdTVUJNSVRfU1VDQ0VTUyc6XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGlzU3VibWl0dGluZzogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufSAvLyBJbml0aWFsIGVtcHR5IHN0YXRlcyAvLyBvYmplY3RzXG5cblxudmFyIGVtcHR5RXJyb3JzID0ge307XG52YXIgZW1wdHlUb3VjaGVkID0ge307XG5mdW5jdGlvbiB1c2VGb3JtaWsoX3JlZikge1xuICB2YXIgX3JlZiR2YWxpZGF0ZU9uQ2hhbmdlID0gX3JlZi52YWxpZGF0ZU9uQ2hhbmdlLFxuICAgICAgdmFsaWRhdGVPbkNoYW5nZSA9IF9yZWYkdmFsaWRhdGVPbkNoYW5nZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYkdmFsaWRhdGVPbkNoYW5nZSxcbiAgICAgIF9yZWYkdmFsaWRhdGVPbkJsdXIgPSBfcmVmLnZhbGlkYXRlT25CbHVyLFxuICAgICAgdmFsaWRhdGVPbkJsdXIgPSBfcmVmJHZhbGlkYXRlT25CbHVyID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiR2YWxpZGF0ZU9uQmx1cixcbiAgICAgIF9yZWYkdmFsaWRhdGVPbk1vdW50ID0gX3JlZi52YWxpZGF0ZU9uTW91bnQsXG4gICAgICB2YWxpZGF0ZU9uTW91bnQgPSBfcmVmJHZhbGlkYXRlT25Nb3VudCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJHZhbGlkYXRlT25Nb3VudCxcbiAgICAgIGlzSW5pdGlhbFZhbGlkID0gX3JlZi5pc0luaXRpYWxWYWxpZCxcbiAgICAgIF9yZWYkZW5hYmxlUmVpbml0aWFsaSA9IF9yZWYuZW5hYmxlUmVpbml0aWFsaXplLFxuICAgICAgZW5hYmxlUmVpbml0aWFsaXplID0gX3JlZiRlbmFibGVSZWluaXRpYWxpID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkZW5hYmxlUmVpbml0aWFsaSxcbiAgICAgIG9uU3VibWl0ID0gX3JlZi5vblN1Ym1pdCxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBbXCJ2YWxpZGF0ZU9uQ2hhbmdlXCIsIFwidmFsaWRhdGVPbkJsdXJcIiwgXCJ2YWxpZGF0ZU9uTW91bnRcIiwgXCJpc0luaXRpYWxWYWxpZFwiLCBcImVuYWJsZVJlaW5pdGlhbGl6ZVwiLCBcIm9uU3VibWl0XCJdKTtcblxuICB2YXIgcHJvcHMgPSBfZXh0ZW5kcyh7XG4gICAgdmFsaWRhdGVPbkNoYW5nZTogdmFsaWRhdGVPbkNoYW5nZSxcbiAgICB2YWxpZGF0ZU9uQmx1cjogdmFsaWRhdGVPbkJsdXIsXG4gICAgdmFsaWRhdGVPbk1vdW50OiB2YWxpZGF0ZU9uTW91bnQsXG4gICAgb25TdWJtaXQ6IG9uU3VibWl0XG4gIH0sIHJlc3QpO1xuXG4gIHZhciBpbml0aWFsVmFsdWVzID0gdXNlUmVmKHByb3BzLmluaXRpYWxWYWx1ZXMpO1xuICB2YXIgaW5pdGlhbEVycm9ycyA9IHVzZVJlZihwcm9wcy5pbml0aWFsRXJyb3JzIHx8IGVtcHR5RXJyb3JzKTtcbiAgdmFyIGluaXRpYWxUb3VjaGVkID0gdXNlUmVmKHByb3BzLmluaXRpYWxUb3VjaGVkIHx8IGVtcHR5VG91Y2hlZCk7XG4gIHZhciBpbml0aWFsU3RhdHVzID0gdXNlUmVmKHByb3BzLmluaXRpYWxTdGF0dXMpO1xuICB2YXIgaXNNb3VudGVkID0gdXNlUmVmKGZhbHNlKTtcbiAgdmFyIGZpZWxkUmVnaXN0cnkgPSB1c2VSZWYoe30pO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgISh0eXBlb2YgaXNJbml0aWFsVmFsaWQgPT09ICd1bmRlZmluZWQnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ2lzSW5pdGlhbFZhbGlkIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgRm9ybWlrLiBQbGVhc2UgdXNlIGluaXRpYWxFcnJvcnMgb3IgdmFsaWRhdGVPbk1vdW50IGluc3RlYWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICB9LCBbXSk7XG4gIH1cblxuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IHVzZVN0YXRlKDApLFxuICAgICAgc2V0SXRlcmF0aW9uID0gX1JlYWN0JHVzZVN0YXRlWzFdO1xuXG4gIHZhciBzdGF0ZVJlZiA9IHVzZVJlZih7XG4gICAgdmFsdWVzOiBwcm9wcy5pbml0aWFsVmFsdWVzLFxuICAgIGVycm9yczogcHJvcHMuaW5pdGlhbEVycm9ycyB8fCBlbXB0eUVycm9ycyxcbiAgICB0b3VjaGVkOiBwcm9wcy5pbml0aWFsVG91Y2hlZCB8fCBlbXB0eVRvdWNoZWQsXG4gICAgc3RhdHVzOiBwcm9wcy5pbml0aWFsU3RhdHVzLFxuICAgIGlzU3VibWl0dGluZzogZmFsc2UsXG4gICAgaXNWYWxpZGF0aW5nOiBmYWxzZSxcbiAgICBzdWJtaXRDb3VudDogMFxuICB9KTtcbiAgdmFyIHN0YXRlID0gc3RhdGVSZWYuY3VycmVudDtcbiAgdmFyIGRpc3BhdGNoID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGFjdGlvbikge1xuICAgIHZhciBwcmV2ID0gc3RhdGVSZWYuY3VycmVudDtcbiAgICBzdGF0ZVJlZi5jdXJyZW50ID0gZm9ybWlrUmVkdWNlcihwcmV2LCBhY3Rpb24pOyAvLyBmb3JjZSByZXJlbmRlclxuXG4gICAgaWYgKHByZXYgIT09IHN0YXRlUmVmLmN1cnJlbnQpIHNldEl0ZXJhdGlvbihmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHggKyAxO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIHZhciBydW5WYWxpZGF0ZUhhbmRsZXIgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsdWVzLCBmaWVsZCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgbWF5YmVQcm9taXNlZEVycm9ycyA9IHByb3BzLnZhbGlkYXRlKHZhbHVlcywgZmllbGQpO1xuXG4gICAgICBpZiAobWF5YmVQcm9taXNlZEVycm9ycyA9PSBudWxsKSB7XG4gICAgICAgIC8vIHVzZSBsb29zZSBudWxsIGNoZWNrIGhlcmUgb24gcHVycG9zZVxuICAgICAgICByZXNvbHZlKGVtcHR5RXJyb3JzKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNQcm9taXNlKG1heWJlUHJvbWlzZWRFcnJvcnMpKSB7XG4gICAgICAgIG1heWJlUHJvbWlzZWRFcnJvcnMudGhlbihmdW5jdGlvbiAoZXJyb3JzKSB7XG4gICAgICAgICAgcmVzb2x2ZShlcnJvcnMgfHwgZW1wdHlFcnJvcnMpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoYWN0dWFsRXhjZXB0aW9uKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIldhcm5pbmc6IEFuIHVuaGFuZGxlZCBlcnJvciB3YXMgY2F1Z2h0IGR1cmluZyB2YWxpZGF0aW9uIGluIDxGb3JtaWsgdmFsaWRhdGUgLz5cIiwgYWN0dWFsRXhjZXB0aW9uKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZWplY3QoYWN0dWFsRXhjZXB0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKG1heWJlUHJvbWlzZWRFcnJvcnMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbcHJvcHMudmFsaWRhdGVdKTtcbiAgLyoqXHJcbiAgICogUnVuIHZhbGlkYXRpb24gYWdhaW5zdCBhIFl1cCBzY2hlbWEgYW5kIG9wdGlvbmFsbHkgcnVuIGEgZnVuY3Rpb24gaWYgc3VjY2Vzc2Z1bFxyXG4gICAqL1xuXG4gIHZhciBydW5WYWxpZGF0aW9uU2NoZW1hID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHZhbHVlcywgZmllbGQpIHtcbiAgICB2YXIgdmFsaWRhdGlvblNjaGVtYSA9IHByb3BzLnZhbGlkYXRpb25TY2hlbWE7XG4gICAgdmFyIHNjaGVtYSA9IGlzRnVuY3Rpb24odmFsaWRhdGlvblNjaGVtYSkgPyB2YWxpZGF0aW9uU2NoZW1hKGZpZWxkKSA6IHZhbGlkYXRpb25TY2hlbWE7XG4gICAgdmFyIHByb21pc2UgPSBmaWVsZCAmJiBzY2hlbWEudmFsaWRhdGVBdCA/IHNjaGVtYS52YWxpZGF0ZUF0KGZpZWxkLCB2YWx1ZXMpIDogdmFsaWRhdGVZdXBTY2hlbWEodmFsdWVzLCBzY2hlbWEpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXNvbHZlKGVtcHR5RXJyb3JzKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgLy8gWXVwIHdpbGwgdGhyb3cgYSB2YWxpZGF0aW9uIGVycm9yIGlmIHZhbGlkYXRpb24gZmFpbHMuIFdlIGNhdGNoIHRob3NlIGFuZFxuICAgICAgICAvLyByZXNvbHZlIHRoZW0gaW50byBGb3JtaWsgZXJyb3JzLiBXZSBjYW4gc25pZmYgaWYgc29tZXRoaW5nIGlzIGEgWXVwIGVycm9yXG4gICAgICAgIC8vIGJ5IGNoZWNraW5nIGVycm9yLm5hbWUuXG4gICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVuc2UveXVwI3ZhbGlkYXRpb25lcnJvcmVycm9ycy1zdHJpbmctLWFycmF5c3RyaW5nLXZhbHVlLWFueS1wYXRoLXN0cmluZ1xuICAgICAgICBpZiAoZXJyLm5hbWUgPT09ICdWYWxpZGF0aW9uRXJyb3InKSB7XG4gICAgICAgICAgcmVzb2x2ZSh5dXBUb0Zvcm1FcnJvcnMoZXJyKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gV2UgdGhyb3cgYW55IG90aGVyIGVycm9yc1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBBbiB1bmhhbmRsZWQgZXJyb3Igd2FzIGNhdWdodCBkdXJpbmcgdmFsaWRhdGlvbiBpbiA8Rm9ybWlrIHZhbGlkYXRpb25TY2hlbWEgLz5cIiwgZXJyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIFtwcm9wcy52YWxpZGF0aW9uU2NoZW1hXSk7XG4gIHZhciBydW5TaW5nbGVGaWVsZExldmVsVmFsaWRhdGlvbiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIHJldHVybiByZXNvbHZlKGZpZWxkUmVnaXN0cnkuY3VycmVudFtmaWVsZF0udmFsaWRhdGUodmFsdWUpKTtcbiAgICB9KTtcbiAgfSwgW10pO1xuICB2YXIgcnVuRmllbGRMZXZlbFZhbGlkYXRpb25zID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHZhbHVlcykge1xuICAgIHZhciBmaWVsZEtleXNXaXRoVmFsaWRhdGlvbiA9IE9iamVjdC5rZXlzKGZpZWxkUmVnaXN0cnkuY3VycmVudCkuZmlsdGVyKGZ1bmN0aW9uIChmKSB7XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihmaWVsZFJlZ2lzdHJ5LmN1cnJlbnRbZl0udmFsaWRhdGUpO1xuICAgIH0pOyAvLyBDb25zdHJ1Y3QgYW4gYXJyYXkgd2l0aCBhbGwgb2YgdGhlIGZpZWxkIHZhbGlkYXRpb24gZnVuY3Rpb25zXG5cbiAgICB2YXIgZmllbGRWYWxpZGF0aW9ucyA9IGZpZWxkS2V5c1dpdGhWYWxpZGF0aW9uLmxlbmd0aCA+IDAgPyBmaWVsZEtleXNXaXRoVmFsaWRhdGlvbi5tYXAoZnVuY3Rpb24gKGYpIHtcbiAgICAgIHJldHVybiBydW5TaW5nbGVGaWVsZExldmVsVmFsaWRhdGlvbihmLCBnZXRJbih2YWx1ZXMsIGYpKTtcbiAgICB9KSA6IFtQcm9taXNlLnJlc29sdmUoJ0RPX05PVF9ERUxFVEVfWU9VX1dJTExfQkVfRklSRUQnKV07IC8vIHVzZSBzcGVjaWFsIGNhc2UgOylcblxuICAgIHJldHVybiBQcm9taXNlLmFsbChmaWVsZFZhbGlkYXRpb25zKS50aGVuKGZ1bmN0aW9uIChmaWVsZEVycm9yc0xpc3QpIHtcbiAgICAgIHJldHVybiBmaWVsZEVycm9yc0xpc3QucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyLCBpbmRleCkge1xuICAgICAgICBpZiAoY3VyciA9PT0gJ0RPX05PVF9ERUxFVEVfWU9VX1dJTExfQkVfRklSRUQnKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3Vycikge1xuICAgICAgICAgIHByZXYgPSBzZXRJbihwcmV2LCBmaWVsZEtleXNXaXRoVmFsaWRhdGlvbltpbmRleF0sIGN1cnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICB9LCB7fSk7XG4gICAgfSk7XG4gIH0sIFtydW5TaW5nbGVGaWVsZExldmVsVmFsaWRhdGlvbl0pOyAvLyBSdW4gYWxsIHZhbGlkYXRpb25zIGFuZCByZXR1cm4gdGhlIHJlc3VsdFxuXG4gIHZhciBydW5BbGxWYWxpZGF0aW9ucyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3J1bkZpZWxkTGV2ZWxWYWxpZGF0aW9ucyh2YWx1ZXMpLCBwcm9wcy52YWxpZGF0aW9uU2NoZW1hID8gcnVuVmFsaWRhdGlvblNjaGVtYSh2YWx1ZXMpIDoge30sIHByb3BzLnZhbGlkYXRlID8gcnVuVmFsaWRhdGVIYW5kbGVyKHZhbHVlcykgOiB7fV0pLnRoZW4oZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICB2YXIgZmllbGRFcnJvcnMgPSBfcmVmMlswXSxcbiAgICAgICAgICBzY2hlbWFFcnJvcnMgPSBfcmVmMlsxXSxcbiAgICAgICAgICB2YWxpZGF0ZUVycm9ycyA9IF9yZWYyWzJdO1xuICAgICAgdmFyIGNvbWJpbmVkRXJyb3JzID0gZGVlcG1lcmdlLmFsbChbZmllbGRFcnJvcnMsIHNjaGVtYUVycm9ycywgdmFsaWRhdGVFcnJvcnNdLCB7XG4gICAgICAgIGFycmF5TWVyZ2U6IGFycmF5TWVyZ2VcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbWJpbmVkRXJyb3JzO1xuICAgIH0pO1xuICB9LCBbcHJvcHMudmFsaWRhdGUsIHByb3BzLnZhbGlkYXRpb25TY2hlbWEsIHJ1bkZpZWxkTGV2ZWxWYWxpZGF0aW9ucywgcnVuVmFsaWRhdGVIYW5kbGVyLCBydW5WYWxpZGF0aW9uU2NoZW1hXSk7IC8vIFJ1biBhbGwgdmFsaWRhdGlvbnMgbWV0aG9kcyBhbmQgdXBkYXRlIHN0YXRlIGFjY29yZGluZ2x5XG5cbiAgdmFyIHZhbGlkYXRlRm9ybVdpdGhIaWdoUHJpb3JpdHkgPSB1c2VFdmVudENhbGxiYWNrKGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICBpZiAodmFsdWVzID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlcyA9IHN0YXRlLnZhbHVlcztcbiAgICB9XG5cbiAgICBkaXNwYXRjaCh7XG4gICAgICB0eXBlOiAnU0VUX0lTVkFMSURBVElORycsXG4gICAgICBwYXlsb2FkOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHJ1bkFsbFZhbGlkYXRpb25zKHZhbHVlcykudGhlbihmdW5jdGlvbiAoY29tYmluZWRFcnJvcnMpIHtcbiAgICAgIGlmICghIWlzTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiAnU0VUX0lTVkFMSURBVElORycsXG4gICAgICAgICAgcGF5bG9hZDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiAnU0VUX0VSUk9SUycsXG4gICAgICAgICAgcGF5bG9hZDogY29tYmluZWRFcnJvcnNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb21iaW5lZEVycm9ycztcbiAgICB9KTtcbiAgfSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHZhbGlkYXRlT25Nb3VudCAmJiBpc01vdW50ZWQuY3VycmVudCA9PT0gdHJ1ZSAmJiBpc0VxdWFsKGluaXRpYWxWYWx1ZXMuY3VycmVudCwgcHJvcHMuaW5pdGlhbFZhbHVlcykpIHtcbiAgICAgIHZhbGlkYXRlRm9ybVdpdGhIaWdoUHJpb3JpdHkoaW5pdGlhbFZhbHVlcy5jdXJyZW50KTtcbiAgICB9XG4gIH0sIFt2YWxpZGF0ZU9uTW91bnQsIHZhbGlkYXRlRm9ybVdpdGhIaWdoUHJpb3JpdHldKTtcbiAgdmFyIHJlc2V0Rm9ybSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChuZXh0U3RhdGUpIHtcbiAgICB2YXIgdmFsdWVzID0gbmV4dFN0YXRlICYmIG5leHRTdGF0ZS52YWx1ZXMgPyBuZXh0U3RhdGUudmFsdWVzIDogaW5pdGlhbFZhbHVlcy5jdXJyZW50O1xuICAgIHZhciBlcnJvcnMgPSBuZXh0U3RhdGUgJiYgbmV4dFN0YXRlLmVycm9ycyA/IG5leHRTdGF0ZS5lcnJvcnMgOiBpbml0aWFsRXJyb3JzLmN1cnJlbnQgPyBpbml0aWFsRXJyb3JzLmN1cnJlbnQgOiBwcm9wcy5pbml0aWFsRXJyb3JzIHx8IHt9O1xuICAgIHZhciB0b3VjaGVkID0gbmV4dFN0YXRlICYmIG5leHRTdGF0ZS50b3VjaGVkID8gbmV4dFN0YXRlLnRvdWNoZWQgOiBpbml0aWFsVG91Y2hlZC5jdXJyZW50ID8gaW5pdGlhbFRvdWNoZWQuY3VycmVudCA6IHByb3BzLmluaXRpYWxUb3VjaGVkIHx8IHt9O1xuICAgIHZhciBzdGF0dXMgPSBuZXh0U3RhdGUgJiYgbmV4dFN0YXRlLnN0YXR1cyA/IG5leHRTdGF0ZS5zdGF0dXMgOiBpbml0aWFsU3RhdHVzLmN1cnJlbnQgPyBpbml0aWFsU3RhdHVzLmN1cnJlbnQgOiBwcm9wcy5pbml0aWFsU3RhdHVzO1xuICAgIGluaXRpYWxWYWx1ZXMuY3VycmVudCA9IHZhbHVlcztcbiAgICBpbml0aWFsRXJyb3JzLmN1cnJlbnQgPSBlcnJvcnM7XG4gICAgaW5pdGlhbFRvdWNoZWQuY3VycmVudCA9IHRvdWNoZWQ7XG4gICAgaW5pdGlhbFN0YXR1cy5jdXJyZW50ID0gc3RhdHVzO1xuXG4gICAgdmFyIGRpc3BhdGNoRm4gPSBmdW5jdGlvbiBkaXNwYXRjaEZuKCkge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiAnUkVTRVRfRk9STScsXG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICBpc1N1Ym1pdHRpbmc6ICEhbmV4dFN0YXRlICYmICEhbmV4dFN0YXRlLmlzU3VibWl0dGluZyxcbiAgICAgICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgICAgICB0b3VjaGVkOiB0b3VjaGVkLFxuICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICAgIGlzVmFsaWRhdGluZzogISFuZXh0U3RhdGUgJiYgISFuZXh0U3RhdGUuaXNWYWxpZGF0aW5nLFxuICAgICAgICAgIHN1Ym1pdENvdW50OiAhIW5leHRTdGF0ZSAmJiAhIW5leHRTdGF0ZS5zdWJtaXRDb3VudCAmJiB0eXBlb2YgbmV4dFN0YXRlLnN1Ym1pdENvdW50ID09PSAnbnVtYmVyJyA/IG5leHRTdGF0ZS5zdWJtaXRDb3VudCA6IDBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmIChwcm9wcy5vblJlc2V0KSB7XG4gICAgICB2YXIgbWF5YmVQcm9taXNlZE9uUmVzZXQgPSBwcm9wcy5vblJlc2V0KHN0YXRlLnZhbHVlcywgaW1wZXJhdGl2ZU1ldGhvZHMpO1xuXG4gICAgICBpZiAoaXNQcm9taXNlKG1heWJlUHJvbWlzZWRPblJlc2V0KSkge1xuICAgICAgICBtYXliZVByb21pc2VkT25SZXNldC50aGVuKGRpc3BhdGNoRm4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlzcGF0Y2hGbigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkaXNwYXRjaEZuKCk7XG4gICAgfVxuICB9LCBbcHJvcHMuaW5pdGlhbEVycm9ycywgcHJvcHMuaW5pdGlhbFN0YXR1cywgcHJvcHMuaW5pdGlhbFRvdWNoZWQsIHByb3BzLm9uUmVzZXRdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaXNNb3VudGVkLmN1cnJlbnQgPT09IHRydWUgJiYgIWlzRXF1YWwoaW5pdGlhbFZhbHVlcy5jdXJyZW50LCBwcm9wcy5pbml0aWFsVmFsdWVzKSkge1xuICAgICAgaWYgKGVuYWJsZVJlaW5pdGlhbGl6ZSkge1xuICAgICAgICBpbml0aWFsVmFsdWVzLmN1cnJlbnQgPSBwcm9wcy5pbml0aWFsVmFsdWVzO1xuICAgICAgICByZXNldEZvcm0oKTtcblxuICAgICAgICBpZiAodmFsaWRhdGVPbk1vdW50KSB7XG4gICAgICAgICAgdmFsaWRhdGVGb3JtV2l0aEhpZ2hQcmlvcml0eShpbml0aWFsVmFsdWVzLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCBbZW5hYmxlUmVpbml0aWFsaXplLCBwcm9wcy5pbml0aWFsVmFsdWVzLCByZXNldEZvcm0sIHZhbGlkYXRlT25Nb3VudCwgdmFsaWRhdGVGb3JtV2l0aEhpZ2hQcmlvcml0eV0pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmFibGVSZWluaXRpYWxpemUgJiYgaXNNb3VudGVkLmN1cnJlbnQgPT09IHRydWUgJiYgIWlzRXF1YWwoaW5pdGlhbEVycm9ycy5jdXJyZW50LCBwcm9wcy5pbml0aWFsRXJyb3JzKSkge1xuICAgICAgaW5pdGlhbEVycm9ycy5jdXJyZW50ID0gcHJvcHMuaW5pdGlhbEVycm9ycyB8fCBlbXB0eUVycm9ycztcbiAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogJ1NFVF9FUlJPUlMnLFxuICAgICAgICBwYXlsb2FkOiBwcm9wcy5pbml0aWFsRXJyb3JzIHx8IGVtcHR5RXJyb3JzXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtlbmFibGVSZWluaXRpYWxpemUsIHByb3BzLmluaXRpYWxFcnJvcnNdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZW5hYmxlUmVpbml0aWFsaXplICYmIGlzTW91bnRlZC5jdXJyZW50ID09PSB0cnVlICYmICFpc0VxdWFsKGluaXRpYWxUb3VjaGVkLmN1cnJlbnQsIHByb3BzLmluaXRpYWxUb3VjaGVkKSkge1xuICAgICAgaW5pdGlhbFRvdWNoZWQuY3VycmVudCA9IHByb3BzLmluaXRpYWxUb3VjaGVkIHx8IGVtcHR5VG91Y2hlZDtcbiAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogJ1NFVF9UT1VDSEVEJyxcbiAgICAgICAgcGF5bG9hZDogcHJvcHMuaW5pdGlhbFRvdWNoZWQgfHwgZW1wdHlUb3VjaGVkXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtlbmFibGVSZWluaXRpYWxpemUsIHByb3BzLmluaXRpYWxUb3VjaGVkXSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuYWJsZVJlaW5pdGlhbGl6ZSAmJiBpc01vdW50ZWQuY3VycmVudCA9PT0gdHJ1ZSAmJiAhaXNFcXVhbChpbml0aWFsU3RhdHVzLmN1cnJlbnQsIHByb3BzLmluaXRpYWxTdGF0dXMpKSB7XG4gICAgICBpbml0aWFsU3RhdHVzLmN1cnJlbnQgPSBwcm9wcy5pbml0aWFsU3RhdHVzO1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiAnU0VUX1NUQVRVUycsXG4gICAgICAgIHBheWxvYWQ6IHByb3BzLmluaXRpYWxTdGF0dXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2VuYWJsZVJlaW5pdGlhbGl6ZSwgcHJvcHMuaW5pdGlhbFN0YXR1cywgcHJvcHMuaW5pdGlhbFRvdWNoZWRdKTtcbiAgdmFyIHZhbGlkYXRlRmllbGQgPSB1c2VFdmVudENhbGxiYWNrKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgLy8gVGhpcyB3aWxsIGVmZmljaWVudGx5IHZhbGlkYXRlIGEgc2luZ2xlIGZpZWxkIGJ5IGF2b2lkaW5nIHN0YXRlXG4gICAgLy8gY2hhbmdlcyBpZiB0aGUgdmFsaWRhdGlvbiBmdW5jdGlvbiBpcyBzeW5jaHJvbm91cy4gSXQncyBkaWZmZXJlbnQgZnJvbVxuICAgIC8vIHdoYXQgaXMgY2FsbGVkIHdoZW4gdXNpbmcgdmFsaWRhdGVGb3JtLlxuICAgIGlmIChmaWVsZFJlZ2lzdHJ5LmN1cnJlbnRbbmFtZV0gJiYgaXNGdW5jdGlvbihmaWVsZFJlZ2lzdHJ5LmN1cnJlbnRbbmFtZV0udmFsaWRhdGUpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXRJbihzdGF0ZS52YWx1ZXMsIG5hbWUpO1xuICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZpZWxkUmVnaXN0cnkuY3VycmVudFtuYW1lXS52YWxpZGF0ZSh2YWx1ZSk7XG5cbiAgICAgIGlmIChpc1Byb21pc2UobWF5YmVQcm9taXNlKSkge1xuICAgICAgICAvLyBPbmx5IGZsaXAgaXNWYWxpZGF0aW5nIGlmIHRoZSBmdW5jdGlvbiBpcyBhc3luYy5cbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6ICdTRVRfSVNWQUxJREFUSU5HJyxcbiAgICAgICAgICBwYXlsb2FkOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWF5YmVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnU0VUX0ZJRUxEX0VSUk9SJyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgZmllbGQ6IG5hbWUsXG4gICAgICAgICAgICAgIHZhbHVlOiBlcnJvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdTRVRfSVNWQUxJREFUSU5HJyxcbiAgICAgICAgICAgIHBheWxvYWQ6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6ICdTRVRfRklFTERfRVJST1InLFxuICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgIGZpZWxkOiBuYW1lLFxuICAgICAgICAgICAgdmFsdWU6IG1heWJlUHJvbWlzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWF5YmVQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BzLnZhbGlkYXRpb25TY2hlbWEpIHtcbiAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogJ1NFVF9JU1ZBTElEQVRJTkcnLFxuICAgICAgICBwYXlsb2FkOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBydW5WYWxpZGF0aW9uU2NoZW1hKHN0YXRlLnZhbHVlcywgbmFtZSkudGhlbihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geDtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiAnU0VUX0ZJRUxEX0VSUk9SJyxcbiAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICBmaWVsZDogbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiBnZXRJbihlcnJvciwgbmFtZSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogJ1NFVF9JU1ZBTElEQVRJTkcnLFxuICAgICAgICAgIHBheWxvYWQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9KTtcbiAgdmFyIHJlZ2lzdGVyRmllbGQgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAobmFtZSwgX3JlZjMpIHtcbiAgICB2YXIgdmFsaWRhdGUgPSBfcmVmMy52YWxpZGF0ZTtcbiAgICBmaWVsZFJlZ2lzdHJ5LmN1cnJlbnRbbmFtZV0gPSB7XG4gICAgICB2YWxpZGF0ZTogdmFsaWRhdGVcbiAgICB9O1xuICB9LCBbXSk7XG4gIHZhciB1bnJlZ2lzdGVyRmllbGQgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAobmFtZSkge1xuICAgIGRlbGV0ZSBmaWVsZFJlZ2lzdHJ5LmN1cnJlbnRbbmFtZV07XG4gIH0sIFtdKTtcbiAgdmFyIHNldFRvdWNoZWQgPSB1c2VFdmVudENhbGxiYWNrKGZ1bmN0aW9uICh0b3VjaGVkLCBzaG91bGRWYWxpZGF0ZSkge1xuICAgIGRpc3BhdGNoKHtcbiAgICAgIHR5cGU6ICdTRVRfVE9VQ0hFRCcsXG4gICAgICBwYXlsb2FkOiB0b3VjaGVkXG4gICAgfSk7XG4gICAgdmFyIHdpbGxWYWxpZGF0ZSA9IHNob3VsZFZhbGlkYXRlID09PSB1bmRlZmluZWQgPyB2YWxpZGF0ZU9uQmx1ciA6IHNob3VsZFZhbGlkYXRlO1xuICAgIHJldHVybiB3aWxsVmFsaWRhdGUgPyB2YWxpZGF0ZUZvcm1XaXRoSGlnaFByaW9yaXR5KHN0YXRlLnZhbHVlcykgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfSk7XG4gIHZhciBzZXRFcnJvcnMgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoZXJyb3JzKSB7XG4gICAgZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ1NFVF9FUlJPUlMnLFxuICAgICAgcGF5bG9hZDogZXJyb3JzXG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgdmFyIHNldFZhbHVlcyA9IHVzZUV2ZW50Q2FsbGJhY2soZnVuY3Rpb24gKHZhbHVlcywgc2hvdWxkVmFsaWRhdGUpIHtcbiAgICB2YXIgcmVzb2x2ZWRWYWx1ZXMgPSBpc0Z1bmN0aW9uKHZhbHVlcykgPyB2YWx1ZXMoc3RhdGUudmFsdWVzKSA6IHZhbHVlcztcbiAgICBkaXNwYXRjaCh7XG4gICAgICB0eXBlOiAnU0VUX1ZBTFVFUycsXG4gICAgICBwYXlsb2FkOiByZXNvbHZlZFZhbHVlc1xuICAgIH0pO1xuICAgIHZhciB3aWxsVmFsaWRhdGUgPSBzaG91bGRWYWxpZGF0ZSA9PT0gdW5kZWZpbmVkID8gdmFsaWRhdGVPbkNoYW5nZSA6IHNob3VsZFZhbGlkYXRlO1xuICAgIHJldHVybiB3aWxsVmFsaWRhdGUgPyB2YWxpZGF0ZUZvcm1XaXRoSGlnaFByaW9yaXR5KHJlc29sdmVkVmFsdWVzKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICB9KTtcbiAgdmFyIHNldEZpZWxkRXJyb3IgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoZmllbGQsIHZhbHVlKSB7XG4gICAgZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ1NFVF9GSUVMRF9FUlJPUicsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgdmFyIHNldEZpZWxkVmFsdWUgPSB1c2VFdmVudENhbGxiYWNrKGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUsIHNob3VsZFZhbGlkYXRlKSB7XG4gICAgZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ1NFVF9GSUVMRF9WQUxVRScsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIHdpbGxWYWxpZGF0ZSA9IHNob3VsZFZhbGlkYXRlID09PSB1bmRlZmluZWQgPyB2YWxpZGF0ZU9uQ2hhbmdlIDogc2hvdWxkVmFsaWRhdGU7XG4gICAgcmV0dXJuIHdpbGxWYWxpZGF0ZSA/IHZhbGlkYXRlRm9ybVdpdGhIaWdoUHJpb3JpdHkoc2V0SW4oc3RhdGUudmFsdWVzLCBmaWVsZCwgdmFsdWUpKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICB9KTtcbiAgdmFyIGV4ZWN1dGVDaGFuZ2UgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnRPclRleHRWYWx1ZSwgbWF5YmVQYXRoKSB7XG4gICAgLy8gQnkgZGVmYXVsdCwgYXNzdW1lIHRoYXQgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nLiBUaGlzIGFsbG93cyB1cyB0byB1c2VcbiAgICAvLyBoYW5kbGVDaGFuZ2Ugd2l0aCBSZWFjdCBOYXRpdmUgYW5kIFJlYWN0IE5hdGl2ZSBXZWIncyBvbkNoYW5nZVRleHQgcHJvcCB3aGljaFxuICAgIC8vIHByb3ZpZGVzIGp1c3QgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dC5cbiAgICB2YXIgZmllbGQgPSBtYXliZVBhdGg7XG4gICAgdmFyIHZhbCA9IGV2ZW50T3JUZXh0VmFsdWU7XG4gICAgdmFyIHBhcnNlZDsgLy8gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIG5vdCBhIHN0cmluZyB0aG91Z2gsIGl0IGhhcyB0byBiZSBhIHN5bnRoZXRpYyBSZWFjdCBFdmVudCAob3IgYSBmYWtlIG9uZSksXG4gICAgLy8gc28gd2UgaGFuZGxlIGxpa2Ugd2Ugd291bGQgYSBub3JtYWwgSFRNTCBjaGFuZ2UgZXZlbnQuXG5cbiAgICBpZiAoIWlzU3RyaW5nKGV2ZW50T3JUZXh0VmFsdWUpKSB7XG4gICAgICAvLyBJZiB3ZSBjYW4sIHBlcnNpc3QgdGhlIGV2ZW50XG4gICAgICAvLyBAc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9ldmVudHMuaHRtbCNldmVudC1wb29saW5nXG4gICAgICBpZiAoZXZlbnRPclRleHRWYWx1ZS5wZXJzaXN0KSB7XG4gICAgICAgIGV2ZW50T3JUZXh0VmFsdWUucGVyc2lzdCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFyZ2V0ID0gZXZlbnRPclRleHRWYWx1ZS50YXJnZXQgPyBldmVudE9yVGV4dFZhbHVlLnRhcmdldCA6IGV2ZW50T3JUZXh0VmFsdWUuY3VycmVudFRhcmdldDtcbiAgICAgIHZhciB0eXBlID0gdGFyZ2V0LnR5cGUsXG4gICAgICAgICAgbmFtZSA9IHRhcmdldC5uYW1lLFxuICAgICAgICAgIGlkID0gdGFyZ2V0LmlkLFxuICAgICAgICAgIHZhbHVlID0gdGFyZ2V0LnZhbHVlLFxuICAgICAgICAgIGNoZWNrZWQgPSB0YXJnZXQuY2hlY2tlZCxcbiAgICAgICAgICBvdXRlckhUTUwgPSB0YXJnZXQub3V0ZXJIVE1MLFxuICAgICAgICAgIG9wdGlvbnMgPSB0YXJnZXQub3B0aW9ucyxcbiAgICAgICAgICBtdWx0aXBsZSA9IHRhcmdldC5tdWx0aXBsZTtcbiAgICAgIGZpZWxkID0gbWF5YmVQYXRoID8gbWF5YmVQYXRoIDogbmFtZSA/IG5hbWUgOiBpZDtcblxuICAgICAgaWYgKCFmaWVsZCAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgd2FybkFib3V0TWlzc2luZ0lkZW50aWZpZXIoe1xuICAgICAgICAgIGh0bWxDb250ZW50OiBvdXRlckhUTUwsXG4gICAgICAgICAgZG9jdW1lbnRhdGlvbkFuY2hvckxpbms6ICdoYW5kbGVjaGFuZ2UtZS1yZWFjdGNoYW5nZWV2ZW50YW55LS12b2lkJyxcbiAgICAgICAgICBoYW5kbGVyTmFtZTogJ2hhbmRsZUNoYW5nZSdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhbCA9IC9udW1iZXJ8cmFuZ2UvLnRlc3QodHlwZSkgPyAocGFyc2VkID0gcGFyc2VGbG9hdCh2YWx1ZSksIGlzTmFOKHBhcnNlZCkgPyAnJyA6IHBhcnNlZCkgOiAvY2hlY2tib3gvLnRlc3QodHlwZSkgLy8gY2hlY2tib3hlc1xuICAgICAgPyBnZXRWYWx1ZUZvckNoZWNrYm94KGdldEluKHN0YXRlLnZhbHVlcywgZmllbGQpLCBjaGVja2VkLCB2YWx1ZSkgOiBvcHRpb25zICYmIG11bHRpcGxlIC8vIDxzZWxlY3QgbXVsdGlwbGU+XG4gICAgICA/IGdldFNlbGVjdGVkVmFsdWVzKG9wdGlvbnMpIDogdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGZpZWxkKSB7XG4gICAgICAvLyBTZXQgZm9ybSBmaWVsZHMgYnkgbmFtZVxuICAgICAgc2V0RmllbGRWYWx1ZShmaWVsZCwgdmFsKTtcbiAgICB9XG4gIH0sIFtzZXRGaWVsZFZhbHVlLCBzdGF0ZS52YWx1ZXNdKTtcbiAgdmFyIGhhbmRsZUNoYW5nZSA9IHVzZUV2ZW50Q2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50T3JQYXRoKSB7XG4gICAgaWYgKGlzU3RyaW5nKGV2ZW50T3JQYXRoKSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gZXhlY3V0ZUNoYW5nZShldmVudCwgZXZlbnRPclBhdGgpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhlY3V0ZUNoYW5nZShldmVudE9yUGF0aCk7XG4gICAgfVxuICB9KTtcbiAgdmFyIHNldEZpZWxkVG91Y2hlZCA9IHVzZUV2ZW50Q2FsbGJhY2soZnVuY3Rpb24gKGZpZWxkLCB0b3VjaGVkLCBzaG91bGRWYWxpZGF0ZSkge1xuICAgIGlmICh0b3VjaGVkID09PSB2b2lkIDApIHtcbiAgICAgIHRvdWNoZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGRpc3BhdGNoKHtcbiAgICAgIHR5cGU6ICdTRVRfRklFTERfVE9VQ0hFRCcsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgdmFsdWU6IHRvdWNoZWRcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgd2lsbFZhbGlkYXRlID0gc2hvdWxkVmFsaWRhdGUgPT09IHVuZGVmaW5lZCA/IHZhbGlkYXRlT25CbHVyIDogc2hvdWxkVmFsaWRhdGU7XG4gICAgcmV0dXJuIHdpbGxWYWxpZGF0ZSA/IHZhbGlkYXRlRm9ybVdpdGhIaWdoUHJpb3JpdHkoc3RhdGUudmFsdWVzKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICB9KTtcbiAgdmFyIGV4ZWN1dGVCbHVyID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGUsIHBhdGgpIHtcbiAgICBpZiAoZS5wZXJzaXN0KSB7XG4gICAgICBlLnBlcnNpc3QoKTtcbiAgICB9XG5cbiAgICB2YXIgX2UkdGFyZ2V0ID0gZS50YXJnZXQsXG4gICAgICAgIG5hbWUgPSBfZSR0YXJnZXQubmFtZSxcbiAgICAgICAgaWQgPSBfZSR0YXJnZXQuaWQsXG4gICAgICAgIG91dGVySFRNTCA9IF9lJHRhcmdldC5vdXRlckhUTUw7XG4gICAgdmFyIGZpZWxkID0gcGF0aCA/IHBhdGggOiBuYW1lID8gbmFtZSA6IGlkO1xuXG4gICAgaWYgKCFmaWVsZCAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHdhcm5BYm91dE1pc3NpbmdJZGVudGlmaWVyKHtcbiAgICAgICAgaHRtbENvbnRlbnQ6IG91dGVySFRNTCxcbiAgICAgICAgZG9jdW1lbnRhdGlvbkFuY2hvckxpbms6ICdoYW5kbGVibHVyLWUtYW55LS12b2lkJyxcbiAgICAgICAgaGFuZGxlck5hbWU6ICdoYW5kbGVCbHVyJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2V0RmllbGRUb3VjaGVkKGZpZWxkLCB0cnVlKTtcbiAgfSwgW3NldEZpZWxkVG91Y2hlZF0pO1xuICB2YXIgaGFuZGxlQmx1ciA9IHVzZUV2ZW50Q2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50T3JTdHJpbmcpIHtcbiAgICBpZiAoaXNTdHJpbmcoZXZlbnRPclN0cmluZykpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGVCbHVyKGV2ZW50LCBldmVudE9yU3RyaW5nKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4ZWN1dGVCbHVyKGV2ZW50T3JTdHJpbmcpO1xuICAgIH1cbiAgfSk7XG4gIHZhciBzZXRGb3JtaWtTdGF0ZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChzdGF0ZU9yQ2IpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihzdGF0ZU9yQ2IpKSB7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6ICdTRVRfRk9STUlLX1NUQVRFJyxcbiAgICAgICAgcGF5bG9hZDogc3RhdGVPckNiXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiAnU0VUX0ZPUk1JS19TVEFURScsXG4gICAgICAgIHBheWxvYWQ6IGZ1bmN0aW9uIHBheWxvYWQoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlT3JDYjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbXSk7XG4gIHZhciBzZXRTdGF0dXMgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoc3RhdHVzKSB7XG4gICAgZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ1NFVF9TVEFUVVMnLFxuICAgICAgcGF5bG9hZDogc3RhdHVzXG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgdmFyIHNldFN1Ym1pdHRpbmcgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoaXNTdWJtaXR0aW5nKSB7XG4gICAgZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ1NFVF9JU1NVQk1JVFRJTkcnLFxuICAgICAgcGF5bG9hZDogaXNTdWJtaXR0aW5nXG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgdmFyIHN1Ym1pdEZvcm0gPSB1c2VFdmVudENhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBkaXNwYXRjaCh7XG4gICAgICB0eXBlOiAnU1VCTUlUX0FUVEVNUFQnXG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbGlkYXRlRm9ybVdpdGhIaWdoUHJpb3JpdHkoKS50aGVuKGZ1bmN0aW9uIChjb21iaW5lZEVycm9ycykge1xuICAgICAgLy8gSW4gY2FzZSBhbiBlcnJvciB3YXMgdGhyb3duIGFuZCBwYXNzZWQgdG8gdGhlIHJlc29sdmVkIFByb21pc2UsXG4gICAgICAvLyBgY29tYmluZWRFcnJvcnNgIGNhbiBiZSBhbiBpbnN0YW5jZSBvZiBhbiBFcnJvci4gV2UgbmVlZCB0byBjaGVja1xuICAgICAgLy8gdGhhdCBhbmQgYWJvcnQgdGhlIHN1Ym1pdC5cbiAgICAgIC8vIElmIHdlIGRvbid0IGRvIHRoYXQsIGNhbGxpbmcgYE9iamVjdC5rZXlzKG5ldyBFcnJvcigpKWAgeWllbGRzIGFuXG4gICAgICAvLyBlbXB0eSBhcnJheSwgd2hpY2ggY2F1c2VzIHRoZSB2YWxpZGF0aW9uIHRvIHBhc3MgYW5kIHRoZSBmb3JtXG4gICAgICAvLyB0byBiZSBzdWJtaXR0ZWQuXG4gICAgICB2YXIgaXNJbnN0YW5jZU9mRXJyb3IgPSBjb21iaW5lZEVycm9ycyBpbnN0YW5jZW9mIEVycm9yO1xuICAgICAgdmFyIGlzQWN0dWFsbHlWYWxpZCA9ICFpc0luc3RhbmNlT2ZFcnJvciAmJiBPYmplY3Qua2V5cyhjb21iaW5lZEVycm9ycykubGVuZ3RoID09PSAwO1xuXG4gICAgICBpZiAoaXNBY3R1YWxseVZhbGlkKSB7XG4gICAgICAgIC8vIFByb2NlZWQgd2l0aCBzdWJtaXQuLi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVG8gcmVzcGVjdCBzeW5jIHN1Ym1pdCBmbnMsIHdlIGNhbid0IHNpbXBseSB3cmFwIGV4ZWN1dGVTdWJtaXQgaW4gYSBwcm9taXNlIGFuZFxuICAgICAgICAvLyBfYWx3YXlzXyBkaXNwYXRjaCBTVUJNSVRfU1VDQ0VTUyBiZWNhdXNlIGlzU3VibWl0dGluZyB3b3VsZCB0aGVuIGFsd2F5cyBiZSBmYWxzZS5cbiAgICAgICAgLy8gVGhpcyB3b3VsZCBiZSBmaW5lIGluIHNpbXBsZSBjYXNlcywgYnV0IG1ha2UgaXQgaW1wb3NzaWJsZSB0byBkaXNhYmxlIHN1Ym1pdFxuICAgICAgICAvLyBidXR0b25zIHdoZXJlIHBlb3BsZSB1c2UgY2FsbGJhY2tzIG9yIHByb21pc2VzIGFzIHNpZGUgZWZmZWN0cyAod2hpY2ggaXMgYmFzaWNhbGx5XG4gICAgICAgIC8vIGFsbCBvZiB2MSBGb3JtaWsgY29kZSkuIEluc3RlYWQsIHJlY2FsbCB0aGF0IHdlIGFyZSBpbnNpZGUgb2YgYSBwcm9taXNlIGNoYWluIGFscmVhZHksXG4gICAgICAgIC8vICBzbyB3ZSBjYW4gdHJ5L2NhdGNoIGV4ZWN1dGVTdWJtaXQoKSwgaWYgaXQgcmV0dXJucyB1bmRlZmluZWQsIHRoZW4ganVzdCBiYWlsLlxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgZXJyb3JzLCB0aHJvdyBlbS4gT3RoZXJ3aXNlLCB3cmFwIGV4ZWN1dGVTdWJtaXQgaW4gYSBwcm9taXNlIGFuZCBoYW5kbGVcbiAgICAgICAgLy8gY2xlYW51cCBvZiBpc1N1Ym1pdHRpbmcgb24gYmVoYWxmIG9mIHRoZSBjb25zdW1lci5cbiAgICAgICAgdmFyIHByb21pc2VPclVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHByb21pc2VPclVuZGVmaW5lZCA9IGV4ZWN1dGVTdWJtaXQoKTsgLy8gQmFpbCBpZiBpdCdzIHN5bmMsIGNvbnN1bWVyIGlzIHJlc3BvbnNpYmxlIGZvciBjbGVhbmluZyB1cFxuICAgICAgICAgIC8vIHZpYSBzZXRTdWJtaXR0aW5nKGZhbHNlKVxuXG4gICAgICAgICAgaWYgKHByb21pc2VPclVuZGVmaW5lZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcm9taXNlT3JVbmRlZmluZWQpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIGlmICghIWlzTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICAgIHR5cGU6ICdTVUJNSVRfU1VDQ0VTUydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKF9lcnJvcnMpIHtcbiAgICAgICAgICBpZiAoISFpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgICB0eXBlOiAnU1VCTUlUX0ZBSUxVUkUnXG4gICAgICAgICAgICB9KTsgLy8gVGhpcyBpcyBhIGxlZ2l0IGVycm9yIHJlamVjdGVkIGJ5IHRoZSBvblN1Ym1pdCBmblxuICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3Qgd2FudCB0byBicmVhayB0aGUgcHJvbWlzZSBjaGFpblxuXG4gICAgICAgICAgICB0aHJvdyBfZXJyb3JzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKCEhaXNNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgICAgLy8gXl5eIE1ha2Ugc3VyZSBGb3JtaWsgaXMgc3RpbGwgbW91bnRlZCBiZWZvcmUgdXBkYXRpbmcgc3RhdGVcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6ICdTVUJNSVRfRkFJTFVSRSdcbiAgICAgICAgfSk7IC8vIHRocm93IGNvbWJpbmVkRXJyb3JzO1xuXG4gICAgICAgIGlmIChpc0luc3RhbmNlT2ZFcnJvcikge1xuICAgICAgICAgIHRocm93IGNvbWJpbmVkRXJyb3JzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9KTtcbiAgfSk7XG4gIHZhciBoYW5kbGVTdWJtaXQgPSB1c2VFdmVudENhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUgJiYgZS5wcmV2ZW50RGVmYXVsdCAmJiBpc0Z1bmN0aW9uKGUucHJldmVudERlZmF1bHQpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgaWYgKGUgJiYgZS5zdG9wUHJvcGFnYXRpb24gJiYgaXNGdW5jdGlvbihlLnN0b3BQcm9wYWdhdGlvbikpIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSAvLyBXYXJuIGlmIGZvcm0gc3VibWlzc2lvbiBpcyB0cmlnZ2VyZWQgYnkgYSA8YnV0dG9uPiB3aXRob3V0IGFcbiAgICAvLyBzcGVjaWZpZWQgYHR5cGVgIGF0dHJpYnV0ZSBkdXJpbmcgZGV2ZWxvcG1lbnQuIFRoaXMgbWl0aWdhdGVzXG4gICAgLy8gYSBjb21tb24gZ290Y2hhIGluIGZvcm1zIHdpdGggYm90aCByZXNldCBhbmQgc3VibWl0IGJ1dHRvbnMsXG4gICAgLy8gd2hlcmUgdGhlIGRldiBmb3JnZXRzIHRvIGFkZCB0eXBlPVwiYnV0dG9uXCIgdG8gdGhlIHJlc2V0IGJ1dHRvbi5cblxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBTYWZlbHkgZ2V0IHRoZSBhY3RpdmUgZWxlbWVudCAod29ya3Mgd2l0aCBJRSlcbiAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuXG4gICAgICBpZiAoYWN0aXZlRWxlbWVudCAhPT0gbnVsbCAmJiBhY3RpdmVFbGVtZW50IGluc3RhbmNlb2YgSFRNTEJ1dHRvbkVsZW1lbnQpIHtcbiAgICAgICAgIShhY3RpdmVFbGVtZW50LmF0dHJpYnV0ZXMgJiYgYWN0aXZlRWxlbWVudC5hdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgndHlwZScpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1lvdSBzdWJtaXR0ZWQgYSBGb3JtaWsgZm9ybSB1c2luZyBhIGJ1dHRvbiB3aXRoIGFuIHVuc3BlY2lmaWVkIGB0eXBlYCBhdHRyaWJ1dGUuICBNb3N0IGJyb3dzZXJzIGRlZmF1bHQgYnV0dG9uIGVsZW1lbnRzIHRvIGB0eXBlPVwic3VibWl0XCJgLiBJZiB0aGlzIGlzIG5vdCBhIHN1Ym1pdCBidXR0b24sIHBsZWFzZSBhZGQgYHR5cGU9XCJidXR0b25cImAuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN1Ym1pdEZvcm0oKVtcImNhdGNoXCJdKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGNvbnNvbGUud2FybihcIldhcm5pbmc6IEFuIHVuaGFuZGxlZCBlcnJvciB3YXMgY2F1Z2h0IGZyb20gc3VibWl0Rm9ybSgpXCIsIHJlYXNvbik7XG4gICAgfSk7XG4gIH0pO1xuICB2YXIgaW1wZXJhdGl2ZU1ldGhvZHMgPSB7XG4gICAgcmVzZXRGb3JtOiByZXNldEZvcm0sXG4gICAgdmFsaWRhdGVGb3JtOiB2YWxpZGF0ZUZvcm1XaXRoSGlnaFByaW9yaXR5LFxuICAgIHZhbGlkYXRlRmllbGQ6IHZhbGlkYXRlRmllbGQsXG4gICAgc2V0RXJyb3JzOiBzZXRFcnJvcnMsXG4gICAgc2V0RmllbGRFcnJvcjogc2V0RmllbGRFcnJvcixcbiAgICBzZXRGaWVsZFRvdWNoZWQ6IHNldEZpZWxkVG91Y2hlZCxcbiAgICBzZXRGaWVsZFZhbHVlOiBzZXRGaWVsZFZhbHVlLFxuICAgIHNldFN0YXR1czogc2V0U3RhdHVzLFxuICAgIHNldFN1Ym1pdHRpbmc6IHNldFN1Ym1pdHRpbmcsXG4gICAgc2V0VG91Y2hlZDogc2V0VG91Y2hlZCxcbiAgICBzZXRWYWx1ZXM6IHNldFZhbHVlcyxcbiAgICBzZXRGb3JtaWtTdGF0ZTogc2V0Rm9ybWlrU3RhdGUsXG4gICAgc3VibWl0Rm9ybTogc3VibWl0Rm9ybVxuICB9O1xuICB2YXIgZXhlY3V0ZVN1Ym1pdCA9IHVzZUV2ZW50Q2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBvblN1Ym1pdChzdGF0ZS52YWx1ZXMsIGltcGVyYXRpdmVNZXRob2RzKTtcbiAgfSk7XG4gIHZhciBoYW5kbGVSZXNldCA9IHVzZUV2ZW50Q2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZSAmJiBlLnByZXZlbnREZWZhdWx0ICYmIGlzRnVuY3Rpb24oZS5wcmV2ZW50RGVmYXVsdCkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBpZiAoZSAmJiBlLnN0b3BQcm9wYWdhdGlvbiAmJiBpc0Z1bmN0aW9uKGUuc3RvcFByb3BhZ2F0aW9uKSkge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICByZXNldEZvcm0oKTtcbiAgfSk7XG4gIHZhciBnZXRGaWVsZE1ldGEgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogZ2V0SW4oc3RhdGUudmFsdWVzLCBuYW1lKSxcbiAgICAgIGVycm9yOiBnZXRJbihzdGF0ZS5lcnJvcnMsIG5hbWUpLFxuICAgICAgdG91Y2hlZDogISFnZXRJbihzdGF0ZS50b3VjaGVkLCBuYW1lKSxcbiAgICAgIGluaXRpYWxWYWx1ZTogZ2V0SW4oaW5pdGlhbFZhbHVlcy5jdXJyZW50LCBuYW1lKSxcbiAgICAgIGluaXRpYWxUb3VjaGVkOiAhIWdldEluKGluaXRpYWxUb3VjaGVkLmN1cnJlbnQsIG5hbWUpLFxuICAgICAgaW5pdGlhbEVycm9yOiBnZXRJbihpbml0aWFsRXJyb3JzLmN1cnJlbnQsIG5hbWUpXG4gICAgfTtcbiAgfSwgW3N0YXRlLmVycm9ycywgc3RhdGUudG91Y2hlZCwgc3RhdGUudmFsdWVzXSk7XG4gIHZhciBnZXRGaWVsZEhlbHBlcnMgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRWYWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUodmFsdWUsIHNob3VsZFZhbGlkYXRlKSB7XG4gICAgICAgIHJldHVybiBzZXRGaWVsZFZhbHVlKG5hbWUsIHZhbHVlLCBzaG91bGRWYWxpZGF0ZSk7XG4gICAgICB9LFxuICAgICAgc2V0VG91Y2hlZDogZnVuY3Rpb24gc2V0VG91Y2hlZCh2YWx1ZSwgc2hvdWxkVmFsaWRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHNldEZpZWxkVG91Y2hlZChuYW1lLCB2YWx1ZSwgc2hvdWxkVmFsaWRhdGUpO1xuICAgICAgfSxcbiAgICAgIHNldEVycm9yOiBmdW5jdGlvbiBzZXRFcnJvcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gc2V0RmllbGRFcnJvcihuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW3NldEZpZWxkVmFsdWUsIHNldEZpZWxkVG91Y2hlZCwgc2V0RmllbGRFcnJvcl0pO1xuICB2YXIgZ2V0RmllbGRQcm9wcyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChuYW1lT3JPcHRpb25zKSB7XG4gICAgdmFyIGlzQW5PYmplY3QgPSBpc09iamVjdChuYW1lT3JPcHRpb25zKTtcbiAgICB2YXIgbmFtZSA9IGlzQW5PYmplY3QgPyBuYW1lT3JPcHRpb25zLm5hbWUgOiBuYW1lT3JPcHRpb25zO1xuICAgIHZhciB2YWx1ZVN0YXRlID0gZ2V0SW4oc3RhdGUudmFsdWVzLCBuYW1lKTtcbiAgICB2YXIgZmllbGQgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlU3RhdGUsXG4gICAgICBvbkNoYW5nZTogaGFuZGxlQ2hhbmdlLFxuICAgICAgb25CbHVyOiBoYW5kbGVCbHVyXG4gICAgfTtcblxuICAgIGlmIChpc0FuT2JqZWN0KSB7XG4gICAgICB2YXIgdHlwZSA9IG5hbWVPck9wdGlvbnMudHlwZSxcbiAgICAgICAgICB2YWx1ZVByb3AgPSBuYW1lT3JPcHRpb25zLnZhbHVlLFxuICAgICAgICAgIGlzID0gbmFtZU9yT3B0aW9ucy5hcyxcbiAgICAgICAgICBtdWx0aXBsZSA9IG5hbWVPck9wdGlvbnMubXVsdGlwbGU7XG5cbiAgICAgIGlmICh0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICAgIGlmICh2YWx1ZVByb3AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZpZWxkLmNoZWNrZWQgPSAhIXZhbHVlU3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmllbGQuY2hlY2tlZCA9ICEhKEFycmF5LmlzQXJyYXkodmFsdWVTdGF0ZSkgJiYgfnZhbHVlU3RhdGUuaW5kZXhPZih2YWx1ZVByb3ApKTtcbiAgICAgICAgICBmaWVsZC52YWx1ZSA9IHZhbHVlUHJvcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAncmFkaW8nKSB7XG4gICAgICAgIGZpZWxkLmNoZWNrZWQgPSB2YWx1ZVN0YXRlID09PSB2YWx1ZVByb3A7XG4gICAgICAgIGZpZWxkLnZhbHVlID0gdmFsdWVQcm9wO1xuICAgICAgfSBlbHNlIGlmIChpcyA9PT0gJ3NlbGVjdCcgJiYgbXVsdGlwbGUpIHtcbiAgICAgICAgZmllbGQudmFsdWUgPSBmaWVsZC52YWx1ZSB8fCBbXTtcbiAgICAgICAgZmllbGQubXVsdGlwbGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmaWVsZDtcbiAgfSwgW2hhbmRsZUJsdXIsIGhhbmRsZUNoYW5nZSwgc3RhdGUudmFsdWVzXSk7XG4gIHZhciBkaXJ0eSA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhaXNFcXVhbChpbml0aWFsVmFsdWVzLmN1cnJlbnQsIHN0YXRlLnZhbHVlcyk7XG4gIH0sIFtpbml0aWFsVmFsdWVzLmN1cnJlbnQsIHN0YXRlLnZhbHVlc10pO1xuICB2YXIgaXNWYWxpZCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0eXBlb2YgaXNJbml0aWFsVmFsaWQgIT09ICd1bmRlZmluZWQnID8gZGlydHkgPyBzdGF0ZS5lcnJvcnMgJiYgT2JqZWN0LmtleXMoc3RhdGUuZXJyb3JzKS5sZW5ndGggPT09IDAgOiBpc0luaXRpYWxWYWxpZCAhPT0gZmFsc2UgJiYgaXNGdW5jdGlvbihpc0luaXRpYWxWYWxpZCkgPyBpc0luaXRpYWxWYWxpZChwcm9wcykgOiBpc0luaXRpYWxWYWxpZCA6IHN0YXRlLmVycm9ycyAmJiBPYmplY3Qua2V5cyhzdGF0ZS5lcnJvcnMpLmxlbmd0aCA9PT0gMDtcbiAgfSwgW2lzSW5pdGlhbFZhbGlkLCBkaXJ0eSwgc3RhdGUuZXJyb3JzLCBwcm9wc10pO1xuXG4gIHZhciBjdHggPSBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICBpbml0aWFsVmFsdWVzOiBpbml0aWFsVmFsdWVzLmN1cnJlbnQsXG4gICAgaW5pdGlhbEVycm9yczogaW5pdGlhbEVycm9ycy5jdXJyZW50LFxuICAgIGluaXRpYWxUb3VjaGVkOiBpbml0aWFsVG91Y2hlZC5jdXJyZW50LFxuICAgIGluaXRpYWxTdGF0dXM6IGluaXRpYWxTdGF0dXMuY3VycmVudCxcbiAgICBoYW5kbGVCbHVyOiBoYW5kbGVCbHVyLFxuICAgIGhhbmRsZUNoYW5nZTogaGFuZGxlQ2hhbmdlLFxuICAgIGhhbmRsZVJlc2V0OiBoYW5kbGVSZXNldCxcbiAgICBoYW5kbGVTdWJtaXQ6IGhhbmRsZVN1Ym1pdCxcbiAgICByZXNldEZvcm06IHJlc2V0Rm9ybSxcbiAgICBzZXRFcnJvcnM6IHNldEVycm9ycyxcbiAgICBzZXRGb3JtaWtTdGF0ZTogc2V0Rm9ybWlrU3RhdGUsXG4gICAgc2V0RmllbGRUb3VjaGVkOiBzZXRGaWVsZFRvdWNoZWQsXG4gICAgc2V0RmllbGRWYWx1ZTogc2V0RmllbGRWYWx1ZSxcbiAgICBzZXRGaWVsZEVycm9yOiBzZXRGaWVsZEVycm9yLFxuICAgIHNldFN0YXR1czogc2V0U3RhdHVzLFxuICAgIHNldFN1Ym1pdHRpbmc6IHNldFN1Ym1pdHRpbmcsXG4gICAgc2V0VG91Y2hlZDogc2V0VG91Y2hlZCxcbiAgICBzZXRWYWx1ZXM6IHNldFZhbHVlcyxcbiAgICBzdWJtaXRGb3JtOiBzdWJtaXRGb3JtLFxuICAgIHZhbGlkYXRlRm9ybTogdmFsaWRhdGVGb3JtV2l0aEhpZ2hQcmlvcml0eSxcbiAgICB2YWxpZGF0ZUZpZWxkOiB2YWxpZGF0ZUZpZWxkLFxuICAgIGlzVmFsaWQ6IGlzVmFsaWQsXG4gICAgZGlydHk6IGRpcnR5LFxuICAgIHVucmVnaXN0ZXJGaWVsZDogdW5yZWdpc3RlckZpZWxkLFxuICAgIHJlZ2lzdGVyRmllbGQ6IHJlZ2lzdGVyRmllbGQsXG4gICAgZ2V0RmllbGRQcm9wczogZ2V0RmllbGRQcm9wcyxcbiAgICBnZXRGaWVsZE1ldGE6IGdldEZpZWxkTWV0YSxcbiAgICBnZXRGaWVsZEhlbHBlcnM6IGdldEZpZWxkSGVscGVycyxcbiAgICB2YWxpZGF0ZU9uQmx1cjogdmFsaWRhdGVPbkJsdXIsXG4gICAgdmFsaWRhdGVPbkNoYW5nZTogdmFsaWRhdGVPbkNoYW5nZSxcbiAgICB2YWxpZGF0ZU9uTW91bnQ6IHZhbGlkYXRlT25Nb3VudFxuICB9KTtcblxuICByZXR1cm4gY3R4O1xufVxuZnVuY3Rpb24gRm9ybWlrKHByb3BzKSB7XG4gIHZhciBmb3JtaWtiYWcgPSB1c2VGb3JtaWsocHJvcHMpO1xuICB2YXIgY29tcG9uZW50ID0gcHJvcHMuY29tcG9uZW50LFxuICAgICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIHJlbmRlciA9IHByb3BzLnJlbmRlcixcbiAgICAgIGlubmVyUmVmID0gcHJvcHMuaW5uZXJSZWY7IC8vIFRoaXMgYWxsb3dzIGZvbGtzIHRvIHBhc3MgYSByZWYgdG8gPEZvcm1payAvPlxuXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUoaW5uZXJSZWYsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZm9ybWlrYmFnO1xuICB9KTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICEhcHJvcHMucmVuZGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIjxGb3JtaWsgcmVuZGVyPiBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zIG9mIEZvcm1pay4gUGxlYXNlIHVzZSBhIGNoaWxkIGNhbGxiYWNrIGZ1bmN0aW9uIGluc3RlYWQuIFRvIGdldCByaWQgb2YgdGhpcyB3YXJuaW5nLCByZXBsYWNlIDxGb3JtaWsgcmVuZGVyPXsocHJvcHMpID0+IC4uLn0gLz4gd2l0aCA8Rm9ybWlrPnsocHJvcHMpID0+IC4uLn08L0Zvcm1paz5cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICB9LCBbXSk7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlRWxlbWVudChGb3JtaWtQcm92aWRlciwge1xuICAgIHZhbHVlOiBmb3JtaWtiYWdcbiAgfSwgY29tcG9uZW50ID8gY3JlYXRlRWxlbWVudChjb21wb25lbnQsIGZvcm1pa2JhZykgOiByZW5kZXIgPyByZW5kZXIoZm9ybWlrYmFnKSA6IGNoaWxkcmVuIC8vIGNoaWxkcmVuIGNvbWUgbGFzdCwgYWx3YXlzIGNhbGxlZFxuICA/IGlzRnVuY3Rpb24oY2hpbGRyZW4pID8gY2hpbGRyZW4oZm9ybWlrYmFnKSA6ICFpc0VtcHR5Q2hpbGRyZW4oY2hpbGRyZW4pID8gQ2hpbGRyZW4ub25seShjaGlsZHJlbikgOiBudWxsIDogbnVsbCk7XG59XG5cbmZ1bmN0aW9uIHdhcm5BYm91dE1pc3NpbmdJZGVudGlmaWVyKF9yZWY0KSB7XG4gIHZhciBodG1sQ29udGVudCA9IF9yZWY0Lmh0bWxDb250ZW50LFxuICAgICAgZG9jdW1lbnRhdGlvbkFuY2hvckxpbmsgPSBfcmVmNC5kb2N1bWVudGF0aW9uQW5jaG9yTGluayxcbiAgICAgIGhhbmRsZXJOYW1lID0gX3JlZjQuaGFuZGxlck5hbWU7XG4gIGNvbnNvbGUud2FybihcIldhcm5pbmc6IEZvcm1payBjYWxsZWQgYFwiICsgaGFuZGxlck5hbWUgKyBcImAsIGJ1dCB5b3UgZm9yZ290IHRvIHBhc3MgYW4gYGlkYCBvciBgbmFtZWAgYXR0cmlidXRlIHRvIHlvdXIgaW5wdXQ6XFxuICAgIFwiICsgaHRtbENvbnRlbnQgKyBcIlxcbiAgICBGb3JtaWsgY2Fubm90IGRldGVybWluZSB3aGljaCB2YWx1ZSB0byB1cGRhdGUuIEZvciBtb3JlIGluZm8gc2VlIGh0dHBzOi8vZm9ybWlrLm9yZy9kb2NzL2FwaS9mb3JtaWsjXCIgKyBkb2N1bWVudGF0aW9uQW5jaG9yTGluayArIFwiXFxuICBcIik7XG59XG4vKipcclxuICogVHJhbnNmb3JtIFl1cCBWYWxpZGF0aW9uRXJyb3IgdG8gYSBtb3JlIHVzYWJsZSBvYmplY3RcclxuICovXG5cblxuZnVuY3Rpb24geXVwVG9Gb3JtRXJyb3JzKHl1cEVycm9yKSB7XG4gIHZhciBlcnJvcnMgPSB7fTtcblxuICBpZiAoeXVwRXJyb3IuaW5uZXIpIHtcbiAgICBpZiAoeXVwRXJyb3IuaW5uZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gc2V0SW4oZXJyb3JzLCB5dXBFcnJvci5wYXRoLCB5dXBFcnJvci5tZXNzYWdlKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSB5dXBFcnJvci5pbm5lciwgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgIHZhciBfcmVmNTtcblxuICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgX3JlZjUgPSBfaXRlcmF0b3JbX2krK107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfaSA9IF9pdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChfaS5kb25lKSBicmVhaztcbiAgICAgICAgX3JlZjUgPSBfaS52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVyciA9IF9yZWY1O1xuXG4gICAgICBpZiAoIWdldEluKGVycm9ycywgZXJyLnBhdGgpKSB7XG4gICAgICAgIGVycm9ycyA9IHNldEluKGVycm9ycywgZXJyLnBhdGgsIGVyci5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXJyb3JzO1xufVxuLyoqXHJcbiAqIFZhbGlkYXRlIGEgeXVwIHNjaGVtYS5cclxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlWXVwU2NoZW1hKHZhbHVlcywgc2NoZW1hLCBzeW5jLCBjb250ZXh0KSB7XG4gIGlmIChzeW5jID09PSB2b2lkIDApIHtcbiAgICBzeW5jID0gZmFsc2U7XG4gIH1cblxuICB2YXIgbm9ybWFsaXplZFZhbHVlcyA9IHByZXBhcmVEYXRhRm9yVmFsaWRhdGlvbih2YWx1ZXMpO1xuICByZXR1cm4gc2NoZW1hW3N5bmMgPyAndmFsaWRhdGVTeW5jJyA6ICd2YWxpZGF0ZSddKG5vcm1hbGl6ZWRWYWx1ZXMsIHtcbiAgICBhYm9ydEVhcmx5OiBmYWxzZSxcbiAgICBjb250ZXh0OiBjb250ZXh0IHx8IG5vcm1hbGl6ZWRWYWx1ZXNcbiAgfSk7XG59XG4vKipcclxuICogUmVjdXJzaXZlbHkgcHJlcGFyZSB2YWx1ZXMuXHJcbiAqL1xuXG5mdW5jdGlvbiBwcmVwYXJlRGF0YUZvclZhbGlkYXRpb24odmFsdWVzKSB7XG4gIHZhciBkYXRhID0gQXJyYXkuaXNBcnJheSh2YWx1ZXMpID8gW10gOiB7fTtcblxuICBmb3IgKHZhciBrIGluIHZhbHVlcykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWVzLCBrKSkge1xuICAgICAgdmFyIGtleSA9IFN0cmluZyhrKTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzW2tleV0pID09PSB0cnVlKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IHZhbHVlc1trZXldLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPT09IHRydWUgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVwYXJlRGF0YUZvclZhbGlkYXRpb24odmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09ICcnID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZXNba2V5XSkpIHtcbiAgICAgICAgZGF0YVtrZXldID0gcHJlcGFyZURhdGFGb3JWYWxpZGF0aW9uKHZhbHVlc1trZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFba2V5XSA9IHZhbHVlc1trZXldICE9PSAnJyA/IHZhbHVlc1trZXldIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuLyoqXHJcbiAqIGRlZXBtZXJnZSBhcnJheSBtZXJnaW5nIGFsZ29yaXRobVxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vS3lsZUFNYXRoZXdzL2RlZXBtZXJnZSNjb21iaW5lLWFycmF5XHJcbiAqL1xuXG5mdW5jdGlvbiBhcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBkZXN0aW5hdGlvbiA9IHRhcmdldC5zbGljZSgpO1xuICBzb3VyY2UuZm9yRWFjaChmdW5jdGlvbiBtZXJnZShlLCBpKSB7XG4gICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbltpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBjbG9uZVJlcXVlc3RlZCA9IG9wdGlvbnMuY2xvbmUgIT09IGZhbHNlO1xuICAgICAgdmFyIHNob3VsZENsb25lID0gY2xvbmVSZXF1ZXN0ZWQgJiYgb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdChlKTtcbiAgICAgIGRlc3RpbmF0aW9uW2ldID0gc2hvdWxkQ2xvbmUgPyBkZWVwbWVyZ2UoQXJyYXkuaXNBcnJheShlKSA/IFtdIDoge30sIGUsIG9wdGlvbnMpIDogZTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QoZSkpIHtcbiAgICAgIGRlc3RpbmF0aW9uW2ldID0gZGVlcG1lcmdlKHRhcmdldFtpXSwgZSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQuaW5kZXhPZihlKSA9PT0gLTEpIHtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2goZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufVxuLyoqIFJldHVybiBtdWx0aSBzZWxlY3QgdmFsdWVzIGJhc2VkIG9uIGFuIGFycmF5IG9mIG9wdGlvbnMgKi9cblxuXG5mdW5jdGlvbiBnZXRTZWxlY3RlZFZhbHVlcyhvcHRpb25zKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKG9wdGlvbnMpLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgICByZXR1cm4gZWwuc2VsZWN0ZWQ7XG4gIH0pLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICByZXR1cm4gZWwudmFsdWU7XG4gIH0pO1xufVxuLyoqIFJldHVybiB0aGUgbmV4dCB2YWx1ZSBmb3IgYSBjaGVja2JveCAqL1xuXG5cbmZ1bmN0aW9uIGdldFZhbHVlRm9yQ2hlY2tib3goY3VycmVudFZhbHVlLCBjaGVja2VkLCB2YWx1ZVByb3ApIHtcbiAgLy8gSWYgdGhlIGN1cnJlbnQgdmFsdWUgd2FzIGEgYm9vbGVhbiwgcmV0dXJuIGEgYm9vbGVhblxuICBpZiAodHlwZW9mIGN1cnJlbnRWYWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oY2hlY2tlZCk7XG4gIH0gLy8gSWYgdGhlIGN1cnJlbnRWYWx1ZSB3YXMgbm90IGEgYm9vbGVhbiB3ZSB3YW50IHRvIHJldHVybiBhbiBhcnJheVxuXG5cbiAgdmFyIGN1cnJlbnRBcnJheU9mVmFsdWVzID0gW107XG4gIHZhciBpc1ZhbHVlSW5BcnJheSA9IGZhbHNlO1xuICB2YXIgaW5kZXggPSAtMTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkoY3VycmVudFZhbHVlKSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICBpZiAoIXZhbHVlUHJvcCB8fCB2YWx1ZVByb3AgPT0gJ3RydWUnIHx8IHZhbHVlUHJvcCA9PSAnZmFsc2UnKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbihjaGVja2VkKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgdmFsdWUgaXMgYWxyZWFkeSBhbiBhcnJheSwgdXNlIGl0XG4gICAgY3VycmVudEFycmF5T2ZWYWx1ZXMgPSBjdXJyZW50VmFsdWU7XG4gICAgaW5kZXggPSBjdXJyZW50VmFsdWUuaW5kZXhPZih2YWx1ZVByb3ApO1xuICAgIGlzVmFsdWVJbkFycmF5ID0gaW5kZXggPj0gMDtcbiAgfSAvLyBJZiB0aGUgY2hlY2tib3ggd2FzIGNoZWNrZWQgYW5kIHRoZSB2YWx1ZSBpcyBub3QgYWxyZWFkeSBwcmVzZW50IGluIHRoZSBhcmF5IHdlIHdhbnQgdG8gYWRkIHRoZSBuZXcgdmFsdWUgdG8gdGhlIGFycmF5IG9mIHZhbHVlc1xuXG5cbiAgaWYgKGNoZWNrZWQgJiYgdmFsdWVQcm9wICYmICFpc1ZhbHVlSW5BcnJheSkge1xuICAgIHJldHVybiBjdXJyZW50QXJyYXlPZlZhbHVlcy5jb25jYXQodmFsdWVQcm9wKTtcbiAgfSAvLyBJZiB0aGUgY2hlY2tib3ggd2FzIHVuY2hlY2tlZCBhbmQgdGhlIHZhbHVlIGlzIG5vdCBpbiB0aGUgYXJyYXksIHNpbXBseSByZXR1cm4gdGhlIGFscmVhZHkgZXhpc3RpbmcgYXJyYXkgb2YgdmFsdWVzXG5cblxuICBpZiAoIWlzVmFsdWVJbkFycmF5KSB7XG4gICAgcmV0dXJuIGN1cnJlbnRBcnJheU9mVmFsdWVzO1xuICB9IC8vIElmIHRoZSBjaGVja2JveCB3YXMgdW5jaGVja2VkIGFuZCB0aGUgdmFsdWUgaXMgaW4gdGhlIGFycmF5LCByZW1vdmUgdGhlIHZhbHVlIGFuZCByZXR1cm4gdGhlIGFycmF5XG5cblxuICByZXR1cm4gY3VycmVudEFycmF5T2ZWYWx1ZXMuc2xpY2UoMCwgaW5kZXgpLmNvbmNhdChjdXJyZW50QXJyYXlPZlZhbHVlcy5zbGljZShpbmRleCArIDEpKTtcbn0gLy8gUmVhY3QgY3VycmVudGx5IHRocm93cyBhIHdhcm5pbmcgd2hlbiB1c2luZyB1c2VMYXlvdXRFZmZlY3Qgb24gdGhlIHNlcnZlci5cbi8vIFRvIGdldCBhcm91bmQgaXQsIHdlIGNhbiBjb25kaXRpb25hbGx5IHVzZUVmZmVjdCBvbiB0aGUgc2VydmVyIChuby1vcCkgYW5kXG4vLyB1c2VMYXlvdXRFZmZlY3QgaW4gdGhlIGJyb3dzZXIuXG4vLyBAc2VlIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2dhZWFyb24vZTdkOTdjZGYzOGEyOTA3OTI0ZWExMmU0ZWJkZjNjODVcblxuXG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbmZ1bmN0aW9uIHVzZUV2ZW50Q2FsbGJhY2soZm4pIHtcbiAgdmFyIHJlZiA9IHVzZVJlZihmbik7IC8vIHdlIGNvcHkgYSByZWYgdG8gdGhlIGNhbGxiYWNrIHNjb3BlZCB0byB0aGUgY3VycmVudCBzdGF0ZS9wcm9wcyBvbiBlYWNoIHJlbmRlclxuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlZi5jdXJyZW50ID0gZm47XG4gIH0pO1xuICByZXR1cm4gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVmLmN1cnJlbnQuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiB1c2VGaWVsZChwcm9wc09yRmllbGROYW1lKSB7XG4gIHZhciBmb3JtaWsgPSB1c2VGb3JtaWtDb250ZXh0KCk7XG4gIHZhciBnZXRGaWVsZFByb3BzID0gZm9ybWlrLmdldEZpZWxkUHJvcHMsXG4gICAgICBnZXRGaWVsZE1ldGEgPSBmb3JtaWsuZ2V0RmllbGRNZXRhLFxuICAgICAgZ2V0RmllbGRIZWxwZXJzID0gZm9ybWlrLmdldEZpZWxkSGVscGVycyxcbiAgICAgIHJlZ2lzdGVyRmllbGQgPSBmb3JtaWsucmVnaXN0ZXJGaWVsZCxcbiAgICAgIHVucmVnaXN0ZXJGaWVsZCA9IGZvcm1pay51bnJlZ2lzdGVyRmllbGQ7XG4gIHZhciBpc0FuT2JqZWN0ID0gaXNPYmplY3QocHJvcHNPckZpZWxkTmFtZSk7IC8vIE5vcm1hbGl6ZSBwcm9wc09yRmllbGROYW1lIHRvIEZpZWxkSG9va0NvbmZpZzxWYWw+XG5cbiAgdmFyIHByb3BzID0gaXNBbk9iamVjdCA/IHByb3BzT3JGaWVsZE5hbWUgOiB7XG4gICAgbmFtZTogcHJvcHNPckZpZWxkTmFtZVxuICB9O1xuICB2YXIgZmllbGROYW1lID0gcHJvcHMubmFtZSxcbiAgICAgIHZhbGlkYXRlRm4gPSBwcm9wcy52YWxpZGF0ZTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZmllbGROYW1lKSB7XG4gICAgICByZWdpc3RlckZpZWxkKGZpZWxkTmFtZSwge1xuICAgICAgICB2YWxpZGF0ZTogdmFsaWRhdGVGblxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChmaWVsZE5hbWUpIHtcbiAgICAgICAgdW5yZWdpc3RlckZpZWxkKGZpZWxkTmFtZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW3JlZ2lzdGVyRmllbGQsIHVucmVnaXN0ZXJGaWVsZCwgZmllbGROYW1lLCB2YWxpZGF0ZUZuXSk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICFmb3JtaWsgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICd1c2VGaWVsZCgpIC8gPEZpZWxkIC8+IG11c3QgYmUgdXNlZCB1bmRlcm5lYXRoIGEgPEZvcm1paz4gY29tcG9uZW50IG9yIHdpdGhGb3JtaWsoKSBoaWdoZXIgb3JkZXIgY29tcG9uZW50JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB9XG5cbiAgIWZpZWxkTmFtZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgZmllbGQgbmFtZS4gRWl0aGVyIHBhc3MgYHVzZUZpZWxkYCBhIHN0cmluZyBvciBhbiBvYmplY3QgY29udGFpbmluZyBhIGBuYW1lYCBrZXkuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB2YXIgZmllbGRIZWxwZXJzID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldEZpZWxkSGVscGVycyhmaWVsZE5hbWUpO1xuICB9LCBbZ2V0RmllbGRIZWxwZXJzLCBmaWVsZE5hbWVdKTtcbiAgcmV0dXJuIFtnZXRGaWVsZFByb3BzKHByb3BzKSwgZ2V0RmllbGRNZXRhKGZpZWxkTmFtZSksIGZpZWxkSGVscGVyc107XG59XG5mdW5jdGlvbiBGaWVsZChfcmVmKSB7XG4gIHZhciB2YWxpZGF0ZSA9IF9yZWYudmFsaWRhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgcmVuZGVyID0gX3JlZi5yZW5kZXIsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBpcyA9IF9yZWYuYXMsXG4gICAgICBjb21wb25lbnQgPSBfcmVmLmNvbXBvbmVudCxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBbXCJ2YWxpZGF0ZVwiLCBcIm5hbWVcIiwgXCJyZW5kZXJcIiwgXCJjaGlsZHJlblwiLCBcImFzXCIsIFwiY29tcG9uZW50XCIsIFwiY2xhc3NOYW1lXCJdKTtcblxuICB2YXIgX3VzZUZvcm1pa0NvbnRleHQgPSB1c2VGb3JtaWtDb250ZXh0KCksXG4gICAgICBmb3JtaWsgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdXNlRm9ybWlrQ29udGV4dCwgW1widmFsaWRhdGVcIiwgXCJ2YWxpZGF0aW9uU2NoZW1hXCJdKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICEhcmVuZGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIjxGaWVsZCByZW5kZXI+IGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgRm9ybWlrLiBQbGVhc2UgdXNlIGEgY2hpbGQgY2FsbGJhY2sgZnVuY3Rpb24gaW5zdGVhZC4gVG8gZ2V0IHJpZCBvZiB0aGlzIHdhcm5pbmcsIHJlcGxhY2UgPEZpZWxkIG5hbWU9XFxcIlwiICsgbmFtZSArIFwiXFxcIiByZW5kZXI9eyh7ZmllbGQsIGZvcm19KSA9PiAuLi59IC8+IHdpdGggPEZpZWxkIG5hbWU9XFxcIlwiICsgbmFtZSArIFwiXFxcIj57KHtmaWVsZCwgZm9ybSwgbWV0YX0pID0+IC4uLn08L0ZpZWxkPlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICAhIShpcyAmJiBjaGlsZHJlbiAmJiBpc0Z1bmN0aW9uKGNoaWxkcmVuKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdZb3Ugc2hvdWxkIG5vdCB1c2UgPEZpZWxkIGFzPiBhbmQgPEZpZWxkIGNoaWxkcmVuPiBhcyBhIGZ1bmN0aW9uIGluIHRoZSBzYW1lIDxGaWVsZD4gY29tcG9uZW50OyA8RmllbGQgYXM+IHdpbGwgYmUgaWdub3JlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICAhIShjb21wb25lbnQgJiYgY2hpbGRyZW4gJiYgaXNGdW5jdGlvbihjaGlsZHJlbikpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnWW91IHNob3VsZCBub3QgdXNlIDxGaWVsZCBjb21wb25lbnQ+IGFuZCA8RmllbGQgY2hpbGRyZW4+IGFzIGEgZnVuY3Rpb24gaW4gdGhlIHNhbWUgPEZpZWxkPiBjb21wb25lbnQ7IDxGaWVsZCBjb21wb25lbnQ+IHdpbGwgYmUgaWdub3JlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICAhIShyZW5kZXIgJiYgY2hpbGRyZW4gJiYgIWlzRW1wdHlDaGlsZHJlbihjaGlsZHJlbikpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnWW91IHNob3VsZCBub3QgdXNlIDxGaWVsZCByZW5kZXI+IGFuZCA8RmllbGQgY2hpbGRyZW4+IGluIHRoZSBzYW1lIDxGaWVsZD4gY29tcG9uZW50OyA8RmllbGQgY2hpbGRyZW4+IHdpbGwgYmUgaWdub3JlZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgfSwgW10pO1xuICB9IC8vIFJlZ2lzdGVyIGZpZWxkIGFuZCBmaWVsZC1sZXZlbCB2YWxpZGF0aW9uIHdpdGggcGFyZW50IDxGb3JtaWs+XG5cblxuICB2YXIgcmVnaXN0ZXJGaWVsZCA9IGZvcm1pay5yZWdpc3RlckZpZWxkLFxuICAgICAgdW5yZWdpc3RlckZpZWxkID0gZm9ybWlrLnVucmVnaXN0ZXJGaWVsZDtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZWdpc3RlckZpZWxkKG5hbWUsIHtcbiAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZVxuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB1bnJlZ2lzdGVyRmllbGQobmFtZSk7XG4gICAgfTtcbiAgfSwgW3JlZ2lzdGVyRmllbGQsIHVucmVnaXN0ZXJGaWVsZCwgbmFtZSwgdmFsaWRhdGVdKTtcbiAgdmFyIGZpZWxkID0gZm9ybWlrLmdldEZpZWxkUHJvcHMoX2V4dGVuZHMoe1xuICAgIG5hbWU6IG5hbWVcbiAgfSwgcHJvcHMpKTtcbiAgdmFyIG1ldGEgPSBmb3JtaWsuZ2V0RmllbGRNZXRhKG5hbWUpO1xuICB2YXIgbGVnYWN5QmFnID0ge1xuICAgIGZpZWxkOiBmaWVsZCxcbiAgICBmb3JtOiBmb3JtaWtcbiAgfTtcblxuICBpZiAocmVuZGVyKSB7XG4gICAgcmV0dXJuIHJlbmRlcihfZXh0ZW5kcyh7fSwgbGVnYWN5QmFnLCB7XG4gICAgICBtZXRhOiBtZXRhXG4gICAgfSkpO1xuICB9XG5cbiAgaWYgKGlzRnVuY3Rpb24oY2hpbGRyZW4pKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuKF9leHRlbmRzKHt9LCBsZWdhY3lCYWcsIHtcbiAgICAgIG1ldGE6IG1ldGFcbiAgICB9KSk7XG4gIH1cblxuICBpZiAoY29tcG9uZW50KSB7XG4gICAgLy8gVGhpcyBiZWhhdmlvciBpcyBiYWNrd2FyZHMgY29tcGF0IHdpdGggZWFybGllciBGb3JtaWsgMC45IHRvIDEueFxuICAgIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIGlubmVyUmVmID0gcHJvcHMuaW5uZXJSZWYsXG4gICAgICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBbXCJpbm5lclJlZlwiXSk7XG5cbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgICAgICByZWY6IGlubmVyUmVmXG4gICAgICB9LCBmaWVsZCwgcmVzdCwge1xuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICAgICAgfSksIGNoaWxkcmVuKTtcbiAgICB9IC8vIFdlIGRvbid0IHBhc3MgYG1ldGFgIGZvciBiYWNrd2FyZHMgY29tcGF0XG5cblxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgZm9ybTogZm9ybWlrXG4gICAgfSwgcHJvcHMsIHtcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gICAgfSksIGNoaWxkcmVuKTtcbiAgfSAvLyBkZWZhdWx0IHRvIGlucHV0IGhlcmUgc28gd2UgY2FuIGNoZWNrIGZvciBib3RoIGBhc2AgYW5kIGBjaGlsZHJlbmAgYWJvdmVcblxuXG4gIHZhciBhc0VsZW1lbnQgPSBpcyB8fCAnaW5wdXQnO1xuXG4gIGlmICh0eXBlb2YgYXNFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIHZhciBfaW5uZXJSZWYgPSBwcm9wcy5pbm5lclJlZixcbiAgICAgICAgX3Jlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgW1wiaW5uZXJSZWZcIl0pO1xuXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoYXNFbGVtZW50LCBfZXh0ZW5kcyh7XG4gICAgICByZWY6IF9pbm5lclJlZlxuICAgIH0sIGZpZWxkLCBfcmVzdCwge1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgICB9KSwgY2hpbGRyZW4pO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoYXNFbGVtZW50LCBfZXh0ZW5kcyh7fSwgZmllbGQsIHByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgfSksIGNoaWxkcmVuKTtcbn1cblxudmFyIEZvcm0gPSAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICAvLyBpT1MgbmVlZHMgYW4gXCJhY3Rpb25cIiBhdHRyaWJ1dGUgZm9yIG5pY2UgaW5wdXQ6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTQ4NTE2Mi80MDY3MjVcbiAgLy8gV2UgZGVmYXVsdCB0aGUgYWN0aW9uIHRvIFwiI1wiIGluIGNhc2UgdGhlIHByZXZlbnREZWZhdWx0IGZhaWxzIChqdXN0IHVwZGF0ZXMgdGhlIFVSTCBoYXNoKVxuICB2YXIgYWN0aW9uID0gcHJvcHMuYWN0aW9uLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBbXCJhY3Rpb25cIl0pO1xuXG4gIHZhciBfYWN0aW9uID0gYWN0aW9uICE9IG51bGwgPyBhY3Rpb24gOiAnIyc7XG5cbiAgdmFyIF91c2VGb3JtaWtDb250ZXh0ID0gdXNlRm9ybWlrQ29udGV4dCgpLFxuICAgICAgaGFuZGxlUmVzZXQgPSBfdXNlRm9ybWlrQ29udGV4dC5oYW5kbGVSZXNldCxcbiAgICAgIGhhbmRsZVN1Ym1pdCA9IF91c2VGb3JtaWtDb250ZXh0LmhhbmRsZVN1Ym1pdDtcblxuICByZXR1cm4gY3JlYXRlRWxlbWVudChcImZvcm1cIiwgX2V4dGVuZHMoe1xuICAgIG9uU3VibWl0OiBoYW5kbGVTdWJtaXQsXG4gICAgcmVmOiByZWYsXG4gICAgb25SZXNldDogaGFuZGxlUmVzZXQsXG4gICAgYWN0aW9uOiBfYWN0aW9uXG4gIH0sIHJlc3QpKTtcbn0pO1xuRm9ybS5kaXNwbGF5TmFtZSA9ICdGb3JtJztcblxuLyoqXHJcbiAqIEEgcHVibGljIGhpZ2hlci1vcmRlciBjb21wb25lbnQgdG8gYWNjZXNzIHRoZSBpbXBlcmF0aXZlIEFQSVxyXG4gKi9cblxuZnVuY3Rpb24gd2l0aEZvcm1payhfcmVmKSB7XG4gIHZhciBfcmVmJG1hcFByb3BzVG9WYWx1ZXMgPSBfcmVmLm1hcFByb3BzVG9WYWx1ZXMsXG4gICAgICBtYXBQcm9wc1RvVmFsdWVzID0gX3JlZiRtYXBQcm9wc1RvVmFsdWVzID09PSB2b2lkIDAgPyBmdW5jdGlvbiAodmFuaWxsYVByb3BzKSB7XG4gICAgdmFyIHZhbCA9IHt9O1xuXG4gICAgZm9yICh2YXIgayBpbiB2YW5pbGxhUHJvcHMpIHtcbiAgICAgIGlmICh2YW5pbGxhUHJvcHMuaGFzT3duUHJvcGVydHkoaykgJiYgdHlwZW9mIHZhbmlsbGFQcm9wc1trXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBAdG9kbyBUeXBlU2NyaXB0IGZpeFxuICAgICAgICB2YWxba10gPSB2YW5pbGxhUHJvcHNba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfSA6IF9yZWYkbWFwUHJvcHNUb1ZhbHVlcyxcbiAgICAgIGNvbmZpZyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIFtcIm1hcFByb3BzVG9WYWx1ZXNcIl0pO1xuXG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVGb3JtaWsoQ29tcG9uZW50JDEpIHtcbiAgICB2YXIgY29tcG9uZW50RGlzcGxheU5hbWUgPSBDb21wb25lbnQkMS5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQkMS5uYW1lIHx8IENvbXBvbmVudCQxLmNvbnN0cnVjdG9yICYmIENvbXBvbmVudCQxLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ0NvbXBvbmVudCc7XG4gICAgLyoqXHJcbiAgICAgKiBXZSBuZWVkIHRvIHVzZSBjbG9zdXJlcyBoZXJlIGZvciB0byBwcm92aWRlIHRoZSB3cmFwcGVkIGNvbXBvbmVudCdzIHByb3BzIHRvXHJcbiAgICAgKiB0aGUgcmVzcGVjdGl2ZSB3aXRoRm9ybWlrIGNvbmZpZyBtZXRob2RzLlxyXG4gICAgICovXG5cbiAgICB2YXIgQyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgICAgX2luaGVyaXRzTG9vc2UoQywgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICAgIGZ1bmN0aW9uIEMoKSB7XG4gICAgICAgIHZhciBfdGhpcztcblxuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcblxuICAgICAgICBfdGhpcy52YWxpZGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgICByZXR1cm4gY29uZmlnLnZhbGlkYXRlKHZhbHVlcywgX3RoaXMucHJvcHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLnZhbGlkYXRpb25TY2hlbWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oY29uZmlnLnZhbGlkYXRpb25TY2hlbWEpID8gY29uZmlnLnZhbGlkYXRpb25TY2hlbWEoX3RoaXMucHJvcHMpIDogY29uZmlnLnZhbGlkYXRpb25TY2hlbWE7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMuaGFuZGxlU3VibWl0ID0gZnVuY3Rpb24gKHZhbHVlcywgYWN0aW9ucykge1xuICAgICAgICAgIHJldHVybiBjb25maWcuaGFuZGxlU3VibWl0KHZhbHVlcywgX2V4dGVuZHMoe30sIGFjdGlvbnMsIHtcbiAgICAgICAgICAgIHByb3BzOiBfdGhpcy5wcm9wc1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5yZW5kZXJGb3JtQ29tcG9uZW50ID0gZnVuY3Rpb24gKGZvcm1pa1Byb3BzKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50JDEsIF9leHRlbmRzKHt9LCBfdGhpcy5wcm9wcywgZm9ybWlrUHJvcHMpKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBfcHJvdG8gPSBDLnByb3RvdHlwZTtcblxuICAgICAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMsIFtcImNoaWxkcmVuXCJdKTtcblxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChGb3JtaWssIF9leHRlbmRzKHt9LCBwcm9wcywgY29uZmlnLCB7XG4gICAgICAgICAgdmFsaWRhdGU6IGNvbmZpZy52YWxpZGF0ZSAmJiB0aGlzLnZhbGlkYXRlLFxuICAgICAgICAgIHZhbGlkYXRpb25TY2hlbWE6IGNvbmZpZy52YWxpZGF0aW9uU2NoZW1hICYmIHRoaXMudmFsaWRhdGlvblNjaGVtYSxcbiAgICAgICAgICBpbml0aWFsVmFsdWVzOiBtYXBQcm9wc1RvVmFsdWVzKHRoaXMucHJvcHMpLFxuICAgICAgICAgIGluaXRpYWxTdGF0dXM6IGNvbmZpZy5tYXBQcm9wc1RvU3RhdHVzICYmIGNvbmZpZy5tYXBQcm9wc1RvU3RhdHVzKHRoaXMucHJvcHMpLFxuICAgICAgICAgIGluaXRpYWxFcnJvcnM6IGNvbmZpZy5tYXBQcm9wc1RvRXJyb3JzICYmIGNvbmZpZy5tYXBQcm9wc1RvRXJyb3JzKHRoaXMucHJvcHMpLFxuICAgICAgICAgIGluaXRpYWxUb3VjaGVkOiBjb25maWcubWFwUHJvcHNUb1RvdWNoZWQgJiYgY29uZmlnLm1hcFByb3BzVG9Ub3VjaGVkKHRoaXMucHJvcHMpLFxuICAgICAgICAgIG9uU3VibWl0OiB0aGlzLmhhbmRsZVN1Ym1pdCxcbiAgICAgICAgICBjaGlsZHJlbjogdGhpcy5yZW5kZXJGb3JtQ29tcG9uZW50XG4gICAgICAgIH0pKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBDO1xuICAgIH0oQ29tcG9uZW50KTtcblxuICAgIEMuZGlzcGxheU5hbWUgPSBcIldpdGhGb3JtaWsoXCIgKyBjb21wb25lbnREaXNwbGF5TmFtZSArIFwiKVwiO1xuICAgIHJldHVybiBob2lzdE5vblJlYWN0U3RhdGljcyhDLCBDb21wb25lbnQkMSAvLyBjYXN0IHR5cGUgdG8gQ29tcG9uZW50Q2xhc3MgKGV2ZW4gaWYgU0ZDKVxuICAgICk7XG4gIH07XG59XG5cbi8qKlxyXG4gKiBDb25uZWN0IGFueSBjb21wb25lbnQgdG8gRm9ybWlrIGNvbnRleHQsIGFuZCBpbmplY3QgYXMgYSBwcm9wIGNhbGxlZCBgZm9ybWlrYDtcclxuICogQHBhcmFtIENvbXAgUmVhY3QgQ29tcG9uZW50XHJcbiAqL1xuXG5mdW5jdGlvbiBjb25uZWN0KENvbXApIHtcbiAgdmFyIEMgPSBmdW5jdGlvbiBDKHByb3BzKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoRm9ybWlrQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChmb3JtaWspIHtcbiAgICAgICEhIWZvcm1payA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJGb3JtaWsgY29udGV4dCBpcyB1bmRlZmluZWQsIHBsZWFzZSB2ZXJpZnkgeW91IGFyZSByZW5kZXJpbmcgPEZvcm0+LCA8RmllbGQ+LCA8RmFzdEZpZWxkPiwgPEZpZWxkQXJyYXk+LCBvciB5b3VyIGN1c3RvbSBjb250ZXh0LXVzaW5nIGNvbXBvbmVudCBhcyBhIGNoaWxkIG9mIGEgPEZvcm1paz4gY29tcG9uZW50LiBDb21wb25lbnQgbmFtZTogXCIgKyBDb21wLm5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KENvbXAsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgICBmb3JtaWs6IGZvcm1pa1xuICAgICAgfSkpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBjb21wb25lbnREaXNwbGF5TmFtZSA9IENvbXAuZGlzcGxheU5hbWUgfHwgQ29tcC5uYW1lIHx8IENvbXAuY29uc3RydWN0b3IgJiYgQ29tcC5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdDb21wb25lbnQnOyAvLyBBc3NpZ24gQ29tcCB0byBDLldyYXBwZWRDb21wb25lbnQgc28gd2UgY2FuIGFjY2VzcyB0aGUgaW5uZXIgY29tcG9uZW50IGluIHRlc3RzXG4gIC8vIEZvciBleGFtcGxlLCA8RmllbGQuV3JhcHBlZENvbXBvbmVudCAvPiBnZXRzIHVzIDxGaWVsZElubmVyLz5cblxuICBDLldyYXBwZWRDb21wb25lbnQgPSBDb21wO1xuICBDLmRpc3BsYXlOYW1lID0gXCJGb3JtaWtDb25uZWN0KFwiICsgY29tcG9uZW50RGlzcGxheU5hbWUgKyBcIilcIjtcbiAgcmV0dXJuIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKEMsIENvbXAgLy8gY2FzdCB0eXBlIHRvIENvbXBvbmVudENsYXNzIChldmVuIGlmIFNGQylcbiAgKTtcbn1cblxuLyoqXHJcbiAqIFNvbWUgYXJyYXkgaGVscGVycyFcclxuICovXG5cbnZhciBtb3ZlID0gZnVuY3Rpb24gbW92ZShhcnJheSwgZnJvbSwgdG8pIHtcbiAgdmFyIGNvcHkgPSBjb3B5QXJyYXlMaWtlKGFycmF5KTtcbiAgdmFyIHZhbHVlID0gY29weVtmcm9tXTtcbiAgY29weS5zcGxpY2UoZnJvbSwgMSk7XG4gIGNvcHkuc3BsaWNlKHRvLCAwLCB2YWx1ZSk7XG4gIHJldHVybiBjb3B5O1xufTtcbnZhciBzd2FwID0gZnVuY3Rpb24gc3dhcChhcnJheUxpa2UsIGluZGV4QSwgaW5kZXhCKSB7XG4gIHZhciBjb3B5ID0gY29weUFycmF5TGlrZShhcnJheUxpa2UpO1xuICB2YXIgYSA9IGNvcHlbaW5kZXhBXTtcbiAgY29weVtpbmRleEFdID0gY29weVtpbmRleEJdO1xuICBjb3B5W2luZGV4Ql0gPSBhO1xuICByZXR1cm4gY29weTtcbn07XG52YXIgaW5zZXJ0ID0gZnVuY3Rpb24gaW5zZXJ0KGFycmF5TGlrZSwgaW5kZXgsIHZhbHVlKSB7XG4gIHZhciBjb3B5ID0gY29weUFycmF5TGlrZShhcnJheUxpa2UpO1xuICBjb3B5LnNwbGljZShpbmRleCwgMCwgdmFsdWUpO1xuICByZXR1cm4gY29weTtcbn07XG52YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UoYXJyYXlMaWtlLCBpbmRleCwgdmFsdWUpIHtcbiAgdmFyIGNvcHkgPSBjb3B5QXJyYXlMaWtlKGFycmF5TGlrZSk7XG4gIGNvcHlbaW5kZXhdID0gdmFsdWU7XG4gIHJldHVybiBjb3B5O1xufTtcblxudmFyIGNvcHlBcnJheUxpa2UgPSBmdW5jdGlvbiBjb3B5QXJyYXlMaWtlKGFycmF5TGlrZSkge1xuICBpZiAoIWFycmF5TGlrZSkge1xuICAgIHJldHVybiBbXTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFycmF5TGlrZSkpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KGFycmF5TGlrZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1heEluZGV4ID0gT2JqZWN0LmtleXMoYXJyYXlMaWtlKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KGtleSk7XG4gICAgfSkucmVkdWNlKGZ1bmN0aW9uIChtYXgsIGVsKSB7XG4gICAgICByZXR1cm4gZWwgPiBtYXggPyBlbCA6IG1heDtcbiAgICB9LCAwKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShfZXh0ZW5kcyh7fSwgYXJyYXlMaWtlLCB7XG4gICAgICBsZW5ndGg6IG1heEluZGV4ICsgMVxuICAgIH0pKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUFsdGVyYXRpb25IYW5kbGVyID0gZnVuY3Rpb24gY3JlYXRlQWx0ZXJhdGlvbkhhbmRsZXIoYWx0ZXJhdGlvbiwgZGVmYXVsdEZ1bmN0aW9uKSB7XG4gIHZhciBmbiA9IHR5cGVvZiBhbHRlcmF0aW9uID09PSAnZnVuY3Rpb24nID8gYWx0ZXJhdGlvbiA6IGRlZmF1bHRGdW5jdGlvbjtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIHZhciBjbG9uZSA9IGNvcHlBcnJheUxpa2UoZGF0YSk7XG4gICAgICByZXR1cm4gZm4oY2xvbmUpO1xuICAgIH0gLy8gVGhpcyBjYW4gYmUgYXNzdW1lZCB0byBiZSBhIHByaW1pdGl2ZSwgd2hpY2hcbiAgICAvLyBpcyBhIGNhc2UgZm9yIHRvcCBsZXZlbCB2YWxpZGF0aW9uIGVycm9yc1xuXG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcbn07XG5cbnZhciBGaWVsZEFycmF5SW5uZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoRmllbGRBcnJheUlubmVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBGaWVsZEFycmF5SW5uZXIocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpczsgLy8gV2UgbmVlZCBUeXBlU2NyaXB0IGdlbmVyaWNzIG9uIHRoZXNlLCBzbyB3ZSdsbCBiaW5kIHRoZW0gaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgLy8gQHRvZG8gRml4IFRTIDMuMi4xXG5cbiAgICBfdGhpcy51cGRhdGVBcnJheUZpZWxkID0gZnVuY3Rpb24gKGZuLCBhbHRlclRvdWNoZWQsIGFsdGVyRXJyb3JzKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBuYW1lID0gX3RoaXMkcHJvcHMubmFtZSxcbiAgICAgICAgICBzZXRGb3JtaWtTdGF0ZSA9IF90aGlzJHByb3BzLmZvcm1pay5zZXRGb3JtaWtTdGF0ZTtcbiAgICAgIHNldEZvcm1pa1N0YXRlKGZ1bmN0aW9uIChwcmV2U3RhdGUpIHtcbiAgICAgICAgdmFyIHVwZGF0ZUVycm9ycyA9IGNyZWF0ZUFsdGVyYXRpb25IYW5kbGVyKGFsdGVyRXJyb3JzLCBmbik7XG4gICAgICAgIHZhciB1cGRhdGVUb3VjaGVkID0gY3JlYXRlQWx0ZXJhdGlvbkhhbmRsZXIoYWx0ZXJUb3VjaGVkLCBmbik7IC8vIHZhbHVlcyBmbiBzaG91bGQgYmUgZXhlY3V0ZWQgYmVmb3JlIHVwZGF0ZUVycm9ycyBhbmQgdXBkYXRlVG91Y2hlZCxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGl0IGNhdXNlcyBhbiBlcnJvciB3aXRoIHVuc2hpZnQuXG5cbiAgICAgICAgdmFyIHZhbHVlcyA9IHNldEluKHByZXZTdGF0ZS52YWx1ZXMsIG5hbWUsIGZuKGdldEluKHByZXZTdGF0ZS52YWx1ZXMsIG5hbWUpKSk7XG4gICAgICAgIHZhciBmaWVsZEVycm9yID0gYWx0ZXJFcnJvcnMgPyB1cGRhdGVFcnJvcnMoZ2V0SW4ocHJldlN0YXRlLmVycm9ycywgbmFtZSkpIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgZmllbGRUb3VjaGVkID0gYWx0ZXJUb3VjaGVkID8gdXBkYXRlVG91Y2hlZChnZXRJbihwcmV2U3RhdGUudG91Y2hlZCwgbmFtZSkpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChpc0VtcHR5QXJyYXkoZmllbGRFcnJvcikpIHtcbiAgICAgICAgICBmaWVsZEVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRW1wdHlBcnJheShmaWVsZFRvdWNoZWQpKSB7XG4gICAgICAgICAgZmllbGRUb3VjaGVkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBwcmV2U3RhdGUsIHtcbiAgICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgICBlcnJvcnM6IGFsdGVyRXJyb3JzID8gc2V0SW4ocHJldlN0YXRlLmVycm9ycywgbmFtZSwgZmllbGRFcnJvcikgOiBwcmV2U3RhdGUuZXJyb3JzLFxuICAgICAgICAgIHRvdWNoZWQ6IGFsdGVyVG91Y2hlZCA/IHNldEluKHByZXZTdGF0ZS50b3VjaGVkLCBuYW1lLCBmaWVsZFRvdWNoZWQpIDogcHJldlN0YXRlLnRvdWNoZWRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3RoaXMucHVzaCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZUFycmF5RmllbGQoZnVuY3Rpb24gKGFycmF5TGlrZSkge1xuICAgICAgICByZXR1cm4gW10uY29uY2F0KGNvcHlBcnJheUxpa2UoYXJyYXlMaWtlKSwgW2Nsb25lRGVlcCh2YWx1ZSldKTtcbiAgICAgIH0sIGZhbHNlLCBmYWxzZSk7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZVB1c2ggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5wdXNoKHZhbHVlKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIF90aGlzLnN3YXAgPSBmdW5jdGlvbiAoaW5kZXhBLCBpbmRleEIpIHtcbiAgICAgIHJldHVybiBfdGhpcy51cGRhdGVBcnJheUZpZWxkKGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICByZXR1cm4gc3dhcChhcnJheSwgaW5kZXhBLCBpbmRleEIpO1xuICAgICAgfSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZVN3YXAgPSBmdW5jdGlvbiAoaW5kZXhBLCBpbmRleEIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5zd2FwKGluZGV4QSwgaW5kZXhCKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIF90aGlzLm1vdmUgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgICAgIHJldHVybiBfdGhpcy51cGRhdGVBcnJheUZpZWxkKGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICByZXR1cm4gbW92ZShhcnJheSwgZnJvbSwgdG8pO1xuICAgICAgfSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZU1vdmUgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5tb3ZlKGZyb20sIHRvKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIF90aGlzLmluc2VydCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBfdGhpcy51cGRhdGVBcnJheUZpZWxkKGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICByZXR1cm4gaW5zZXJ0KGFycmF5LCBpbmRleCwgdmFsdWUpO1xuICAgICAgfSwgZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgIHJldHVybiBpbnNlcnQoYXJyYXksIGluZGV4LCBudWxsKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICByZXR1cm4gaW5zZXJ0KGFycmF5LCBpbmRleCwgbnVsbCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlSW5zZXJ0ID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmluc2VydChpbmRleCwgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgX3RoaXMucmVwbGFjZSA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBfdGhpcy51cGRhdGVBcnJheUZpZWxkKGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICByZXR1cm4gcmVwbGFjZShhcnJheSwgaW5kZXgsIHZhbHVlKTtcbiAgICAgIH0sIGZhbHNlLCBmYWxzZSk7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZVJlcGxhY2UgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMucmVwbGFjZShpbmRleCwgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgX3RoaXMudW5zaGlmdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IC0xO1xuXG4gICAgICBfdGhpcy51cGRhdGVBcnJheUZpZWxkKGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICB2YXIgYXJyID0gYXJyYXkgPyBbdmFsdWVdLmNvbmNhdChhcnJheSkgOiBbdmFsdWVdO1xuICAgICAgICBsZW5ndGggPSBhcnIubGVuZ3RoO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgfSwgZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgIHJldHVybiBhcnJheSA/IFtudWxsXS5jb25jYXQoYXJyYXkpIDogW251bGxdO1xuICAgICAgfSwgZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgIHJldHVybiBhcnJheSA/IFtudWxsXS5jb25jYXQoYXJyYXkpIDogW251bGxdO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZVVuc2hpZnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy51bnNoaWZ0KHZhbHVlKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZVJlbW92ZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnJlbW92ZShpbmRleCk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVQb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMucG9wKCk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBfdGhpcy5yZW1vdmUgPSBfdGhpcy5yZW1vdmUuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMucG9wID0gX3RoaXMucG9wLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBGaWVsZEFycmF5SW5uZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgaWYgKHRoaXMucHJvcHMudmFsaWRhdGVPbkNoYW5nZSAmJiB0aGlzLnByb3BzLmZvcm1pay52YWxpZGF0ZU9uQ2hhbmdlICYmICFpc0VxdWFsKGdldEluKHByZXZQcm9wcy5mb3JtaWsudmFsdWVzLCBwcmV2UHJvcHMubmFtZSksIGdldEluKHRoaXMucHJvcHMuZm9ybWlrLnZhbHVlcywgdGhpcy5wcm9wcy5uYW1lKSkpIHtcbiAgICAgIHRoaXMucHJvcHMuZm9ybWlrLnZhbGlkYXRlRm9ybSh0aGlzLnByb3BzLmZvcm1pay52YWx1ZXMpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGluZGV4KSB7XG4gICAgLy8gV2UgbmVlZCB0byBtYWtlIHN1cmUgd2UgYWxzbyByZW1vdmUgcmVsZXZhbnQgcGllY2VzIG9mIGB0b3VjaGVkYCBhbmQgYGVycm9yc2BcbiAgICB2YXIgcmVzdWx0O1xuICAgIHRoaXMudXBkYXRlQXJyYXlGaWVsZCggLy8gc28gdGhpcyBnZXRzIGNhbGwgMyB0aW1lc1xuICAgIGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgdmFyIGNvcHkgPSBhcnJheSA/IGNvcHlBcnJheUxpa2UoYXJyYXkpIDogW107XG5cbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdCA9IGNvcHlbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbihjb3B5LnNwbGljZSkpIHtcbiAgICAgICAgY29weS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfSAvLyBpZiB0aGUgYXJyYXkgb25seSBpbmNsdWRlcyB1bmRlZmluZWQgdmFsdWVzIHdlIGhhdmUgdG8gcmV0dXJuIGFuIGVtcHR5IGFycmF5XG5cblxuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oY29weS5ldmVyeSkgPyBjb3B5LmV2ZXJ5KGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiB2ID09PSB1bmRlZmluZWQ7XG4gICAgICB9KSA/IFtdIDogY29weSA6IGNvcHk7XG4gICAgfSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBfcHJvdG8ucG9wID0gZnVuY3Rpb24gcG9wKCkge1xuICAgIC8vIFJlbW92ZSByZWxldmFudCBwaWVjZXMgb2YgYHRvdWNoZWRgIGFuZCBgZXJyb3JzYCB0b28hXG4gICAgdmFyIHJlc3VsdDtcbiAgICB0aGlzLnVwZGF0ZUFycmF5RmllbGQoIC8vIHNvIHRoaXMgZ2V0cyBjYWxsIDMgdGltZXNcbiAgICBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgIHZhciB0bXAgPSBhcnJheS5zbGljZSgpO1xuXG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXN1bHQgPSB0bXAgJiYgdG1wLnBvcCAmJiB0bXAucG9wKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0bXA7XG4gICAgfSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBhcnJheUhlbHBlcnMgPSB7XG4gICAgICBwdXNoOiB0aGlzLnB1c2gsXG4gICAgICBwb3A6IHRoaXMucG9wLFxuICAgICAgc3dhcDogdGhpcy5zd2FwLFxuICAgICAgbW92ZTogdGhpcy5tb3ZlLFxuICAgICAgaW5zZXJ0OiB0aGlzLmluc2VydCxcbiAgICAgIHJlcGxhY2U6IHRoaXMucmVwbGFjZSxcbiAgICAgIHVuc2hpZnQ6IHRoaXMudW5zaGlmdCxcbiAgICAgIHJlbW92ZTogdGhpcy5yZW1vdmUsXG4gICAgICBoYW5kbGVQdXNoOiB0aGlzLmhhbmRsZVB1c2gsXG4gICAgICBoYW5kbGVQb3A6IHRoaXMuaGFuZGxlUG9wLFxuICAgICAgaGFuZGxlU3dhcDogdGhpcy5oYW5kbGVTd2FwLFxuICAgICAgaGFuZGxlTW92ZTogdGhpcy5oYW5kbGVNb3ZlLFxuICAgICAgaGFuZGxlSW5zZXJ0OiB0aGlzLmhhbmRsZUluc2VydCxcbiAgICAgIGhhbmRsZVJlcGxhY2U6IHRoaXMuaGFuZGxlUmVwbGFjZSxcbiAgICAgIGhhbmRsZVVuc2hpZnQ6IHRoaXMuaGFuZGxlVW5zaGlmdCxcbiAgICAgIGhhbmRsZVJlbW92ZTogdGhpcy5oYW5kbGVSZW1vdmVcbiAgICB9O1xuXG4gICAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNvbXBvbmVudCA9IF90aGlzJHByb3BzMi5jb21wb25lbnQsXG4gICAgICAgIHJlbmRlciA9IF90aGlzJHByb3BzMi5yZW5kZXIsXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMyLmNoaWxkcmVuLFxuICAgICAgICBuYW1lID0gX3RoaXMkcHJvcHMyLm5hbWUsXG4gICAgICAgIF90aGlzJHByb3BzMiRmb3JtaWsgPSBfdGhpcyRwcm9wczIuZm9ybWlrLFxuICAgICAgICByZXN0T2ZGb3JtaWsgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wczIkZm9ybWlrLCBbXCJ2YWxpZGF0ZVwiLCBcInZhbGlkYXRpb25TY2hlbWFcIl0pO1xuXG4gICAgdmFyIHByb3BzID0gX2V4dGVuZHMoe30sIGFycmF5SGVscGVycywge1xuICAgICAgZm9ybTogcmVzdE9mRm9ybWlrLFxuICAgICAgbmFtZTogbmFtZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudCA/IGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBwcm9wcykgOiByZW5kZXIgPyByZW5kZXIocHJvcHMpIDogY2hpbGRyZW4gLy8gY2hpbGRyZW4gY29tZSBsYXN0LCBhbHdheXMgY2FsbGVkXG4gICAgPyB0eXBlb2YgY2hpbGRyZW4gPT09ICdmdW5jdGlvbicgPyBjaGlsZHJlbihwcm9wcykgOiAhaXNFbXB0eUNoaWxkcmVuKGNoaWxkcmVuKSA/IENoaWxkcmVuLm9ubHkoY2hpbGRyZW4pIDogbnVsbCA6IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIEZpZWxkQXJyYXlJbm5lcjtcbn0oQ29tcG9uZW50KTtcblxuRmllbGRBcnJheUlubmVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgdmFsaWRhdGVPbkNoYW5nZTogdHJ1ZVxufTtcbnZhciBGaWVsZEFycmF5ID0gLyojX19QVVJFX18qL2Nvbm5lY3QoRmllbGRBcnJheUlubmVyKTtcblxudmFyIEVycm9yTWVzc2FnZUltcGwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoRXJyb3JNZXNzYWdlSW1wbCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRXJyb3JNZXNzYWdlSW1wbCgpIHtcbiAgICByZXR1cm4gX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRXJyb3JNZXNzYWdlSW1wbC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShwcm9wcykge1xuICAgIGlmIChnZXRJbih0aGlzLnByb3BzLmZvcm1pay5lcnJvcnMsIHRoaXMucHJvcHMubmFtZSkgIT09IGdldEluKHByb3BzLmZvcm1pay5lcnJvcnMsIHRoaXMucHJvcHMubmFtZSkgfHwgZ2V0SW4odGhpcy5wcm9wcy5mb3JtaWsudG91Y2hlZCwgdGhpcy5wcm9wcy5uYW1lKSAhPT0gZ2V0SW4ocHJvcHMuZm9ybWlrLnRvdWNoZWQsIHRoaXMucHJvcHMubmFtZSkgfHwgT2JqZWN0LmtleXModGhpcy5wcm9wcykubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhwcm9wcykubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNvbXBvbmVudCA9IF90aGlzJHByb3BzLmNvbXBvbmVudCxcbiAgICAgICAgZm9ybWlrID0gX3RoaXMkcHJvcHMuZm9ybWlrLFxuICAgICAgICByZW5kZXIgPSBfdGhpcyRwcm9wcy5yZW5kZXIsXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIG5hbWUgPSBfdGhpcyRwcm9wcy5uYW1lLFxuICAgICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMsIFtcImNvbXBvbmVudFwiLCBcImZvcm1pa1wiLCBcInJlbmRlclwiLCBcImNoaWxkcmVuXCIsIFwibmFtZVwiXSk7XG5cbiAgICB2YXIgdG91Y2ggPSBnZXRJbihmb3JtaWsudG91Y2hlZCwgbmFtZSk7XG4gICAgdmFyIGVycm9yID0gZ2V0SW4oZm9ybWlrLmVycm9ycywgbmFtZSk7XG4gICAgcmV0dXJuICEhdG91Y2ggJiYgISFlcnJvciA/IHJlbmRlciA/IGlzRnVuY3Rpb24ocmVuZGVyKSA/IHJlbmRlcihlcnJvcikgOiBudWxsIDogY2hpbGRyZW4gPyBpc0Z1bmN0aW9uKGNoaWxkcmVuKSA/IGNoaWxkcmVuKGVycm9yKSA6IG51bGwgOiBjb21wb25lbnQgPyBjcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgcmVzdCwgZXJyb3IpIDogZXJyb3IgOiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBFcnJvck1lc3NhZ2VJbXBsO1xufShDb21wb25lbnQpO1xuXG52YXIgRXJyb3JNZXNzYWdlID0gLyojX19QVVJFX18qL2Nvbm5lY3QoRXJyb3JNZXNzYWdlSW1wbCk7XG5cbi8qKlxyXG4gKiBDdXN0b20gRmllbGQgY29tcG9uZW50IGZvciBxdWlja2x5IGhvb2tpbmcgaW50byBGb3JtaWtcclxuICogY29udGV4dCBhbmQgd2lyaW5nIHVwIGZvcm1zLlxyXG4gKi9cblxudmFyIEZhc3RGaWVsZElubmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKEZhc3RGaWVsZElubmVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBGYXN0RmllbGRJbm5lcihwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgIHZhciByZW5kZXIgPSBwcm9wcy5yZW5kZXIsXG4gICAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIGNvbXBvbmVudCA9IHByb3BzLmNvbXBvbmVudCxcbiAgICAgICAgaXMgPSBwcm9wcy5hcyxcbiAgICAgICAgbmFtZSA9IHByb3BzLm5hbWU7XG4gICAgISFyZW5kZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiPEZhc3RGaWVsZCByZW5kZXI+IGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgYSBjaGlsZCBjYWxsYmFjayBmdW5jdGlvbiBpbnN0ZWFkOiA8RmFzdEZpZWxkIG5hbWU9e1wiICsgbmFtZSArIFwifT57cHJvcHMgPT4gLi4ufTwvRmFzdEZpZWxkPiBpbnN0ZWFkLlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgISEoY29tcG9uZW50ICYmIHJlbmRlcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdZb3Ugc2hvdWxkIG5vdCB1c2UgPEZhc3RGaWVsZCBjb21wb25lbnQ+IGFuZCA8RmFzdEZpZWxkIHJlbmRlcj4gaW4gdGhlIHNhbWUgPEZhc3RGaWVsZD4gY29tcG9uZW50OyA8RmFzdEZpZWxkIGNvbXBvbmVudD4gd2lsbCBiZSBpZ25vcmVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICEhKGlzICYmIGNoaWxkcmVuICYmIGlzRnVuY3Rpb24oY2hpbGRyZW4pKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1lvdSBzaG91bGQgbm90IHVzZSA8RmFzdEZpZWxkIGFzPiBhbmQgPEZhc3RGaWVsZCBjaGlsZHJlbj4gYXMgYSBmdW5jdGlvbiBpbiB0aGUgc2FtZSA8RmFzdEZpZWxkPiBjb21wb25lbnQ7IDxGYXN0RmllbGQgYXM+IHdpbGwgYmUgaWdub3JlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgISEoY29tcG9uZW50ICYmIGNoaWxkcmVuICYmIGlzRnVuY3Rpb24oY2hpbGRyZW4pKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1lvdSBzaG91bGQgbm90IHVzZSA8RmFzdEZpZWxkIGNvbXBvbmVudD4gYW5kIDxGYXN0RmllbGQgY2hpbGRyZW4+IGFzIGEgZnVuY3Rpb24gaW4gdGhlIHNhbWUgPEZhc3RGaWVsZD4gY29tcG9uZW50OyA8RmFzdEZpZWxkIGNvbXBvbmVudD4gd2lsbCBiZSBpZ25vcmVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhIShyZW5kZXIgJiYgY2hpbGRyZW4gJiYgIWlzRW1wdHlDaGlsZHJlbihjaGlsZHJlbikpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnWW91IHNob3VsZCBub3QgdXNlIDxGYXN0RmllbGQgcmVuZGVyPiBhbmQgPEZhc3RGaWVsZCBjaGlsZHJlbj4gaW4gdGhlIHNhbWUgPEZhc3RGaWVsZD4gY29tcG9uZW50OyA8RmFzdEZpZWxkIGNoaWxkcmVuPiB3aWxsIGJlIGlnbm9yZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEZhc3RGaWVsZElubmVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKHByb3BzKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuc2hvdWxkVXBkYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5zaG91bGRVcGRhdGUocHJvcHMsIHRoaXMucHJvcHMpO1xuICAgIH0gZWxzZSBpZiAocHJvcHMubmFtZSAhPT0gdGhpcy5wcm9wcy5uYW1lIHx8IGdldEluKHByb3BzLmZvcm1pay52YWx1ZXMsIHRoaXMucHJvcHMubmFtZSkgIT09IGdldEluKHRoaXMucHJvcHMuZm9ybWlrLnZhbHVlcywgdGhpcy5wcm9wcy5uYW1lKSB8fCBnZXRJbihwcm9wcy5mb3JtaWsuZXJyb3JzLCB0aGlzLnByb3BzLm5hbWUpICE9PSBnZXRJbih0aGlzLnByb3BzLmZvcm1pay5lcnJvcnMsIHRoaXMucHJvcHMubmFtZSkgfHwgZ2V0SW4ocHJvcHMuZm9ybWlrLnRvdWNoZWQsIHRoaXMucHJvcHMubmFtZSkgIT09IGdldEluKHRoaXMucHJvcHMuZm9ybWlrLnRvdWNoZWQsIHRoaXMucHJvcHMubmFtZSkgfHwgT2JqZWN0LmtleXModGhpcy5wcm9wcykubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhwcm9wcykubGVuZ3RoIHx8IHByb3BzLmZvcm1pay5pc1N1Ym1pdHRpbmcgIT09IHRoaXMucHJvcHMuZm9ybWlrLmlzU3VibWl0dGluZykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgLy8gUmVnaXN0ZXIgdGhlIEZpZWxkIHdpdGggdGhlIHBhcmVudCBGb3JtaWsuIFBhcmVudCB3aWxsIGN5Y2xlIHRocm91Z2hcbiAgICAvLyByZWdpc3RlcmVkIEZpZWxkJ3MgdmFsaWRhdGUgZm5zIHJpZ2h0IHByaW9yIHRvIHN1Ym1pdFxuICAgIHRoaXMucHJvcHMuZm9ybWlrLnJlZ2lzdGVyRmllbGQodGhpcy5wcm9wcy5uYW1lLCB7XG4gICAgICB2YWxpZGF0ZTogdGhpcy5wcm9wcy52YWxpZGF0ZVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgaWYgKHRoaXMucHJvcHMubmFtZSAhPT0gcHJldlByb3BzLm5hbWUpIHtcbiAgICAgIHRoaXMucHJvcHMuZm9ybWlrLnVucmVnaXN0ZXJGaWVsZChwcmV2UHJvcHMubmFtZSk7XG4gICAgICB0aGlzLnByb3BzLmZvcm1pay5yZWdpc3RlckZpZWxkKHRoaXMucHJvcHMubmFtZSwge1xuICAgICAgICB2YWxpZGF0ZTogdGhpcy5wcm9wcy52YWxpZGF0ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMudmFsaWRhdGUgIT09IHByZXZQcm9wcy52YWxpZGF0ZSkge1xuICAgICAgdGhpcy5wcm9wcy5mb3JtaWsucmVnaXN0ZXJGaWVsZCh0aGlzLnByb3BzLm5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHRoaXMucHJvcHMudmFsaWRhdGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnByb3BzLmZvcm1pay51bnJlZ2lzdGVyRmllbGQodGhpcy5wcm9wcy5uYW1lKTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIG5hbWUgPSBfdGhpcyRwcm9wcy5uYW1lLFxuICAgICAgICByZW5kZXIgPSBfdGhpcyRwcm9wcy5yZW5kZXIsXG4gICAgICAgIGlzID0gX3RoaXMkcHJvcHMuYXMsXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIGNvbXBvbmVudCA9IF90aGlzJHByb3BzLmNvbXBvbmVudCxcbiAgICAgICAgZm9ybWlrID0gX3RoaXMkcHJvcHMuZm9ybWlrLFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBbXCJ2YWxpZGF0ZVwiLCBcIm5hbWVcIiwgXCJyZW5kZXJcIiwgXCJhc1wiLCBcImNoaWxkcmVuXCIsIFwiY29tcG9uZW50XCIsIFwic2hvdWxkVXBkYXRlXCIsIFwiZm9ybWlrXCJdKTtcblxuICAgIHZhciByZXN0T2ZGb3JtaWsgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShmb3JtaWssIFtcInZhbGlkYXRlXCIsIFwidmFsaWRhdGlvblNjaGVtYVwiXSk7XG5cbiAgICB2YXIgZmllbGQgPSBmb3JtaWsuZ2V0RmllbGRQcm9wcyhfZXh0ZW5kcyh7XG4gICAgICBuYW1lOiBuYW1lXG4gICAgfSwgcHJvcHMpKTtcbiAgICB2YXIgbWV0YSA9IHtcbiAgICAgIHZhbHVlOiBnZXRJbihmb3JtaWsudmFsdWVzLCBuYW1lKSxcbiAgICAgIGVycm9yOiBnZXRJbihmb3JtaWsuZXJyb3JzLCBuYW1lKSxcbiAgICAgIHRvdWNoZWQ6ICEhZ2V0SW4oZm9ybWlrLnRvdWNoZWQsIG5hbWUpLFxuICAgICAgaW5pdGlhbFZhbHVlOiBnZXRJbihmb3JtaWsuaW5pdGlhbFZhbHVlcywgbmFtZSksXG4gICAgICBpbml0aWFsVG91Y2hlZDogISFnZXRJbihmb3JtaWsuaW5pdGlhbFRvdWNoZWQsIG5hbWUpLFxuICAgICAgaW5pdGlhbEVycm9yOiBnZXRJbihmb3JtaWsuaW5pdGlhbEVycm9ycywgbmFtZSlcbiAgICB9O1xuICAgIHZhciBiYWcgPSB7XG4gICAgICBmaWVsZDogZmllbGQsXG4gICAgICBtZXRhOiBtZXRhLFxuICAgICAgZm9ybTogcmVzdE9mRm9ybWlrXG4gICAgfTtcblxuICAgIGlmIChyZW5kZXIpIHtcbiAgICAgIHJldHVybiByZW5kZXIoYmFnKTtcbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbihjaGlsZHJlbikpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbihiYWcpO1xuICAgIH1cblxuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIC8vIFRoaXMgYmVoYXZpb3IgaXMgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGVhcmxpZXIgRm9ybWlrIDAuOSB0byAxLnhcbiAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgaW5uZXJSZWYgPSBwcm9wcy5pbm5lclJlZixcbiAgICAgICAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgW1wiaW5uZXJSZWZcIl0pO1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgICAgICAgIHJlZjogaW5uZXJSZWZcbiAgICAgICAgfSwgZmllbGQsIHJlc3QpLCBjaGlsZHJlbik7XG4gICAgICB9IC8vIFdlIGRvbid0IHBhc3MgYG1ldGFgIGZvciBiYWNrd2FyZHMgY29tcGF0XG5cblxuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBfZXh0ZW5kcyh7XG4gICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgZm9ybTogZm9ybWlrXG4gICAgICB9LCBwcm9wcyksIGNoaWxkcmVuKTtcbiAgICB9IC8vIGRlZmF1bHQgdG8gaW5wdXQgaGVyZSBzbyB3ZSBjYW4gY2hlY2sgZm9yIGJvdGggYGFzYCBhbmQgYGNoaWxkcmVuYCBhYm92ZVxuXG5cbiAgICB2YXIgYXNFbGVtZW50ID0gaXMgfHwgJ2lucHV0JztcblxuICAgIGlmICh0eXBlb2YgYXNFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIF9pbm5lclJlZiA9IHByb3BzLmlubmVyUmVmLFxuICAgICAgICAgIF9yZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIFtcImlubmVyUmVmXCJdKTtcblxuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoYXNFbGVtZW50LCBfZXh0ZW5kcyh7XG4gICAgICAgIHJlZjogX2lubmVyUmVmXG4gICAgICB9LCBmaWVsZCwgX3Jlc3QpLCBjaGlsZHJlbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoYXNFbGVtZW50LCBfZXh0ZW5kcyh7fSwgZmllbGQsIHByb3BzKSwgY2hpbGRyZW4pO1xuICB9O1xuXG4gIHJldHVybiBGYXN0RmllbGRJbm5lcjtcbn0oQ29tcG9uZW50KTtcblxudmFyIEZhc3RGaWVsZCA9IC8qI19fUFVSRV9fKi9jb25uZWN0KEZhc3RGaWVsZElubmVyKTtcblxuZXhwb3J0IHsgRXJyb3JNZXNzYWdlLCBGYXN0RmllbGQsIEZpZWxkLCBGaWVsZEFycmF5LCBGb3JtLCBGb3JtaWssIEZvcm1pa0NvbnN1bWVyLCBGb3JtaWtDb250ZXh0LCBGb3JtaWtQcm92aWRlciwgY29ubmVjdCwgZ2V0QWN0aXZlRWxlbWVudCwgZ2V0SW4sIGluc2VydCwgaXNFbXB0eUFycmF5LCBpc0VtcHR5Q2hpbGRyZW4sIGlzRnVuY3Rpb24sIGlzSW5wdXRFdmVudCwgaXNJbnRlZ2VyLCBpc05hTiQxIGFzIGlzTmFOLCBpc09iamVjdCwgaXNQcm9taXNlLCBpc1N0cmluZywgbW92ZSwgcHJlcGFyZURhdGFGb3JWYWxpZGF0aW9uLCByZXBsYWNlLCBzZXRJbiwgc2V0TmVzdGVkT2JqZWN0VmFsdWVzLCBzd2FwLCB1c2VGaWVsZCwgdXNlRm9ybWlrLCB1c2VGb3JtaWtDb250ZXh0LCB2YWxpZGF0ZVl1cFNjaGVtYSwgd2l0aEZvcm1paywgeXVwVG9Gb3JtRXJyb3JzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtaWsuZXNtLmpzLm1hcFxuIiwiaW1wb3J0IHsgbWFrZU9ic2VydmFibGUgfSBmcm9tIFwibW9ieFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmlmICghdXNlU3RhdGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtb2J4LXJlYWN0LWxpdGUgcmVxdWlyZXMgUmVhY3Qgd2l0aCBIb29rcyBzdXBwb3J0XCIpO1xufVxuaWYgKCFtYWtlT2JzZXJ2YWJsZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1vYngtcmVhY3QtbGl0ZUAzIHJlcXVpcmVzIG1vYnggYXQgbGVhc3QgdmVyc2lvbiA2IHRvIGJlIGF2YWlsYWJsZVwiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VydEVudmlyb25tZW50LmpzLm1hcCIsImV4cG9ydCB7IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIH0gZnJvbSBcInJlYWN0LWRvbVwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3RCYXRjaGVkVXBkYXRlcy5qcy5tYXAiLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tIFwibW9ieFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHROb29wQmF0Y2goY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmVyQmF0Y2hpbmcocmVhY3Rpb25TY2hlZHVsZXIpIHtcbiAgICBpZiAoIXJlYWN0aW9uU2NoZWR1bGVyKSB7XG4gICAgICAgIHJlYWN0aW9uU2NoZWR1bGVyID0gZGVmYXVsdE5vb3BCYXRjaDtcbiAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW01vYlhdIEZhaWxlZCB0byBnZXQgdW5zdGFibGVfYmF0Y2hlZCB1cGRhdGVzIGZyb20gcmVhY3QtZG9tIC8gcmVhY3QtbmF0aXZlXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbmZpZ3VyZSh7IHJlYWN0aW9uU2NoZWR1bGVyOiByZWFjdGlvblNjaGVkdWxlciB9KTtcbn1cbmV4cG9ydCB2YXIgaXNPYnNlcnZlckJhdGNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbTW9iWF0gRGVwcmVjYXRlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2ZXJCYXRjaGluZy5qcy5tYXAiLCJpbXBvcnQgeyBnZXREZXBlbmRlbmN5VHJlZSB9IGZyb20gXCJtb2J4XCI7XG5leHBvcnQgZnVuY3Rpb24gcHJpbnREZWJ1Z1ZhbHVlKHYpIHtcbiAgICByZXR1cm4gZ2V0RGVwZW5kZW5jeVRyZWUodik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmludERlYnVnVmFsdWUuanMubWFwIiwiZXhwb3J0IHZhciBSRUdJU1RSWV9GSU5BTElaRV9BRlRFUiA9IDEwMDAwO1xuZXhwb3J0IHZhciBSRUdJU1RSWV9TV0VFUF9JTlRFUlZBTCA9IDEwMDAwO1xudmFyIFRpbWVyQmFzZWRGaW5hbGl6YXRpb25SZWdpc3RyeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaW1lckJhc2VkRmluYWxpemF0aW9uUmVnaXN0cnkoZmluYWxpemUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmluYWxpemVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZpbmFsaXplXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWdpc3RyYXRpb25zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN3ZWVwVGltZW91dFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBCb3VuZCBzbyBpdCBjYW4gYmUgdXNlZCBkaXJlY3RseSBhcyBzZXRUaW1lb3V0IGNhbGxiYWNrLlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzd2VlcFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKG1heEFnZSkge1xuICAgICAgICAgICAgICAgIGlmIChtYXhBZ2UgPT09IHZvaWQgMCkgeyBtYXhBZ2UgPSBSRUdJU1RSWV9GSU5BTElaRV9BRlRFUjsgfVxuICAgICAgICAgICAgICAgIC8vIGNhbmNlbCB0aW1lb3V0IHNvIHdlIGNhbiBmb3JjZSBzd2VlcCBhbnl0aW1lXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnN3ZWVwVGltZW91dCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3dlZXBUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlZ2lzdHJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocmVnaXN0cmF0aW9uLCB0b2tlbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm93IC0gcmVnaXN0cmF0aW9uLnJlZ2lzdGVyZWRBdCA+PSBtYXhBZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmZpbmFsaXplKHJlZ2lzdHJhdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWdpc3RyYXRpb25zLmRlbGV0ZSh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVnaXN0cmF0aW9ucy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zY2hlZHVsZVN3ZWVwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQm91bmQgc28gaXQgY2FuIGJlIGV4cG9ydGVkIGRpcmVjdGx5IGFzIGNsZWFyVGltZXJzIHRlc3QgdXRpbGl0eS5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmluYWxpemVBbGxJbW1lZGlhdGVseVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnN3ZWVwKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gVG9rZW4gaXMgYWN0dWFsbHkgcmVxdWlyZWQgd2l0aCB0aGlzIGltcGxcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGltZXJCYXNlZEZpbmFsaXphdGlvblJlZ2lzdHJ5LnByb3RvdHlwZSwgXCJyZWdpc3RlclwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHRhcmdldCwgdmFsdWUsIHRva2VuKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdHJhdGlvbnMuc2V0KHRva2VuLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWRBdDogRGF0ZS5ub3coKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlU3dlZXAoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaW1lckJhc2VkRmluYWxpemF0aW9uUmVnaXN0cnkucHJvdG90eXBlLCBcInVucmVnaXN0ZXJcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RyYXRpb25zLmRlbGV0ZSh0b2tlbik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGltZXJCYXNlZEZpbmFsaXphdGlvblJlZ2lzdHJ5LnByb3RvdHlwZSwgXCJzY2hlZHVsZVN3ZWVwXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zd2VlcFRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3dlZXBUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLnN3ZWVwLCBSRUdJU1RSWV9TV0VFUF9JTlRFUlZBTCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gVGltZXJCYXNlZEZpbmFsaXphdGlvblJlZ2lzdHJ5O1xufSgpKTtcbmV4cG9ydCB7IFRpbWVyQmFzZWRGaW5hbGl6YXRpb25SZWdpc3RyeSB9O1xuZXhwb3J0IHZhciBVbml2ZXJzYWxGaW5hbGl6YXRpb25SZWdpc3RyeSA9IHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSAhPT0gXCJ1bmRlZmluZWRcIlxuICAgID8gRmluYWxpemF0aW9uUmVnaXN0cnlcbiAgICA6IFRpbWVyQmFzZWRGaW5hbGl6YXRpb25SZWdpc3RyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVuaXZlcnNhbEZpbmFsaXphdGlvblJlZ2lzdHJ5LmpzLm1hcCIsImltcG9ydCB7IFVuaXZlcnNhbEZpbmFsaXphdGlvblJlZ2lzdHJ5IH0gZnJvbSBcIi4vVW5pdmVyc2FsRmluYWxpemF0aW9uUmVnaXN0cnlcIjtcbmV4cG9ydCB2YXIgb2JzZXJ2ZXJGaW5hbGl6YXRpb25SZWdpc3RyeSA9IG5ldyBVbml2ZXJzYWxGaW5hbGl6YXRpb25SZWdpc3RyeShmdW5jdGlvbiAoYWRtKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IGFkbS5yZWFjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc3Bvc2UoKTtcbiAgICBhZG0ucmVhY3Rpb24gPSBudWxsO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZlckZpbmFsaXphdGlvblJlZ2lzdHJ5LmpzLm1hcCIsInZhciBnbG9iYWxJc1VzaW5nU3RhdGljUmVuZGVyaW5nID0gZmFsc2U7XG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlU3RhdGljUmVuZGVyaW5nKGVuYWJsZSkge1xuICAgIGdsb2JhbElzVXNpbmdTdGF0aWNSZW5kZXJpbmcgPSBlbmFibGU7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNVc2luZ1N0YXRpY1JlbmRlcmluZygpIHtcbiAgICByZXR1cm4gZ2xvYmFsSXNVc2luZ1N0YXRpY1JlbmRlcmluZztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRpY1JlbmRlcmluZy5qcy5tYXAiLCJ2YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG5pbXBvcnQgeyBSZWFjdGlvbiB9IGZyb20gXCJtb2J4XCI7XG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBwcmludERlYnVnVmFsdWUgfSBmcm9tIFwiLi91dGlscy9wcmludERlYnVnVmFsdWVcIjtcbmltcG9ydCB7IG9ic2VydmVyRmluYWxpemF0aW9uUmVnaXN0cnkgfSBmcm9tIFwiLi91dGlscy9vYnNlcnZlckZpbmFsaXphdGlvblJlZ2lzdHJ5XCI7XG5pbXBvcnQgeyBpc1VzaW5nU3RhdGljUmVuZGVyaW5nIH0gZnJvbSBcIi4vc3RhdGljUmVuZGVyaW5nXCI7XG5mdW5jdGlvbiBvYnNlcnZlckNvbXBvbmVudE5hbWVGb3IoYmFzZUNvbXBvbmVudE5hbWUpIHtcbiAgICByZXR1cm4gXCJvYnNlcnZlclwiLmNvbmNhdChiYXNlQ29tcG9uZW50TmFtZSk7XG59XG4vKipcbiAqIFdlIHVzZSBjbGFzcyB0byBtYWtlIGl0IGVhc2llciB0byBkZXRlY3QgaW4gaGVhcCBzbmFwc2hvdHMgYnkgbmFtZVxuICovXG52YXIgT2JqZWN0VG9CZVJldGFpbmVkQnlSZWFjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPYmplY3RUb0JlUmV0YWluZWRCeVJlYWN0KCkge1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0VG9CZVJldGFpbmVkQnlSZWFjdDtcbn0oKSk7XG5mdW5jdGlvbiBvYmplY3RUb0JlUmV0YWluZWRCeVJlYWN0RmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IE9iamVjdFRvQmVSZXRhaW5lZEJ5UmVhY3QoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VPYnNlcnZlcihmbiwgYmFzZUNvbXBvbmVudE5hbWUpIHtcbiAgICBpZiAoYmFzZUNvbXBvbmVudE5hbWUgPT09IHZvaWQgMCkgeyBiYXNlQ29tcG9uZW50TmFtZSA9IFwib2JzZXJ2ZWRcIjsgfVxuICAgIGlmIChpc1VzaW5nU3RhdGljUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfVxuICAgIHZhciBfYSA9IF9fcmVhZChSZWFjdC51c2VTdGF0ZShvYmplY3RUb0JlUmV0YWluZWRCeVJlYWN0RmFjdG9yeSksIDEpLCBvYmplY3RSZXRhaW5lZEJ5UmVhY3QgPSBfYVswXTtcbiAgICAvLyBGb3JjZSB1cGRhdGUsIHNlZSAjMjk4MlxuICAgIHZhciBfYiA9IF9fcmVhZChSZWFjdC51c2VTdGF0ZSgpLCAyKSwgc2V0U3RhdGUgPSBfYlsxXTtcbiAgICB2YXIgZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXRTdGF0ZShbXSk7IH07XG4gICAgLy8gU3RyaWN0TW9kZS9Db25jdXJyZW50TW9kZS9TdXNwZW5zZSBtYXkgbWVhbiB0aGF0IG91ciBjb21wb25lbnQgaXNcbiAgICAvLyByZW5kZXJlZCBhbmQgYWJhbmRvbmVkIG11bHRpcGxlIHRpbWVzLCBzbyB3ZSBuZWVkIHRvIHRyYWNrIGxlYWtlZFxuICAgIC8vIFJlYWN0aW9ucy5cbiAgICB2YXIgYWRtUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIGlmICghYWRtUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgLy8gRmlyc3QgcmVuZGVyXG4gICAgICAgIGFkbVJlZi5jdXJyZW50ID0ge1xuICAgICAgICAgICAgcmVhY3Rpb246IG51bGwsXG4gICAgICAgICAgICBtb3VudGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGNoYW5nZWRCZWZvcmVNb3VudDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGFkbSA9IGFkbVJlZi5jdXJyZW50O1xuICAgIGlmICghYWRtLnJlYWN0aW9uKSB7XG4gICAgICAgIC8vIEZpcnN0IHJlbmRlciBvciBjb21wb25lbnQgd2FzIG5vdCBjb21taXR0ZWQgYW5kIHJlYWN0aW9uIHdhcyBkaXNwb3NlZCBieSByZWdpc3RyeVxuICAgICAgICBhZG0ucmVhY3Rpb24gPSBuZXcgUmVhY3Rpb24ob2JzZXJ2ZXJDb21wb25lbnROYW1lRm9yKGJhc2VDb21wb25lbnROYW1lKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gT2JzZXJ2YWJsZSBoYXMgY2hhbmdlZCwgbWVhbmluZyB3ZSB3YW50IHRvIHJlLXJlbmRlclxuICAgICAgICAgICAgLy8gQlVUIGlmIHdlJ3JlIGEgY29tcG9uZW50IHRoYXQgaGFzbid0IHlldCBnb3QgdG8gdGhlIHVzZUVmZmVjdCgpXG4gICAgICAgICAgICAvLyBzdGFnZSwgd2UgbWlnaHQgYmUgYSBjb21wb25lbnQgdGhhdCBfc3RhcnRlZF8gdG8gcmVuZGVyLCBidXRcbiAgICAgICAgICAgIC8vIGdvdCBkcm9wcGVkLCBhbmQgd2UgZG9uJ3Qgd2FudCB0byBtYWtlIHN0YXRlIGNoYW5nZXMgdGhlbi5cbiAgICAgICAgICAgIC8vIChJdCB0cmlnZ2VycyB3YXJuaW5ncyBpbiBTdHJpY3RNb2RlLCBmb3IgYSBzdGFydC4pXG4gICAgICAgICAgICBpZiAoYWRtLm1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHJlYWNoZWQgdXNlRWZmZWN0KCksIHNvIHdlJ3JlIG1vdW50ZWQsIGFuZCBjYW4gdHJpZ2dlciBhbiB1cGRhdGVcbiAgICAgICAgICAgICAgICBmb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZW4ndCB5ZXQgcmVhY2hlZCB1c2VFZmZlY3QoKSwgc28gd2UnbGwgbmVlZCB0byB0cmlnZ2VyIGEgcmUtcmVuZGVyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiAoYW5kIGlmKSB1c2VFZmZlY3QoKSBhcnJpdmVzLlxuICAgICAgICAgICAgICAgIGFkbS5jaGFuZ2VkQmVmb3JlTW91bnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgb2JzZXJ2ZXJGaW5hbGl6YXRpb25SZWdpc3RyeS5yZWdpc3RlcihvYmplY3RSZXRhaW5lZEJ5UmVhY3QsIGFkbSwgYWRtKTtcbiAgICB9XG4gICAgUmVhY3QudXNlRGVidWdWYWx1ZShhZG0ucmVhY3Rpb24sIHByaW50RGVidWdWYWx1ZSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2JzZXJ2ZXJGaW5hbGl6YXRpb25SZWdpc3RyeS51bnJlZ2lzdGVyKGFkbSk7XG4gICAgICAgIGFkbS5tb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGFkbS5yZWFjdGlvbikge1xuICAgICAgICAgICAgaWYgKGFkbS5jaGFuZ2VkQmVmb3JlTW91bnQpIHtcbiAgICAgICAgICAgICAgICAvLyBHb3QgYSBjaGFuZ2UgYmVmb3JlIG1vdW50LCBmb3JjZSBhbiB1cGRhdGVcbiAgICAgICAgICAgICAgICBhZG0uY2hhbmdlZEJlZm9yZU1vdW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZSByZWFjdGlvbiB3ZSBzZXQgdXAgaW4gb3VyIHJlbmRlciBoYXMgYmVlbiBkaXNwb3NlZC5cbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIGJlIGR1ZSB0byBiYWQgdGltaW5ncyBvZiByZW5kZXJpbmdzLCBlLmcuIG91clxuICAgICAgICAgICAgLy8gY29tcG9uZW50IHdhcyBwYXVzZWQgZm9yIGEgX3ZlcnlfIGxvbmcgdGltZSwgYW5kIG91clxuICAgICAgICAgICAgLy8gcmVhY3Rpb24gZ290IGNsZWFuZWQgdXBcbiAgICAgICAgICAgIC8vIFJlLWNyZWF0ZSB0aGUgcmVhY3Rpb25cbiAgICAgICAgICAgIGFkbS5yZWFjdGlvbiA9IG5ldyBSZWFjdGlvbihvYnNlcnZlckNvbXBvbmVudE5hbWVGb3IoYmFzZUNvbXBvbmVudE5hbWUpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UndmUgZGVmaW5pdGVseSBhbHJlYWR5IGJlZW4gbW91bnRlZCBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICAgICAgZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYWRtLnJlYWN0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIGFkbS5yZWFjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBhZG0ubW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYWRtLmNoYW5nZWRCZWZvcmVNb3VudCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICAvLyByZW5kZXIgdGhlIG9yaWdpbmFsIGNvbXBvbmVudCwgYnV0IGhhdmUgdGhlXG4gICAgLy8gcmVhY3Rpb24gdHJhY2sgdGhlIG9ic2VydmFibGVzLCBzbyB0aGF0IHJlbmRlcmluZ1xuICAgIC8vIGNhbiBiZSBpbnZhbGlkYXRlZCAoc2VlIGFib3ZlKSBvbmNlIGEgZGVwZW5kZW5jeSBjaGFuZ2VzXG4gICAgdmFyIHJlbmRlcmluZztcbiAgICB2YXIgZXhjZXB0aW9uO1xuICAgIGFkbS5yZWFjdGlvbi50cmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZW5kZXJpbmcgPSBmbigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBleGNlcHRpb24gPSBlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGV4Y2VwdGlvbikge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247IC8vIHJlLXRocm93IGFueSBleGNlcHRpb25zIGNhdWdodCBkdXJpbmcgcmVuZGVyaW5nXG4gICAgfVxuICAgIHJldHVybiByZW5kZXJpbmc7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VPYnNlcnZlci5qcy5tYXAiLCJpbXBvcnQgeyBmb3J3YXJkUmVmLCBtZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBpc1VzaW5nU3RhdGljUmVuZGVyaW5nIH0gZnJvbSBcIi4vc3RhdGljUmVuZGVyaW5nXCI7XG5pbXBvcnQgeyB1c2VPYnNlcnZlciB9IGZyb20gXCIuL3VzZU9ic2VydmVyXCI7XG52YXIgd2Fybk9ic2VydmVyT3B0aW9uc0RlcHJlY2F0ZWQgPSB0cnVlO1xudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuZm9yO1xuLy8gVXNpbmcgcmVhY3QtaXMgaGFkIHNvbWUgaXNzdWVzIChhbmQgb3BlcmF0ZXMgb24gZWxlbWVudHMsIG5vdCBvbiB0eXBlcyksIHNlZSAjNjA4IC8gIzYwOVxudmFyIFJlYWN0Rm9yd2FyZFJlZlN5bWJvbCA9IGhhc1N5bWJvbFxuICAgID8gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpXG4gICAgOiB0eXBlb2YgZm9yd2FyZFJlZiA9PT0gXCJmdW5jdGlvblwiICYmIGZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiBudWxsOyB9KVtcIiQkdHlwZW9mXCJdO1xudmFyIFJlYWN0TWVtb1N5bWJvbCA9IGhhc1N5bWJvbFxuICAgID8gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIilcbiAgICA6IHR5cGVvZiBtZW1vID09PSBcImZ1bmN0aW9uXCIgJiYgbWVtbyhmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIG51bGw7IH0pW1wiJCR0eXBlb2ZcIl07XG4vLyBuLmIuIGJhc2UgY2FzZSBpcyBub3QgdXNlZCBmb3IgYWN0dWFsIHR5cGluZ3Mgb3IgZXhwb3J0ZWQgaW4gdGhlIHR5cGluZyBmaWxlc1xuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmVyKGJhc2VDb21wb25lbnQsIFxuLy8gVE9ETyByZW1vdmUgaW4gbmV4dCBtYWpvclxub3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHdhcm5PYnNlcnZlck9wdGlvbnNEZXByZWNhdGVkICYmIG9wdGlvbnMpIHtcbiAgICAgICAgd2Fybk9ic2VydmVyT3B0aW9uc0RlcHJlY2F0ZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW21vYngtcmVhY3QtbGl0ZV0gYG9ic2VydmVyKGZuLCB7IGZvcndhcmRSZWY6IHRydWUgfSlgIGlzIGRlcHJlY2F0ZWQsIHVzZSBgb2JzZXJ2ZXIoUmVhY3QuZm9yd2FyZFJlZihmbikpYFwiKTtcbiAgICB9XG4gICAgaWYgKFJlYWN0TWVtb1N5bWJvbCAmJiBiYXNlQ29tcG9uZW50W1wiJCR0eXBlb2ZcIl0gPT09IFJlYWN0TWVtb1N5bWJvbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbbW9ieC1yZWFjdC1saXRlXSBZb3UgYXJlIHRyeWluZyB0byB1c2UgYG9ic2VydmVyYCBvbiBhIGZ1bmN0aW9uIGNvbXBvbmVudCB3cmFwcGVkIGluIGVpdGhlciBhbm90aGVyIGBvYnNlcnZlcmAgb3IgYFJlYWN0Lm1lbW9gLiBUaGUgb2JzZXJ2ZXIgYWxyZWFkeSBhcHBsaWVzICdSZWFjdC5tZW1vJyBmb3IgeW91LlwiKTtcbiAgICB9XG4gICAgLy8gVGhlIHdvcmtpbmcgb2Ygb2JzZXJ2ZXIgaXMgZXhwbGFpbmVkIHN0ZXAgYnkgc3RlcCBpbiB0aGlzIHRhbGs6IGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9Y1BGNGlCZWRvRjAmZmVhdHVyZT15b3V0dS5iZSZ0PTEzMDdcbiAgICBpZiAoaXNVc2luZ1N0YXRpY1JlbmRlcmluZygpKSB7XG4gICAgICAgIHJldHVybiBiYXNlQ29tcG9uZW50O1xuICAgIH1cbiAgICB2YXIgdXNlRm9yd2FyZFJlZiA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mb3J3YXJkUmVmKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICB2YXIgcmVuZGVyID0gYmFzZUNvbXBvbmVudDtcbiAgICB2YXIgYmFzZUNvbXBvbmVudE5hbWUgPSBiYXNlQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IGJhc2VDb21wb25lbnQubmFtZTtcbiAgICAvLyBJZiBhbHJlYWR5IHdyYXBwZWQgd2l0aCBmb3J3YXJkUmVmLCB1bndyYXAsXG4gICAgLy8gc28gd2UgY2FuIHBhdGNoIHJlbmRlciBhbmQgYXBwbHkgbWVtb1xuICAgIGlmIChSZWFjdEZvcndhcmRSZWZTeW1ib2wgJiYgYmFzZUNvbXBvbmVudFtcIiQkdHlwZW9mXCJdID09PSBSZWFjdEZvcndhcmRSZWZTeW1ib2wpIHtcbiAgICAgICAgdXNlRm9yd2FyZFJlZiA9IHRydWU7XG4gICAgICAgIHJlbmRlciA9IGJhc2VDb21wb25lbnRbXCJyZW5kZXJcIl07XG4gICAgICAgIGlmICh0eXBlb2YgcmVuZGVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlttb2J4LXJlYWN0LWxpdGVdIGByZW5kZXJgIHByb3BlcnR5IG9mIEZvcndhcmRSZWYgd2FzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBvYnNlcnZlckNvbXBvbmVudCA9IGZ1bmN0aW9uIChwcm9wcywgcmVmKSB7XG4gICAgICAgIHJldHVybiB1c2VPYnNlcnZlcihmdW5jdGlvbiAoKSB7IHJldHVybiByZW5kZXIocHJvcHMsIHJlZik7IH0sIGJhc2VDb21wb25lbnROYW1lKTtcbiAgICB9O1xuICAgIC8vIERvbid0IHNldCBgZGlzcGxheU5hbWVgIGZvciBhbm9ueW1vdXMgY29tcG9uZW50cyxcbiAgICAvLyBzbyB0aGUgYGRpc3BsYXlOYW1lYCBjYW4gYmUgY3VzdG9taXplZCBieSB1c2VyLCBzZWUgIzMxOTIuXG4gICAgaWYgKGJhc2VDb21wb25lbnROYW1lICE9PSBcIlwiKSB7XG4gICAgICAgIDtcbiAgICAgICAgb2JzZXJ2ZXJDb21wb25lbnQuZGlzcGxheU5hbWUgPSBiYXNlQ29tcG9uZW50TmFtZTtcbiAgICB9XG4gICAgLy8gU3VwcG9ydCBsZWdhY3kgY29udGV4dDogYGNvbnRleHRUeXBlc2AgbXVzdCBiZSBhcHBsaWVkIGJlZm9yZSBgbWVtb2BcbiAgICBpZiAoYmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgO1xuICAgICAgICBvYnNlcnZlckNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBiYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlcztcbiAgICB9XG4gICAgaWYgKHVzZUZvcndhcmRSZWYpIHtcbiAgICAgICAgLy8gYGZvcndhcmRSZWZgIG11c3QgYmUgYXBwbGllZCBwcmlvciBgbWVtb2BcbiAgICAgICAgLy8gYGZvcndhcmRSZWYob2JzZXJ2ZXIoY21wKSlgIHRocm93czpcbiAgICAgICAgLy8gXCJmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCByZWNlaXZlZCBhIGBtZW1vYCBjb21wb25lbnQuIEluc3RlYWQgb2YgZm9yd2FyZFJlZihtZW1vKC4uLikpLCB1c2UgbWVtbyhmb3J3YXJkUmVmKC4uLikpXCJcbiAgICAgICAgb2JzZXJ2ZXJDb21wb25lbnQgPSBmb3J3YXJkUmVmKG9ic2VydmVyQ29tcG9uZW50KTtcbiAgICB9XG4gICAgLy8gbWVtbzsgd2UgYXJlIG5vdCBpbnRlcmVzdGVkIGluIGRlZXAgdXBkYXRlc1xuICAgIC8vIGluIHByb3BzOyB3ZSBhc3N1bWUgdGhhdCBpZiBkZWVwIG9iamVjdHMgYXJlIGNoYW5nZWQsXG4gICAgLy8gdGhpcyBpcyBpbiBvYnNlcnZhYmxlcywgd2hpY2ggd291bGQgaGF2ZSBiZWVuIHRyYWNrZWQgYW55d2F5XG4gICAgb2JzZXJ2ZXJDb21wb25lbnQgPSBtZW1vKG9ic2VydmVyQ29tcG9uZW50KTtcbiAgICBjb3B5U3RhdGljUHJvcGVydGllcyhiYXNlQ29tcG9uZW50LCBvYnNlcnZlckNvbXBvbmVudCk7XG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JzZXJ2ZXJDb21wb25lbnQsIFwiY29udGV4dFR5cGVzXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbbW9ieC1yZWFjdC1saXRlXSBgXCIuY29uY2F0KHRoaXMuZGlzcGxheU5hbWUgfHwgKChfYSA9IHRoaXMudHlwZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc3BsYXlOYW1lKSB8fCBcIkNvbXBvbmVudFwiLCBcIi5jb250ZXh0VHlwZXNgIG11c3QgYmUgc2V0IGJlZm9yZSBhcHBseWluZyBgb2JzZXJ2ZXJgLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb2JzZXJ2ZXJDb21wb25lbnQ7XG59XG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbXJpZGd3YXkvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvYmxvYi9tYXN0ZXIvc3JjL2luZGV4LmpzXG52YXIgaG9pc3RCbGFja0xpc3QgPSB7XG4gICAgJCR0eXBlb2Y6IHRydWUsXG4gICAgcmVuZGVyOiB0cnVlLFxuICAgIGNvbXBhcmU6IHRydWUsXG4gICAgdHlwZTogdHJ1ZSxcbiAgICAvLyBEb24ndCByZWRlZmluZSBgZGlzcGxheU5hbWVgLFxuICAgIC8vIGl0J3MgZGVmaW5lZCBhcyBnZXR0ZXItc2V0dGVyIHBhaXIgb24gYG1lbW9gIChzZWUgIzMxOTIpLlxuICAgIGRpc3BsYXlOYW1lOiB0cnVlXG59O1xuZnVuY3Rpb24gY29weVN0YXRpY1Byb3BlcnRpZXMoYmFzZSwgdGFyZ2V0KSB7XG4gICAgT2JqZWN0LmtleXMoYmFzZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghaG9pc3RCbGFja0xpc3Rba2V5XSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIGtleSkpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZlci5qcy5tYXAiLCJpbXBvcnQgeyB1c2VPYnNlcnZlciB9IGZyb20gXCIuL3VzZU9ic2VydmVyXCI7XG5mdW5jdGlvbiBPYnNlcnZlckNvbXBvbmVudChfYSkge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCByZW5kZXIgPSBfYS5yZW5kZXI7XG4gICAgdmFyIGNvbXBvbmVudCA9IGNoaWxkcmVuIHx8IHJlbmRlcjtcbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdXNlT2JzZXJ2ZXIoY29tcG9uZW50KTtcbn1cbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICBPYnNlcnZlckNvbXBvbmVudC5wcm9wVHlwZXMgPSB7XG4gICAgICAgIGNoaWxkcmVuOiBPYnNlcnZlclByb3BzQ2hlY2ssXG4gICAgICAgIHJlbmRlcjogT2JzZXJ2ZXJQcm9wc0NoZWNrXG4gICAgfTtcbn1cbk9ic2VydmVyQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gXCJPYnNlcnZlclwiO1xuZXhwb3J0IHsgT2JzZXJ2ZXJDb21wb25lbnQgYXMgT2JzZXJ2ZXIgfTtcbmZ1bmN0aW9uIE9ic2VydmVyUHJvcHNDaGVjayhwcm9wcywga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIGV4dHJhS2V5ID0ga2V5ID09PSBcImNoaWxkcmVuXCIgPyBcInJlbmRlclwiIDogXCJjaGlsZHJlblwiO1xuICAgIHZhciBoYXNQcm9wID0gdHlwZW9mIHByb3BzW2tleV0gPT09IFwiZnVuY3Rpb25cIjtcbiAgICB2YXIgaGFzRXh0cmFQcm9wID0gdHlwZW9mIHByb3BzW2V4dHJhS2V5XSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIGlmIChoYXNQcm9wICYmIGhhc0V4dHJhUHJvcCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiTW9iWCBPYnNlcnZlcjogRG8gbm90IHVzZSBjaGlsZHJlbiBhbmQgcmVuZGVyIGluIHRoZSBzYW1lIHRpbWUgaW5gXCIgKyBjb21wb25lbnROYW1lKTtcbiAgICB9XG4gICAgaWYgKGhhc1Byb3AgfHwgaGFzRXh0cmFQcm9wKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKFwiSW52YWxpZCBwcm9wIGBcIiArXG4gICAgICAgIHByb3BGdWxsTmFtZSArXG4gICAgICAgIFwiYCBvZiB0eXBlIGBcIiArXG4gICAgICAgIHR5cGVvZiBwcm9wc1trZXldICtcbiAgICAgICAgXCJgIHN1cHBsaWVkIHRvXCIgK1xuICAgICAgICBcIiBgXCIgK1xuICAgICAgICBjb21wb25lbnROYW1lICtcbiAgICAgICAgXCJgLCBleHBlY3RlZCBgZnVuY3Rpb25gLlwiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmVyQ29tcG9uZW50LmpzLm1hcCIsImltcG9ydCB7IG9ic2VydmFibGUgfSBmcm9tIFwibW9ieFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2NhbE9ic2VydmFibGUoaW5pdGlhbGl6ZXIsIGFubm90YXRpb25zKSB7XG4gICAgcmV0dXJuIHVzZVN0YXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9ic2VydmFibGUoaW5pdGlhbGl6ZXIoKSwgYW5ub3RhdGlvbnMsIHsgYXV0b0JpbmQ6IHRydWUgfSk7IH0pWzBdO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlTG9jYWxPYnNlcnZhYmxlLmpzLm1hcCIsInZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbmltcG9ydCB7IHVzZURlcHJlY2F0ZWQgfSBmcm9tIFwiLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgb2JzZXJ2YWJsZSwgcnVuSW5BY3Rpb24gfSBmcm9tIFwibW9ieFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VBc09ic2VydmFibGVTb3VyY2UoY3VycmVudCkge1xuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpXG4gICAgICAgIHVzZURlcHJlY2F0ZWQoXCJbbW9ieC1yZWFjdC1saXRlXSAndXNlQXNPYnNlcnZhYmxlU291cmNlJyBpcyBkZXByZWNhdGVkLCBwbGVhc2Ugc3RvcmUgdGhlIHZhbHVlcyBkaXJlY3RseSBpbiBhbiBvYnNlcnZhYmxlLCBmb3IgZXhhbXBsZSBieSB1c2luZyAndXNlTG9jYWxPYnNlcnZhYmxlJywgYW5kIHN5bmMgZnV0dXJlIHVwZGF0ZXMgdXNpbmcgJ3VzZUVmZmVjdCcgd2hlbiBuZWVkZWQuIFNlZSB0aGUgUkVBRE1FIGZvciBleGFtcGxlcy5cIik7XG4gICAgdmFyIF9hID0gX19yZWFkKHVzZVN0YXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9ic2VydmFibGUoY3VycmVudCwge30sIHsgZGVlcDogZmFsc2UgfSk7IH0pLCAxKSwgcmVzID0gX2FbMF07XG4gICAgcnVuSW5BY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHJlcywgY3VycmVudCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZUFzT2JzZXJ2YWJsZVNvdXJjZS5qcy5tYXAiLCJpbXBvcnQgeyBvYnNlcnZhYmxlIH0gZnJvbSBcIm1vYnhcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VEZXByZWNhdGVkIH0gZnJvbSBcIi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IHVzZUFzT2JzZXJ2YWJsZVNvdXJjZSB9IGZyb20gXCIuL3VzZUFzT2JzZXJ2YWJsZVNvdXJjZVwiO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxvY2FsU3RvcmUoaW5pdGlhbGl6ZXIsIGN1cnJlbnQpIHtcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKVxuICAgICAgICB1c2VEZXByZWNhdGVkKFwiW21vYngtcmVhY3QtbGl0ZV0gJ3VzZUxvY2FsU3RvcmUnIGlzIGRlcHJlY2F0ZWQsIHVzZSAndXNlTG9jYWxPYnNlcnZhYmxlJyBpbnN0ZWFkLlwiKTtcbiAgICB2YXIgc291cmNlID0gY3VycmVudCAmJiB1c2VBc09ic2VydmFibGVTb3VyY2UoY3VycmVudCk7XG4gICAgcmV0dXJuIHVzZVN0YXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9ic2VydmFibGUoaW5pdGlhbGl6ZXIoc291cmNlKSwgdW5kZWZpbmVkLCB7IGF1dG9CaW5kOiB0cnVlIH0pOyB9KVswXTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZUxvY2FsU3RvcmUuanMubWFwIiwidmFyIF9hO1xuaW1wb3J0IFwiLi91dGlscy9hc3NlcnRFbnZpcm9ubWVudFwiO1xuaW1wb3J0IHsgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgYXMgYmF0Y2ggfSBmcm9tIFwiLi91dGlscy9yZWFjdEJhdGNoZWRVcGRhdGVzXCI7XG5pbXBvcnQgeyBvYnNlcnZlckJhdGNoaW5nIH0gZnJvbSBcIi4vdXRpbHMvb2JzZXJ2ZXJCYXRjaGluZ1wiO1xuaW1wb3J0IHsgdXNlRGVwcmVjYXRlZCB9IGZyb20gXCIuL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyB1c2VPYnNlcnZlciBhcyB1c2VPYnNlcnZlck9yaWdpbmFsIH0gZnJvbSBcIi4vdXNlT2JzZXJ2ZXJcIjtcbmltcG9ydCB7IGVuYWJsZVN0YXRpY1JlbmRlcmluZyB9IGZyb20gXCIuL3N0YXRpY1JlbmRlcmluZ1wiO1xuaW1wb3J0IHsgb2JzZXJ2ZXJGaW5hbGl6YXRpb25SZWdpc3RyeSB9IGZyb20gXCIuL3V0aWxzL29ic2VydmVyRmluYWxpemF0aW9uUmVnaXN0cnlcIjtcbm9ic2VydmVyQmF0Y2hpbmcoYmF0Y2gpO1xuZXhwb3J0IHsgaXNVc2luZ1N0YXRpY1JlbmRlcmluZywgZW5hYmxlU3RhdGljUmVuZGVyaW5nIH0gZnJvbSBcIi4vc3RhdGljUmVuZGVyaW5nXCI7XG5leHBvcnQgeyBvYnNlcnZlciB9IGZyb20gXCIuL29ic2VydmVyXCI7XG5leHBvcnQgeyBPYnNlcnZlciB9IGZyb20gXCIuL09ic2VydmVyQ29tcG9uZW50XCI7XG5leHBvcnQgeyB1c2VMb2NhbE9ic2VydmFibGUgfSBmcm9tIFwiLi91c2VMb2NhbE9ic2VydmFibGVcIjtcbmV4cG9ydCB7IHVzZUxvY2FsU3RvcmUgfSBmcm9tIFwiLi91c2VMb2NhbFN0b3JlXCI7XG5leHBvcnQgeyB1c2VBc09ic2VydmFibGVTb3VyY2UgfSBmcm9tIFwiLi91c2VBc09ic2VydmFibGVTb3VyY2VcIjtcbmV4cG9ydCB2YXIgY2xlYXJUaW1lcnMgPSAoX2EgPSBvYnNlcnZlckZpbmFsaXphdGlvblJlZ2lzdHJ5W1wiZmluYWxpemVBbGxJbW1lZGlhdGVseVwiXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGZ1bmN0aW9uICgpIHsgfSk7XG5leHBvcnQgZnVuY3Rpb24gdXNlT2JzZXJ2ZXIoZm4sIGJhc2VDb21wb25lbnROYW1lKSB7XG4gICAgaWYgKGJhc2VDb21wb25lbnROYW1lID09PSB2b2lkIDApIHsgYmFzZUNvbXBvbmVudE5hbWUgPSBcIm9ic2VydmVkXCI7IH1cbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgIHVzZURlcHJlY2F0ZWQoXCJbbW9ieC1yZWFjdC1saXRlXSAndXNlT2JzZXJ2ZXIoZm4pJyBpcyBkZXByZWNhdGVkLiBVc2UgYDxPYnNlcnZlcj57Zm59PC9PYnNlcnZlcj5gIGluc3RlYWQsIG9yIHdyYXAgdGhlIGVudGlyZSBjb21wb25lbnQgaW4gYG9ic2VydmVyYC5cIik7XG4gICAgfVxuICAgIHJldHVybiB1c2VPYnNlcnZlck9yaWdpbmFsKGZuLCBiYXNlQ29tcG9uZW50TmFtZSk7XG59XG5leHBvcnQgeyBpc09ic2VydmVyQmF0Y2hlZCwgb2JzZXJ2ZXJCYXRjaGluZyB9IGZyb20gXCIuL3V0aWxzL29ic2VydmVyQmF0Y2hpbmdcIjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGF0aWNSZW5kZXJpbmcoZW5hYmxlKSB7XG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbbW9ieC1yZWFjdC1saXRlXSAndXNlU3RhdGljUmVuZGVyaW5nJyBpcyBkZXByZWNhdGVkLCB1c2UgJ2VuYWJsZVN0YXRpY1JlbmRlcmluZycgaW5zdGVhZFwiKTtcbiAgICB9XG4gICAgZW5hYmxlU3RhdGljUmVuZGVyaW5nKGVuYWJsZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgbWVyZ2UgZnJvbSAnbG9kYXNoLm1lcmdlJztcbmltcG9ydCB0eXBlIHsgVENvcmVTdG9yZXMsIFRTdG9yZXMgfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IG1vY2sgPSAoKTogVFN0b3JlcyAmIHsgaXNfbW9jazogYm9vbGVhbiB9ID0+IHtcbiAgICBjb25zdCBjb21tb25fc3RvcmVfZXJyb3IgPSB7XG4gICAgICAgIGFwcF9yb3V0aW5nX2hpc3Rvcnk6IFtdLFxuICAgICAgICBoZWFkZXI6ICcnLFxuICAgICAgICBtZXNzYWdlOiAnJyxcbiAgICAgICAgdHlwZTogJycsXG4gICAgICAgIHJlZGlyZWN0X2xhYmVsOiAnJyxcbiAgICAgICAgcmVkaXJlY3RfdG86ICcnLFxuICAgICAgICBzaG91bGRfY2xlYXJfZXJyb3Jfb25fY2xpY2s6IGZhbHNlLFxuICAgICAgICBzaG91bGRfc2hvd19yZWZyZXNoOiBmYWxzZSxcbiAgICAgICAgcmVkaXJlY3RPbkNsaWNrOiBqZXN0LmZuKCksXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc19tb2NrOiB0cnVlLFxuICAgICAgICBjbGllbnQ6IHtcbiAgICAgICAgICAgIGFjY291bnRfc2V0dGluZ3M6IHt9LFxuICAgICAgICAgICAgYWNjb3VudF90eXBlOiAndmlydHVhbCcsXG4gICAgICAgICAgICBhY2NvdW50czoge30sXG4gICAgICAgICAgICBhY3RpdmVfYWNjb3VudF9sYW5kaW5nX2NvbXBhbnk6ICcnLFxuICAgICAgICAgICAgdHJhZGluZ19wbGF0Zm9ybV9hdmFpbGFibGVfYWNjb3VudHM6IFtdLFxuICAgICAgICAgICAgYWNjb3VudF9saW1pdHM6IHt9LFxuICAgICAgICAgICAgYWNjb3VudF9zdGF0dXM6IHtcbiAgICAgICAgICAgICAgICBhdXRoZW50aWNhdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBoaXN0b3J5OiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudHJ5X2NvZGU6ICdpZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnODkxOScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZpY2U6ICdtYW51YWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6ICd2ZXJpZmllZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogMTY3NDYzMzY4MSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhdGVzdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50cnlfY29kZTogJ2lkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJzg5MTknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZpY2U6ICdtYW51YWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogJ3ZlcmlmaWVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IDE2NzQ2MzM2ODEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAndmVyaWZpZWQnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aXR5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkdjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0X3JlamVjdGVkOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwb3J0ZWRfcHJvcGVydGllczoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJtaXNzaW9uc19sZWZ0OiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFudWFsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25maWRvOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50cnlfY29kZTogJ0lETicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50c19zdXBwb3J0ZWQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdEcml2aW5nIExpY2VuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ05hdGlvbmFsIElkZW50aXR5IENhcmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1Bhc3Nwb3J0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdSZXNpZGVuY2UgUGVybWl0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNfY291bnRyeV9zdXBwb3J0ZWQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfcmVqZWN0ZWQ6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBvcnRlZF9wcm9wZXJ0aWVzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Ym1pc3Npb25zX2xlZnQ6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6ICd2ZXJpZmllZCcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGluY29tZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG5lZWRzX3ZlcmlmaWNhdGlvbjogW10sXG4gICAgICAgICAgICAgICAgICAgIG93bmVyc2hpcDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjdXJyZW5jeV9jb25maWc6IHtcbiAgICAgICAgICAgICAgICAgICAgVVNEOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc19kZXBvc2l0X3N1c3BlbmRlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzX3dpdGhkcmF3YWxfc3VzcGVuZGVkOiAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcDJwX3N0YXR1czogJ25vbmUnLFxuICAgICAgICAgICAgICAgIHByb21wdF9jbGllbnRfdG9fYXV0aGVudGljYXRlOiAwLFxuICAgICAgICAgICAgICAgIHJpc2tfY2xhc3NpZmljYXRpb246ICdsb3cnLFxuICAgICAgICAgICAgICAgIHN0YXR1czogW1xuICAgICAgICAgICAgICAgICAgICAnYWdlX3ZlcmlmaWNhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICdhbGxvd19kb2N1bWVudF91cGxvYWQnLFxuICAgICAgICAgICAgICAgICAgICAnYXV0aGVudGljYXRlZCcsXG4gICAgICAgICAgICAgICAgICAgICdkeHRyYWRlX3Bhc3N3b3JkX25vdF9zZXQnLFxuICAgICAgICAgICAgICAgICAgICAnZmluYW5jaWFsX2luZm9ybWF0aW9uX25vdF9jb21wbGV0ZScsXG4gICAgICAgICAgICAgICAgICAgICdpZHZfZGlzYWxsb3dlZCcsXG4gICAgICAgICAgICAgICAgICAgICdtdDVfcGFzc3dvcmRfbm90X3NldCcsXG4gICAgICAgICAgICAgICAgICAgICd0cmFkaW5nX2V4cGVyaWVuY2Vfbm90X2NvbXBsZXRlJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhbGFuY2U6ICcnLFxuICAgICAgICAgICAgY2FuX2NoYW5nZV9maWF0X2N1cnJlbmN5OiBmYWxzZSxcbiAgICAgICAgICAgIGNsaWVudHNfY291bnRyeTogJycsXG4gICAgICAgICAgICBjb3VudHJ5X3N0YW5kcG9pbnQ6IHtcbiAgICAgICAgICAgICAgICBpc19iZWxnaXVtOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc19mcmFuY2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzX2lzbGVfb2ZfbWFuOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc19vdGhlcl9ldTogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNfcmVzdF9vZl9ldTogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNfdW5pdGVkX2tpbmdkb206IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGN1cnJlbmN5OiAnJyxcbiAgICAgICAgICAgIGN1cnJlbmNpZXNfbGlzdDogW3sgdGV4dDogJycsIHZhbHVlOiAnJywgaGFzX3Rvb2xfdGlwOiBmYWxzZSB9XSxcbiAgICAgICAgICAgIGN1cnJlbnRfY3VycmVuY3lfdHlwZTogJycsXG4gICAgICAgICAgICBjdXJyZW50X2ZpYXRfY3VycmVuY3k6ICcnLFxuICAgICAgICAgICAgY2ZkX3Njb3JlOiAwLFxuICAgICAgICAgICAgY3RyYWRlcl9hY2NvdW50c19saXN0OiBbXSxcbiAgICAgICAgICAgIHNldENGRFNjb3JlOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBnZXRMaW1pdHM6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIGhhc19hY3RpdmVfcmVhbF9hY2NvdW50OiBmYWxzZSxcbiAgICAgICAgICAgIGhhc19maWF0OiBmYWxzZSxcbiAgICAgICAgICAgIGhhc19sb2dnZWRfb3V0OiBmYWxzZSxcbiAgICAgICAgICAgIGhhc19tYWx0YWludmVzdF9hY2NvdW50OiBmYWxzZSxcbiAgICAgICAgICAgIGhhc19yZXN0cmljdGVkX210NV9hY2NvdW50OiBmYWxzZSxcbiAgICAgICAgICAgIGluaXRpYWxpemVkX2Jyb2FkY2FzdDogZmFsc2UsXG4gICAgICAgICAgICBpc19hY2NvdW50X3NldHRpbmdfbG9hZGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzX2F1dGhvcml6ZTogZmFsc2UsXG4gICAgICAgICAgICBpc19kZXBvc2l0X2xvY2s6IGZhbHNlLFxuICAgICAgICAgICAgaXNfZHh0cmFkZV9hbGxvd2VkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzX2R4dHJhZGVfcGFzc3dvcmRfbm90X3NldDogZmFsc2UsXG4gICAgICAgICAgICBpc19ldTogZmFsc2UsXG4gICAgICAgICAgICBpc19ldV9jb3VudHJ5OiBmYWxzZSxcbiAgICAgICAgICAgIGhhc19yZXNpZGVuY2U6IGZhbHNlLFxuICAgICAgICAgICAgaXNfZmluYW5jaWFsX2FjY291bnQ6IGZhbHNlLFxuICAgICAgICAgICAgaXNfZmluYW5jaWFsX2Fzc2Vzc21lbnRfbmVlZGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzX2ZpbmFuY2lhbF9pbmZvcm1hdGlvbl9pbmNvbXBsZXRlOiBmYWxzZSxcbiAgICAgICAgICAgIGlzX2xvd19yaXNrOiBmYWxzZSxcbiAgICAgICAgICAgIGlzX2lkZW50aXR5X3ZlcmlmaWNhdGlvbl9uZWVkZWQ6IGZhbHNlLFxuICAgICAgICAgICAgaXNfbGFuZGluZ19jb21wYW55X2xvYWRlZDogZmFsc2UsXG4gICAgICAgICAgICBpc19sb2dnZWRfaW46IGZhbHNlLFxuICAgICAgICAgICAgaXNfbG9nZ2luZ19pbjogZmFsc2UsXG4gICAgICAgICAgICBpc19tdDVfcGFzc3dvcmRfbm90X3NldDogZmFsc2UsXG4gICAgICAgICAgICBpc19wZW5kaW5nX3Byb29mX29mX293bmVyc2hpcDogZmFsc2UsXG4gICAgICAgICAgICBpc19wb3B1bGF0aW5nX2R4dHJhZGVfYWNjb3VudF9saXN0OiBmYWxzZSxcbiAgICAgICAgICAgIGlzX3NvY2lhbF9zaWdudXA6IGZhbHNlLFxuICAgICAgICAgICAgaXNfc2luZ2xlX2N1cnJlbmN5OiBmYWxzZSxcbiAgICAgICAgICAgIGlzX3N3aXRjaGluZzogZmFsc2UsXG4gICAgICAgICAgICBpc190bmNfbmVlZGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzX2hpZ2hfcmlzazogZmFsc2UsXG4gICAgICAgICAgICBpc190cmFkaW5nX2V4cGVyaWVuY2VfaW5jb21wbGV0ZTogZmFsc2UsXG4gICAgICAgICAgICBpc191bndlbGNvbWU6IGZhbHNlLFxuICAgICAgICAgICAgaXNfdmlydHVhbDogZmFsc2UsXG4gICAgICAgICAgICBpc193aXRoZHJhd2FsX2xvY2s6IGZhbHNlLFxuICAgICAgICAgICAgaXNfcG9wdWxhdGluZ19hY2NvdW50X2xpc3Q6IGZhbHNlLFxuICAgICAgICAgICAgbGFuZGluZ19jb21wYW55X3Nob3J0Y29kZTogJycsXG4gICAgICAgICAgICBsb2NhbF9jdXJyZW5jeV9jb25maWc6IHtcbiAgICAgICAgICAgICAgICBjdXJyZW5jeTogJycsXG4gICAgICAgICAgICAgICAgZGVjaW1hbF9wbGFjZXM6IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9naW5pZDogJycsXG4gICAgICAgICAgICBwcmVfc3dpdGNoX2Jyb2FkY2FzdDogZmFsc2UsXG4gICAgICAgICAgICByZXNpZGVuY2U6ICcnLFxuICAgICAgICAgICAgaXNfc3ZnOiBmYWxzZSxcbiAgICAgICAgICAgIHJlc3BvbnNlTXQ1TG9naW5MaXN0OiBqZXN0LmZuKCksXG4gICAgICAgICAgICByZXNwb25zZVRyYWRpbmdQbGF0Zm9ybUFjY291bnRzTGlzdDogamVzdC5mbigpLFxuICAgICAgICAgICAgc2V0RmluYW5jaWFsQW5kVHJhZGluZ0Fzc2Vzc21lbnQ6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHN0YW5kcG9pbnQ6IHtcbiAgICAgICAgICAgICAgICBmaW5hbmNpYWxfY29tcGFueTogJycsXG4gICAgICAgICAgICAgICAgZ2FtaW5nX2NvbXBhbnk6ICcnLFxuICAgICAgICAgICAgICAgIG1hbHRhaW52ZXN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzdmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlvbTogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWFsdGE6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN3aXRjaEFjY291bnQ6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHZlcmlmaWNhdGlvbl9jb2RlOiB7XG4gICAgICAgICAgICAgICAgcGF5bWVudF9hZ2VudF93aXRoZHJhdzogJycsXG4gICAgICAgICAgICAgICAgcGF5bWVudF93aXRoZHJhdzogJycsXG4gICAgICAgICAgICAgICAgcmVxdWVzdF9lbWFpbDogJycsXG4gICAgICAgICAgICAgICAgcmVzZXRfcGFzc3dvcmQ6ICcnLFxuICAgICAgICAgICAgICAgIHNpZ251cDogJycsXG4gICAgICAgICAgICAgICAgc3lzdGVtX2VtYWlsX2NoYW5nZTogJycsXG4gICAgICAgICAgICAgICAgdHJhZGluZ19wbGF0Zm9ybV9keHRyYWRlX3Bhc3N3b3JkX3Jlc2V0OiAnJyxcbiAgICAgICAgICAgICAgICB0cmFkaW5nX3BsYXRmb3JtX210NV9wYXNzd29yZF9yZXNldDogJycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW1haWw6ICcnLFxuICAgICAgICAgICAgc2V0VmVyaWZpY2F0aW9uQ29kZTogamVzdC5mbigpLFxuICAgICAgICAgICAgdXBkYXRlQWNjb3VudFN0YXR1czogamVzdC5mbigpLFxuICAgICAgICAgICAgaXNfYXV0aGVudGljYXRpb25fbmVlZGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0aW9uX3N0YXR1czoge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50X3N0YXR1czogJycsXG4gICAgICAgICAgICAgICAgaWRlbnRpdHlfc3RhdHVzOiAnJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtdDVfbG9naW5fbGlzdDogW10sXG4gICAgICAgICAgICBsb2dvdXQ6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHNob3VsZF9hbGxvd19hdXRoZW50aWNhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICBhY3RpdmVfYWNjb3VudHM6IFtdLFxuICAgICAgICAgICAgYWNjb3VudF9saXN0OiBbXSxcbiAgICAgICAgICAgIGF2YWlsYWJsZV9jcnlwdG9fY3VycmVuY2llczogW10sXG4gICAgICAgICAgICBzZWxlY3RDdXJyZW5jeTogamVzdC5mbigpLFxuICAgICAgICAgICAgc2V0QWNjb3VudFN0YXR1czogamVzdC5mbigpLFxuICAgICAgICAgICAgc2V0QmFsYW5jZU90aGVyQWNjb3VudHM6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHNldEluaXRpYWxpemVkOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBzZXRMb2dvdXQ6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHNldFZpc2liaWxpdHlSZWFsaXR5Q2hlY2s6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHNldFAycEFkdmVydGlzZXJJbmZvOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBzZXRQcmVTd2l0Y2hBY2NvdW50OiBqZXN0LmZuKCksXG4gICAgICAgICAgICBzb2NpYWxfaWRlbnRpdHlfcHJvdmlkZXI6ICcnLFxuICAgICAgICAgICAgc3dpdGNoZWQ6IGZhbHNlLFxuICAgICAgICAgICAgc3dpdGNoX2Jyb2FkY2FzdDogZmFsc2UsXG4gICAgICAgICAgICBzd2l0Y2hFbmRTaWduYWw6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIGlzX3VrOiBmYWxzZSxcbiAgICAgICAgICAgIGlzRWxpZ2libGVGb3JNb3JlUmVhbE10NTogamVzdC5mbigpLFxuICAgICAgICAgICAgaXNFbGlnaWJsZUZvck1vcmVEZW1vTXQ1U3ZnOiBqZXN0LmZuKCksXG4gICAgICAgICAgICB1cGRhdGVNVDVTdGF0dXM6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIGZldGNoUmVzaWRlbmNlTGlzdDogamVzdC5mbigpLFxuICAgICAgICAgICAgcmVzaWRlbmNlX2xpc3Q6IFtdLFxuICAgICAgICAgICAgc2hvdWxkX3Jlc3RyaWN0X2J2aV9hY2NvdW50X2NyZWF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3VsZF9yZXN0cmljdF92YW51YXR1X2FjY291bnRfY3JlYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgZmV0Y2hBY2NvdW50U2V0dGluZ3M6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHNldEFjY291bnRTZXR0aW5nczogamVzdC5mbigpLFxuICAgICAgICAgICAgdXBncmFkZWFibGVfbGFuZGluZ19jb21wYW5pZXM6IFtdLFxuICAgICAgICAgICAgaXNfcG9wdWxhdGluZ19tdDVfYWNjb3VudF9saXN0OiBmYWxzZSxcbiAgICAgICAgICAgIGxhbmRpbmdfY29tcGFuaWVzOiB7fSxcbiAgICAgICAgICAgIGxhbmRpbmdfY29tcGFueToge30sXG4gICAgICAgICAgICB1cGdyYWRlYWJsZV9jdXJyZW5jaWVzOiBbXSxcbiAgICAgICAgICAgIGdldENoYW5nZWFibGVGaWVsZHM6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIGlzQWNjb3VudE9mVHlwZURpc2FibGVkOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBpc19tdDVfYWxsb3dlZDogZmFsc2UsXG4gICAgICAgICAgICBtdDVfZGlzYWJsZWRfc2lnbnVwX3R5cGVzOiB7XG4gICAgICAgICAgICAgICAgcmVhbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGVtbzogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHh0cmFkZV9kaXNhYmxlZF9zaWdudXBfdHlwZXM6IHtcbiAgICAgICAgICAgICAgICByZWFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkZW1vOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkeHRyYWRlX2FjY291bnRzX2xpc3RfZXJyb3I6IG51bGwsXG4gICAgICAgICAgICBoYXNfYWNjb3VudF9lcnJvcl9pbl9tdDVfZGVtb19saXN0OiBmYWxzZSxcbiAgICAgICAgICAgIGhhc19hY2NvdW50X2Vycm9yX2luX210NV9yZWFsX2xpc3Q6IGZhbHNlLFxuICAgICAgICAgICAgaGFzX2FjY291bnRfZXJyb3JfaW5fZHh0cmFkZV9kZW1vX2xpc3Q6IGZhbHNlLFxuICAgICAgICAgICAgaGFzX2FjY291bnRfZXJyb3JfaW5fZHh0cmFkZV9yZWFsX2xpc3Q6IGZhbHNlLFxuICAgICAgICAgICAgd2Vic2l0ZV9zdGF0dXM6IHtcbiAgICAgICAgICAgICAgICBkeF90cmFkZV9zdGF0dXM6IHtcbiAgICAgICAgICAgICAgICAgICAgYWxsOiAwLFxuICAgICAgICAgICAgICAgICAgICBkZW1vOiAwLFxuICAgICAgICAgICAgICAgICAgICByZWFsOiAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbXQ1X3N0YXR1czoge1xuICAgICAgICAgICAgICAgICAgICByZWFsOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgZGVtbzogW10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc19mdWxseV9hdXRoZW50aWNhdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHN0YXRlc19saXN0OiBbXSxcbiAgICAgICAgICAgIGZldGNoU3RhdGVzTGlzdDogamVzdC5mbigpLFxuICAgICAgICAgICAgaXNfY3J5cHRvOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBkeHRyYWRlX2FjY291bnRzX2xpc3Q6IFtdLFxuICAgICAgICAgICAgZGVyaXZlel9hY2NvdW50c19saXN0OiBbXSxcbiAgICAgICAgICAgIGRlZmF1bHRfY3VycmVuY3k6ICdVU0QnLFxuICAgICAgICAgICAgcmVzZXRWaXJ0dWFsQmFsYW5jZTogamVzdC5mbigpLFxuICAgICAgICAgICAgaGFzX2VuYWJsZWRfdHdvX2ZhOiBmYWxzZSxcbiAgICAgICAgICAgIHNldFR3b0ZBU3RhdHVzOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBoYXNfY2hhbmdlZF90d29fZmE6IGZhbHNlLFxuICAgICAgICAgICAgc2V0VHdvRkFDaGFuZ2VkU3RhdHVzOiBqZXN0LmZuKCksXG4gICAgICAgICAgICByZWFsX2FjY291bnRfY3JlYXRpb25fdW5sb2NrX2RhdGU6ICcnLFxuICAgICAgICAgICAgaGFzX2FueV9yZWFsX2FjY291bnQ6IGZhbHNlLFxuICAgICAgICAgICAgc2V0UHJldkFjY291bnRUeXBlOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBwcmV2X2FjY291bnRfdHlwZTogJ2RlbW8nLFxuICAgICAgICAgICAgaXNfYmV0YV9jaGFydDogdHJ1ZSxcbiAgICAgICAgICAgIHNldExvZ2luSW5mb3JtYXRpb246IGplc3QuZm4oKSxcbiAgICAgICAgICAgIGluaXQ6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHNldExvZ2luSWQ6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHJlc2V0TG9jYWxTdG9yYWdlVmFsdWVzOiBqZXN0LmZuKCksXG4gICAgICAgIH0sXG4gICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgZXJyb3I6IGNvbW1vbl9zdG9yZV9lcnJvcixcbiAgICAgICAgICAgIGN1cnJlbnRfbGFuZ3VhZ2U6ICdFTicsXG4gICAgICAgICAgICBpc0N1cnJlbnRMYW5ndWFnZTogamVzdC5mbigpLFxuICAgICAgICAgICAgaXNfZnJvbV9kZXJpdmdvOiBmYWxzZSxcbiAgICAgICAgICAgIGlzX3NvY2tldF9vcGVuZWQ6IGZhbHNlLFxuICAgICAgICAgICAgaGFzX2Vycm9yOiBmYWxzZSxcbiAgICAgICAgICAgIHBsYXRmb3JtOiAnJyxcbiAgICAgICAgICAgIHJvdXRlQmFja0luQXBwOiBqZXN0LmZuKCksXG4gICAgICAgICAgICByb3V0ZVRvOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBjaGFuZ2VDdXJyZW50TGFuZ3VhZ2U6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIGNoYW5nZVNlbGVjdGVkTGFuZ3VhZ2U6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIGlzX25ldHdvcmtfb25saW5lOiBmYWxzZSxcbiAgICAgICAgICAgIG5ldHdvcmtfc3RhdHVzOiB7fSxcbiAgICAgICAgICAgIHNlcnZpY2VzX2Vycm9yOiB7fSxcbiAgICAgICAgICAgIHNlcnZlcl90aW1lOiBuZXcgRGF0ZSgpIGFzIHVua25vd24gYXMgVENvcmVTdG9yZXNbJ2NvbW1vbiddWydzZXJ2ZXJfdGltZSddLFxuICAgICAgICAgICAgc2V0RXJyb3I6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHNldFNlbGVjdGVkQ29udHJhY3RUeXBlOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBzZXRTZXJ2aWNlc0Vycm9yOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBzaG93RXJyb3I6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIGlzX2xhbmd1YWdlX2NoYW5naW5nOiBmYWxzZSxcbiAgICAgICAgICAgIHNldEFwcHN0b3JlUGxhdGZvcm06IGplc3QuZm4oKSxcbiAgICAgICAgICAgIGFwcF9yb3V0aW5nX2hpc3Rvcnk6IFtdLFxuICAgICAgICAgICAgZ2V0RXhjaGFuZ2VSYXRlOiBqZXN0LmZuKCksXG4gICAgICAgIH0sXG4gICAgICAgIHVpOiB7XG4gICAgICAgICAgICBhZHZhbmNlZF9kdXJhdGlvbl91bml0OiAndCcsXG4gICAgICAgICAgICBhY2NvdW50X3N3aXRjaGVyX2Rpc2FibGVkX21lc3NhZ2U6ICcnLFxuICAgICAgICAgICAgYXBwX2NvbnRlbnRzX3Njcm9sbF9yZWY6IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGN1cnJlbnRfZm9jdXM6IG51bGwsXG4gICAgICAgICAgICBpc19hY2NvdW50X3NldHRpbmdzX3Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgaXNfYWR2YW5jZWRfZHVyYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgaXNfbG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBpc19jYXNoaWVyX3Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgaXNfd2FsbGV0X21vZGFsX3Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgaXNfY2hhcnRfbGF5b3V0X2RlZmF1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgaXNfY2xvc2luZ19jcmVhdGVfcmVhbF9hY2NvdW50X21vZGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGlzX2RhcmtfbW9kZV9vbjogZmFsc2UsXG4gICAgICAgICAgICBpc19sYW5ndWFnZV9zZXR0aW5nc19tb2RhbF9vbjogZmFsc2UsXG4gICAgICAgICAgICBpc19kZXNrdG9wOiBmYWxzZSxcbiAgICAgICAgICAgIGlzX2FwcF9kaXNhYmxlZDogZmFsc2UsXG4gICAgICAgICAgICBoYXNfb25seV9mb3J3YXJkX3N0YXJ0aW5nX2NvbnRyYWN0czogZmFsc2UsXG4gICAgICAgICAgICBoZWFkZXJfZXh0ZW5zaW9uOiBudWxsLFxuICAgICAgICAgICAgaXNfbGlua19leHBpcmVkX21vZGFsX3Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgaXNfbW9iaWxlOiBmYWxzZSxcbiAgICAgICAgICAgIGlzX3RhYmxldDogZmFsc2UsXG4gICAgICAgICAgICBpc19tb2JpbGVfbGFuZ3VhZ2VfbWVudV9vcGVuOiBmYWxzZSxcbiAgICAgICAgICAgIGlzX3Bvc2l0aW9uc19kcmF3ZXJfb246IGZhbHNlLFxuICAgICAgICAgICAgaXNfcmVwb3J0c192aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGlzX3JvdXRlX21vZGFsX29uOiBmYWxzZSxcbiAgICAgICAgICAgIGlzX3NlcnZpY2VzX2Vycm9yX3Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgaXNfdW5zdXBwb3J0ZWRfY29udHJhY3RfbW9kYWxfdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBkaXNhYmxlQXBwOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBlbmFibGVBcHA6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHNldEN1cnJlbnRGb2N1czogamVzdC5mbigpLFxuICAgICAgICAgICAgdG9nZ2xlQWNjb3VudHNEaWFsb2c6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHRvZ2dsZUFjY291bnRTZXR0aW5nczogamVzdC5mbigpLFxuICAgICAgICAgICAgdG9nZ2xlQ2FzaGllcjogamVzdC5mbigpLFxuICAgICAgICAgICAgc2V0RGFya01vZGU6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHNldFJlcG9ydHNUYWJJbmRleDogamVzdC5mbigpLFxuICAgICAgICAgICAgaGFzX3JlYWxfYWNjb3VudF9zaWdudXBfZW5kZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcmVhbF9hY2NvdW50X3NpZ251cF90YXJnZXQ6ICcnLFxuICAgICAgICAgICAgcmVhbF9hY2NvdW50X3NpZ251cDoge1xuICAgICAgICAgICAgICAgIGFjdGl2ZV9tb2RhbF9pbmRleDogLTEsXG4gICAgICAgICAgICAgICAgcHJldmlvdXNfY3VycmVuY3k6ICcnLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRfY3VycmVuY3k6ICcnLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3NfbWVzc2FnZTogJycsXG4gICAgICAgICAgICAgICAgZXJyb3JfbWVzc2FnZTogJycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzZXRSZWFsQWNjb3VudFNpZ251cFBhcmFtczogamVzdC5mbigpLFxuICAgICAgICAgICAgbm90aWZpY2F0aW9uX21lc3NhZ2VzX3VpOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBvcGVuUG9zaXRpb25zRHJhd2VyOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBvcGVuUmVhbEFjY291bnRTaWdudXA6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHNldElzV2FsbGV0TW9kYWxWaXNpYmxlOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBzZXRIYXNPbmx5Rm9yd2FyZGluZ0NvbnRyYWN0czogamVzdC5mbigpLFxuICAgICAgICAgICAgc2V0SXNDbG9zaW5nQ3JlYXRlUmVhbEFjY291bnRNb2RhbDogamVzdC5mbigpLFxuICAgICAgICAgICAgc2V0TW9iaWxlTGFuZ3VhZ2VNZW51T3BlbjogamVzdC5mbigpLFxuICAgICAgICAgICAgc2V0UmVhbEFjY291bnRTaWdudXBFbmQ6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHNldFB1cmNoYXNlU3RhdGU6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHNldEFwcENvbnRlbnRzU2Nyb2xsUmVmOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBzaG91bGROYXZpZ2F0ZUFmdGVyQ2hvb3NlQ3J5cHRvOiBqZXN0LmZuKCksXG4gICAgICAgICAgICB0b2dnbGVMYW5ndWFnZVNldHRpbmdzTW9kYWw6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHRvZ2dsZVBvc2l0aW9uc0RyYXdlcjogamVzdC5mbigpLFxuICAgICAgICAgICAgdG9nZ2xlTGlua0V4cGlyZWRNb2RhbDogamVzdC5mbigpLFxuICAgICAgICAgICAgdG9nZ2xlU2VydmljZXNFcnJvck1vZGFsOiBqZXN0LmZuKCksXG4gICAgICAgICAgICB0b2dnbGVTZXRDdXJyZW5jeU1vZGFsOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBhZGRUb2FzdDogamVzdC5mbigpLFxuICAgICAgICAgICAgcmVtb3ZlVG9hc3Q6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHJlcG9ydHNfcm91dGVfdGFiX2luZGV4OiAxLFxuICAgICAgICAgICAgcmVzZXRQdXJjaGFzZVN0YXRlczogamVzdC5mbigpLFxuICAgICAgICAgICAgc2hvdWxkX3Nob3dfY2FuY2VsbGF0aW9uX3dhcm5pbmc6IGZhbHNlLFxuICAgICAgICAgICAgdG9nZ2xlQ2FuY2VsbGF0aW9uV2FybmluZzogamVzdC5mbigpLFxuICAgICAgICAgICAgdG9nZ2xlVW5zdXBwb3J0ZWRDb250cmFjdE1vZGFsOiBqZXN0LmZuKCksXG4gICAgICAgICAgICB0b2dnbGVSZXBvcnRzOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBzZXRTdWJTZWN0aW9uSW5kZXg6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHN1Yl9zZWN0aW9uX2luZGV4OiAwLFxuICAgICAgICAgICAgdG9nZ2xlUmVhZHlUb0RlcG9zaXRNb2RhbDogamVzdC5mbigpLFxuICAgICAgICAgICAgaXNfcmVhZHlfdG9fZGVwb3NpdF9tb2RhbF92aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGlzX3JlYWxfYWNjX3NpZ251cF9vbjogZmFsc2UsXG4gICAgICAgICAgICBpc19uZWVkX3JlYWxfYWNjb3VudF9mb3JfY2FzaGllcl9tb2RhbF92aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHRvZ2dsZU5lZWRSZWFsQWNjb3VudEZvckNhc2hpZXJNb2RhbDogamVzdC5mbigpLFxuICAgICAgICAgICAgaXNfc3dpdGNoX3RvX2Rlcml2X2FjY291bnRfbW9kYWxfdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBvcGVuU3dpdGNoVG9SZWFsQWNjb3VudE1vZGFsOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBpc190b3BfdXBfdmlydHVhbF9vcGVuOiBmYWxzZSxcbiAgICAgICAgICAgIGlzX3RvcF91cF92aXJ0dWFsX2luX3Byb2dyZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGlzX3RvcF91cF92aXJ0dWFsX3N1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgY2xvc2VUb3BVcE1vZGFsOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBjbG9zZVN1Y2Nlc3NUb3BVcE1vZGFsOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBpc19jZmRfcmVzZXRfcGFzc3dvcmRfbW9kYWxfZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICBzZXRDRkRQYXNzd29yZFJlc2V0TW9kYWw6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIG9wZW5EZXJpdlJlYWxBY2NvdW50TmVlZGVkTW9kYWw6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHBvcHVsYXRlSGVhZGVyRXh0ZW5zaW9uczogamVzdC5mbigpLFxuICAgICAgICAgICAgcG9wdWxhdGVTZXR0aW5nc0V4dGVuc2lvbnM6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHB1cmNoYXNlX3N0YXRlczogW10sXG4gICAgICAgICAgICBzZXRTaG91bGRTaG93Q29vbGRvd25Nb2RhbDogamVzdC5mbigpLFxuICAgICAgICAgICAgcG9wdWxhdGVGb290ZXJFeHRlbnNpb25zOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBvcGVuQWNjb3VudE5lZWRlZE1vZGFsOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBpc19hY2NvdW50c19zd2l0Y2hlcl9vbjogZmFsc2UsXG4gICAgICAgICAgICBvcGVuVG9wVXBNb2RhbDogamVzdC5mbigpLFxuICAgICAgICAgICAgdG9nZ2xlU2hvdWxkU2hvd1JlYWxBY2NvdW50c0xpc3Q6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIGlzX3Jlc2V0X3RyYWRpbmdfcGFzc3dvcmRfbW9kYWxfdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBzZXRSZXNldFRyYWRpbmdQYXNzd29yZE1vZGFsT3BlbjogamVzdC5mbigpLFxuICAgICAgICAgICAgdmFuaWxsYV90cmFkZV90eXBlOiAnVkFOSUxMQUxPTkdDQUxMJyxcbiAgICAgICAgICAgIGlzX2FkZGl0aW9uYWxfa3ljX2luZm9fbW9kYWxfb3BlbjogZmFsc2UsXG4gICAgICAgICAgICB0b2dnbGVBZGRpdGlvbmFsS3ljSW5mb01vZGFsOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBpc19reWNfaW5mb3JtYXRpb25fc3VibWl0dGVkX21vZGFsX29wZW46IGZhbHNlLFxuICAgICAgICAgICAgdG9nZ2xlS3ljSW5mb3JtYXRpb25TdWJtaXR0ZWRNb2RhbDogamVzdC5mbigpLFxuICAgICAgICB9LFxuICAgICAgICB0cmFkZXJzX2h1Yjoge1xuICAgICAgICAgICAgZ2V0QWNjb3VudDogamVzdC5mbigpLFxuICAgICAgICAgICAgY2xvc2VNb2RhbDogamVzdC5mbigpLFxuICAgICAgICAgICAgY29tYmluZWRfY2ZkX210NV9hY2NvdW50czogW10sXG4gICAgICAgICAgICBhdmFpbGFibGVfY2ZkX2FjY291bnRzOiBbXSxcbiAgICAgICAgICAgIGNvbnRlbnRfZmxhZzogJycsXG4gICAgICAgICAgICBDRkRzX3Jlc3RyaWN0ZWRfY291bnRyaWVzOiBmYWxzZSxcbiAgICAgICAgICAgIG9wZW5Nb2RhbDogamVzdC5mbigpLFxuICAgICAgICAgICAgc2VsZWN0ZWRfYWNjb3VudDoge1xuICAgICAgICAgICAgICAgIGxvZ2luOiAnJyxcbiAgICAgICAgICAgICAgICBhY2NvdW50X2lkOiAnJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc19ldV91c2VyOiBmYWxzZSxcbiAgICAgICAgICAgIGlzX2RlbW86IGZhbHNlLFxuICAgICAgICAgICAgc2V0SXNPbmJvYXJkaW5nVmlzaXRlZDogamVzdC5mbigpLFxuICAgICAgICAgICAgaXNfcmVhbDogZmFsc2UsXG4gICAgICAgICAgICBzZWxlY3RSZWdpb246IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHNldFNlbGVjdGVkQWNjb3VudDogamVzdC5mbigpLFxuICAgICAgICAgICAgaXNfbG93X3Jpc2tfY3JfZXVfcmVhbDogZmFsc2UsXG4gICAgICAgICAgICBpc19yZWFsX3dhbGxldHNfdXBncmFkZV9vbjogZmFsc2UsXG4gICAgICAgICAgICB0b2dnbGVXYWxsZXRzVXBncmFkZTogamVzdC5mbigpLFxuICAgICAgICAgICAgc2hvd19ldV9yZWxhdGVkX2NvbnRlbnQ6IGZhbHNlLFxuICAgICAgICAgICAgcGxhdGZvcm1fcmVhbF9iYWxhbmNlOiB7XG4gICAgICAgICAgICAgICAgY3VycmVuY3k6ICcnLFxuICAgICAgICAgICAgICAgIGJhbGFuY2U6IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2ZkX2RlbW9fYmFsYW5jZToge1xuICAgICAgICAgICAgICAgIGN1cnJlbmN5OiAnJyxcbiAgICAgICAgICAgICAgICBiYWxhbmNlOiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBsYXRmb3JtX2RlbW9fYmFsYW5jZToge1xuICAgICAgICAgICAgICAgIGN1cnJlbmN5OiAnJyxcbiAgICAgICAgICAgICAgICBiYWxhbmNlOiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNmZF9yZWFsX2JhbGFuY2U6IHtcbiAgICAgICAgICAgICAgICBjdXJyZW5jeTogJycsXG4gICAgICAgICAgICAgICAgYmFsYW5jZTogMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZUFjY291bnRUcmFuc2Zlck1vZGFsOiBqZXN0LmZuKCksXG4gICAgICAgICAgICB0b2dnbGVSZWd1bGF0b3JzQ29tcGFyZU1vZGFsOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBmaW5hbmNpYWxfcmVzdHJpY3RlZF9jb3VudHJpZXM6IGZhbHNlLFxuICAgICAgICAgICAgc2VsZWN0ZWRfYWNjb3VudF90eXBlOiAncmVhbCcsXG4gICAgICAgICAgICBub19DUl9hY2NvdW50OiBmYWxzZSxcbiAgICAgICAgICAgIG5vX01GX2FjY291bnQ6IGZhbHNlLFxuICAgICAgICAgICAgbW9kYWxfZGF0YToge1xuICAgICAgICAgICAgICAgIGFjdGl2ZV9tb2RhbDogJycsXG4gICAgICAgICAgICAgICAgZGF0YToge30sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbXVsdGlwbGllcnNfYWNjb3VudF9zdGF0dXM6ICcnLFxuICAgICAgICAgICAgb3BlbkZhaWxlZFZlcmlmaWNhdGlvbk1vZGFsOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBzZXRUb2dnbGVQbGF0Zm9ybVR5cGU6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHRvZ2dsZUFjY291bnRUcmFuc2Zlck1vZGFsOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBzZWxlY3RBY2NvdW50VHlwZTogamVzdC5mbigpLFxuICAgICAgICAgICAgaXNfd2FsbGV0X21pZ3JhdGlvbl9mYWlsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgc2V0V2FsbGV0c01pZ3JhdGlvbkZhaWxlZFBvcHVwOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBzZWxlY3RlZF9wbGF0Zm9ybV90eXBlOiAnJyxcbiAgICAgICAgICAgIGF2YWlsYWJsZV9wbGF0Zm9ybXM6IFtdLFxuICAgICAgICAgICAgc2VsZWN0ZWRfcmVnaW9uOiAnQWxsJyxcbiAgICAgICAgICAgIGdldEV4aXN0aW5nQWNjb3VudHM6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIGF2YWlsYWJsZV9keHRyYWRlX2FjY291bnRzOiBbXSxcbiAgICAgICAgICAgIHRvZ2dsZUFjY291bnRUeXBlTW9kYWxWaXNpYmlsaXR5OiBqZXN0LmZuKCksXG4gICAgICAgICAgICBhY3RpdmVfbW9kYWxfdGFiOiAnRGVwb3NpdCcsXG4gICAgICAgICAgICBzZXRXYWxsZXRNb2RhbEFjdGl2ZVRhYjogamVzdC5mbigpLFxuICAgICAgICAgICAgYWN0aXZlX21vZGFsX3dhbGxldF9pZDogJycsXG4gICAgICAgICAgICBzZXRXYWxsZXRNb2RhbEFjdGl2ZVdhbGxldElEOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBhdmFpbGFibGVfY3RyYWRlcl9hY2NvdW50czogW10sXG4gICAgICAgICAgICB0b2dnbGVJc1RvdXJPcGVuOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBpc19kZW1vX2xvd19yaXNrOiBmYWxzZSxcbiAgICAgICAgICAgIGlzX210NV9ub3RpZmljYXRpb25fbW9kYWxfdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBzZXRNVDVOb3RpZmljYXRpb25Nb2RhbDogamVzdC5mbigpLFxuICAgICAgICAgICAgYXZhaWxhYmxlX2Rlcml2ZXpfYWNjb3VudHM6IFtdLFxuICAgICAgICAgICAgaGFzX2FueV9yZWFsX2FjY291bnQ6IGZhbHNlLFxuICAgICAgICAgICAgc3RhcnRUcmFkZTogamVzdC5mbigpLFxuICAgICAgICAgICAgc2hvd1RvcFVwTW9kYWw6IGplc3QuZm4oKSxcbiAgICAgICAgfSxcbiAgICAgICAgbm90aWZpY2F0aW9uczoge1xuICAgICAgICAgICAgYWRkTm90aWZpY2F0aW9uTWVzc2FnZTogamVzdC5mbigpLFxuICAgICAgICAgICAgYWRkTm90aWZpY2F0aW9uTWVzc2FnZUJ5S2V5OiBqZXN0LmZuKCksXG4gICAgICAgICAgICBjbGllbnRfbm90aWZpY2F0aW9uczoge30sXG4gICAgICAgICAgICBpc19ub3RpZmljYXRpb25zX2VtcHR5OiB0cnVlLFxuICAgICAgICAgICAgaXNfbm90aWZpY2F0aW9uc192aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGZpbHRlck5vdGlmaWNhdGlvbk1lc3NhZ2VzOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBub3RpZmljYXRpb25zOiBbXSxcbiAgICAgICAgICAgIHJlZnJlc2hOb3RpZmljYXRpb25zOiBqZXN0LmZuKCksXG4gICAgICAgICAgICByZW1vdmVBbGxOb3RpZmljYXRpb25NZXNzYWdlczogamVzdC5mbigpLFxuICAgICAgICAgICAgcmVtb3ZlTm90aWZpY2F0aW9uczogamVzdC5mbigpLFxuICAgICAgICAgICAgcmVtb3ZlTm90aWZpY2F0aW9uQnlLZXk6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHJlbW92ZU5vdGlmaWNhdGlvbk1lc3NhZ2U6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHJlbW92ZU5vdGlmaWNhdGlvbk1lc3NhZ2VCeUtleTogamVzdC5mbigpLFxuICAgICAgICAgICAgc2V0UDJQT3JkZXJQcm9wczogamVzdC5mbigpLFxuICAgICAgICAgICAgc2V0UDJQUmVkaXJlY3RUbzogamVzdC5mbigpLFxuICAgICAgICAgICAgc2hvd0FjY291bnRTd2l0Y2hUb1JlYWxOb3RpZmljYXRpb246IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHNldFNob3VsZFNob3dQb3B1cHM6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHRvZ2dsZU5vdGlmaWNhdGlvbnNNb2RhbDogamVzdC5mbigpLFxuICAgICAgICB9LFxuICAgICAgICBwb3J0Zm9saW86IHtcbiAgICAgICAgICAgIGFjdGl2ZV9wb3NpdGlvbnM6IFtdLFxuICAgICAgICAgICAgYWN0aXZlX3Bvc2l0aW9uc19jb3VudDogMCxcbiAgICAgICAgICAgIGFsbF9wb3NpdGlvbnM6IFtdLFxuICAgICAgICAgICAgYmFycmllcnM6IFtdLFxuICAgICAgICAgICAgZXJyb3I6ICcnLFxuICAgICAgICAgICAgZ2V0UG9zaXRpb25CeUlkOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBpc19sb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGlzX2FjY3VtdWxhdG9yOiBmYWxzZSxcbiAgICAgICAgICAgIGlzX211bHRpcGxpZXI6IGZhbHNlLFxuICAgICAgICAgICAgaXNfdHVyYm9zOiBmYWxzZSxcbiAgICAgICAgICAgIG9uSG92ZXJQb3NpdGlvbjogamVzdC5mbigpLFxuICAgICAgICAgICAgb25CdXlSZXNwb25zZTogamVzdC5mbigpLFxuICAgICAgICAgICAgb25DbGlja0NhbmNlbDogamVzdC5mbigpLFxuICAgICAgICAgICAgb25DbGlja1NlbGw6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIG9uTW91bnQ6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIG9wZW5fYWNjdV9jb250cmFjdDogbnVsbCxcbiAgICAgICAgICAgIHBvc2l0aW9uczogW10sXG4gICAgICAgICAgICByZW1vdmVQb3NpdGlvbkJ5SWQ6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHNldENvbnRyYWN0VHlwZTogamVzdC5mbigpLFxuICAgICAgICB9LFxuICAgICAgICBjb250cmFjdF90cmFkZToge1xuICAgICAgICAgICAgYWNjb3VudFN3aXRjaExpc3RlbmVyOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBhY2N1X2JhcnJpZXJzX3RpbWVvdXRfaWQ6IG51bGwsXG4gICAgICAgICAgICBhY2N1bXVsYXRvcl9iYXJyaWVyc19kYXRhOiB7fSxcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yX2NvbnRyYWN0X2JhcnJpZXJzX2RhdGE6IHt9LFxuICAgICAgICAgICAgYWRkQ29udHJhY3Q6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIGNoYXJ0X3R5cGU6ICcnLFxuICAgICAgICAgICAgY2xlYXJBY2N1bXVsYXRvckJhcnJpZXJzRGF0YTogamVzdC5mbigpLFxuICAgICAgICAgICAgY2xlYXJFcnJvcjogamVzdC5mbigpLFxuICAgICAgICAgICAgY29udHJhY3RzOiBbXSxcbiAgICAgICAgICAgIGVycm9yX21lc3NhZ2U6ICcnLFxuICAgICAgICAgICAgZ2V0Q29udHJhY3RCeUlkOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBncmFudWxhcml0eTogMCxcbiAgICAgICAgICAgIGhhc19jcm9zc2VkX2FjY3VfYmFycmllcnM6IGZhbHNlLFxuICAgICAgICAgICAgaGFzX2Vycm9yOiBmYWxzZSxcbiAgICAgICAgICAgIGxhc3RfY29udHJhY3Q6IHt9LFxuICAgICAgICAgICAgbWFya2Vyc19hcnJheTogW10sXG4gICAgICAgICAgICBvblVubW91bnQ6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHByZXZfY2hhcnRfdHlwZTogJycsXG4gICAgICAgICAgICBwcmV2X2dyYW51bGFyaXR5OiBudWxsLFxuICAgICAgICAgICAgcmVtb3ZlQ29udHJhY3Q6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHNhdmVQcmV2aW91c0NoYXJ0TW9kZTogamVzdC5mbigpLFxuICAgICAgICAgICAgc2V0TmV3QWNjdW11bGF0b3JCYXJyaWVyc0RhdGE6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHVwZGF0ZUFjY3VtdWxhdG9yQmFycmllcnNEYXRhOiBqZXN0LmZuKCksXG4gICAgICAgICAgICB1cGRhdGVDaGFydFR5cGU6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHVwZGF0ZUdyYW51bGFyaXR5OiBqZXN0LmZuKCksXG4gICAgICAgICAgICB1cGRhdGVQcm9wb3NhbDogamVzdC5mbigpLFxuICAgICAgICB9LFxuICAgICAgICBtb2R1bGVzOiB7fSxcbiAgICAgICAgZXhjaGFuZ2VfcmF0ZXM6IHtcbiAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVwZGF0ZTogamVzdC5mbigpLFxuICAgICAgICAgICAgdW5tb3VudDogamVzdC5mbigpLFxuICAgICAgICB9LFxuICAgICAgICBmZWF0dXJlX2ZsYWdzOiB7XG4gICAgICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB1cGRhdGU6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHVubW91bnQ6IGplc3QuZm4oKSxcbiAgICAgICAgfSxcbiAgICAgICAgZ3RtOiB7XG4gICAgICAgICAgICBpc19ndG1fYXBwbGljYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2aXNpdG9ySWQ6ICd2aXNpdG9ySWQnLFxuICAgICAgICAgICAgY29tbW9uX3ZhcmlhYmxlczoge1xuICAgICAgICAgICAgICAgIGxhbmd1YWdlOiAnZW4nLFxuICAgICAgICAgICAgICAgIHRoZW1lOiAnZGFyaycsXG4gICAgICAgICAgICAgICAgcGxhdGZvcm06ICdEQm90JyxcbiAgICAgICAgICAgICAgICBsb2dnZWRJbjogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWNjb3VudFN3aXRjaGVyTGlzdGVuZXI6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHB1c2hEYXRhTGF5ZXI6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHB1c2hUcmFuc2FjdGlvbkRhdGE6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIGV2ZW50SGFuZGxlcjogamVzdC5mbigpLFxuICAgICAgICAgICAgc2V0TG9naW5GbGFnOiBqZXN0LmZuKCksXG4gICAgICAgIH0sXG4gICAgICAgIHB1c2h3b29zaDoge30sXG4gICAgICAgIGNvbnRyYWN0X3JlcGxheToge1xuICAgICAgICAgICAgY29udHJhY3Rfc3RvcmU6IHtcbiAgICAgICAgICAgICAgICBjb250cmFjdF9pbmZvOiB7fSxcbiAgICAgICAgICAgICAgICBkaWdpdHNfaW5mbzoge30sXG4gICAgICAgICAgICAgICAgZGlzcGxheV9zdGF0dXM6ICcnLFxuICAgICAgICAgICAgICAgIGlzX2RpZ2l0X2NvbnRyYWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc19lbmRlZDogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBjaGFydF9iYXJyaWVyX3N0b3JlOiB7fSxcbiAgICAgICAgYWN0aXZlX3N5bWJvbHM6IHtcbiAgICAgICAgICAgIGFjdGl2ZV9zeW1ib2xzOiBbXSxcbiAgICAgICAgICAgIHNldEFjdGl2ZVN5bWJvbHM6IGplc3QuZm4oKSxcbiAgICAgICAgfSxcbiAgICB9O1xufTtcblxuY29uc3QgbW9ja1N0b3JlID0gKG92ZXJyaWRlOiBEZWVwUGFydGlhbDxUU3RvcmVzPik6IFRTdG9yZXMgPT4gbWVyZ2UobW9jaygpLCBvdmVycmlkZSk7XG5cbmV4cG9ydCBkZWZhdWx0IG1vY2tTdG9yZTtcbiIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdHlwZSB7IFRTdG9yZXMgfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IFN0b3JlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VFN0b3JlcyB8IG51bGw+KG51bGwpO1xuXG5leHBvcnQgZGVmYXVsdCBTdG9yZUNvbnRleHQ7XG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuXG4vLyBEb24ndCBuZWVkIHRvIHR5cGUgYGRlcml2X2FwaWAgaGVyZSwgV2Ugd2lsbCBiZSB1c2luZyB0aGVzZSBtZXRob2RzIGluc2lkZVxuLy8gdGhlIGB1c2VRdWVyeWAsIGB1c2VNdXRhdGlvbmAgYW5kIGB1c2VTdWJzY3JpcHRpb25gIGhvb2sgdG8gbWFrZSBpdCB0eXBlLXNhZmUuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgQVBJQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8UmVjb3JkPHN0cmluZywgYW55PiB8IG51bGw+KG51bGwpO1xuXG5leHBvcnQgZGVmYXVsdCBBUElDb250ZXh0O1xuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB0eXBlIHtcbiAgICBUU29ja2V0RW5kcG9pbnROYW1lcyxcbiAgICBUU29ja2V0UGFnaW5hdGVhYmxlRW5kcG9pbnROYW1lcyxcbiAgICBUU29ja2V0UmVxdWVzdFBheWxvYWQsXG4gICAgVFNvY2tldFJlc3BvbnNlRGF0YSxcbiAgICBUU29ja2V0U3Vic2NyaWJhYmxlRW5kcG9pbnROYW1lcyxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgQVBJQ29udGV4dCBmcm9tICcuL0FQSUNvbnRleHQnO1xuXG5jb25zdCB1c2VBUEkgPSAoKSA9PiB7XG4gICAgY29uc3QgYXBpID0gdXNlQ29udGV4dChBUElDb250ZXh0KTtcblxuICAgIGNvbnN0IHNlbmQgPSB1c2VDYWxsYmFjayhcbiAgICAgICAgYXN5bmMgPFQgZXh0ZW5kcyBUU29ja2V0RW5kcG9pbnROYW1lcyB8IFRTb2NrZXRQYWdpbmF0ZWFibGVFbmRwb2ludE5hbWVzID0gVFNvY2tldEVuZHBvaW50TmFtZXM+KFxuICAgICAgICAgICAgbmFtZTogVCxcbiAgICAgICAgICAgIHBheWxvYWQ/OiBUU29ja2V0UmVxdWVzdFBheWxvYWQ8VD5cbiAgICAgICAgKTogUHJvbWlzZTxUU29ja2V0UmVzcG9uc2VEYXRhPFQ+PiA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaT8uc2VuZCh7IFtuYW1lXTogMSwgLi4uKHBheWxvYWQgfHwge30pIH0pO1xuXG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyByZXNwb25zZS5lcnJvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9LFxuICAgICAgICBbYXBpXVxuICAgICk7XG5cbiAgICBjb25zdCBzdWJzY3JpYmUgPSB1c2VDYWxsYmFjayhcbiAgICAgICAgPFQgZXh0ZW5kcyBUU29ja2V0U3Vic2NyaWJhYmxlRW5kcG9pbnROYW1lcz4oXG4gICAgICAgICAgICBuYW1lOiBULFxuICAgICAgICAgICAgcGF5bG9hZD86IFRTb2NrZXRSZXF1ZXN0UGF5bG9hZDxUPlxuICAgICAgICApOiB7XG4gICAgICAgICAgICBzdWJzY3JpYmU6IChcbiAgICAgICAgICAgICAgICAvLyBUaGUgdHlwZSB3aWxsIGJlIGhhbmRsZWQgYnkgdGhlIGB1c2VTdWJzY3JpcHRpb25gIGhvb2suXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBvbkRhdGE6IChyZXNwb25zZTogYW55KSA9PiB2b2lkLFxuICAgICAgICAgICAgICAgIC8vIFRoZSB0eXBlIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgYHVzZVN1YnNjcmlwdGlvbmAgaG9vay5cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIG9uRXJyb3I6IChyZXNwb25zZTogYW55KSA9PiB2b2lkXG4gICAgICAgICAgICApID0+IHsgdW5zdWJzY3JpYmU/OiBWb2lkRnVuY3Rpb24gfTtcbiAgICAgICAgfSA9PiBhcGk/LnN1YnNjcmliZSh7IFtuYW1lXTogMSwgc3Vic2NyaWJlOiAxLCAuLi4ocGF5bG9hZCB8fCB7fSkgfSksXG4gICAgICAgIFthcGldXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHNlbmQsXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlQVBJO1xuIiwiaW1wb3J0IHsgdXNlSW5maW5pdGVRdWVyeSBhcyBfdXNlSW5maW5pdGVRdWVyeSB9IGZyb20gJ0B0YW5zdGFjay9yZWFjdC1xdWVyeSc7XG5cbmltcG9ydCB0eXBlIHtcbiAgICBUU29ja2V0QWNjZXB0YWJsZVByb3BzLFxuICAgIFRTb2NrZXRFcnJvcixcbiAgICBUU29ja2V0UGFnaW5hdGF0ZWFibGVSZXF1ZXN0Q2xlYW5lZCxcbiAgICBUU29ja2V0UGFnaW5hdGVhYmxlRW5kcG9pbnROYW1lcyxcbiAgICBUU29ja2V0UmVxdWVzdEluZmluaXRlUXVlcnlPcHRpb25zLFxuICAgIFRTb2NrZXRSZXF1ZXN0UGF5bG9hZCxcbiAgICBUU29ja2V0UmVzcG9uc2VEYXRhLFxufSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB1c2VBUEkgZnJvbSAnLi91c2VBUEknO1xuaW1wb3J0IHsgZ2V0UXVlcnlLZXlzIH0gZnJvbSAnLi91dGlscyc7XG5cbmNvbnN0IHVzZUluZmluaXRlUXVlcnkgPSA8VCBleHRlbmRzIFRTb2NrZXRQYWdpbmF0ZWFibGVFbmRwb2ludE5hbWVzPihcbiAgICBuYW1lOiBULFxuICAgIC4uLnByb3BzOiBUU29ja2V0QWNjZXB0YWJsZVByb3BzPFQsIHRydWUsICd1c2VJbmZpbml0ZVF1ZXJ5Jz5cbikgPT4ge1xuICAgIGNvbnN0IHByb3AgPSBwcm9wcz8uWzBdO1xuICAgIGNvbnN0IHBheWxvYWQgPSBwcm9wICYmICdwYXlsb2FkJyBpbiBwcm9wID8gKHByb3AucGF5bG9hZCBhcyBUU29ja2V0UGFnaW5hdGF0ZWFibGVSZXF1ZXN0Q2xlYW5lZDxUPikgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHByb3AgJiYgJ29wdGlvbnMnIGluIHByb3AgPyAocHJvcC5vcHRpb25zIGFzIFRTb2NrZXRSZXF1ZXN0SW5maW5pdGVRdWVyeU9wdGlvbnM8VD4pIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHsgc2VuZCB9ID0gdXNlQVBJKCk7XG5cbiAgICBjb25zdCBpbml0aWFsX29mZnNldCA9IHBheWxvYWQ/Lm9mZnNldCB8fCAwO1xuICAgIGNvbnN0IGxpbWl0ID0gcGF5bG9hZD8ubGltaXQgfHwgNTA7XG5cbiAgICByZXR1cm4gX3VzZUluZmluaXRlUXVlcnk8VFNvY2tldFJlc3BvbnNlRGF0YTxUPiwgVFNvY2tldEVycm9yPFQ+PihcbiAgICAgICAgZ2V0UXVlcnlLZXlzKG5hbWUsIHBheWxvYWQpLFxuXG4gICAgICAgICh7IHBhZ2VQYXJhbSA9IDAgfSkgPT5cbiAgICAgICAgICAgIHNlbmQobmFtZSwge1xuICAgICAgICAgICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgICAgICAgICAgbGltaXQsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBwYWdlUGFyYW0gKiBsaW1pdCArIGluaXRpYWxfb2Zmc2V0LFxuICAgICAgICAgICAgfSBhcyB1bmtub3duIGFzIFRTb2NrZXRSZXF1ZXN0UGF5bG9hZDxUPiksXG4gICAgICAgIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBnZXROZXh0UGFnZVBhcmFtOiBvcHRpb25zPy5nZXROZXh0UGFnZVBhcmFtID8gb3B0aW9ucy5nZXROZXh0UGFnZVBhcmFtIDogKF9sYXN0UGFnZSwgcGFnZXMpID0+IHBhZ2VzLmxlbmd0aCxcbiAgICAgICAgfVxuICAgICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VJbmZpbml0ZVF1ZXJ5O1xuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VNdXRhdGlvbiBhcyBfdXNlTXV0YXRpb24gfSBmcm9tICdAdGFuc3RhY2svcmVhY3QtcXVlcnknO1xuaW1wb3J0IHVzZUFQSSBmcm9tICcuL3VzZUFQSSc7XG5pbXBvcnQgdHlwZSB7XG4gICAgVFNvY2tldEFjY2VwdGFibGVQcm9wcyxcbiAgICBUU29ja2V0RW5kcG9pbnROYW1lcyxcbiAgICBUU29ja2V0RXJyb3IsXG4gICAgVFNvY2tldFJlcXVlc3RNdXRhdGlvbk9wdGlvbnMsXG4gICAgVFNvY2tldFJlcXVlc3RQYXlsb2FkLFxuICAgIFRTb2NrZXRSZXNwb25zZURhdGEsXG59IGZyb20gJy4uL3R5cGVzJztcblxuY29uc3QgdXNlTXV0YXRpb24gPSA8VCBleHRlbmRzIFRTb2NrZXRFbmRwb2ludE5hbWVzPihuYW1lOiBULCBvcHRpb25zPzogVFNvY2tldFJlcXVlc3RNdXRhdGlvbk9wdGlvbnM8VD4pID0+IHtcbiAgICBjb25zdCB7IHNlbmQgfSA9IHVzZUFQSSgpO1xuICAgIGNvbnN0IHsgbXV0YXRlOiBfbXV0YXRlLCAuLi5yZXN0IH0gPSBfdXNlTXV0YXRpb248XG4gICAgICAgIFRTb2NrZXRSZXNwb25zZURhdGE8VD4sXG4gICAgICAgIFRTb2NrZXRFcnJvcjxUPixcbiAgICAgICAgVFNvY2tldEFjY2VwdGFibGVQcm9wczxUPlxuICAgID4ocHJvcHMgPT4ge1xuICAgICAgICBjb25zdCBwcm9wID0gcHJvcHM/LlswXTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHByb3AgJiYgJ3BheWxvYWQnIGluIHByb3AgPyAocHJvcC5wYXlsb2FkIGFzIFRTb2NrZXRSZXF1ZXN0UGF5bG9hZDxUPikgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgcmV0dXJuIHNlbmQobmFtZSwgcGF5bG9hZCk7XG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICBjb25zdCBtdXRhdGUgPSB1c2VDYWxsYmFjaygoLi4ucGF5bG9hZDogVFNvY2tldEFjY2VwdGFibGVQcm9wczxUPikgPT4gX211dGF0ZShwYXlsb2FkKSwgW19tdXRhdGVdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIG11dGF0ZSxcbiAgICAgICAgLi4ucmVzdCxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlTXV0YXRpb247XG4iLCIvLyBUWVBFU1xuLy8gVVRJTFNcbmNvbnN0IGlzU2VydmVyID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgJ0Rlbm8nIGluIHdpbmRvdztcbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIGlucHV0KSB7XG4gIHJldHVybiB0eXBlb2YgdXBkYXRlciA9PT0gJ2Z1bmN0aW9uJyA/IHVwZGF0ZXIoaW5wdXQpIDogdXBkYXRlcjtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRUaW1lb3V0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlID49IDAgJiYgdmFsdWUgIT09IEluZmluaXR5O1xufVxuZnVuY3Rpb24gZGlmZmVyZW5jZShhcnJheTEsIGFycmF5Mikge1xuICByZXR1cm4gYXJyYXkxLmZpbHRlcih4ID0+ICFhcnJheTIuaW5jbHVkZXMoeCkpO1xufVxuZnVuY3Rpb24gcmVwbGFjZUF0KGFycmF5LCBpbmRleCwgdmFsdWUpIHtcbiAgY29uc3QgY29weSA9IGFycmF5LnNsaWNlKDApO1xuICBjb3B5W2luZGV4XSA9IHZhbHVlO1xuICByZXR1cm4gY29weTtcbn1cbmZ1bmN0aW9uIHRpbWVVbnRpbFN0YWxlKHVwZGF0ZWRBdCwgc3RhbGVUaW1lKSB7XG4gIHJldHVybiBNYXRoLm1heCh1cGRhdGVkQXQgKyAoc3RhbGVUaW1lIHx8IDApIC0gRGF0ZS5ub3coKSwgMCk7XG59XG5mdW5jdGlvbiBwYXJzZVF1ZXJ5QXJncyhhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICghaXNRdWVyeUtleShhcmcxKSkge1xuICAgIHJldHVybiBhcmcxO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhcmcyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHsgLi4uYXJnMyxcbiAgICAgIHF1ZXJ5S2V5OiBhcmcxLFxuICAgICAgcXVlcnlGbjogYXJnMlxuICAgIH07XG4gIH1cblxuICByZXR1cm4geyAuLi5hcmcyLFxuICAgIHF1ZXJ5S2V5OiBhcmcxXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZU11dGF0aW9uQXJncyhhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmIChpc1F1ZXJ5S2V5KGFyZzEpKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4geyAuLi5hcmczLFxuICAgICAgICBtdXRhdGlvbktleTogYXJnMSxcbiAgICAgICAgbXV0YXRpb25GbjogYXJnMlxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyAuLi5hcmcyLFxuICAgICAgbXV0YXRpb25LZXk6IGFyZzFcbiAgICB9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhcmcxID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHsgLi4uYXJnMixcbiAgICAgIG11dGF0aW9uRm46IGFyZzFcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHsgLi4uYXJnMVxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJBcmdzKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgcmV0dXJuIGlzUXVlcnlLZXkoYXJnMSkgPyBbeyAuLi5hcmcyLFxuICAgIHF1ZXJ5S2V5OiBhcmcxXG4gIH0sIGFyZzNdIDogW2FyZzEgfHwge30sIGFyZzJdO1xufVxuZnVuY3Rpb24gcGFyc2VNdXRhdGlvbkZpbHRlckFyZ3MoYXJnMSwgYXJnMiwgYXJnMykge1xuICByZXR1cm4gaXNRdWVyeUtleShhcmcxKSA/IFt7IC4uLmFyZzIsXG4gICAgbXV0YXRpb25LZXk6IGFyZzFcbiAgfSwgYXJnM10gOiBbYXJnMSB8fCB7fSwgYXJnMl07XG59XG5mdW5jdGlvbiBtYXRjaFF1ZXJ5KGZpbHRlcnMsIHF1ZXJ5KSB7XG4gIGNvbnN0IHtcbiAgICB0eXBlID0gJ2FsbCcsXG4gICAgZXhhY3QsXG4gICAgZmV0Y2hTdGF0dXMsXG4gICAgcHJlZGljYXRlLFxuICAgIHF1ZXJ5S2V5LFxuICAgIHN0YWxlXG4gIH0gPSBmaWx0ZXJzO1xuXG4gIGlmIChpc1F1ZXJ5S2V5KHF1ZXJ5S2V5KSkge1xuICAgIGlmIChleGFjdCkge1xuICAgICAgaWYgKHF1ZXJ5LnF1ZXJ5SGFzaCAhPT0gaGFzaFF1ZXJ5S2V5QnlPcHRpb25zKHF1ZXJ5S2V5LCBxdWVyeS5vcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghcGFydGlhbE1hdGNoS2V5KHF1ZXJ5LnF1ZXJ5S2V5LCBxdWVyeUtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSAhPT0gJ2FsbCcpIHtcbiAgICBjb25zdCBpc0FjdGl2ZSA9IHF1ZXJ5LmlzQWN0aXZlKCk7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2FjdGl2ZScgJiYgIWlzQWN0aXZlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdpbmFjdGl2ZScgJiYgaXNBY3RpdmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHN0YWxlID09PSAnYm9vbGVhbicgJiYgcXVlcnkuaXNTdGFsZSgpICE9PSBzdGFsZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZmV0Y2hTdGF0dXMgIT09ICd1bmRlZmluZWQnICYmIGZldGNoU3RhdHVzICE9PSBxdWVyeS5zdGF0ZS5mZXRjaFN0YXR1cykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChwcmVkaWNhdGUgJiYgIXByZWRpY2F0ZShxdWVyeSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1hdGNoTXV0YXRpb24oZmlsdGVycywgbXV0YXRpb24pIHtcbiAgY29uc3Qge1xuICAgIGV4YWN0LFxuICAgIGZldGNoaW5nLFxuICAgIHByZWRpY2F0ZSxcbiAgICBtdXRhdGlvbktleVxuICB9ID0gZmlsdGVycztcblxuICBpZiAoaXNRdWVyeUtleShtdXRhdGlvbktleSkpIHtcbiAgICBpZiAoIW11dGF0aW9uLm9wdGlvbnMubXV0YXRpb25LZXkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZXhhY3QpIHtcbiAgICAgIGlmIChoYXNoUXVlcnlLZXkobXV0YXRpb24ub3B0aW9ucy5tdXRhdGlvbktleSkgIT09IGhhc2hRdWVyeUtleShtdXRhdGlvbktleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXBhcnRpYWxNYXRjaEtleShtdXRhdGlvbi5vcHRpb25zLm11dGF0aW9uS2V5LCBtdXRhdGlvbktleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGZldGNoaW5nID09PSAnYm9vbGVhbicgJiYgbXV0YXRpb24uc3RhdGUuc3RhdHVzID09PSAnbG9hZGluZycgIT09IGZldGNoaW5nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHByZWRpY2F0ZSAmJiAhcHJlZGljYXRlKG11dGF0aW9uKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaGFzaFF1ZXJ5S2V5QnlPcHRpb25zKHF1ZXJ5S2V5LCBvcHRpb25zKSB7XG4gIGNvbnN0IGhhc2hGbiA9IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnF1ZXJ5S2V5SGFzaEZuKSB8fCBoYXNoUXVlcnlLZXk7XG4gIHJldHVybiBoYXNoRm4ocXVlcnlLZXkpO1xufVxuLyoqXG4gKiBEZWZhdWx0IHF1ZXJ5IGtleXMgaGFzaCBmdW5jdGlvbi5cbiAqIEhhc2hlcyB0aGUgdmFsdWUgaW50byBhIHN0YWJsZSBoYXNoLlxuICovXG5cbmZ1bmN0aW9uIGhhc2hRdWVyeUtleShxdWVyeUtleSkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocXVlcnlLZXksIChfLCB2YWwpID0+IGlzUGxhaW5PYmplY3QodmFsKSA/IE9iamVjdC5rZXlzKHZhbCkuc29ydCgpLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICByZXN1bHRba2V5XSA9IHZhbFtrZXldO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIHt9KSA6IHZhbCk7XG59XG4vKipcbiAqIENoZWNrcyBpZiBrZXkgYGJgIHBhcnRpYWxseSBtYXRjaGVzIHdpdGgga2V5IGBhYC5cbiAqL1xuXG5mdW5jdGlvbiBwYXJ0aWFsTWF0Y2hLZXkoYSwgYikge1xuICByZXR1cm4gcGFydGlhbERlZXBFcXVhbChhLCBiKTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGBiYCBwYXJ0aWFsbHkgbWF0Y2hlcyB3aXRoIGBhYC5cbiAqL1xuXG5mdW5jdGlvbiBwYXJ0aWFsRGVlcEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYSAhPT0gdHlwZW9mIGIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gIU9iamVjdC5rZXlzKGIpLnNvbWUoa2V5ID0+ICFwYXJ0aWFsRGVlcEVxdWFsKGFba2V5XSwgYltrZXldKSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBgYWAgaWYgYGJgIGlzIGRlZXBseSBlcXVhbC5cbiAqIElmIG5vdCwgaXQgd2lsbCByZXBsYWNlIGFueSBkZWVwbHkgZXF1YWwgY2hpbGRyZW4gb2YgYGJgIHdpdGggdGhvc2Ugb2YgYGFgLlxuICogVGhpcyBjYW4gYmUgdXNlZCBmb3Igc3RydWN0dXJhbCBzaGFyaW5nIGJldHdlZW4gSlNPTiB2YWx1ZXMgZm9yIGV4YW1wbGUuXG4gKi9cblxuZnVuY3Rpb24gcmVwbGFjZUVxdWFsRGVlcChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICBjb25zdCBhcnJheSA9IGlzUGxhaW5BcnJheShhKSAmJiBpc1BsYWluQXJyYXkoYik7XG5cbiAgaWYgKGFycmF5IHx8IGlzUGxhaW5PYmplY3QoYSkgJiYgaXNQbGFpbk9iamVjdChiKSkge1xuICAgIGNvbnN0IGFTaXplID0gYXJyYXkgPyBhLmxlbmd0aCA6IE9iamVjdC5rZXlzKGEpLmxlbmd0aDtcbiAgICBjb25zdCBiSXRlbXMgPSBhcnJheSA/IGIgOiBPYmplY3Qua2V5cyhiKTtcbiAgICBjb25zdCBiU2l6ZSA9IGJJdGVtcy5sZW5ndGg7XG4gICAgY29uc3QgY29weSA9IGFycmF5ID8gW10gOiB7fTtcbiAgICBsZXQgZXF1YWxJdGVtcyA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJTaXplOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGFycmF5ID8gaSA6IGJJdGVtc1tpXTtcbiAgICAgIGNvcHlba2V5XSA9IHJlcGxhY2VFcXVhbERlZXAoYVtrZXldLCBiW2tleV0pO1xuXG4gICAgICBpZiAoY29weVtrZXldID09PSBhW2tleV0pIHtcbiAgICAgICAgZXF1YWxJdGVtcysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhU2l6ZSA9PT0gYlNpemUgJiYgZXF1YWxJdGVtcyA9PT0gYVNpemUgPyBhIDogY29weTtcbiAgfVxuXG4gIHJldHVybiBiO1xufVxuLyoqXG4gKiBTaGFsbG93IGNvbXBhcmUgb2JqZWN0cy4gT25seSB3b3JrcyB3aXRoIG9iamVjdHMgdGhhdCBhbHdheXMgaGF2ZSB0aGUgc2FtZSBwcm9wZXJ0aWVzLlxuICovXG5cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbE9iamVjdHMoYSwgYikge1xuICBpZiAoYSAmJiAhYiB8fCBiICYmICFhKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgIGlmIChhW2tleV0gIT09IGJba2V5XSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaXNQbGFpbkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGg7XG59IC8vIENvcGllZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1wbGFpbi1vYmplY3RcblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvKSB7XG4gIGlmICghaGFzT2JqZWN0UHJvdG90eXBlKG8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIElmIGhhcyBtb2RpZmllZCBjb25zdHJ1Y3RvclxuXG5cbiAgY29uc3QgY3RvciA9IG8uY29uc3RydWN0b3I7XG5cbiAgaWYgKHR5cGVvZiBjdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIElmIGhhcyBtb2RpZmllZCBwcm90b3R5cGVcblxuXG4gIGNvbnN0IHByb3QgPSBjdG9yLnByb3RvdHlwZTtcblxuICBpZiAoIWhhc09iamVjdFByb3RvdHlwZShwcm90KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBJZiBjb25zdHJ1Y3RvciBkb2VzIG5vdCBoYXZlIGFuIE9iamVjdC1zcGVjaWZpYyBtZXRob2RcblxuXG4gIGlmICghcHJvdC5oYXNPd25Qcm9wZXJ0eSgnaXNQcm90b3R5cGVPZicpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIE1vc3QgbGlrZWx5IGEgcGxhaW4gT2JqZWN0XG5cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaGFzT2JqZWN0UHJvdG90eXBlKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbmZ1bmN0aW9uIGlzUXVlcnlLZXkodmFsdWUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbmZ1bmN0aW9uIHNsZWVwKHRpbWVvdXQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dCk7XG4gIH0pO1xufVxuLyoqXG4gKiBTY2hlZHVsZXMgYSBtaWNyb3Rhc2suXG4gKiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gc2NoZWR1bGUgc3RhdGUgdXBkYXRlcyBhZnRlciByZW5kZXJpbmcuXG4gKi9cblxuZnVuY3Rpb24gc2NoZWR1bGVNaWNyb3Rhc2soY2FsbGJhY2spIHtcbiAgc2xlZXAoMCkudGhlbihjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBnZXRBYm9ydENvbnRyb2xsZXIoKSB7XG4gIGlmICh0eXBlb2YgQWJvcnRDb250cm9sbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgfVxuXG4gIHJldHVybjtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VEYXRhKHByZXZEYXRhLCBkYXRhLCBvcHRpb25zKSB7XG4gIC8vIFVzZSBwcmV2IGRhdGEgaWYgYW4gaXNEYXRhRXF1YWwgZnVuY3Rpb24gaXMgZGVmaW5lZCBhbmQgcmV0dXJucyBgdHJ1ZWBcbiAgaWYgKG9wdGlvbnMuaXNEYXRhRXF1YWwgIT0gbnVsbCAmJiBvcHRpb25zLmlzRGF0YUVxdWFsKHByZXZEYXRhLCBkYXRhKSkge1xuICAgIHJldHVybiBwcmV2RGF0YTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5zdHJ1Y3R1cmFsU2hhcmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBvcHRpb25zLnN0cnVjdHVyYWxTaGFyaW5nKHByZXZEYXRhLCBkYXRhKTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLnN0cnVjdHVyYWxTaGFyaW5nICE9PSBmYWxzZSkge1xuICAgIC8vIFN0cnVjdHVyYWxseSBzaGFyZSBkYXRhIGJldHdlZW4gcHJldiBhbmQgbmV3IGRhdGEgaWYgbmVlZGVkXG4gICAgcmV0dXJuIHJlcGxhY2VFcXVhbERlZXAocHJldkRhdGEsIGRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmV4cG9ydCB7IGRpZmZlcmVuY2UsIGZ1bmN0aW9uYWxVcGRhdGUsIGdldEFib3J0Q29udHJvbGxlciwgaGFzaFF1ZXJ5S2V5LCBoYXNoUXVlcnlLZXlCeU9wdGlvbnMsIGlzRXJyb3IsIGlzUGxhaW5BcnJheSwgaXNQbGFpbk9iamVjdCwgaXNRdWVyeUtleSwgaXNTZXJ2ZXIsIGlzVmFsaWRUaW1lb3V0LCBtYXRjaE11dGF0aW9uLCBtYXRjaFF1ZXJ5LCBub29wLCBwYXJzZUZpbHRlckFyZ3MsIHBhcnNlTXV0YXRpb25BcmdzLCBwYXJzZU11dGF0aW9uRmlsdGVyQXJncywgcGFyc2VRdWVyeUFyZ3MsIHBhcnRpYWxEZWVwRXF1YWwsIHBhcnRpYWxNYXRjaEtleSwgcmVwbGFjZUF0LCByZXBsYWNlRGF0YSwgcmVwbGFjZUVxdWFsRGVlcCwgc2NoZWR1bGVNaWNyb3Rhc2ssIHNoYWxsb3dFcXVhbE9iamVjdHMsIHNsZWVwLCB0aW1lVW50aWxTdGFsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMubWpzLm1hcFxuIiwiaW1wb3J0IHsgc2NoZWR1bGVNaWNyb3Rhc2sgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vdGlmeU1hbmFnZXIoKSB7XG4gIGxldCBxdWV1ZSA9IFtdO1xuICBsZXQgdHJhbnNhY3Rpb25zID0gMDtcblxuICBsZXQgbm90aWZ5Rm4gPSBjYWxsYmFjayA9PiB7XG4gICAgY2FsbGJhY2soKTtcbiAgfTtcblxuICBsZXQgYmF0Y2hOb3RpZnlGbiA9IGNhbGxiYWNrID0+IHtcbiAgICBjYWxsYmFjaygpO1xuICB9O1xuXG4gIGNvbnN0IGJhdGNoID0gY2FsbGJhY2sgPT4ge1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJhbnNhY3Rpb25zKys7XG5cbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gY2FsbGJhY2soKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJhbnNhY3Rpb25zLS07XG5cbiAgICAgIGlmICghdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIGZsdXNoKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBjb25zdCBzY2hlZHVsZSA9IGNhbGxiYWNrID0+IHtcbiAgICBpZiAodHJhbnNhY3Rpb25zKSB7XG4gICAgICBxdWV1ZS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBub3RpZnlGbihjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBBbGwgY2FsbHMgdG8gdGhlIHdyYXBwZWQgZnVuY3Rpb24gd2lsbCBiZSBiYXRjaGVkLlxuICAgKi9cblxuXG4gIGNvbnN0IGJhdGNoQ2FsbHMgPSBjYWxsYmFjayA9PiB7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICBzY2hlZHVsZSgoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICBjb25zdCBmbHVzaCA9ICgpID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbFF1ZXVlID0gcXVldWU7XG4gICAgcXVldWUgPSBbXTtcblxuICAgIGlmIChvcmlnaW5hbFF1ZXVlLmxlbmd0aCkge1xuICAgICAgc2NoZWR1bGVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBiYXRjaE5vdGlmeUZuKCgpID0+IHtcbiAgICAgICAgICBvcmlnaW5hbFF1ZXVlLmZvckVhY2goY2FsbGJhY2sgPT4ge1xuICAgICAgICAgICAgbm90aWZ5Rm4oY2FsbGJhY2spO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZXQgYSBjdXN0b20gbm90aWZ5IGZ1bmN0aW9uLlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGZvciBleGFtcGxlIHdyYXAgbm90aWZpY2F0aW9ucyB3aXRoIGBSZWFjdC5hY3RgIHdoaWxlIHJ1bm5pbmcgdGVzdHMuXG4gICAqL1xuXG5cbiAgY29uc3Qgc2V0Tm90aWZ5RnVuY3Rpb24gPSBmbiA9PiB7XG4gICAgbm90aWZ5Rm4gPSBmbjtcbiAgfTtcbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZXQgYSBjdXN0b20gZnVuY3Rpb24gdG8gYmF0Y2ggbm90aWZpY2F0aW9ucyB0b2dldGhlciBpbnRvIGEgc2luZ2xlIHRpY2suXG4gICAqIEJ5IGRlZmF1bHQgUmVhY3QgUXVlcnkgd2lsbCB1c2UgdGhlIGJhdGNoIGZ1bmN0aW9uIHByb3ZpZGVkIGJ5IFJlYWN0RE9NIG9yIFJlYWN0IE5hdGl2ZS5cbiAgICovXG5cblxuICBjb25zdCBzZXRCYXRjaE5vdGlmeUZ1bmN0aW9uID0gZm4gPT4ge1xuICAgIGJhdGNoTm90aWZ5Rm4gPSBmbjtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGJhdGNoLFxuICAgIGJhdGNoQ2FsbHMsXG4gICAgc2NoZWR1bGUsXG4gICAgc2V0Tm90aWZ5RnVuY3Rpb24sXG4gICAgc2V0QmF0Y2hOb3RpZnlGdW5jdGlvblxuICB9O1xufSAvLyBTSU5HTEVUT05cblxuY29uc3Qgbm90aWZ5TWFuYWdlciA9IGNyZWF0ZU5vdGlmeU1hbmFnZXIoKTtcblxuZXhwb3J0IHsgY3JlYXRlTm90aWZ5TWFuYWdlciwgbm90aWZ5TWFuYWdlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm90aWZ5TWFuYWdlci5tanMubWFwXG4iLCJjbGFzcyBTdWJzY3JpYmFibGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmxpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLnN1YnNjcmliZSA9IHRoaXMuc3Vic2NyaWJlLmJpbmQodGhpcyk7XG4gIH1cblxuICBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBjb25zdCBpZGVudGl0eSA9IHtcbiAgICAgIGxpc3RlbmVyXG4gICAgfTtcbiAgICB0aGlzLmxpc3RlbmVycy5hZGQoaWRlbnRpdHkpO1xuICAgIHRoaXMub25TdWJzY3JpYmUoKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhpcy5saXN0ZW5lcnMuZGVsZXRlKGlkZW50aXR5KTtcbiAgICAgIHRoaXMub25VbnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH1cblxuICBoYXNMaXN0ZW5lcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzLnNpemUgPiAwO1xuICB9XG5cbiAgb25TdWJzY3JpYmUoKSB7Ly8gRG8gbm90aGluZ1xuICB9XG5cbiAgb25VbnN1YnNjcmliZSgpIHsvLyBEbyBub3RoaW5nXG4gIH1cblxufVxuXG5leHBvcnQgeyBTdWJzY3JpYmFibGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnNjcmliYWJsZS5tanMubWFwXG4iLCJpbXBvcnQgeyBTdWJzY3JpYmFibGUgfSBmcm9tICcuL3N1YnNjcmliYWJsZS5tanMnO1xuaW1wb3J0IHsgaXNTZXJ2ZXIgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG5cbmNsYXNzIEZvY3VzTWFuYWdlciBleHRlbmRzIFN1YnNjcmliYWJsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLnNldHVwID0gb25Gb2N1cyA9PiB7XG4gICAgICAvLyBhZGRFdmVudExpc3RlbmVyIGRvZXMgbm90IGV4aXN0IGluIFJlYWN0IE5hdGl2ZSwgYnV0IHdpbmRvdyBkb2VzXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgaWYgKCFpc1NlcnZlciAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9ICgpID0+IG9uRm9jdXMoKTsgLy8gTGlzdGVuIHRvIHZpc2liaWxsaXR5Y2hhbmdlIGFuZCBmb2N1c1xuXG5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIC8vIEJlIHN1cmUgdG8gdW5zdWJzY3JpYmUgaWYgYSBuZXcgaGFuZGxlciBpcyBzZXRcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGxpc3RlbmVyKTtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBsaXN0ZW5lcik7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9O1xuICB9XG5cbiAgb25TdWJzY3JpYmUoKSB7XG4gICAgaWYgKCF0aGlzLmNsZWFudXApIHtcbiAgICAgIHRoaXMuc2V0RXZlbnRMaXN0ZW5lcih0aGlzLnNldHVwKTtcbiAgICB9XG4gIH1cblxuICBvblVuc3Vic2NyaWJlKCkge1xuICAgIGlmICghdGhpcy5oYXNMaXN0ZW5lcnMoKSkge1xuICAgICAgdmFyIF90aGlzJGNsZWFudXA7XG5cbiAgICAgIChfdGhpcyRjbGVhbnVwID0gdGhpcy5jbGVhbnVwKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkY2xlYW51cC5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5jbGVhbnVwID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHNldEV2ZW50TGlzdGVuZXIoc2V0dXApIHtcbiAgICB2YXIgX3RoaXMkY2xlYW51cDI7XG5cbiAgICB0aGlzLnNldHVwID0gc2V0dXA7XG4gICAgKF90aGlzJGNsZWFudXAyID0gdGhpcy5jbGVhbnVwKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkY2xlYW51cDIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmNsZWFudXAgPSBzZXR1cChmb2N1c2VkID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZm9jdXNlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRoaXMuc2V0Rm9jdXNlZChmb2N1c2VkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub25Gb2N1cygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2V0Rm9jdXNlZChmb2N1c2VkKSB7XG4gICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuZm9jdXNlZCAhPT0gZm9jdXNlZDtcblxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLmZvY3VzZWQgPSBmb2N1c2VkO1xuICAgICAgdGhpcy5vbkZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgb25Gb2N1cygpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKCh7XG4gICAgICBsaXN0ZW5lclxuICAgIH0pID0+IHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfSk7XG4gIH1cblxuICBpc0ZvY3VzZWQoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmZvY3VzZWQgPT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuIHRoaXMuZm9jdXNlZDtcbiAgICB9IC8vIGRvY3VtZW50IGdsb2JhbCBjYW4gYmUgdW5hdmFpbGFibGUgaW4gcmVhY3QgbmF0aXZlXG5cblxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3VuZGVmaW5lZCwgJ3Zpc2libGUnLCAncHJlcmVuZGVyJ10uaW5jbHVkZXMoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlKTtcbiAgfVxuXG59XG5jb25zdCBmb2N1c01hbmFnZXIgPSBuZXcgRm9jdXNNYW5hZ2VyKCk7XG5cbmV4cG9ydCB7IEZvY3VzTWFuYWdlciwgZm9jdXNNYW5hZ2VyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1c01hbmFnZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgU3Vic2NyaWJhYmxlIH0gZnJvbSAnLi9zdWJzY3JpYmFibGUubWpzJztcbmltcG9ydCB7IGlzU2VydmVyIH0gZnJvbSAnLi91dGlscy5tanMnO1xuXG5jb25zdCBvbmxpbmVFdmVudHMgPSBbJ29ubGluZScsICdvZmZsaW5lJ107XG5jbGFzcyBPbmxpbmVNYW5hZ2VyIGV4dGVuZHMgU3Vic2NyaWJhYmxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuc2V0dXAgPSBvbk9ubGluZSA9PiB7XG4gICAgICAvLyBhZGRFdmVudExpc3RlbmVyIGRvZXMgbm90IGV4aXN0IGluIFJlYWN0IE5hdGl2ZSwgYnV0IHdpbmRvdyBkb2VzXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgaWYgKCFpc1NlcnZlciAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9ICgpID0+IG9uT25saW5lKCk7IC8vIExpc3RlbiB0byBvbmxpbmVcblxuXG4gICAgICAgIG9ubGluZUV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgLy8gQmUgc3VyZSB0byB1bnN1YnNjcmliZSBpZiBhIG5ldyBoYW5kbGVyIGlzIHNldFxuICAgICAgICAgIG9ubGluZUV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9O1xuICB9XG5cbiAgb25TdWJzY3JpYmUoKSB7XG4gICAgaWYgKCF0aGlzLmNsZWFudXApIHtcbiAgICAgIHRoaXMuc2V0RXZlbnRMaXN0ZW5lcih0aGlzLnNldHVwKTtcbiAgICB9XG4gIH1cblxuICBvblVuc3Vic2NyaWJlKCkge1xuICAgIGlmICghdGhpcy5oYXNMaXN0ZW5lcnMoKSkge1xuICAgICAgdmFyIF90aGlzJGNsZWFudXA7XG5cbiAgICAgIChfdGhpcyRjbGVhbnVwID0gdGhpcy5jbGVhbnVwKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkY2xlYW51cC5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5jbGVhbnVwID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHNldEV2ZW50TGlzdGVuZXIoc2V0dXApIHtcbiAgICB2YXIgX3RoaXMkY2xlYW51cDI7XG5cbiAgICB0aGlzLnNldHVwID0gc2V0dXA7XG4gICAgKF90aGlzJGNsZWFudXAyID0gdGhpcy5jbGVhbnVwKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkY2xlYW51cDIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmNsZWFudXAgPSBzZXR1cChvbmxpbmUgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBvbmxpbmUgPT09ICdib29sZWFuJykge1xuICAgICAgICB0aGlzLnNldE9ubGluZShvbmxpbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbk9ubGluZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2V0T25saW5lKG9ubGluZSkge1xuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLm9ubGluZSAhPT0gb25saW5lO1xuXG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMub25saW5lID0gb25saW5lO1xuICAgICAgdGhpcy5vbk9ubGluZSgpO1xuICAgIH1cbiAgfVxuXG4gIG9uT25saW5lKCkge1xuICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKHtcbiAgICAgIGxpc3RlbmVyXG4gICAgfSkgPT4ge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlzT25saW5lKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5vbmxpbmUgPT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuIHRoaXMub25saW5lO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgbmF2aWdhdG9yLm9uTGluZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBuYXZpZ2F0b3Iub25MaW5lO1xuICB9XG5cbn1cbmNvbnN0IG9ubGluZU1hbmFnZXIgPSBuZXcgT25saW5lTWFuYWdlcigpO1xuXG5leHBvcnQgeyBPbmxpbmVNYW5hZ2VyLCBvbmxpbmVNYW5hZ2VyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbmxpbmVNYW5hZ2VyLm1qcy5tYXBcbiIsImltcG9ydCB7IGZvY3VzTWFuYWdlciB9IGZyb20gJy4vZm9jdXNNYW5hZ2VyLm1qcyc7XG5pbXBvcnQgeyBvbmxpbmVNYW5hZ2VyIH0gZnJvbSAnLi9vbmxpbmVNYW5hZ2VyLm1qcyc7XG5pbXBvcnQgeyBzbGVlcCB9IGZyb20gJy4vdXRpbHMubWpzJztcblxuZnVuY3Rpb24gZGVmYXVsdFJldHJ5RGVsYXkoZmFpbHVyZUNvdW50KSB7XG4gIHJldHVybiBNYXRoLm1pbigxMDAwICogMiAqKiBmYWlsdXJlQ291bnQsIDMwMDAwKTtcbn1cblxuZnVuY3Rpb24gY2FuRmV0Y2gobmV0d29ya01vZGUpIHtcbiAgcmV0dXJuIChuZXR3b3JrTW9kZSAhPSBudWxsID8gbmV0d29ya01vZGUgOiAnb25saW5lJykgPT09ICdvbmxpbmUnID8gb25saW5lTWFuYWdlci5pc09ubGluZSgpIDogdHJ1ZTtcbn1cbmNsYXNzIENhbmNlbGxlZEVycm9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMucmV2ZXJ0ID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5yZXZlcnQ7XG4gICAgdGhpcy5zaWxlbnQgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnNpbGVudDtcbiAgfVxuXG59XG5mdW5jdGlvbiBpc0NhbmNlbGxlZEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIENhbmNlbGxlZEVycm9yO1xufVxuZnVuY3Rpb24gY3JlYXRlUmV0cnllcihjb25maWcpIHtcbiAgbGV0IGlzUmV0cnlDYW5jZWxsZWQgPSBmYWxzZTtcbiAgbGV0IGZhaWx1cmVDb3VudCA9IDA7XG4gIGxldCBpc1Jlc29sdmVkID0gZmFsc2U7XG4gIGxldCBjb250aW51ZUZuO1xuICBsZXQgcHJvbWlzZVJlc29sdmU7XG4gIGxldCBwcm9taXNlUmVqZWN0O1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKG91dGVyUmVzb2x2ZSwgb3V0ZXJSZWplY3QpID0+IHtcbiAgICBwcm9taXNlUmVzb2x2ZSA9IG91dGVyUmVzb2x2ZTtcbiAgICBwcm9taXNlUmVqZWN0ID0gb3V0ZXJSZWplY3Q7XG4gIH0pO1xuXG4gIGNvbnN0IGNhbmNlbCA9IGNhbmNlbE9wdGlvbnMgPT4ge1xuICAgIGlmICghaXNSZXNvbHZlZCkge1xuICAgICAgcmVqZWN0KG5ldyBDYW5jZWxsZWRFcnJvcihjYW5jZWxPcHRpb25zKSk7XG4gICAgICBjb25maWcuYWJvcnQgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbmZpZy5hYm9ydCgpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBjYW5jZWxSZXRyeSA9ICgpID0+IHtcbiAgICBpc1JldHJ5Q2FuY2VsbGVkID0gdHJ1ZTtcbiAgfTtcblxuICBjb25zdCBjb250aW51ZVJldHJ5ID0gKCkgPT4ge1xuICAgIGlzUmV0cnlDYW5jZWxsZWQgPSBmYWxzZTtcbiAgfTtcblxuICBjb25zdCBzaG91bGRQYXVzZSA9ICgpID0+ICFmb2N1c01hbmFnZXIuaXNGb2N1c2VkKCkgfHwgY29uZmlnLm5ldHdvcmtNb2RlICE9PSAnYWx3YXlzJyAmJiAhb25saW5lTWFuYWdlci5pc09ubGluZSgpO1xuXG4gIGNvbnN0IHJlc29sdmUgPSB2YWx1ZSA9PiB7XG4gICAgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgIGNvbmZpZy5vblN1Y2Nlc3MgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbmZpZy5vblN1Y2Nlc3ModmFsdWUpO1xuICAgICAgY29udGludWVGbiA9PSBudWxsID8gdm9pZCAwIDogY29udGludWVGbigpO1xuICAgICAgcHJvbWlzZVJlc29sdmUodmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCByZWplY3QgPSB2YWx1ZSA9PiB7XG4gICAgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgIGNvbmZpZy5vbkVycm9yID09IG51bGwgPyB2b2lkIDAgOiBjb25maWcub25FcnJvcih2YWx1ZSk7XG4gICAgICBjb250aW51ZUZuID09IG51bGwgPyB2b2lkIDAgOiBjb250aW51ZUZuKCk7XG4gICAgICBwcm9taXNlUmVqZWN0KHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcGF1c2UgPSAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGNvbnRpbnVlUmVzb2x2ZSA9PiB7XG4gICAgICBjb250aW51ZUZuID0gdmFsdWUgPT4ge1xuICAgICAgICBjb25zdCBjYW5Db250aW51ZSA9IGlzUmVzb2x2ZWQgfHwgIXNob3VsZFBhdXNlKCk7XG5cbiAgICAgICAgaWYgKGNhbkNvbnRpbnVlKSB7XG4gICAgICAgICAgY29udGludWVSZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYW5Db250aW51ZTtcbiAgICAgIH07XG5cbiAgICAgIGNvbmZpZy5vblBhdXNlID09IG51bGwgPyB2b2lkIDAgOiBjb25maWcub25QYXVzZSgpO1xuICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgY29udGludWVGbiA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICAgIGNvbmZpZy5vbkNvbnRpbnVlID09IG51bGwgPyB2b2lkIDAgOiBjb25maWcub25Db250aW51ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9OyAvLyBDcmVhdGUgbG9vcCBmdW5jdGlvblxuXG5cbiAgY29uc3QgcnVuID0gKCkgPT4ge1xuICAgIC8vIERvIG5vdGhpbmcgaWYgYWxyZWFkeSByZXNvbHZlZFxuICAgIGlmIChpc1Jlc29sdmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHByb21pc2VPclZhbHVlOyAvLyBFeGVjdXRlIHF1ZXJ5XG5cbiAgICB0cnkge1xuICAgICAgcHJvbWlzZU9yVmFsdWUgPSBjb25maWcuZm4oKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcHJvbWlzZU9yVmFsdWUgPSBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgUHJvbWlzZS5yZXNvbHZlKHByb21pc2VPclZhbHVlKS50aGVuKHJlc29sdmUpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIHZhciBfY29uZmlnJHJldHJ5LCBfY29uZmlnJHJldHJ5RGVsYXk7XG5cbiAgICAgIC8vIFN0b3AgaWYgdGhlIGZldGNoIGlzIGFscmVhZHkgcmVzb2x2ZWRcbiAgICAgIGlmIChpc1Jlc29sdmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRG8gd2UgbmVlZCB0byByZXRyeSB0aGUgcmVxdWVzdD9cblxuXG4gICAgICBjb25zdCByZXRyeSA9IChfY29uZmlnJHJldHJ5ID0gY29uZmlnLnJldHJ5KSAhPSBudWxsID8gX2NvbmZpZyRyZXRyeSA6IDM7XG4gICAgICBjb25zdCByZXRyeURlbGF5ID0gKF9jb25maWckcmV0cnlEZWxheSA9IGNvbmZpZy5yZXRyeURlbGF5KSAhPSBudWxsID8gX2NvbmZpZyRyZXRyeURlbGF5IDogZGVmYXVsdFJldHJ5RGVsYXk7XG4gICAgICBjb25zdCBkZWxheSA9IHR5cGVvZiByZXRyeURlbGF5ID09PSAnZnVuY3Rpb24nID8gcmV0cnlEZWxheShmYWlsdXJlQ291bnQsIGVycm9yKSA6IHJldHJ5RGVsYXk7XG4gICAgICBjb25zdCBzaG91bGRSZXRyeSA9IHJldHJ5ID09PSB0cnVlIHx8IHR5cGVvZiByZXRyeSA9PT0gJ251bWJlcicgJiYgZmFpbHVyZUNvdW50IDwgcmV0cnkgfHwgdHlwZW9mIHJldHJ5ID09PSAnZnVuY3Rpb24nICYmIHJldHJ5KGZhaWx1cmVDb3VudCwgZXJyb3IpO1xuXG4gICAgICBpZiAoaXNSZXRyeUNhbmNlbGxlZCB8fCAhc2hvdWxkUmV0cnkpIHtcbiAgICAgICAgLy8gV2UgYXJlIGRvbmUgaWYgdGhlIHF1ZXJ5IGRvZXMgbm90IG5lZWQgdG8gYmUgcmV0cmllZFxuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZhaWx1cmVDb3VudCsrOyAvLyBOb3RpZnkgb24gZmFpbFxuXG4gICAgICBjb25maWcub25GYWlsID09IG51bGwgPyB2b2lkIDAgOiBjb25maWcub25GYWlsKGZhaWx1cmVDb3VudCwgZXJyb3IpOyAvLyBEZWxheVxuXG4gICAgICBzbGVlcChkZWxheSkgLy8gUGF1c2UgaWYgdGhlIGRvY3VtZW50IGlzIG5vdCB2aXNpYmxlIG9yIHdoZW4gdGhlIGRldmljZSBpcyBvZmZsaW5lXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRQYXVzZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhdXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKGlzUmV0cnlDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJ1bigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTsgLy8gU3RhcnQgbG9vcFxuXG5cbiAgaWYgKGNhbkZldGNoKGNvbmZpZy5uZXR3b3JrTW9kZSkpIHtcbiAgICBydW4oKTtcbiAgfSBlbHNlIHtcbiAgICBwYXVzZSgpLnRoZW4ocnVuKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcHJvbWlzZSxcbiAgICBjYW5jZWwsXG4gICAgY29udGludWU6ICgpID0+IHtcbiAgICAgIGNvbnN0IGRpZENvbnRpbnVlID0gY29udGludWVGbiA9PSBudWxsID8gdm9pZCAwIDogY29udGludWVGbigpO1xuICAgICAgcmV0dXJuIGRpZENvbnRpbnVlID8gcHJvbWlzZSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH0sXG4gICAgY2FuY2VsUmV0cnksXG4gICAgY29udGludWVSZXRyeVxuICB9O1xufVxuXG5leHBvcnQgeyBDYW5jZWxsZWRFcnJvciwgY2FuRmV0Y2gsIGNyZWF0ZVJldHJ5ZXIsIGlzQ2FuY2VsbGVkRXJyb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJldHJ5ZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgc2hhbGxvd0VxdWFsT2JqZWN0cywgbm9vcCwgaXNTZXJ2ZXIsIGlzVmFsaWRUaW1lb3V0LCB0aW1lVW50aWxTdGFsZSwgcmVwbGFjZURhdGEgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG5pbXBvcnQgeyBub3RpZnlNYW5hZ2VyIH0gZnJvbSAnLi9ub3RpZnlNYW5hZ2VyLm1qcyc7XG5pbXBvcnQgeyBmb2N1c01hbmFnZXIgfSBmcm9tICcuL2ZvY3VzTWFuYWdlci5tanMnO1xuaW1wb3J0IHsgU3Vic2NyaWJhYmxlIH0gZnJvbSAnLi9zdWJzY3JpYmFibGUubWpzJztcbmltcG9ydCB7IGNhbkZldGNoLCBpc0NhbmNlbGxlZEVycm9yIH0gZnJvbSAnLi9yZXRyeWVyLm1qcyc7XG5cbmNsYXNzIFF1ZXJ5T2JzZXJ2ZXIgZXh0ZW5kcyBTdWJzY3JpYmFibGUge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy50cmFja2VkUHJvcHMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5zZWxlY3RFcnJvciA9IG51bGw7XG4gICAgdGhpcy5iaW5kTWV0aG9kcygpO1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIGJpbmRNZXRob2RzKCkge1xuICAgIHRoaXMucmVtb3ZlID0gdGhpcy5yZW1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLnJlZmV0Y2ggPSB0aGlzLnJlZmV0Y2guYmluZCh0aGlzKTtcbiAgfVxuXG4gIG9uU3Vic2NyaWJlKCkge1xuICAgIGlmICh0aGlzLmxpc3RlbmVycy5zaXplID09PSAxKSB7XG4gICAgICB0aGlzLmN1cnJlbnRRdWVyeS5hZGRPYnNlcnZlcih0aGlzKTtcblxuICAgICAgaWYgKHNob3VsZEZldGNoT25Nb3VudCh0aGlzLmN1cnJlbnRRdWVyeSwgdGhpcy5vcHRpb25zKSkge1xuICAgICAgICB0aGlzLmV4ZWN1dGVGZXRjaCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZVRpbWVycygpO1xuICAgIH1cbiAgfVxuXG4gIG9uVW5zdWJzY3JpYmUoKSB7XG4gICAgaWYgKCF0aGlzLmhhc0xpc3RlbmVycygpKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cblxuICBzaG91bGRGZXRjaE9uUmVjb25uZWN0KCkge1xuICAgIHJldHVybiBzaG91bGRGZXRjaE9uKHRoaXMuY3VycmVudFF1ZXJ5LCB0aGlzLm9wdGlvbnMsIHRoaXMub3B0aW9ucy5yZWZldGNoT25SZWNvbm5lY3QpO1xuICB9XG5cbiAgc2hvdWxkRmV0Y2hPbldpbmRvd0ZvY3VzKCkge1xuICAgIHJldHVybiBzaG91bGRGZXRjaE9uKHRoaXMuY3VycmVudFF1ZXJ5LCB0aGlzLm9wdGlvbnMsIHRoaXMub3B0aW9ucy5yZWZldGNoT25XaW5kb3dGb2N1cyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuY2xlYXJTdGFsZVRpbWVvdXQoKTtcbiAgICB0aGlzLmNsZWFyUmVmZXRjaEludGVydmFsKCk7XG4gICAgdGhpcy5jdXJyZW50UXVlcnkucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XG4gIH1cblxuICBzZXRPcHRpb25zKG9wdGlvbnMsIG5vdGlmeU9wdGlvbnMpIHtcbiAgICBjb25zdCBwcmV2T3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBwcmV2UXVlcnkgPSB0aGlzLmN1cnJlbnRRdWVyeTtcbiAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLmNsaWVudC5kZWZhdWx0UXVlcnlPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmlzRGF0YUVxdWFsKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuY2xpZW50LmdldExvZ2dlcigpLmVycm9yKFwiVGhlIGlzRGF0YUVxdWFsIG9wdGlvbiBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi4gWW91IGNhbiBhY2hpZXZlIHRoZSBzYW1lIGZ1bmN0aW9uYWxpdHkgYnkgcGFzc2luZyBhIGZ1bmN0aW9uIGFzIHRoZSBzdHJ1Y3R1cmFsU2hhcmluZyBvcHRpb25cIik7XG4gICAgfVxuXG4gICAgaWYgKCFzaGFsbG93RXF1YWxPYmplY3RzKHByZXZPcHRpb25zLCB0aGlzLm9wdGlvbnMpKSB7XG4gICAgICB0aGlzLmNsaWVudC5nZXRRdWVyeUNhY2hlKCkubm90aWZ5KHtcbiAgICAgICAgdHlwZTogJ29ic2VydmVyT3B0aW9uc1VwZGF0ZWQnLFxuICAgICAgICBxdWVyeTogdGhpcy5jdXJyZW50UXVlcnksXG4gICAgICAgIG9ic2VydmVyOiB0aGlzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5lbmFibGVkICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLmVuYWJsZWQgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBlbmFibGVkIHRvIGJlIGEgYm9vbGVhbicpO1xuICAgIH0gLy8gS2VlcCBwcmV2aW91cyBxdWVyeSBrZXkgaWYgdGhlIHVzZXIgZG9lcyBub3Qgc3VwcGx5IG9uZVxuXG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5xdWVyeUtleSkge1xuICAgICAgdGhpcy5vcHRpb25zLnF1ZXJ5S2V5ID0gcHJldk9wdGlvbnMucXVlcnlLZXk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVRdWVyeSgpO1xuICAgIGNvbnN0IG1vdW50ZWQgPSB0aGlzLmhhc0xpc3RlbmVycygpOyAvLyBGZXRjaCBpZiB0aGVyZSBhcmUgc3Vic2NyaWJlcnNcblxuICAgIGlmIChtb3VudGVkICYmIHNob3VsZEZldGNoT3B0aW9uYWxseSh0aGlzLmN1cnJlbnRRdWVyeSwgcHJldlF1ZXJ5LCB0aGlzLm9wdGlvbnMsIHByZXZPcHRpb25zKSkge1xuICAgICAgdGhpcy5leGVjdXRlRmV0Y2goKTtcbiAgICB9IC8vIFVwZGF0ZSByZXN1bHRcblxuXG4gICAgdGhpcy51cGRhdGVSZXN1bHQobm90aWZ5T3B0aW9ucyk7IC8vIFVwZGF0ZSBzdGFsZSBpbnRlcnZhbCBpZiBuZWVkZWRcblxuICAgIGlmIChtb3VudGVkICYmICh0aGlzLmN1cnJlbnRRdWVyeSAhPT0gcHJldlF1ZXJ5IHx8IHRoaXMub3B0aW9ucy5lbmFibGVkICE9PSBwcmV2T3B0aW9ucy5lbmFibGVkIHx8IHRoaXMub3B0aW9ucy5zdGFsZVRpbWUgIT09IHByZXZPcHRpb25zLnN0YWxlVGltZSkpIHtcbiAgICAgIHRoaXMudXBkYXRlU3RhbGVUaW1lb3V0KCk7XG4gICAgfVxuXG4gICAgY29uc3QgbmV4dFJlZmV0Y2hJbnRlcnZhbCA9IHRoaXMuY29tcHV0ZVJlZmV0Y2hJbnRlcnZhbCgpOyAvLyBVcGRhdGUgcmVmZXRjaCBpbnRlcnZhbCBpZiBuZWVkZWRcblxuICAgIGlmIChtb3VudGVkICYmICh0aGlzLmN1cnJlbnRRdWVyeSAhPT0gcHJldlF1ZXJ5IHx8IHRoaXMub3B0aW9ucy5lbmFibGVkICE9PSBwcmV2T3B0aW9ucy5lbmFibGVkIHx8IG5leHRSZWZldGNoSW50ZXJ2YWwgIT09IHRoaXMuY3VycmVudFJlZmV0Y2hJbnRlcnZhbCkpIHtcbiAgICAgIHRoaXMudXBkYXRlUmVmZXRjaEludGVydmFsKG5leHRSZWZldGNoSW50ZXJ2YWwpO1xuICAgIH1cbiAgfVxuXG4gIGdldE9wdGltaXN0aWNSZXN1bHQob3B0aW9ucykge1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5jbGllbnQuZ2V0UXVlcnlDYWNoZSgpLmJ1aWxkKHRoaXMuY2xpZW50LCBvcHRpb25zKTtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNyZWF0ZVJlc3VsdChxdWVyeSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoc2hvdWxkQXNzaWduT2JzZXJ2ZXJDdXJyZW50UHJvcGVydGllcyh0aGlzLCByZXN1bHQsIG9wdGlvbnMpKSB7XG4gICAgICAvLyB0aGlzIGFzc2lnbnMgdGhlIG9wdGltaXN0aWMgcmVzdWx0IHRvIHRoZSBjdXJyZW50IE9ic2VydmVyXG4gICAgICAvLyBiZWNhdXNlIGlmIHRoZSBxdWVyeSBmdW5jdGlvbiBjaGFuZ2VzLCB1c2VRdWVyeSB3aWxsIGJlIHBlcmZvcm1pbmdcbiAgICAgIC8vIGFuIGVmZmVjdCB3aGVyZSBpdCB3b3VsZCBmZXRjaCBhZ2Fpbi5cbiAgICAgIC8vIFdoZW4gdGhlIGZldGNoIGZpbmlzaGVzLCB3ZSBwZXJmb3JtIGEgZGVlcCBkYXRhIGNsb25pbmcgaW4gb3JkZXJcbiAgICAgIC8vIHRvIHJldXNlIG9iamVjdHMgcmVmZXJlbmNlcy4gVGhpcyBkZWVwIGRhdGEgY2xvbmUgaXMgcGVyZm9ybWVkIGFnYWluc3RcbiAgICAgIC8vIHRoZSBgb2JzZXJ2ZXIuY3VycmVudFJlc3VsdC5kYXRhYCBwcm9wZXJ0eVxuICAgICAgLy8gV2hlbiBRdWVyeUtleSBjaGFuZ2VzLCB3ZSByZWZyZXNoIHRoZSBxdWVyeSBhbmQgZ2V0IG5ldyBgb3B0aW1pc3RpY2BcbiAgICAgIC8vIHJlc3VsdCwgd2hpbGUgd2UgbGVhdmUgdGhlIGBvYnNlcnZlci5jdXJyZW50UmVzdWx0YCwgc28gd2hlbiBuZXcgZGF0YVxuICAgICAgLy8gYXJyaXZlcywgaXQgZmluZHMgdGhlIG9sZCBgb2JzZXJ2ZXIuY3VycmVudFJlc3VsdGAgd2hpY2ggaXMgcmVsYXRlZFxuICAgICAgLy8gdG8gdGhlIG9sZCBRdWVyeUtleS4gV2hpY2ggbWVhbnMgdGhhdCBjdXJyZW50UmVzdWx0IGFuZCBzZWxlY3REYXRhIGFyZVxuICAgICAgLy8gb3V0IG9mIHN5bmMgYWxyZWFkeS5cbiAgICAgIC8vIFRvIHNvbHZlIHRoaXMsIHdlIG1vdmUgdGhlIGN1cnNvciBvZiB0aGUgY3VycmVudFJlc3VsdCBldmVyeXRpbWVcbiAgICAgIC8vIGFuIG9ic2VydmVyIHJlYWRzIGFuIG9wdGltaXN0aWMgdmFsdWUuXG4gICAgICAvLyBXaGVuIGtlZXBpbmcgdGhlIHByZXZpb3VzIGRhdGEsIHRoZSByZXN1bHQgZG9lc24ndCBjaGFuZ2UgdW50aWwgbmV3XG4gICAgICAvLyBkYXRhIGFycml2ZXMuXG4gICAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSByZXN1bHQ7XG4gICAgICB0aGlzLmN1cnJlbnRSZXN1bHRPcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdGhpcy5jdXJyZW50UmVzdWx0U3RhdGUgPSB0aGlzLmN1cnJlbnRRdWVyeS5zdGF0ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZ2V0Q3VycmVudFJlc3VsdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50UmVzdWx0O1xuICB9XG5cbiAgdHJhY2tSZXN1bHQocmVzdWx0KSB7XG4gICAgY29uc3QgdHJhY2tlZFJlc3VsdCA9IHt9O1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRyYWNrZWRSZXN1bHQsIGtleSwge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLnRyYWNrZWRQcm9wcy5hZGQoa2V5KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0W2tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0cmFja2VkUmVzdWx0O1xuICB9XG5cbiAgZ2V0Q3VycmVudFF1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRRdWVyeTtcbiAgfVxuXG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLmNsaWVudC5nZXRRdWVyeUNhY2hlKCkucmVtb3ZlKHRoaXMuY3VycmVudFF1ZXJ5KTtcbiAgfVxuXG4gIHJlZmV0Y2goe1xuICAgIHJlZmV0Y2hQYWdlLFxuICAgIC4uLm9wdGlvbnNcbiAgfSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2goeyAuLi5vcHRpb25zLFxuICAgICAgbWV0YToge1xuICAgICAgICByZWZldGNoUGFnZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZmV0Y2hPcHRpbWlzdGljKG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZhdWx0ZWRPcHRpb25zID0gdGhpcy5jbGllbnQuZGVmYXVsdFF1ZXJ5T3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMuY2xpZW50LmdldFF1ZXJ5Q2FjaGUoKS5idWlsZCh0aGlzLmNsaWVudCwgZGVmYXVsdGVkT3B0aW9ucyk7XG4gICAgcXVlcnkuaXNGZXRjaGluZ09wdGltaXN0aWMgPSB0cnVlO1xuICAgIHJldHVybiBxdWVyeS5mZXRjaCgpLnRoZW4oKCkgPT4gdGhpcy5jcmVhdGVSZXN1bHQocXVlcnksIGRlZmF1bHRlZE9wdGlvbnMpKTtcbiAgfVxuXG4gIGZldGNoKGZldGNoT3B0aW9ucykge1xuICAgIHZhciBfZmV0Y2hPcHRpb25zJGNhbmNlbFI7XG5cbiAgICByZXR1cm4gdGhpcy5leGVjdXRlRmV0Y2goeyAuLi5mZXRjaE9wdGlvbnMsXG4gICAgICBjYW5jZWxSZWZldGNoOiAoX2ZldGNoT3B0aW9ucyRjYW5jZWxSID0gZmV0Y2hPcHRpb25zLmNhbmNlbFJlZmV0Y2gpICE9IG51bGwgPyBfZmV0Y2hPcHRpb25zJGNhbmNlbFIgOiB0cnVlXG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZVJlc3VsdCgpO1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFJlc3VsdDtcbiAgICB9KTtcbiAgfVxuXG4gIGV4ZWN1dGVGZXRjaChmZXRjaE9wdGlvbnMpIHtcbiAgICAvLyBNYWtlIHN1cmUgd2UgcmVmZXJlbmNlIHRoZSBsYXRlc3QgcXVlcnkgYXMgdGhlIGN1cnJlbnQgb25lIG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkXG4gICAgdGhpcy51cGRhdGVRdWVyeSgpOyAvLyBGZXRjaFxuXG4gICAgbGV0IHByb21pc2UgPSB0aGlzLmN1cnJlbnRRdWVyeS5mZXRjaCh0aGlzLm9wdGlvbnMsIGZldGNoT3B0aW9ucyk7XG5cbiAgICBpZiAoIShmZXRjaE9wdGlvbnMgIT0gbnVsbCAmJiBmZXRjaE9wdGlvbnMudGhyb3dPbkVycm9yKSkge1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UuY2F0Y2gobm9vcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICB1cGRhdGVTdGFsZVRpbWVvdXQoKSB7XG4gICAgdGhpcy5jbGVhclN0YWxlVGltZW91dCgpO1xuXG4gICAgaWYgKGlzU2VydmVyIHx8IHRoaXMuY3VycmVudFJlc3VsdC5pc1N0YWxlIHx8ICFpc1ZhbGlkVGltZW91dCh0aGlzLm9wdGlvbnMuc3RhbGVUaW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbWUgPSB0aW1lVW50aWxTdGFsZSh0aGlzLmN1cnJlbnRSZXN1bHQuZGF0YVVwZGF0ZWRBdCwgdGhpcy5vcHRpb25zLnN0YWxlVGltZSk7IC8vIFRoZSB0aW1lb3V0IGlzIHNvbWV0aW1lcyB0cmlnZ2VyZWQgMSBtcyBiZWZvcmUgdGhlIHN0YWxlIHRpbWUgZXhwaXJhdGlvbi5cbiAgICAvLyBUbyBtaXRpZ2F0ZSB0aGlzIGlzc3VlIHdlIGFsd2F5cyBhZGQgMSBtcyB0byB0aGUgdGltZW91dC5cblxuICAgIGNvbnN0IHRpbWVvdXQgPSB0aW1lICsgMTtcbiAgICB0aGlzLnN0YWxlVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuY3VycmVudFJlc3VsdC5pc1N0YWxlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUmVzdWx0KCk7XG4gICAgICB9XG4gICAgfSwgdGltZW91dCk7XG4gIH1cblxuICBjb21wdXRlUmVmZXRjaEludGVydmFsKCkge1xuICAgIHZhciBfdGhpcyRvcHRpb25zJHJlZmV0Y2g7XG5cbiAgICByZXR1cm4gdHlwZW9mIHRoaXMub3B0aW9ucy5yZWZldGNoSW50ZXJ2YWwgPT09ICdmdW5jdGlvbicgPyB0aGlzLm9wdGlvbnMucmVmZXRjaEludGVydmFsKHRoaXMuY3VycmVudFJlc3VsdC5kYXRhLCB0aGlzLmN1cnJlbnRRdWVyeSkgOiAoX3RoaXMkb3B0aW9ucyRyZWZldGNoID0gdGhpcy5vcHRpb25zLnJlZmV0Y2hJbnRlcnZhbCkgIT0gbnVsbCA/IF90aGlzJG9wdGlvbnMkcmVmZXRjaCA6IGZhbHNlO1xuICB9XG5cbiAgdXBkYXRlUmVmZXRjaEludGVydmFsKG5leHRJbnRlcnZhbCkge1xuICAgIHRoaXMuY2xlYXJSZWZldGNoSW50ZXJ2YWwoKTtcbiAgICB0aGlzLmN1cnJlbnRSZWZldGNoSW50ZXJ2YWwgPSBuZXh0SW50ZXJ2YWw7XG5cbiAgICBpZiAoaXNTZXJ2ZXIgfHwgdGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IGZhbHNlIHx8ICFpc1ZhbGlkVGltZW91dCh0aGlzLmN1cnJlbnRSZWZldGNoSW50ZXJ2YWwpIHx8IHRoaXMuY3VycmVudFJlZmV0Y2hJbnRlcnZhbCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucmVmZXRjaEludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJlZmV0Y2hJbnRlcnZhbEluQmFja2dyb3VuZCB8fCBmb2N1c01hbmFnZXIuaXNGb2N1c2VkKCkpIHtcbiAgICAgICAgdGhpcy5leGVjdXRlRmV0Y2goKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmN1cnJlbnRSZWZldGNoSW50ZXJ2YWwpO1xuICB9XG5cbiAgdXBkYXRlVGltZXJzKCkge1xuICAgIHRoaXMudXBkYXRlU3RhbGVUaW1lb3V0KCk7XG4gICAgdGhpcy51cGRhdGVSZWZldGNoSW50ZXJ2YWwodGhpcy5jb21wdXRlUmVmZXRjaEludGVydmFsKCkpO1xuICB9XG5cbiAgY2xlYXJTdGFsZVRpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMuc3RhbGVUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnN0YWxlVGltZW91dElkKTtcbiAgICAgIHRoaXMuc3RhbGVUaW1lb3V0SWQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgY2xlYXJSZWZldGNoSW50ZXJ2YWwoKSB7XG4gICAgaWYgKHRoaXMucmVmZXRjaEludGVydmFsSWQpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5yZWZldGNoSW50ZXJ2YWxJZCk7XG4gICAgICB0aGlzLnJlZmV0Y2hJbnRlcnZhbElkID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZVJlc3VsdChxdWVyeSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHByZXZRdWVyeSA9IHRoaXMuY3VycmVudFF1ZXJ5O1xuICAgIGNvbnN0IHByZXZPcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHByZXZSZXN1bHQgPSB0aGlzLmN1cnJlbnRSZXN1bHQ7XG4gICAgY29uc3QgcHJldlJlc3VsdFN0YXRlID0gdGhpcy5jdXJyZW50UmVzdWx0U3RhdGU7XG4gICAgY29uc3QgcHJldlJlc3VsdE9wdGlvbnMgPSB0aGlzLmN1cnJlbnRSZXN1bHRPcHRpb25zO1xuICAgIGNvbnN0IHF1ZXJ5Q2hhbmdlID0gcXVlcnkgIT09IHByZXZRdWVyeTtcbiAgICBjb25zdCBxdWVyeUluaXRpYWxTdGF0ZSA9IHF1ZXJ5Q2hhbmdlID8gcXVlcnkuc3RhdGUgOiB0aGlzLmN1cnJlbnRRdWVyeUluaXRpYWxTdGF0ZTtcbiAgICBjb25zdCBwcmV2UXVlcnlSZXN1bHQgPSBxdWVyeUNoYW5nZSA/IHRoaXMuY3VycmVudFJlc3VsdCA6IHRoaXMucHJldmlvdXNRdWVyeVJlc3VsdDtcbiAgICBjb25zdCB7XG4gICAgICBzdGF0ZVxuICAgIH0gPSBxdWVyeTtcbiAgICBsZXQge1xuICAgICAgZGF0YVVwZGF0ZWRBdCxcbiAgICAgIGVycm9yLFxuICAgICAgZXJyb3JVcGRhdGVkQXQsXG4gICAgICBmZXRjaFN0YXR1cyxcbiAgICAgIHN0YXR1c1xuICAgIH0gPSBzdGF0ZTtcbiAgICBsZXQgaXNQcmV2aW91c0RhdGEgPSBmYWxzZTtcbiAgICBsZXQgaXNQbGFjZWhvbGRlckRhdGEgPSBmYWxzZTtcbiAgICBsZXQgZGF0YTsgLy8gT3B0aW1pc3RpY2FsbHkgc2V0IHJlc3VsdCBpbiBmZXRjaGluZyBzdGF0ZSBpZiBuZWVkZWRcblxuICAgIGlmIChvcHRpb25zLl9vcHRpbWlzdGljUmVzdWx0cykge1xuICAgICAgY29uc3QgbW91bnRlZCA9IHRoaXMuaGFzTGlzdGVuZXJzKCk7XG4gICAgICBjb25zdCBmZXRjaE9uTW91bnQgPSAhbW91bnRlZCAmJiBzaG91bGRGZXRjaE9uTW91bnQocXVlcnksIG9wdGlvbnMpO1xuICAgICAgY29uc3QgZmV0Y2hPcHRpb25hbGx5ID0gbW91bnRlZCAmJiBzaG91bGRGZXRjaE9wdGlvbmFsbHkocXVlcnksIHByZXZRdWVyeSwgb3B0aW9ucywgcHJldk9wdGlvbnMpO1xuXG4gICAgICBpZiAoZmV0Y2hPbk1vdW50IHx8IGZldGNoT3B0aW9uYWxseSkge1xuICAgICAgICBmZXRjaFN0YXR1cyA9IGNhbkZldGNoKHF1ZXJ5Lm9wdGlvbnMubmV0d29ya01vZGUpID8gJ2ZldGNoaW5nJyA6ICdwYXVzZWQnO1xuXG4gICAgICAgIGlmICghZGF0YVVwZGF0ZWRBdCkge1xuICAgICAgICAgIHN0YXR1cyA9ICdsb2FkaW5nJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5fb3B0aW1pc3RpY1Jlc3VsdHMgPT09ICdpc1Jlc3RvcmluZycpIHtcbiAgICAgICAgZmV0Y2hTdGF0dXMgPSAnaWRsZSc7XG4gICAgICB9XG4gICAgfSAvLyBLZWVwIHByZXZpb3VzIGRhdGEgaWYgbmVlZGVkXG5cblxuICAgIGlmIChvcHRpb25zLmtlZXBQcmV2aW91c0RhdGEgJiYgIXN0YXRlLmRhdGFVcGRhdGVkQXQgJiYgcHJldlF1ZXJ5UmVzdWx0ICE9IG51bGwgJiYgcHJldlF1ZXJ5UmVzdWx0LmlzU3VjY2VzcyAmJiBzdGF0dXMgIT09ICdlcnJvcicpIHtcbiAgICAgIGRhdGEgPSBwcmV2UXVlcnlSZXN1bHQuZGF0YTtcbiAgICAgIGRhdGFVcGRhdGVkQXQgPSBwcmV2UXVlcnlSZXN1bHQuZGF0YVVwZGF0ZWRBdDtcbiAgICAgIHN0YXR1cyA9IHByZXZRdWVyeVJlc3VsdC5zdGF0dXM7XG4gICAgICBpc1ByZXZpb3VzRGF0YSA9IHRydWU7XG4gICAgfSAvLyBTZWxlY3QgZGF0YSBpZiBuZWVkZWRcbiAgICBlbHNlIGlmIChvcHRpb25zLnNlbGVjdCAmJiB0eXBlb2Ygc3RhdGUuZGF0YSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIE1lbW9pemUgc2VsZWN0IHJlc3VsdFxuICAgICAgaWYgKHByZXZSZXN1bHQgJiYgc3RhdGUuZGF0YSA9PT0gKHByZXZSZXN1bHRTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcHJldlJlc3VsdFN0YXRlLmRhdGEpICYmIG9wdGlvbnMuc2VsZWN0ID09PSB0aGlzLnNlbGVjdEZuKSB7XG4gICAgICAgIGRhdGEgPSB0aGlzLnNlbGVjdFJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RGbiA9IG9wdGlvbnMuc2VsZWN0O1xuICAgICAgICAgIGRhdGEgPSBvcHRpb25zLnNlbGVjdChzdGF0ZS5kYXRhKTtcbiAgICAgICAgICBkYXRhID0gcmVwbGFjZURhdGEocHJldlJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJldlJlc3VsdC5kYXRhLCBkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgICB0aGlzLnNlbGVjdFJlc3VsdCA9IGRhdGE7XG4gICAgICAgICAgdGhpcy5zZWxlY3RFcnJvciA9IG51bGw7XG4gICAgICAgIH0gY2F0Y2ggKHNlbGVjdEVycm9yKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50LmdldExvZ2dlcigpLmVycm9yKHNlbGVjdEVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnNlbGVjdEVycm9yID0gc2VsZWN0RXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIFVzZSBxdWVyeSBkYXRhXG4gICAgZWxzZSB7XG4gICAgICBkYXRhID0gc3RhdGUuZGF0YTtcbiAgICB9IC8vIFNob3cgcGxhY2Vob2xkZXIgZGF0YSBpZiBuZWVkZWRcblxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnBsYWNlaG9sZGVyRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnICYmIHN0YXR1cyA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICBsZXQgcGxhY2Vob2xkZXJEYXRhOyAvLyBNZW1vaXplIHBsYWNlaG9sZGVyIGRhdGFcblxuICAgICAgaWYgKHByZXZSZXN1bHQgIT0gbnVsbCAmJiBwcmV2UmVzdWx0LmlzUGxhY2Vob2xkZXJEYXRhICYmIG9wdGlvbnMucGxhY2Vob2xkZXJEYXRhID09PSAocHJldlJlc3VsdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZSZXN1bHRPcHRpb25zLnBsYWNlaG9sZGVyRGF0YSkpIHtcbiAgICAgICAgcGxhY2Vob2xkZXJEYXRhID0gcHJldlJlc3VsdC5kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGxhY2Vob2xkZXJEYXRhID0gdHlwZW9mIG9wdGlvbnMucGxhY2Vob2xkZXJEYXRhID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5wbGFjZWhvbGRlckRhdGEoKSA6IG9wdGlvbnMucGxhY2Vob2xkZXJEYXRhO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNlbGVjdCAmJiB0eXBlb2YgcGxhY2Vob2xkZXJEYXRhICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwbGFjZWhvbGRlckRhdGEgPSBvcHRpb25zLnNlbGVjdChwbGFjZWhvbGRlckRhdGEpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RFcnJvciA9IG51bGw7XG4gICAgICAgICAgfSBjYXRjaCAoc2VsZWN0RXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHRoaXMuY2xpZW50LmdldExvZ2dlcigpLmVycm9yKHNlbGVjdEVycm9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZWxlY3RFcnJvciA9IHNlbGVjdEVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHBsYWNlaG9sZGVyRGF0YSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc3RhdHVzID0gJ3N1Y2Nlc3MnO1xuICAgICAgICBkYXRhID0gcmVwbGFjZURhdGEocHJldlJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJldlJlc3VsdC5kYXRhLCBwbGFjZWhvbGRlckRhdGEsIG9wdGlvbnMpO1xuICAgICAgICBpc1BsYWNlaG9sZGVyRGF0YSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2VsZWN0RXJyb3IpIHtcbiAgICAgIGVycm9yID0gdGhpcy5zZWxlY3RFcnJvcjtcbiAgICAgIGRhdGEgPSB0aGlzLnNlbGVjdFJlc3VsdDtcbiAgICAgIGVycm9yVXBkYXRlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgIHN0YXR1cyA9ICdlcnJvcic7XG4gICAgfVxuXG4gICAgY29uc3QgaXNGZXRjaGluZyA9IGZldGNoU3RhdHVzID09PSAnZmV0Y2hpbmcnO1xuICAgIGNvbnN0IGlzTG9hZGluZyA9IHN0YXR1cyA9PT0gJ2xvYWRpbmcnO1xuICAgIGNvbnN0IGlzRXJyb3IgPSBzdGF0dXMgPT09ICdlcnJvcic7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgc3RhdHVzLFxuICAgICAgZmV0Y2hTdGF0dXMsXG4gICAgICBpc0xvYWRpbmcsXG4gICAgICBpc1N1Y2Nlc3M6IHN0YXR1cyA9PT0gJ3N1Y2Nlc3MnLFxuICAgICAgaXNFcnJvcixcbiAgICAgIGlzSW5pdGlhbExvYWRpbmc6IGlzTG9hZGluZyAmJiBpc0ZldGNoaW5nLFxuICAgICAgZGF0YSxcbiAgICAgIGRhdGFVcGRhdGVkQXQsXG4gICAgICBlcnJvcixcbiAgICAgIGVycm9yVXBkYXRlZEF0LFxuICAgICAgZmFpbHVyZUNvdW50OiBzdGF0ZS5mZXRjaEZhaWx1cmVDb3VudCxcbiAgICAgIGZhaWx1cmVSZWFzb246IHN0YXRlLmZldGNoRmFpbHVyZVJlYXNvbixcbiAgICAgIGVycm9yVXBkYXRlQ291bnQ6IHN0YXRlLmVycm9yVXBkYXRlQ291bnQsXG4gICAgICBpc0ZldGNoZWQ6IHN0YXRlLmRhdGFVcGRhdGVDb3VudCA+IDAgfHwgc3RhdGUuZXJyb3JVcGRhdGVDb3VudCA+IDAsXG4gICAgICBpc0ZldGNoZWRBZnRlck1vdW50OiBzdGF0ZS5kYXRhVXBkYXRlQ291bnQgPiBxdWVyeUluaXRpYWxTdGF0ZS5kYXRhVXBkYXRlQ291bnQgfHwgc3RhdGUuZXJyb3JVcGRhdGVDb3VudCA+IHF1ZXJ5SW5pdGlhbFN0YXRlLmVycm9yVXBkYXRlQ291bnQsXG4gICAgICBpc0ZldGNoaW5nLFxuICAgICAgaXNSZWZldGNoaW5nOiBpc0ZldGNoaW5nICYmICFpc0xvYWRpbmcsXG4gICAgICBpc0xvYWRpbmdFcnJvcjogaXNFcnJvciAmJiBzdGF0ZS5kYXRhVXBkYXRlZEF0ID09PSAwLFxuICAgICAgaXNQYXVzZWQ6IGZldGNoU3RhdHVzID09PSAncGF1c2VkJyxcbiAgICAgIGlzUGxhY2Vob2xkZXJEYXRhLFxuICAgICAgaXNQcmV2aW91c0RhdGEsXG4gICAgICBpc1JlZmV0Y2hFcnJvcjogaXNFcnJvciAmJiBzdGF0ZS5kYXRhVXBkYXRlZEF0ICE9PSAwLFxuICAgICAgaXNTdGFsZTogaXNTdGFsZShxdWVyeSwgb3B0aW9ucyksXG4gICAgICByZWZldGNoOiB0aGlzLnJlZmV0Y2gsXG4gICAgICByZW1vdmU6IHRoaXMucmVtb3ZlXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdXBkYXRlUmVzdWx0KG5vdGlmeU9wdGlvbnMpIHtcbiAgICBjb25zdCBwcmV2UmVzdWx0ID0gdGhpcy5jdXJyZW50UmVzdWx0O1xuICAgIGNvbnN0IG5leHRSZXN1bHQgPSB0aGlzLmNyZWF0ZVJlc3VsdCh0aGlzLmN1cnJlbnRRdWVyeSwgdGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLmN1cnJlbnRSZXN1bHRTdGF0ZSA9IHRoaXMuY3VycmVudFF1ZXJ5LnN0YXRlO1xuICAgIHRoaXMuY3VycmVudFJlc3VsdE9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7IC8vIE9ubHkgbm90aWZ5IGFuZCB1cGRhdGUgcmVzdWx0IGlmIHNvbWV0aGluZyBoYXMgY2hhbmdlZFxuXG4gICAgaWYgKHNoYWxsb3dFcXVhbE9iamVjdHMobmV4dFJlc3VsdCwgcHJldlJlc3VsdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBuZXh0UmVzdWx0OyAvLyBEZXRlcm1pbmUgd2hpY2ggY2FsbGJhY2tzIHRvIHRyaWdnZXJcblxuICAgIGNvbnN0IGRlZmF1bHROb3RpZnlPcHRpb25zID0ge1xuICAgICAgY2FjaGU6IHRydWVcbiAgICB9O1xuXG4gICAgY29uc3Qgc2hvdWxkTm90aWZ5TGlzdGVuZXJzID0gKCkgPT4ge1xuICAgICAgaWYgKCFwcmV2UmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIG5vdGlmeU9uQ2hhbmdlUHJvcHNcbiAgICAgIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBjb25zdCBub3RpZnlPbkNoYW5nZVByb3BzVmFsdWUgPSB0eXBlb2Ygbm90aWZ5T25DaGFuZ2VQcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/IG5vdGlmeU9uQ2hhbmdlUHJvcHMoKSA6IG5vdGlmeU9uQ2hhbmdlUHJvcHM7XG5cbiAgICAgIGlmIChub3RpZnlPbkNoYW5nZVByb3BzVmFsdWUgPT09ICdhbGwnIHx8ICFub3RpZnlPbkNoYW5nZVByb3BzVmFsdWUgJiYgIXRoaXMudHJhY2tlZFByb3BzLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGluY2x1ZGVkUHJvcHMgPSBuZXcgU2V0KG5vdGlmeU9uQ2hhbmdlUHJvcHNWYWx1ZSAhPSBudWxsID8gbm90aWZ5T25DaGFuZ2VQcm9wc1ZhbHVlIDogdGhpcy50cmFja2VkUHJvcHMpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVzZUVycm9yQm91bmRhcnkpIHtcbiAgICAgICAgaW5jbHVkZWRQcm9wcy5hZGQoJ2Vycm9yJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmN1cnJlbnRSZXN1bHQpLnNvbWUoa2V5ID0+IHtcbiAgICAgICAgY29uc3QgdHlwZWRLZXkgPSBrZXk7XG4gICAgICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLmN1cnJlbnRSZXN1bHRbdHlwZWRLZXldICE9PSBwcmV2UmVzdWx0W3R5cGVkS2V5XTtcbiAgICAgICAgcmV0dXJuIGNoYW5nZWQgJiYgaW5jbHVkZWRQcm9wcy5oYXModHlwZWRLZXkpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmICgobm90aWZ5T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogbm90aWZ5T3B0aW9ucy5saXN0ZW5lcnMpICE9PSBmYWxzZSAmJiBzaG91bGROb3RpZnlMaXN0ZW5lcnMoKSkge1xuICAgICAgZGVmYXVsdE5vdGlmeU9wdGlvbnMubGlzdGVuZXJzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeSh7IC4uLmRlZmF1bHROb3RpZnlPcHRpb25zLFxuICAgICAgLi4ubm90aWZ5T3B0aW9uc1xuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlUXVlcnkoKSB7XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLmNsaWVudC5nZXRRdWVyeUNhY2hlKCkuYnVpbGQodGhpcy5jbGllbnQsIHRoaXMub3B0aW9ucyk7XG5cbiAgICBpZiAocXVlcnkgPT09IHRoaXMuY3VycmVudFF1ZXJ5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcHJldlF1ZXJ5ID0gdGhpcy5jdXJyZW50UXVlcnk7XG4gICAgdGhpcy5jdXJyZW50UXVlcnkgPSBxdWVyeTtcbiAgICB0aGlzLmN1cnJlbnRRdWVyeUluaXRpYWxTdGF0ZSA9IHF1ZXJ5LnN0YXRlO1xuICAgIHRoaXMucHJldmlvdXNRdWVyeVJlc3VsdCA9IHRoaXMuY3VycmVudFJlc3VsdDtcblxuICAgIGlmICh0aGlzLmhhc0xpc3RlbmVycygpKSB7XG4gICAgICBwcmV2UXVlcnkgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZRdWVyeS5yZW1vdmVPYnNlcnZlcih0aGlzKTtcbiAgICAgIHF1ZXJ5LmFkZE9ic2VydmVyKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIG9uUXVlcnlVcGRhdGUoYWN0aW9uKSB7XG4gICAgY29uc3Qgbm90aWZ5T3B0aW9ucyA9IHt9O1xuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSAnc3VjY2VzcycpIHtcbiAgICAgIG5vdGlmeU9wdGlvbnMub25TdWNjZXNzID0gIWFjdGlvbi5tYW51YWw7XG4gICAgfSBlbHNlIGlmIChhY3Rpb24udHlwZSA9PT0gJ2Vycm9yJyAmJiAhaXNDYW5jZWxsZWRFcnJvcihhY3Rpb24uZXJyb3IpKSB7XG4gICAgICBub3RpZnlPcHRpb25zLm9uRXJyb3IgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlUmVzdWx0KG5vdGlmeU9wdGlvbnMpO1xuXG4gICAgaWYgKHRoaXMuaGFzTGlzdGVuZXJzKCkpIHtcbiAgICAgIHRoaXMudXBkYXRlVGltZXJzKCk7XG4gICAgfVxuICB9XG5cbiAgbm90aWZ5KG5vdGlmeU9wdGlvbnMpIHtcbiAgICBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHtcbiAgICAgIC8vIEZpcnN0IHRyaWdnZXIgdGhlIGNvbmZpZ3VyYXRpb24gY2FsbGJhY2tzXG4gICAgICBpZiAobm90aWZ5T3B0aW9ucy5vblN1Y2Nlc3MpIHtcbiAgICAgICAgdmFyIF90aGlzJG9wdGlvbnMkb25TdWNjZSwgX3RoaXMkb3B0aW9ucywgX3RoaXMkb3B0aW9ucyRvblNldHRsLCBfdGhpcyRvcHRpb25zMjtcblxuICAgICAgICAoX3RoaXMkb3B0aW9ucyRvblN1Y2NlID0gKF90aGlzJG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMpLm9uU3VjY2VzcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnMkb25TdWNjZS5jYWxsKF90aGlzJG9wdGlvbnMsIHRoaXMuY3VycmVudFJlc3VsdC5kYXRhKTtcbiAgICAgICAgKF90aGlzJG9wdGlvbnMkb25TZXR0bCA9IChfdGhpcyRvcHRpb25zMiA9IHRoaXMub3B0aW9ucykub25TZXR0bGVkKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9ucyRvblNldHRsLmNhbGwoX3RoaXMkb3B0aW9uczIsIHRoaXMuY3VycmVudFJlc3VsdC5kYXRhLCBudWxsKTtcbiAgICAgIH0gZWxzZSBpZiAobm90aWZ5T3B0aW9ucy5vbkVycm9yKSB7XG4gICAgICAgIHZhciBfdGhpcyRvcHRpb25zJG9uRXJyb3IsIF90aGlzJG9wdGlvbnMzLCBfdGhpcyRvcHRpb25zJG9uU2V0dGwyLCBfdGhpcyRvcHRpb25zNDtcblxuICAgICAgICAoX3RoaXMkb3B0aW9ucyRvbkVycm9yID0gKF90aGlzJG9wdGlvbnMzID0gdGhpcy5vcHRpb25zKS5vbkVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9ucyRvbkVycm9yLmNhbGwoX3RoaXMkb3B0aW9uczMsIHRoaXMuY3VycmVudFJlc3VsdC5lcnJvcik7XG4gICAgICAgIChfdGhpcyRvcHRpb25zJG9uU2V0dGwyID0gKF90aGlzJG9wdGlvbnM0ID0gdGhpcy5vcHRpb25zKS5vblNldHRsZWQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zJG9uU2V0dGwyLmNhbGwoX3RoaXMkb3B0aW9uczQsIHVuZGVmaW5lZCwgdGhpcy5jdXJyZW50UmVzdWx0LmVycm9yKTtcbiAgICAgIH0gLy8gVGhlbiB0cmlnZ2VyIHRoZSBsaXN0ZW5lcnNcblxuXG4gICAgICBpZiAobm90aWZ5T3B0aW9ucy5saXN0ZW5lcnMpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaCgoe1xuICAgICAgICAgIGxpc3RlbmVyXG4gICAgICAgIH0pID0+IHtcbiAgICAgICAgICBsaXN0ZW5lcih0aGlzLmN1cnJlbnRSZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gVGhlbiB0aGUgY2FjaGUgbGlzdGVuZXJzXG5cblxuICAgICAgaWYgKG5vdGlmeU9wdGlvbnMuY2FjaGUpIHtcbiAgICAgICAgdGhpcy5jbGllbnQuZ2V0UXVlcnlDYWNoZSgpLm5vdGlmeSh7XG4gICAgICAgICAgcXVlcnk6IHRoaXMuY3VycmVudFF1ZXJ5LFxuICAgICAgICAgIHR5cGU6ICdvYnNlcnZlclJlc3VsdHNVcGRhdGVkJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIHNob3VsZExvYWRPbk1vdW50KHF1ZXJ5LCBvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmVuYWJsZWQgIT09IGZhbHNlICYmICFxdWVyeS5zdGF0ZS5kYXRhVXBkYXRlZEF0ICYmICEocXVlcnkuc3RhdGUuc3RhdHVzID09PSAnZXJyb3InICYmIG9wdGlvbnMucmV0cnlPbk1vdW50ID09PSBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZEZldGNoT25Nb3VudChxdWVyeSwgb3B0aW9ucykge1xuICByZXR1cm4gc2hvdWxkTG9hZE9uTW91bnQocXVlcnksIG9wdGlvbnMpIHx8IHF1ZXJ5LnN0YXRlLmRhdGFVcGRhdGVkQXQgPiAwICYmIHNob3VsZEZldGNoT24ocXVlcnksIG9wdGlvbnMsIG9wdGlvbnMucmVmZXRjaE9uTW91bnQpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRGZXRjaE9uKHF1ZXJ5LCBvcHRpb25zLCBmaWVsZCkge1xuICBpZiAob3B0aW9ucy5lbmFibGVkICE9PSBmYWxzZSkge1xuICAgIGNvbnN0IHZhbHVlID0gdHlwZW9mIGZpZWxkID09PSAnZnVuY3Rpb24nID8gZmllbGQocXVlcnkpIDogZmllbGQ7XG4gICAgcmV0dXJuIHZhbHVlID09PSAnYWx3YXlzJyB8fCB2YWx1ZSAhPT0gZmFsc2UgJiYgaXNTdGFsZShxdWVyeSwgb3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNob3VsZEZldGNoT3B0aW9uYWxseShxdWVyeSwgcHJldlF1ZXJ5LCBvcHRpb25zLCBwcmV2T3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5lbmFibGVkICE9PSBmYWxzZSAmJiAocXVlcnkgIT09IHByZXZRdWVyeSB8fCBwcmV2T3B0aW9ucy5lbmFibGVkID09PSBmYWxzZSkgJiYgKCFvcHRpb25zLnN1c3BlbnNlIHx8IHF1ZXJ5LnN0YXRlLnN0YXR1cyAhPT0gJ2Vycm9yJykgJiYgaXNTdGFsZShxdWVyeSwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGlzU3RhbGUocXVlcnksIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHF1ZXJ5LmlzU3RhbGVCeVRpbWUob3B0aW9ucy5zdGFsZVRpbWUpO1xufSAvLyB0aGlzIGZ1bmN0aW9uIHdvdWxkIGRlY2lkZSBpZiB3ZSB3aWxsIHVwZGF0ZSB0aGUgb2JzZXJ2ZXIncyAnY3VycmVudCdcbi8vIHByb3BlcnRpZXMgYWZ0ZXIgYW4gb3B0aW1pc3RpYyByZWFkaW5nIHZpYSBnZXRPcHRpbWlzdGljUmVzdWx0XG5cblxuZnVuY3Rpb24gc2hvdWxkQXNzaWduT2JzZXJ2ZXJDdXJyZW50UHJvcGVydGllcyhvYnNlcnZlciwgb3B0aW1pc3RpY1Jlc3VsdCwgb3B0aW9ucykge1xuICAvLyBpdCBpcyBpbXBvcnRhbnQgdG8ga2VlcCB0aGlzIGNvbmRpdGlvbiBsaWtlIHRoaXMgZm9yIHRocmVlIHJlYXNvbnM6XG4gIC8vIDEuIEl0IHdpbGwgZ2V0IHJlbW92ZWQgaW4gdGhlIHY1XG4gIC8vIDIuIGl0IHJlYWRzOiBkb24ndCB1cGRhdGUgdGhlIHByb3BlcnRpZXMgaWYgd2Ugd2FudCB0byBrZWVwIHRoZSBwcmV2aW91c1xuICAvLyBkYXRhLlxuICAvLyAzLiBUaGUgb3Bwb3NpdGUgY29uZGl0aW9uICghb3B0aW9ucy5rZWVwUHJldmlvdXNEYXRhKSB3b3VsZCBmYWxsdGhyb3VnaFxuICAvLyBhbmQgd2lsbCByZXN1bHQgaW4gYSBiYWQgZGVjaXNpb25cbiAgaWYgKG9wdGlvbnMua2VlcFByZXZpb3VzRGF0YSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyB0aGlzIG1lYW5zIHdlIHdhbnQgdG8gcHV0IHNvbWUgcGxhY2Vob2xkZXIgZGF0YSB3aGVuIHBlbmRpbmcgYW5kIHF1ZXJ5S2V5XG4gIC8vIGNoYW5nZWQuXG5cblxuICBpZiAob3B0aW9ucy5wbGFjZWhvbGRlckRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIHJlLWFzc2lnbiBwcm9wZXJ0aWVzIG9ubHkgaWYgY3VycmVudCBkYXRhIGlzIHBsYWNlaG9sZGVyIGRhdGFcbiAgICAvLyB3aGljaCBtZWFucyB0aGF0IGRhdGEgZGlkIG5vdCBhcnJpdmUgeWV0LCBzbywgaWYgdGhlcmUgaXMgc29tZSBjYWNoZWQgZGF0YVxuICAgIC8vIHdlIG5lZWQgdG8gXCJwcmVwYXJlXCIgdG8gcmVjZWl2ZSBpdFxuICAgIHJldHVybiBvcHRpbWlzdGljUmVzdWx0LmlzUGxhY2Vob2xkZXJEYXRhO1xuICB9IC8vIGlmIHRoZSBuZXdseSBjcmVhdGVkIHJlc3VsdCBpc24ndCB3aGF0IHRoZSBvYnNlcnZlciBpcyBob2xkaW5nIGFzIGN1cnJlbnQsXG4gIC8vIHRoZW4gd2UnbGwgbmVlZCB0byB1cGRhdGUgdGhlIHByb3BlcnRpZXMgYXMgd2VsbFxuXG5cbiAgaWYgKCFzaGFsbG93RXF1YWxPYmplY3RzKG9ic2VydmVyLmdldEN1cnJlbnRSZXN1bHQoKSwgb3B0aW1pc3RpY1Jlc3VsdCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBiYXNpY2FsbHksIGp1c3Qga2VlcCBwcmV2aW91cyBwcm9wZXJ0aWVzIGlmIG5vdGhpbmcgY2hhbmdlZFxuXG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgeyBRdWVyeU9ic2VydmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeU9ic2VydmVyLm1qcy5tYXBcbiIsIid1c2UgY2xpZW50JztcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlIGFzIHVzZVN5bmNFeHRlcm5hbFN0b3JlJDEgfSBmcm9tICd1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzJztcblxuY29uc3QgdXNlU3luY0V4dGVybmFsU3RvcmUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQxO1xuXG5leHBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlU3luY0V4dGVybmFsU3RvcmUubWpzLm1hcFxuIiwiJ3VzZSBjbGllbnQnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5mdW5jdGlvbiBjcmVhdGVWYWx1ZSgpIHtcbiAgbGV0IGlzUmVzZXQgPSBmYWxzZTtcbiAgcmV0dXJuIHtcbiAgICBjbGVhclJlc2V0OiAoKSA9PiB7XG4gICAgICBpc1Jlc2V0ID0gZmFsc2U7XG4gICAgfSxcbiAgICByZXNldDogKCkgPT4ge1xuICAgICAgaXNSZXNldCA9IHRydWU7XG4gICAgfSxcbiAgICBpc1Jlc2V0OiAoKSA9PiB7XG4gICAgICByZXR1cm4gaXNSZXNldDtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IFF1ZXJ5RXJyb3JSZXNldEJvdW5kYXJ5Q29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KGNyZWF0ZVZhbHVlKCkpOyAvLyBIT09LXG5cbmNvbnN0IHVzZVF1ZXJ5RXJyb3JSZXNldEJvdW5kYXJ5ID0gKCkgPT4gUmVhY3QudXNlQ29udGV4dChRdWVyeUVycm9yUmVzZXRCb3VuZGFyeUNvbnRleHQpOyAvLyBDT01QT05FTlRcblxuY29uc3QgUXVlcnlFcnJvclJlc2V0Qm91bmRhcnkgPSAoe1xuICBjaGlsZHJlblxufSkgPT4ge1xuICBjb25zdCBbdmFsdWVdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gY3JlYXRlVmFsdWUoKSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChRdWVyeUVycm9yUmVzZXRCb3VuZGFyeUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSwgdHlwZW9mIGNoaWxkcmVuID09PSAnZnVuY3Rpb24nID8gY2hpbGRyZW4odmFsdWUpIDogY2hpbGRyZW4pO1xufTtcblxuZXhwb3J0IHsgUXVlcnlFcnJvclJlc2V0Qm91bmRhcnksIHVzZVF1ZXJ5RXJyb3JSZXNldEJvdW5kYXJ5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1RdWVyeUVycm9yUmVzZXRCb3VuZGFyeS5tanMubWFwXG4iLCIndXNlIGNsaWVudCc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IGRlZmF1bHRDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbmNvbnN0IFF1ZXJ5Q2xpZW50U2hhcmluZ0NvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChmYWxzZSk7IC8vIElmIHdlIGFyZSBnaXZlbiBhIGNvbnRleHQsIHdlIHdpbGwgdXNlIGl0LlxuLy8gT3RoZXJ3aXNlLCBpZiBjb250ZXh0U2hhcmluZyBpcyBvbiwgd2Ugc2hhcmUgdGhlIGZpcnN0IGFuZCBhdCBsZWFzdCBvbmVcbi8vIGluc3RhbmNlIG9mIHRoZSBjb250ZXh0IGFjcm9zcyB0aGUgd2luZG93XG4vLyB0byBlbnN1cmUgdGhhdCBpZiBSZWFjdCBRdWVyeSBpcyB1c2VkIGFjcm9zc1xuLy8gZGlmZmVyZW50IGJ1bmRsZXMgb3IgbWljcm9mcm9udGVuZHMgdGhleSB3aWxsXG4vLyBhbGwgdXNlIHRoZSBzYW1lICoqaW5zdGFuY2UqKiBvZiBjb250ZXh0LCByZWdhcmRsZXNzXG4vLyBvZiBtb2R1bGUgc2NvcGluZy5cblxuZnVuY3Rpb24gZ2V0UXVlcnlDbGllbnRDb250ZXh0KGNvbnRleHQsIGNvbnRleHRTaGFyaW5nKSB7XG4gIGlmIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cblxuICBpZiAoY29udGV4dFNoYXJpbmcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoIXdpbmRvdy5SZWFjdFF1ZXJ5Q2xpZW50Q29udGV4dCkge1xuICAgICAgd2luZG93LlJlYWN0UXVlcnlDbGllbnRDb250ZXh0ID0gZGVmYXVsdENvbnRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdpbmRvdy5SZWFjdFF1ZXJ5Q2xpZW50Q29udGV4dDtcbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0Q29udGV4dDtcbn1cblxuY29uc3QgdXNlUXVlcnlDbGllbnQgPSAoe1xuICBjb250ZXh0XG59ID0ge30pID0+IHtcbiAgY29uc3QgcXVlcnlDbGllbnQgPSBSZWFjdC51c2VDb250ZXh0KGdldFF1ZXJ5Q2xpZW50Q29udGV4dChjb250ZXh0LCBSZWFjdC51c2VDb250ZXh0KFF1ZXJ5Q2xpZW50U2hhcmluZ0NvbnRleHQpKSk7XG5cbiAgaWYgKCFxdWVyeUNsaWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gUXVlcnlDbGllbnQgc2V0LCB1c2UgUXVlcnlDbGllbnRQcm92aWRlciB0byBzZXQgb25lJyk7XG4gIH1cblxuICByZXR1cm4gcXVlcnlDbGllbnQ7XG59O1xuY29uc3QgUXVlcnlDbGllbnRQcm92aWRlciA9ICh7XG4gIGNsaWVudCxcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHQsXG4gIGNvbnRleHRTaGFyaW5nID0gZmFsc2Vcbn0pID0+IHtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjbGllbnQubW91bnQoKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xpZW50LnVubW91bnQoKTtcbiAgICB9O1xuICB9LCBbY2xpZW50XSk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29udGV4dFNoYXJpbmcpIHtcbiAgICBjbGllbnQuZ2V0TG9nZ2VyKCkuZXJyb3IoXCJUaGUgY29udGV4dFNoYXJpbmcgb3B0aW9uIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uXCIpO1xuICB9XG5cbiAgY29uc3QgQ29udGV4dCA9IGdldFF1ZXJ5Q2xpZW50Q29udGV4dChjb250ZXh0LCBjb250ZXh0U2hhcmluZyk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChRdWVyeUNsaWVudFNoYXJpbmdDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6ICFjb250ZXh0ICYmIGNvbnRleHRTaGFyaW5nXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY2xpZW50XG4gIH0sIGNoaWxkcmVuKSk7XG59O1xuXG5leHBvcnQgeyBRdWVyeUNsaWVudFByb3ZpZGVyLCBkZWZhdWx0Q29udGV4dCwgdXNlUXVlcnlDbGllbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVF1ZXJ5Q2xpZW50UHJvdmlkZXIubWpzLm1hcFxuIiwiJ3VzZSBjbGllbnQnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5jb25zdCBJc1Jlc3RvcmluZ0NvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChmYWxzZSk7XG5jb25zdCB1c2VJc1Jlc3RvcmluZyA9ICgpID0+IFJlYWN0LnVzZUNvbnRleHQoSXNSZXN0b3JpbmdDb250ZXh0KTtcbmNvbnN0IElzUmVzdG9yaW5nUHJvdmlkZXIgPSBJc1Jlc3RvcmluZ0NvbnRleHQuUHJvdmlkZXI7XG5cbmV4cG9ydCB7IElzUmVzdG9yaW5nUHJvdmlkZXIsIHVzZUlzUmVzdG9yaW5nIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1Jlc3RvcmluZy5tanMubWFwXG4iLCJmdW5jdGlvbiBzaG91bGRUaHJvd0Vycm9yKF91c2VFcnJvckJvdW5kYXJ5LCBwYXJhbXMpIHtcbiAgLy8gQWxsb3cgdXNlRXJyb3JCb3VuZGFyeSBmdW5jdGlvbiB0byBvdmVycmlkZSB0aHJvd2luZyBiZWhhdmlvciBvbiBhIHBlci1lcnJvciBiYXNpc1xuICBpZiAodHlwZW9mIF91c2VFcnJvckJvdW5kYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIF91c2VFcnJvckJvdW5kYXJ5KC4uLnBhcmFtcyk7XG4gIH1cblxuICByZXR1cm4gISFfdXNlRXJyb3JCb3VuZGFyeTtcbn1cblxuZXhwb3J0IHsgc2hvdWxkVGhyb3dFcnJvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMubWpzLm1hcFxuIiwiJ3VzZSBjbGllbnQnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgc2hvdWxkVGhyb3dFcnJvciB9IGZyb20gJy4vdXRpbHMubWpzJztcblxuY29uc3QgZW5zdXJlUHJldmVudEVycm9yQm91bmRhcnlSZXRyeSA9IChvcHRpb25zLCBlcnJvclJlc2V0Qm91bmRhcnkpID0+IHtcbiAgaWYgKG9wdGlvbnMuc3VzcGVuc2UgfHwgb3B0aW9ucy51c2VFcnJvckJvdW5kYXJ5KSB7XG4gICAgLy8gUHJldmVudCByZXRyeWluZyBmYWlsZWQgcXVlcnkgaWYgdGhlIGVycm9yIGJvdW5kYXJ5IGhhcyBub3QgYmVlbiByZXNldCB5ZXRcbiAgICBpZiAoIWVycm9yUmVzZXRCb3VuZGFyeS5pc1Jlc2V0KCkpIHtcbiAgICAgIG9wdGlvbnMucmV0cnlPbk1vdW50ID0gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuY29uc3QgdXNlQ2xlYXJSZXNldEVycm9yQm91bmRhcnkgPSBlcnJvclJlc2V0Qm91bmRhcnkgPT4ge1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGVycm9yUmVzZXRCb3VuZGFyeS5jbGVhclJlc2V0KCk7XG4gIH0sIFtlcnJvclJlc2V0Qm91bmRhcnldKTtcbn07XG5jb25zdCBnZXRIYXNFcnJvciA9ICh7XG4gIHJlc3VsdCxcbiAgZXJyb3JSZXNldEJvdW5kYXJ5LFxuICB1c2VFcnJvckJvdW5kYXJ5LFxuICBxdWVyeVxufSkgPT4ge1xuICByZXR1cm4gcmVzdWx0LmlzRXJyb3IgJiYgIWVycm9yUmVzZXRCb3VuZGFyeS5pc1Jlc2V0KCkgJiYgIXJlc3VsdC5pc0ZldGNoaW5nICYmIHNob3VsZFRocm93RXJyb3IodXNlRXJyb3JCb3VuZGFyeSwgW3Jlc3VsdC5lcnJvciwgcXVlcnldKTtcbn07XG5cbmV4cG9ydCB7IGVuc3VyZVByZXZlbnRFcnJvckJvdW5kYXJ5UmV0cnksIGdldEhhc0Vycm9yLCB1c2VDbGVhclJlc2V0RXJyb3JCb3VuZGFyeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JCb3VuZGFyeVV0aWxzLm1qcy5tYXBcbiIsImNvbnN0IGVuc3VyZVN0YWxlVGltZSA9IGRlZmF1bHRlZE9wdGlvbnMgPT4ge1xuICBpZiAoZGVmYXVsdGVkT3B0aW9ucy5zdXNwZW5zZSkge1xuICAgIC8vIEFsd2F5cyBzZXQgc3RhbGUgdGltZSB3aGVuIHVzaW5nIHN1c3BlbnNlIHRvIHByZXZlbnRcbiAgICAvLyBmZXRjaGluZyBhZ2FpbiB3aGVuIGRpcmVjdGx5IG1vdW50aW5nIGFmdGVyIHN1c3BlbmRpbmdcbiAgICBpZiAodHlwZW9mIGRlZmF1bHRlZE9wdGlvbnMuc3RhbGVUaW1lICE9PSAnbnVtYmVyJykge1xuICAgICAgZGVmYXVsdGVkT3B0aW9ucy5zdGFsZVRpbWUgPSAxMDAwO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IHdpbGxGZXRjaCA9IChyZXN1bHQsIGlzUmVzdG9yaW5nKSA9PiByZXN1bHQuaXNMb2FkaW5nICYmIHJlc3VsdC5pc0ZldGNoaW5nICYmICFpc1Jlc3RvcmluZztcbmNvbnN0IHNob3VsZFN1c3BlbmQgPSAoZGVmYXVsdGVkT3B0aW9ucywgcmVzdWx0LCBpc1Jlc3RvcmluZykgPT4gKGRlZmF1bHRlZE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGRlZmF1bHRlZE9wdGlvbnMuc3VzcGVuc2UpICYmIHdpbGxGZXRjaChyZXN1bHQsIGlzUmVzdG9yaW5nKTtcbmNvbnN0IGZldGNoT3B0aW1pc3RpYyA9IChkZWZhdWx0ZWRPcHRpb25zLCBvYnNlcnZlciwgZXJyb3JSZXNldEJvdW5kYXJ5KSA9PiBvYnNlcnZlci5mZXRjaE9wdGltaXN0aWMoZGVmYXVsdGVkT3B0aW9ucykudGhlbigoe1xuICBkYXRhXG59KSA9PiB7XG4gIGRlZmF1bHRlZE9wdGlvbnMub25TdWNjZXNzID09IG51bGwgPyB2b2lkIDAgOiBkZWZhdWx0ZWRPcHRpb25zLm9uU3VjY2VzcyhkYXRhKTtcbiAgZGVmYXVsdGVkT3B0aW9ucy5vblNldHRsZWQgPT0gbnVsbCA/IHZvaWQgMCA6IGRlZmF1bHRlZE9wdGlvbnMub25TZXR0bGVkKGRhdGEsIG51bGwpO1xufSkuY2F0Y2goZXJyb3IgPT4ge1xuICBlcnJvclJlc2V0Qm91bmRhcnkuY2xlYXJSZXNldCgpO1xuICBkZWZhdWx0ZWRPcHRpb25zLm9uRXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGRlZmF1bHRlZE9wdGlvbnMub25FcnJvcihlcnJvcik7XG4gIGRlZmF1bHRlZE9wdGlvbnMub25TZXR0bGVkID09IG51bGwgPyB2b2lkIDAgOiBkZWZhdWx0ZWRPcHRpb25zLm9uU2V0dGxlZCh1bmRlZmluZWQsIGVycm9yKTtcbn0pO1xuXG5leHBvcnQgeyBlbnN1cmVTdGFsZVRpbWUsIGZldGNoT3B0aW1pc3RpYywgc2hvdWxkU3VzcGVuZCwgd2lsbEZldGNoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdXNwZW5zZS5tanMubWFwXG4iLCIndXNlIGNsaWVudCc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBub3RpZnlNYW5hZ2VyIH0gZnJvbSAnQHRhbnN0YWNrL3F1ZXJ5LWNvcmUnO1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmUgfSBmcm9tICcuL3VzZVN5bmNFeHRlcm5hbFN0b3JlLm1qcyc7XG5pbXBvcnQgeyB1c2VRdWVyeUVycm9yUmVzZXRCb3VuZGFyeSB9IGZyb20gJy4vUXVlcnlFcnJvclJlc2V0Qm91bmRhcnkubWpzJztcbmltcG9ydCB7IHVzZVF1ZXJ5Q2xpZW50IH0gZnJvbSAnLi9RdWVyeUNsaWVudFByb3ZpZGVyLm1qcyc7XG5pbXBvcnQgeyB1c2VJc1Jlc3RvcmluZyB9IGZyb20gJy4vaXNSZXN0b3JpbmcubWpzJztcbmltcG9ydCB7IGVuc3VyZVByZXZlbnRFcnJvckJvdW5kYXJ5UmV0cnksIHVzZUNsZWFyUmVzZXRFcnJvckJvdW5kYXJ5LCBnZXRIYXNFcnJvciB9IGZyb20gJy4vZXJyb3JCb3VuZGFyeVV0aWxzLm1qcyc7XG5pbXBvcnQgeyBlbnN1cmVTdGFsZVRpbWUsIHNob3VsZFN1c3BlbmQsIGZldGNoT3B0aW1pc3RpYyB9IGZyb20gJy4vc3VzcGVuc2UubWpzJztcblxuZnVuY3Rpb24gdXNlQmFzZVF1ZXJ5KG9wdGlvbnMsIE9ic2VydmVyKSB7XG4gIGNvbnN0IHF1ZXJ5Q2xpZW50ID0gdXNlUXVlcnlDbGllbnQoe1xuICAgIGNvbnRleHQ6IG9wdGlvbnMuY29udGV4dFxuICB9KTtcbiAgY29uc3QgaXNSZXN0b3JpbmcgPSB1c2VJc1Jlc3RvcmluZygpO1xuICBjb25zdCBlcnJvclJlc2V0Qm91bmRhcnkgPSB1c2VRdWVyeUVycm9yUmVzZXRCb3VuZGFyeSgpO1xuICBjb25zdCBkZWZhdWx0ZWRPcHRpb25zID0gcXVlcnlDbGllbnQuZGVmYXVsdFF1ZXJ5T3B0aW9ucyhvcHRpb25zKTsgLy8gTWFrZSBzdXJlIHJlc3VsdHMgYXJlIG9wdGltaXN0aWNhbGx5IHNldCBpbiBmZXRjaGluZyBzdGF0ZSBiZWZvcmUgc3Vic2NyaWJpbmcgb3IgdXBkYXRpbmcgb3B0aW9uc1xuXG4gIGRlZmF1bHRlZE9wdGlvbnMuX29wdGltaXN0aWNSZXN1bHRzID0gaXNSZXN0b3JpbmcgPyAnaXNSZXN0b3JpbmcnIDogJ29wdGltaXN0aWMnOyAvLyBJbmNsdWRlIGNhbGxiYWNrcyBpbiBiYXRjaCByZW5kZXJzXG5cbiAgaWYgKGRlZmF1bHRlZE9wdGlvbnMub25FcnJvcikge1xuICAgIGRlZmF1bHRlZE9wdGlvbnMub25FcnJvciA9IG5vdGlmeU1hbmFnZXIuYmF0Y2hDYWxscyhkZWZhdWx0ZWRPcHRpb25zLm9uRXJyb3IpO1xuICB9XG5cbiAgaWYgKGRlZmF1bHRlZE9wdGlvbnMub25TdWNjZXNzKSB7XG4gICAgZGVmYXVsdGVkT3B0aW9ucy5vblN1Y2Nlc3MgPSBub3RpZnlNYW5hZ2VyLmJhdGNoQ2FsbHMoZGVmYXVsdGVkT3B0aW9ucy5vblN1Y2Nlc3MpO1xuICB9XG5cbiAgaWYgKGRlZmF1bHRlZE9wdGlvbnMub25TZXR0bGVkKSB7XG4gICAgZGVmYXVsdGVkT3B0aW9ucy5vblNldHRsZWQgPSBub3RpZnlNYW5hZ2VyLmJhdGNoQ2FsbHMoZGVmYXVsdGVkT3B0aW9ucy5vblNldHRsZWQpO1xuICB9XG5cbiAgZW5zdXJlU3RhbGVUaW1lKGRlZmF1bHRlZE9wdGlvbnMpO1xuICBlbnN1cmVQcmV2ZW50RXJyb3JCb3VuZGFyeVJldHJ5KGRlZmF1bHRlZE9wdGlvbnMsIGVycm9yUmVzZXRCb3VuZGFyeSk7XG4gIHVzZUNsZWFyUmVzZXRFcnJvckJvdW5kYXJ5KGVycm9yUmVzZXRCb3VuZGFyeSk7XG4gIGNvbnN0IFtvYnNlcnZlcl0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgT2JzZXJ2ZXIocXVlcnlDbGllbnQsIGRlZmF1bHRlZE9wdGlvbnMpKTtcbiAgY29uc3QgcmVzdWx0ID0gb2JzZXJ2ZXIuZ2V0T3B0aW1pc3RpY1Jlc3VsdChkZWZhdWx0ZWRPcHRpb25zKTtcbiAgdXNlU3luY0V4dGVybmFsU3RvcmUoUmVhY3QudXNlQ2FsbGJhY2sob25TdG9yZUNoYW5nZSA9PiB7XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBpc1Jlc3RvcmluZyA/ICgpID0+IHVuZGVmaW5lZCA6IG9ic2VydmVyLnN1YnNjcmliZShub3RpZnlNYW5hZ2VyLmJhdGNoQ2FsbHMob25TdG9yZUNoYW5nZSkpOyAvLyBVcGRhdGUgcmVzdWx0IHRvIG1ha2Ugc3VyZSB3ZSBkaWQgbm90IG1pc3MgYW55IHF1ZXJ5IHVwZGF0ZXNcbiAgICAvLyBiZXR3ZWVuIGNyZWF0aW5nIHRoZSBvYnNlcnZlciBhbmQgc3Vic2NyaWJpbmcgdG8gaXQuXG5cbiAgICBvYnNlcnZlci51cGRhdGVSZXN1bHQoKTtcbiAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gIH0sIFtvYnNlcnZlciwgaXNSZXN0b3JpbmddKSwgKCkgPT4gb2JzZXJ2ZXIuZ2V0Q3VycmVudFJlc3VsdCgpLCAoKSA9PiBvYnNlcnZlci5nZXRDdXJyZW50UmVzdWx0KCkpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIERvIG5vdCBub3RpZnkgb24gdXBkYXRlcyBiZWNhdXNlIG9mIGNoYW5nZXMgaW4gdGhlIG9wdGlvbnMgYmVjYXVzZVxuICAgIC8vIHRoZXNlIGNoYW5nZXMgc2hvdWxkIGFscmVhZHkgYmUgcmVmbGVjdGVkIGluIHRoZSBvcHRpbWlzdGljIHJlc3VsdC5cbiAgICBvYnNlcnZlci5zZXRPcHRpb25zKGRlZmF1bHRlZE9wdGlvbnMsIHtcbiAgICAgIGxpc3RlbmVyczogZmFsc2VcbiAgICB9KTtcbiAgfSwgW2RlZmF1bHRlZE9wdGlvbnMsIG9ic2VydmVyXSk7IC8vIEhhbmRsZSBzdXNwZW5zZVxuXG4gIGlmIChzaG91bGRTdXNwZW5kKGRlZmF1bHRlZE9wdGlvbnMsIHJlc3VsdCwgaXNSZXN0b3JpbmcpKSB7XG4gICAgdGhyb3cgZmV0Y2hPcHRpbWlzdGljKGRlZmF1bHRlZE9wdGlvbnMsIG9ic2VydmVyLCBlcnJvclJlc2V0Qm91bmRhcnkpO1xuICB9IC8vIEhhbmRsZSBlcnJvciBib3VuZGFyeVxuXG5cbiAgaWYgKGdldEhhc0Vycm9yKHtcbiAgICByZXN1bHQsXG4gICAgZXJyb3JSZXNldEJvdW5kYXJ5LFxuICAgIHVzZUVycm9yQm91bmRhcnk6IGRlZmF1bHRlZE9wdGlvbnMudXNlRXJyb3JCb3VuZGFyeSxcbiAgICBxdWVyeTogb2JzZXJ2ZXIuZ2V0Q3VycmVudFF1ZXJ5KClcbiAgfSkpIHtcbiAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gIH0gLy8gSGFuZGxlIHJlc3VsdCBwcm9wZXJ0eSB1c2FnZSB0cmFja2luZ1xuXG5cbiAgcmV0dXJuICFkZWZhdWx0ZWRPcHRpb25zLm5vdGlmeU9uQ2hhbmdlUHJvcHMgPyBvYnNlcnZlci50cmFja1Jlc3VsdChyZXN1bHQpIDogcmVzdWx0O1xufVxuXG5leHBvcnQgeyB1c2VCYXNlUXVlcnkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZUJhc2VRdWVyeS5tanMubWFwXG4iLCIndXNlIGNsaWVudCc7XG5pbXBvcnQgeyBwYXJzZVF1ZXJ5QXJncywgUXVlcnlPYnNlcnZlciB9IGZyb20gJ0B0YW5zdGFjay9xdWVyeS1jb3JlJztcbmltcG9ydCB7IHVzZUJhc2VRdWVyeSB9IGZyb20gJy4vdXNlQmFzZVF1ZXJ5Lm1qcyc7XG5cbmZ1bmN0aW9uIHVzZVF1ZXJ5KGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgY29uc3QgcGFyc2VkT3B0aW9ucyA9IHBhcnNlUXVlcnlBcmdzKGFyZzEsIGFyZzIsIGFyZzMpO1xuICByZXR1cm4gdXNlQmFzZVF1ZXJ5KHBhcnNlZE9wdGlvbnMsIFF1ZXJ5T2JzZXJ2ZXIpO1xufVxuXG5leHBvcnQgeyB1c2VRdWVyeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlUXVlcnkubWpzLm1hcFxuIiwiZXhwb3J0IGNvbnN0IGdldFF1ZXJ5S2V5cyA9IChuYW1lOiBzdHJpbmcsIHByb3BzPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pID0+IHtcbiAgICBpZiAoIXByb3BzKSByZXR1cm4gW25hbWVdO1xuXG4gICAgZGVsZXRlIHByb3BzLnJlcV9pZDtcbiAgICBpZiAobmFtZSAmJiBwcm9wc1tuYW1lXSA9PT0gMSkgZGVsZXRlIHByb3BzW25hbWVdO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGggPT09IDApIHJldHVybiBbbmFtZV07XG5cbiAgICBjb25zdCBvcmRlcmVkX3Byb3BzID0gT2JqZWN0LmtleXMocHJvcHMpXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpXG4gICAgICAgIC5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHByb3BzW2tleV07XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0sIHt9IGFzIHsgW2s6IHN0cmluZ106IHVua25vd24gfSk7XG5cbiAgICBjb25zdCBxdWVyeV9wcm9wcyA9IEpTT04uc3RyaW5naWZ5KG9yZGVyZWRfcHJvcHMpO1xuXG4gICAgcmV0dXJuIFtuYW1lLCBxdWVyeV9wcm9wc107XG59O1xuIiwiaW1wb3J0IHsgdXNlUXVlcnkgYXMgX3VzZVF1ZXJ5IH0gZnJvbSAnQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5JztcbmltcG9ydCB0eXBlIHtcbiAgICBUU29ja2V0QWNjZXB0YWJsZVByb3BzLFxuICAgIFRTb2NrZXRFbmRwb2ludE5hbWVzLFxuICAgIFRTb2NrZXRFcnJvcixcbiAgICBUU29ja2V0UmVxdWVzdFBheWxvYWQsXG4gICAgVFNvY2tldFJlcXVlc3RRdWVyeU9wdGlvbnMsXG4gICAgVFNvY2tldFJlc3BvbnNlRGF0YSxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHVzZUFQSSBmcm9tICcuL3VzZUFQSSc7XG5pbXBvcnQgeyBnZXRRdWVyeUtleXMgfSBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgdXNlUXVlcnkgPSA8VCBleHRlbmRzIFRTb2NrZXRFbmRwb2ludE5hbWVzPihuYW1lOiBULCAuLi5wcm9wczogVFNvY2tldEFjY2VwdGFibGVQcm9wczxULCB0cnVlPikgPT4ge1xuICAgIGNvbnN0IHByb3AgPSBwcm9wcz8uWzBdO1xuICAgIGNvbnN0IHBheWxvYWQgPSBwcm9wICYmICdwYXlsb2FkJyBpbiBwcm9wID8gKHByb3AucGF5bG9hZCBhcyBUU29ja2V0UmVxdWVzdFBheWxvYWQ8VD4pIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBwcm9wICYmICdvcHRpb25zJyBpbiBwcm9wID8gKHByb3Aub3B0aW9ucyBhcyBUU29ja2V0UmVxdWVzdFF1ZXJ5T3B0aW9uczxUPikgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgeyBzZW5kIH0gPSB1c2VBUEkoKTtcblxuICAgIHJldHVybiBfdXNlUXVlcnk8VFNvY2tldFJlc3BvbnNlRGF0YTxUPiwgVFNvY2tldEVycm9yPFQ+PihcbiAgICAgICAgZ2V0UXVlcnlLZXlzKG5hbWUsIHBheWxvYWQpLFxuICAgICAgICAoKSA9PiBzZW5kKG5hbWUsIHBheWxvYWQpLFxuICAgICAgICBvcHRpb25zXG4gICAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZVF1ZXJ5O1xuIiwiY29uc3QgZGVmYXVsdExvZ2dlciA9IGNvbnNvbGU7XG5cbmV4cG9ydCB7IGRlZmF1bHRMb2dnZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dlci5tanMubWFwXG4iLCJpbXBvcnQgeyBpc1ZhbGlkVGltZW91dCwgaXNTZXJ2ZXIgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG5cbmNsYXNzIFJlbW92YWJsZSB7XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jbGVhckdjVGltZW91dCgpO1xuICB9XG5cbiAgc2NoZWR1bGVHYygpIHtcbiAgICB0aGlzLmNsZWFyR2NUaW1lb3V0KCk7XG5cbiAgICBpZiAoaXNWYWxpZFRpbWVvdXQodGhpcy5jYWNoZVRpbWUpKSB7XG4gICAgICB0aGlzLmdjVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLm9wdGlvbmFsUmVtb3ZlKCk7XG4gICAgICB9LCB0aGlzLmNhY2hlVGltZSk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ2FjaGVUaW1lKG5ld0NhY2hlVGltZSkge1xuICAgIC8vIERlZmF1bHQgdG8gNSBtaW51dGVzIChJbmZpbml0eSBmb3Igc2VydmVyLXNpZGUpIGlmIG5vIGNhY2hlIHRpbWUgaXMgc2V0XG4gICAgdGhpcy5jYWNoZVRpbWUgPSBNYXRoLm1heCh0aGlzLmNhY2hlVGltZSB8fCAwLCBuZXdDYWNoZVRpbWUgIT0gbnVsbCA/IG5ld0NhY2hlVGltZSA6IGlzU2VydmVyID8gSW5maW5pdHkgOiA1ICogNjAgKiAxMDAwKTtcbiAgfVxuXG4gIGNsZWFyR2NUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLmdjVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZ2NUaW1lb3V0KTtcbiAgICAgIHRoaXMuZ2NUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG59XG5cbmV4cG9ydCB7IFJlbW92YWJsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3ZhYmxlLm1qcy5tYXBcbiIsImltcG9ydCB7IHJlcGxhY2VEYXRhLCBub29wLCB0aW1lVW50aWxTdGFsZSwgZ2V0QWJvcnRDb250cm9sbGVyIH0gZnJvbSAnLi91dGlscy5tanMnO1xuaW1wb3J0IHsgZGVmYXVsdExvZ2dlciB9IGZyb20gJy4vbG9nZ2VyLm1qcyc7XG5pbXBvcnQgeyBub3RpZnlNYW5hZ2VyIH0gZnJvbSAnLi9ub3RpZnlNYW5hZ2VyLm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVSZXRyeWVyLCBpc0NhbmNlbGxlZEVycm9yLCBjYW5GZXRjaCB9IGZyb20gJy4vcmV0cnllci5tanMnO1xuaW1wb3J0IHsgUmVtb3ZhYmxlIH0gZnJvbSAnLi9yZW1vdmFibGUubWpzJztcblxuLy8gQ0xBU1NcbmNsYXNzIFF1ZXJ5IGV4dGVuZHMgUmVtb3ZhYmxlIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmFib3J0U2lnbmFsQ29uc3VtZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0gY29uZmlnLmRlZmF1bHRPcHRpb25zO1xuICAgIHRoaXMuc2V0T3B0aW9ucyhjb25maWcub3B0aW9ucyk7XG4gICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICB0aGlzLmNhY2hlID0gY29uZmlnLmNhY2hlO1xuICAgIHRoaXMubG9nZ2VyID0gY29uZmlnLmxvZ2dlciB8fCBkZWZhdWx0TG9nZ2VyO1xuICAgIHRoaXMucXVlcnlLZXkgPSBjb25maWcucXVlcnlLZXk7XG4gICAgdGhpcy5xdWVyeUhhc2ggPSBjb25maWcucXVlcnlIYXNoO1xuICAgIHRoaXMuaW5pdGlhbFN0YXRlID0gY29uZmlnLnN0YXRlIHx8IGdldERlZmF1bHRTdGF0ZSh0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMuc3RhdGUgPSB0aGlzLmluaXRpYWxTdGF0ZTtcbiAgICB0aGlzLnNjaGVkdWxlR2MoKTtcbiAgfVxuXG4gIGdldCBtZXRhKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubWV0YTtcbiAgfVxuXG4gIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IHsgLi4udGhpcy5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICAgIHRoaXMudXBkYXRlQ2FjaGVUaW1lKHRoaXMub3B0aW9ucy5jYWNoZVRpbWUpO1xuICB9XG5cbiAgb3B0aW9uYWxSZW1vdmUoKSB7XG4gICAgaWYgKCF0aGlzLm9ic2VydmVycy5sZW5ndGggJiYgdGhpcy5zdGF0ZS5mZXRjaFN0YXR1cyA9PT0gJ2lkbGUnKSB7XG4gICAgICB0aGlzLmNhY2hlLnJlbW92ZSh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBzZXREYXRhKG5ld0RhdGEsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkYXRhID0gcmVwbGFjZURhdGEodGhpcy5zdGF0ZS5kYXRhLCBuZXdEYXRhLCB0aGlzLm9wdGlvbnMpOyAvLyBTZXQgZGF0YSBhbmQgbWFyayBpdCBhcyBjYWNoZWRcblxuICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgZGF0YSxcbiAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgIGRhdGFVcGRhdGVkQXQ6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudXBkYXRlZEF0LFxuICAgICAgbWFudWFsOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1hbnVhbFxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgc2V0U3RhdGUoc3RhdGUsIHNldFN0YXRlT3B0aW9ucykge1xuICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ3NldFN0YXRlJyxcbiAgICAgIHN0YXRlLFxuICAgICAgc2V0U3RhdGVPcHRpb25zXG4gICAgfSk7XG4gIH1cblxuICBjYW5jZWwob3B0aW9ucykge1xuICAgIHZhciBfdGhpcyRyZXRyeWVyO1xuXG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcbiAgICAoX3RoaXMkcmV0cnllciA9IHRoaXMucmV0cnllcikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHJldHJ5ZXIuY2FuY2VsKG9wdGlvbnMpO1xuICAgIHJldHVybiBwcm9taXNlID8gcHJvbWlzZS50aGVuKG5vb3ApLmNhdGNoKG5vb3ApIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmNhbmNlbCh7XG4gICAgICBzaWxlbnQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIHRoaXMuc2V0U3RhdGUodGhpcy5pbml0aWFsU3RhdGUpO1xuICB9XG5cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMub2JzZXJ2ZXJzLnNvbWUob2JzZXJ2ZXIgPT4gb2JzZXJ2ZXIub3B0aW9ucy5lbmFibGVkICE9PSBmYWxzZSk7XG4gIH1cblxuICBpc0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldE9ic2VydmVyc0NvdW50KCkgPiAwICYmICF0aGlzLmlzQWN0aXZlKCk7XG4gIH1cblxuICBpc1N0YWxlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmlzSW52YWxpZGF0ZWQgfHwgIXRoaXMuc3RhdGUuZGF0YVVwZGF0ZWRBdCB8fCB0aGlzLm9ic2VydmVycy5zb21lKG9ic2VydmVyID0+IG9ic2VydmVyLmdldEN1cnJlbnRSZXN1bHQoKS5pc1N0YWxlKTtcbiAgfVxuXG4gIGlzU3RhbGVCeVRpbWUoc3RhbGVUaW1lID0gMCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmlzSW52YWxpZGF0ZWQgfHwgIXRoaXMuc3RhdGUuZGF0YVVwZGF0ZWRBdCB8fCAhdGltZVVudGlsU3RhbGUodGhpcy5zdGF0ZS5kYXRhVXBkYXRlZEF0LCBzdGFsZVRpbWUpO1xuICB9XG5cbiAgb25Gb2N1cygpIHtcbiAgICB2YXIgX3RoaXMkcmV0cnllcjI7XG5cbiAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXJzLmZpbmQoeCA9PiB4LnNob3VsZEZldGNoT25XaW5kb3dGb2N1cygpKTtcblxuICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgb2JzZXJ2ZXIucmVmZXRjaCh7XG4gICAgICAgIGNhbmNlbFJlZmV0Y2g6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IC8vIENvbnRpbnVlIGZldGNoIGlmIGN1cnJlbnRseSBwYXVzZWRcblxuXG4gICAgKF90aGlzJHJldHJ5ZXIyID0gdGhpcy5yZXRyeWVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcmV0cnllcjIuY29udGludWUoKTtcbiAgfVxuXG4gIG9uT25saW5lKCkge1xuICAgIHZhciBfdGhpcyRyZXRyeWVyMztcblxuICAgIGNvbnN0IG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcnMuZmluZCh4ID0+IHguc2hvdWxkRmV0Y2hPblJlY29ubmVjdCgpKTtcblxuICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgb2JzZXJ2ZXIucmVmZXRjaCh7XG4gICAgICAgIGNhbmNlbFJlZmV0Y2g6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IC8vIENvbnRpbnVlIGZldGNoIGlmIGN1cnJlbnRseSBwYXVzZWRcblxuXG4gICAgKF90aGlzJHJldHJ5ZXIzID0gdGhpcy5yZXRyeWVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcmV0cnllcjMuY29udGludWUoKTtcbiAgfVxuXG4gIGFkZE9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgaWYgKCF0aGlzLm9ic2VydmVycy5pbmNsdWRlcyhvYnNlcnZlcikpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpOyAvLyBTdG9wIHRoZSBxdWVyeSBmcm9tIGJlaW5nIGdhcmJhZ2UgY29sbGVjdGVkXG5cbiAgICAgIHRoaXMuY2xlYXJHY1RpbWVvdXQoKTtcbiAgICAgIHRoaXMuY2FjaGUubm90aWZ5KHtcbiAgICAgICAgdHlwZTogJ29ic2VydmVyQWRkZWQnLFxuICAgICAgICBxdWVyeTogdGhpcyxcbiAgICAgICAgb2JzZXJ2ZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZU9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgaWYgKHRoaXMub2JzZXJ2ZXJzLmluY2x1ZGVzKG9ic2VydmVyKSkge1xuICAgICAgdGhpcy5vYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVycy5maWx0ZXIoeCA9PiB4ICE9PSBvYnNlcnZlcik7XG5cbiAgICAgIGlmICghdGhpcy5vYnNlcnZlcnMubGVuZ3RoKSB7XG4gICAgICAgIC8vIElmIHRoZSB0cmFuc3BvcnQgbGF5ZXIgZG9lcyBub3Qgc3VwcG9ydCBjYW5jZWxsYXRpb25cbiAgICAgICAgLy8gd2UnbGwgbGV0IHRoZSBxdWVyeSBjb250aW51ZSBzbyB0aGUgcmVzdWx0IGNhbiBiZSBjYWNoZWRcbiAgICAgICAgaWYgKHRoaXMucmV0cnllcikge1xuICAgICAgICAgIGlmICh0aGlzLmFib3J0U2lnbmFsQ29uc3VtZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmV0cnllci5jYW5jZWwoe1xuICAgICAgICAgICAgICByZXZlcnQ6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJldHJ5ZXIuY2FuY2VsUmV0cnkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNjaGVkdWxlR2MoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYWNoZS5ub3RpZnkoe1xuICAgICAgICB0eXBlOiAnb2JzZXJ2ZXJSZW1vdmVkJyxcbiAgICAgICAgcXVlcnk6IHRoaXMsXG4gICAgICAgIG9ic2VydmVyXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBnZXRPYnNlcnZlcnNDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5vYnNlcnZlcnMubGVuZ3RoO1xuICB9XG5cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuaXNJbnZhbGlkYXRlZCkge1xuICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6ICdpbnZhbGlkYXRlJ1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZmV0Y2gob3B0aW9ucywgZmV0Y2hPcHRpb25zKSB7XG4gICAgdmFyIF90aGlzJG9wdGlvbnMkYmVoYXZpbywgX2NvbnRleHQkZmV0Y2hPcHRpb25zO1xuXG4gICAgaWYgKHRoaXMuc3RhdGUuZmV0Y2hTdGF0dXMgIT09ICdpZGxlJykge1xuICAgICAgaWYgKHRoaXMuc3RhdGUuZGF0YVVwZGF0ZWRBdCAmJiBmZXRjaE9wdGlvbnMgIT0gbnVsbCAmJiBmZXRjaE9wdGlvbnMuY2FuY2VsUmVmZXRjaCkge1xuICAgICAgICAvLyBTaWxlbnRseSBjYW5jZWwgY3VycmVudCBmZXRjaCBpZiB0aGUgdXNlciB3YW50cyB0byBjYW5jZWwgcmVmZXRjaGVzXG4gICAgICAgIHRoaXMuY2FuY2VsKHtcbiAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucHJvbWlzZSkge1xuICAgICAgICB2YXIgX3RoaXMkcmV0cnllcjQ7XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgcmV0cmllcyB0aGF0IHdlcmUgcG90ZW50aWFsbHkgY2FuY2VsbGVkIGR1ZSB0byB1bm1vdW50cyBjYW4gY29udGludWVcbiAgICAgICAgKF90aGlzJHJldHJ5ZXI0ID0gdGhpcy5yZXRyeWVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcmV0cnllcjQuY29udGludWVSZXRyeSgpOyAvLyBSZXR1cm4gY3VycmVudCBwcm9taXNlIGlmIHdlIGFyZSBhbHJlYWR5IGZldGNoaW5nXG5cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZTtcbiAgICAgIH1cbiAgICB9IC8vIFVwZGF0ZSBjb25maWcgaWYgcGFzc2VkLCBvdGhlcndpc2UgdGhlIGNvbmZpZyBmcm9tIHRoZSBsYXN0IGV4ZWN1dGlvbiBpcyB1c2VkXG5cblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfSAvLyBVc2UgdGhlIG9wdGlvbnMgZnJvbSB0aGUgZmlyc3Qgb2JzZXJ2ZXIgd2l0aCBhIHF1ZXJ5IGZ1bmN0aW9uIGlmIG5vIGZ1bmN0aW9uIGlzIGZvdW5kLlxuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHRoZSBxdWVyeSBpcyBoeWRyYXRlZCBvciBjcmVhdGVkIHdpdGggc2V0UXVlcnlEYXRhLlxuXG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5xdWVyeUZuKSB7XG4gICAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXJzLmZpbmQoeCA9PiB4Lm9wdGlvbnMucXVlcnlGbik7XG5cbiAgICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgICB0aGlzLnNldE9wdGlvbnMob2JzZXJ2ZXIub3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMucXVlcnlLZXkpKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiQXMgb2YgdjQsIHF1ZXJ5S2V5IG5lZWRzIHRvIGJlIGFuIEFycmF5LiBJZiB5b3UgYXJlIHVzaW5nIGEgc3RyaW5nIGxpa2UgJ3JlcG9EYXRhJywgcGxlYXNlIGNoYW5nZSBpdCB0byBhbiBBcnJheSwgZS5nLiBbJ3JlcG9EYXRhJ11cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gZ2V0QWJvcnRDb250cm9sbGVyKCk7IC8vIENyZWF0ZSBxdWVyeSBmdW5jdGlvbiBjb250ZXh0XG5cbiAgICBjb25zdCBxdWVyeUZuQ29udGV4dCA9IHtcbiAgICAgIHF1ZXJ5S2V5OiB0aGlzLnF1ZXJ5S2V5LFxuICAgICAgcGFnZVBhcmFtOiB1bmRlZmluZWQsXG4gICAgICBtZXRhOiB0aGlzLm1ldGFcbiAgICB9OyAvLyBBZGRzIGFuIGVudW1lcmFibGUgc2lnbmFsIHByb3BlcnR5IHRvIHRoZSBvYmplY3QgdGhhdFxuICAgIC8vIHdoaWNoIHNldHMgYWJvcnRTaWduYWxDb25zdW1lZCB0byB0cnVlIHdoZW4gdGhlIHNpZ25hbFxuICAgIC8vIGlzIHJlYWQuXG5cbiAgICBjb25zdCBhZGRTaWduYWxQcm9wZXJ0eSA9IG9iamVjdCA9PiB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnc2lnbmFsJywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICAgICAgICB0aGlzLmFib3J0U2lnbmFsQ29uc3VtZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFkZFNpZ25hbFByb3BlcnR5KHF1ZXJ5Rm5Db250ZXh0KTsgLy8gQ3JlYXRlIGZldGNoIGZ1bmN0aW9uXG5cbiAgICBjb25zdCBmZXRjaEZuID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucXVlcnlGbikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJNaXNzaW5nIHF1ZXJ5Rm4gZm9yIHF1ZXJ5S2V5ICdcIiArIHRoaXMub3B0aW9ucy5xdWVyeUhhc2ggKyBcIidcIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWJvcnRTaWduYWxDb25zdW1lZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5xdWVyeUZuKHF1ZXJ5Rm5Db250ZXh0KTtcbiAgICB9OyAvLyBUcmlnZ2VyIGJlaGF2aW9yIGhvb2tcblxuXG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIGZldGNoT3B0aW9ucyxcbiAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgIHF1ZXJ5S2V5OiB0aGlzLnF1ZXJ5S2V5LFxuICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXG4gICAgICBmZXRjaEZuXG4gICAgfTtcbiAgICBhZGRTaWduYWxQcm9wZXJ0eShjb250ZXh0KTtcbiAgICAoX3RoaXMkb3B0aW9ucyRiZWhhdmlvID0gdGhpcy5vcHRpb25zLmJlaGF2aW9yKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9ucyRiZWhhdmlvLm9uRmV0Y2goY29udGV4dCk7IC8vIFN0b3JlIHN0YXRlIGluIGNhc2UgdGhlIGN1cnJlbnQgZmV0Y2ggbmVlZHMgdG8gYmUgcmV2ZXJ0ZWRcblxuICAgIHRoaXMucmV2ZXJ0U3RhdGUgPSB0aGlzLnN0YXRlOyAvLyBTZXQgdG8gZmV0Y2hpbmcgc3RhdGUgaWYgbm90IGFscmVhZHkgaW4gaXRcblxuICAgIGlmICh0aGlzLnN0YXRlLmZldGNoU3RhdHVzID09PSAnaWRsZScgfHwgdGhpcy5zdGF0ZS5mZXRjaE1ldGEgIT09ICgoX2NvbnRleHQkZmV0Y2hPcHRpb25zID0gY29udGV4dC5mZXRjaE9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfY29udGV4dCRmZXRjaE9wdGlvbnMubWV0YSkpIHtcbiAgICAgIHZhciBfY29udGV4dCRmZXRjaE9wdGlvbnMyO1xuXG4gICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogJ2ZldGNoJyxcbiAgICAgICAgbWV0YTogKF9jb250ZXh0JGZldGNoT3B0aW9uczIgPSBjb250ZXh0LmZldGNoT3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jb250ZXh0JGZldGNoT3B0aW9uczIubWV0YVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3Qgb25FcnJvciA9IGVycm9yID0+IHtcbiAgICAgIC8vIE9wdGltaXN0aWNhbGx5IHVwZGF0ZSBzdGF0ZSBpZiBuZWVkZWRcbiAgICAgIGlmICghKGlzQ2FuY2VsbGVkRXJyb3IoZXJyb3IpICYmIGVycm9yLnNpbGVudCkpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNDYW5jZWxsZWRFcnJvcihlcnJvcikpIHtcbiAgICAgICAgdmFyIF90aGlzJGNhY2hlJGNvbmZpZyRvbiwgX3RoaXMkY2FjaGUkY29uZmlnLCBfdGhpcyRjYWNoZSRjb25maWckb24yLCBfdGhpcyRjYWNoZSRjb25maWcyO1xuXG4gICAgICAgIC8vIE5vdGlmeSBjYWNoZSBjYWxsYmFja1xuICAgICAgICAoX3RoaXMkY2FjaGUkY29uZmlnJG9uID0gKF90aGlzJGNhY2hlJGNvbmZpZyA9IHRoaXMuY2FjaGUuY29uZmlnKS5vbkVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkY2FjaGUkY29uZmlnJG9uLmNhbGwoX3RoaXMkY2FjaGUkY29uZmlnLCBlcnJvciwgdGhpcyk7XG4gICAgICAgIChfdGhpcyRjYWNoZSRjb25maWckb24yID0gKF90aGlzJGNhY2hlJGNvbmZpZzIgPSB0aGlzLmNhY2hlLmNvbmZpZykub25TZXR0bGVkKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkY2FjaGUkY29uZmlnJG9uMi5jYWxsKF90aGlzJGNhY2hlJGNvbmZpZzIsIHRoaXMuc3RhdGUuZGF0YSwgZXJyb3IsIHRoaXMpO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5pc0ZldGNoaW5nT3B0aW1pc3RpYykge1xuICAgICAgICAvLyBTY2hlZHVsZSBxdWVyeSBnYyBhZnRlciBmZXRjaGluZ1xuICAgICAgICB0aGlzLnNjaGVkdWxlR2MoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pc0ZldGNoaW5nT3B0aW1pc3RpYyA9IGZhbHNlO1xuICAgIH07IC8vIFRyeSB0byBmZXRjaCB0aGUgZGF0YVxuXG5cbiAgICB0aGlzLnJldHJ5ZXIgPSBjcmVhdGVSZXRyeWVyKHtcbiAgICAgIGZuOiBjb250ZXh0LmZldGNoRm4sXG4gICAgICBhYm9ydDogYWJvcnRDb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIuYWJvcnQuYmluZChhYm9ydENvbnRyb2xsZXIpLFxuICAgICAgb25TdWNjZXNzOiBkYXRhID0+IHtcbiAgICAgICAgdmFyIF90aGlzJGNhY2hlJGNvbmZpZyRvbjMsIF90aGlzJGNhY2hlJGNvbmZpZzMsIF90aGlzJGNhY2hlJGNvbmZpZyRvbjQsIF90aGlzJGNhY2hlJGNvbmZpZzQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlF1ZXJ5IGRhdGEgY2Fubm90IGJlIHVuZGVmaW5lZC4gUGxlYXNlIG1ha2Ugc3VyZSB0byByZXR1cm4gYSB2YWx1ZSBvdGhlciB0aGFuIHVuZGVmaW5lZCBmcm9tIHlvdXIgcXVlcnkgZnVuY3Rpb24uIEFmZmVjdGVkIHF1ZXJ5IGtleTogXCIgKyB0aGlzLnF1ZXJ5SGFzaCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb25FcnJvcihuZXcgRXJyb3IodGhpcy5xdWVyeUhhc2ggKyBcIiBkYXRhIGlzIHVuZGVmaW5lZFwiKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXREYXRhKGRhdGEpOyAvLyBOb3RpZnkgY2FjaGUgY2FsbGJhY2tcblxuICAgICAgICAoX3RoaXMkY2FjaGUkY29uZmlnJG9uMyA9IChfdGhpcyRjYWNoZSRjb25maWczID0gdGhpcy5jYWNoZS5jb25maWcpLm9uU3VjY2VzcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGNhY2hlJGNvbmZpZyRvbjMuY2FsbChfdGhpcyRjYWNoZSRjb25maWczLCBkYXRhLCB0aGlzKTtcbiAgICAgICAgKF90aGlzJGNhY2hlJGNvbmZpZyRvbjQgPSAoX3RoaXMkY2FjaGUkY29uZmlnNCA9IHRoaXMuY2FjaGUuY29uZmlnKS5vblNldHRsZWQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRjYWNoZSRjb25maWckb240LmNhbGwoX3RoaXMkY2FjaGUkY29uZmlnNCwgZGF0YSwgdGhpcy5zdGF0ZS5lcnJvciwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzRmV0Y2hpbmdPcHRpbWlzdGljKSB7XG4gICAgICAgICAgLy8gU2NoZWR1bGUgcXVlcnkgZ2MgYWZ0ZXIgZmV0Y2hpbmdcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlR2MoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNGZXRjaGluZ09wdGltaXN0aWMgPSBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yLFxuICAgICAgb25GYWlsOiAoZmFpbHVyZUNvdW50LCBlcnJvcikgPT4ge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiAnZmFpbGVkJyxcbiAgICAgICAgICBmYWlsdXJlQ291bnQsXG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgb25QYXVzZTogKCkgPT4ge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiAncGF1c2UnXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG9uQ29udGludWU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogJ2NvbnRpbnVlJ1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICByZXRyeTogY29udGV4dC5vcHRpb25zLnJldHJ5LFxuICAgICAgcmV0cnlEZWxheTogY29udGV4dC5vcHRpb25zLnJldHJ5RGVsYXksXG4gICAgICBuZXR3b3JrTW9kZTogY29udGV4dC5vcHRpb25zLm5ldHdvcmtNb2RlXG4gICAgfSk7XG4gICAgdGhpcy5wcm9taXNlID0gdGhpcy5yZXRyeWVyLnByb21pc2U7XG4gICAgcmV0dXJuIHRoaXMucHJvbWlzZTtcbiAgfVxuXG4gIGRpc3BhdGNoKGFjdGlvbikge1xuICAgIGNvbnN0IHJlZHVjZXIgPSBzdGF0ZSA9PiB7XG4gICAgICB2YXIgX2FjdGlvbiRtZXRhLCBfYWN0aW9uJGRhdGFVcGRhdGVkQXQ7XG5cbiAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGZldGNoRmFpbHVyZUNvdW50OiBhY3Rpb24uZmFpbHVyZUNvdW50LFxuICAgICAgICAgICAgZmV0Y2hGYWlsdXJlUmVhc29uOiBhY3Rpb24uZXJyb3JcbiAgICAgICAgICB9O1xuXG4gICAgICAgIGNhc2UgJ3BhdXNlJzpcbiAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGZldGNoU3RhdHVzOiAncGF1c2VkJ1xuICAgICAgICAgIH07XG5cbiAgICAgICAgY2FzZSAnY29udGludWUnOlxuICAgICAgICAgIHJldHVybiB7IC4uLnN0YXRlLFxuICAgICAgICAgICAgZmV0Y2hTdGF0dXM6ICdmZXRjaGluZydcbiAgICAgICAgICB9O1xuXG4gICAgICAgIGNhc2UgJ2ZldGNoJzpcbiAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGZldGNoRmFpbHVyZUNvdW50OiAwLFxuICAgICAgICAgICAgZmV0Y2hGYWlsdXJlUmVhc29uOiBudWxsLFxuICAgICAgICAgICAgZmV0Y2hNZXRhOiAoX2FjdGlvbiRtZXRhID0gYWN0aW9uLm1ldGEpICE9IG51bGwgPyBfYWN0aW9uJG1ldGEgOiBudWxsLFxuICAgICAgICAgICAgZmV0Y2hTdGF0dXM6IGNhbkZldGNoKHRoaXMub3B0aW9ucy5uZXR3b3JrTW9kZSkgPyAnZmV0Y2hpbmcnIDogJ3BhdXNlZCcsXG4gICAgICAgICAgICAuLi4oIXN0YXRlLmRhdGFVcGRhdGVkQXQgJiYge1xuICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgc3RhdHVzOiAnbG9hZGluZydcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfTtcblxuICAgICAgICBjYXNlICdzdWNjZXNzJzpcbiAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGRhdGE6IGFjdGlvbi5kYXRhLFxuICAgICAgICAgICAgZGF0YVVwZGF0ZUNvdW50OiBzdGF0ZS5kYXRhVXBkYXRlQ291bnQgKyAxLFxuICAgICAgICAgICAgZGF0YVVwZGF0ZWRBdDogKF9hY3Rpb24kZGF0YVVwZGF0ZWRBdCA9IGFjdGlvbi5kYXRhVXBkYXRlZEF0KSAhPSBudWxsID8gX2FjdGlvbiRkYXRhVXBkYXRlZEF0IDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgaXNJbnZhbGlkYXRlZDogZmFsc2UsXG4gICAgICAgICAgICBzdGF0dXM6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgIC4uLighYWN0aW9uLm1hbnVhbCAmJiB7XG4gICAgICAgICAgICAgIGZldGNoU3RhdHVzOiAnaWRsZScsXG4gICAgICAgICAgICAgIGZldGNoRmFpbHVyZUNvdW50OiAwLFxuICAgICAgICAgICAgICBmZXRjaEZhaWx1cmVSZWFzb246IG51bGxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfTtcblxuICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBhY3Rpb24uZXJyb3I7XG5cbiAgICAgICAgICBpZiAoaXNDYW5jZWxsZWRFcnJvcihlcnJvcikgJiYgZXJyb3IucmV2ZXJ0ICYmIHRoaXMucmV2ZXJ0U3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IC4uLnRoaXMucmV2ZXJ0U3RhdGUsXG4gICAgICAgICAgICAgIGZldGNoU3RhdHVzOiAnaWRsZSdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICBlcnJvclVwZGF0ZUNvdW50OiBzdGF0ZS5lcnJvclVwZGF0ZUNvdW50ICsgMSxcbiAgICAgICAgICAgIGVycm9yVXBkYXRlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgZmV0Y2hGYWlsdXJlQ291bnQ6IHN0YXRlLmZldGNoRmFpbHVyZUNvdW50ICsgMSxcbiAgICAgICAgICAgIGZldGNoRmFpbHVyZVJlYXNvbjogZXJyb3IsXG4gICAgICAgICAgICBmZXRjaFN0YXR1czogJ2lkbGUnLFxuICAgICAgICAgICAgc3RhdHVzOiAnZXJyb3InXG4gICAgICAgICAgfTtcblxuICAgICAgICBjYXNlICdpbnZhbGlkYXRlJzpcbiAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGlzSW52YWxpZGF0ZWQ6IHRydWVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIGNhc2UgJ3NldFN0YXRlJzpcbiAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgICAgIC4uLmFjdGlvbi5zdGF0ZVxuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuc3RhdGUgPSByZWR1Y2VyKHRoaXMuc3RhdGUpO1xuICAgIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5vYnNlcnZlcnMuZm9yRWFjaChvYnNlcnZlciA9PiB7XG4gICAgICAgIG9ic2VydmVyLm9uUXVlcnlVcGRhdGUoYWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jYWNoZS5ub3RpZnkoe1xuICAgICAgICBxdWVyeTogdGhpcyxcbiAgICAgICAgdHlwZTogJ3VwZGF0ZWQnLFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdFN0YXRlKG9wdGlvbnMpIHtcbiAgY29uc3QgZGF0YSA9IHR5cGVvZiBvcHRpb25zLmluaXRpYWxEYXRhID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5pbml0aWFsRGF0YSgpIDogb3B0aW9ucy5pbml0aWFsRGF0YTtcbiAgY29uc3QgaGFzRGF0YSA9IHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJztcbiAgY29uc3QgaW5pdGlhbERhdGFVcGRhdGVkQXQgPSBoYXNEYXRhID8gdHlwZW9mIG9wdGlvbnMuaW5pdGlhbERhdGFVcGRhdGVkQXQgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLmluaXRpYWxEYXRhVXBkYXRlZEF0KCkgOiBvcHRpb25zLmluaXRpYWxEYXRhVXBkYXRlZEF0IDogMDtcbiAgcmV0dXJuIHtcbiAgICBkYXRhLFxuICAgIGRhdGFVcGRhdGVDb3VudDogMCxcbiAgICBkYXRhVXBkYXRlZEF0OiBoYXNEYXRhID8gaW5pdGlhbERhdGFVcGRhdGVkQXQgIT0gbnVsbCA/IGluaXRpYWxEYXRhVXBkYXRlZEF0IDogRGF0ZS5ub3coKSA6IDAsXG4gICAgZXJyb3I6IG51bGwsXG4gICAgZXJyb3JVcGRhdGVDb3VudDogMCxcbiAgICBlcnJvclVwZGF0ZWRBdDogMCxcbiAgICBmZXRjaEZhaWx1cmVDb3VudDogMCxcbiAgICBmZXRjaEZhaWx1cmVSZWFzb246IG51bGwsXG4gICAgZmV0Y2hNZXRhOiBudWxsLFxuICAgIGlzSW52YWxpZGF0ZWQ6IGZhbHNlLFxuICAgIHN0YXR1czogaGFzRGF0YSA/ICdzdWNjZXNzJyA6ICdsb2FkaW5nJyxcbiAgICBmZXRjaFN0YXR1czogJ2lkbGUnXG4gIH07XG59XG5cbmV4cG9ydCB7IFF1ZXJ5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS5tanMubWFwXG4iLCJpbXBvcnQgeyBoYXNoUXVlcnlLZXlCeU9wdGlvbnMsIHBhcnNlRmlsdGVyQXJncywgbWF0Y2hRdWVyeSB9IGZyb20gJy4vdXRpbHMubWpzJztcbmltcG9ydCB7IFF1ZXJ5IH0gZnJvbSAnLi9xdWVyeS5tanMnO1xuaW1wb3J0IHsgbm90aWZ5TWFuYWdlciB9IGZyb20gJy4vbm90aWZ5TWFuYWdlci5tanMnO1xuaW1wb3J0IHsgU3Vic2NyaWJhYmxlIH0gZnJvbSAnLi9zdWJzY3JpYmFibGUubWpzJztcblxuLy8gQ0xBU1NcbmNsYXNzIFF1ZXJ5Q2FjaGUgZXh0ZW5kcyBTdWJzY3JpYmFibGUge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgIHRoaXMucXVlcmllcyA9IFtdO1xuICAgIHRoaXMucXVlcmllc01hcCA9IHt9O1xuICB9XG5cbiAgYnVpbGQoY2xpZW50LCBvcHRpb25zLCBzdGF0ZSkge1xuICAgIHZhciBfb3B0aW9ucyRxdWVyeUhhc2g7XG5cbiAgICBjb25zdCBxdWVyeUtleSA9IG9wdGlvbnMucXVlcnlLZXk7XG4gICAgY29uc3QgcXVlcnlIYXNoID0gKF9vcHRpb25zJHF1ZXJ5SGFzaCA9IG9wdGlvbnMucXVlcnlIYXNoKSAhPSBudWxsID8gX29wdGlvbnMkcXVlcnlIYXNoIDogaGFzaFF1ZXJ5S2V5QnlPcHRpb25zKHF1ZXJ5S2V5LCBvcHRpb25zKTtcbiAgICBsZXQgcXVlcnkgPSB0aGlzLmdldChxdWVyeUhhc2gpO1xuXG4gICAgaWYgKCFxdWVyeSkge1xuICAgICAgcXVlcnkgPSBuZXcgUXVlcnkoe1xuICAgICAgICBjYWNoZTogdGhpcyxcbiAgICAgICAgbG9nZ2VyOiBjbGllbnQuZ2V0TG9nZ2VyKCksXG4gICAgICAgIHF1ZXJ5S2V5LFxuICAgICAgICBxdWVyeUhhc2gsXG4gICAgICAgIG9wdGlvbnM6IGNsaWVudC5kZWZhdWx0UXVlcnlPcHRpb25zKG9wdGlvbnMpLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgZGVmYXVsdE9wdGlvbnM6IGNsaWVudC5nZXRRdWVyeURlZmF1bHRzKHF1ZXJ5S2V5KVxuICAgICAgfSk7XG4gICAgICB0aGlzLmFkZChxdWVyeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgYWRkKHF1ZXJ5KSB7XG4gICAgaWYgKCF0aGlzLnF1ZXJpZXNNYXBbcXVlcnkucXVlcnlIYXNoXSkge1xuICAgICAgdGhpcy5xdWVyaWVzTWFwW3F1ZXJ5LnF1ZXJ5SGFzaF0gPSBxdWVyeTtcbiAgICAgIHRoaXMucXVlcmllcy5wdXNoKHF1ZXJ5KTtcbiAgICAgIHRoaXMubm90aWZ5KHtcbiAgICAgICAgdHlwZTogJ2FkZGVkJyxcbiAgICAgICAgcXVlcnlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZShxdWVyeSkge1xuICAgIGNvbnN0IHF1ZXJ5SW5NYXAgPSB0aGlzLnF1ZXJpZXNNYXBbcXVlcnkucXVlcnlIYXNoXTtcblxuICAgIGlmIChxdWVyeUluTWFwKSB7XG4gICAgICBxdWVyeS5kZXN0cm95KCk7XG4gICAgICB0aGlzLnF1ZXJpZXMgPSB0aGlzLnF1ZXJpZXMuZmlsdGVyKHggPT4geCAhPT0gcXVlcnkpO1xuXG4gICAgICBpZiAocXVlcnlJbk1hcCA9PT0gcXVlcnkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMucXVlcmllc01hcFtxdWVyeS5xdWVyeUhhc2hdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5vdGlmeSh7XG4gICAgICAgIHR5cGU6ICdyZW1vdmVkJyxcbiAgICAgICAgcXVlcnlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5xdWVyaWVzLmZvckVhY2gocXVlcnkgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZShxdWVyeSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldChxdWVyeUhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyaWVzTWFwW3F1ZXJ5SGFzaF07XG4gIH1cblxuICBnZXRBbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcmllcztcbiAgfVxuXG4gIGZpbmQoYXJnMSwgYXJnMikge1xuICAgIGNvbnN0IFtmaWx0ZXJzXSA9IHBhcnNlRmlsdGVyQXJncyhhcmcxLCBhcmcyKTtcblxuICAgIGlmICh0eXBlb2YgZmlsdGVycy5leGFjdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGZpbHRlcnMuZXhhY3QgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnF1ZXJpZXMuZmluZChxdWVyeSA9PiBtYXRjaFF1ZXJ5KGZpbHRlcnMsIHF1ZXJ5KSk7XG4gIH1cblxuICBmaW5kQWxsKGFyZzEsIGFyZzIpIHtcbiAgICBjb25zdCBbZmlsdGVyc10gPSBwYXJzZUZpbHRlckFyZ3MoYXJnMSwgYXJnMik7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGZpbHRlcnMpLmxlbmd0aCA+IDAgPyB0aGlzLnF1ZXJpZXMuZmlsdGVyKHF1ZXJ5ID0+IG1hdGNoUXVlcnkoZmlsdGVycywgcXVlcnkpKSA6IHRoaXMucXVlcmllcztcbiAgfVxuXG4gIG5vdGlmeShldmVudCkge1xuICAgIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaCgoe1xuICAgICAgICBsaXN0ZW5lclxuICAgICAgfSkgPT4ge1xuICAgICAgICBsaXN0ZW5lcihldmVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIG9uRm9jdXMoKSB7XG4gICAgbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLnF1ZXJpZXMuZm9yRWFjaChxdWVyeSA9PiB7XG4gICAgICAgIHF1ZXJ5Lm9uRm9jdXMoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgb25PbmxpbmUoKSB7XG4gICAgbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLnF1ZXJpZXMuZm9yRWFjaChxdWVyeSA9PiB7XG4gICAgICAgIHF1ZXJ5Lm9uT25saW5lKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG59XG5cbmV4cG9ydCB7IFF1ZXJ5Q2FjaGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5Q2FjaGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgZGVmYXVsdExvZ2dlciB9IGZyb20gJy4vbG9nZ2VyLm1qcyc7XG5pbXBvcnQgeyBub3RpZnlNYW5hZ2VyIH0gZnJvbSAnLi9ub3RpZnlNYW5hZ2VyLm1qcyc7XG5pbXBvcnQgeyBSZW1vdmFibGUgfSBmcm9tICcuL3JlbW92YWJsZS5tanMnO1xuaW1wb3J0IHsgY3JlYXRlUmV0cnllciwgY2FuRmV0Y2ggfSBmcm9tICcuL3JldHJ5ZXIubWpzJztcblxuLy8gQ0xBU1NcbmNsYXNzIE11dGF0aW9uIGV4dGVuZHMgUmVtb3ZhYmxlIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0gY29uZmlnLmRlZmF1bHRPcHRpb25zO1xuICAgIHRoaXMubXV0YXRpb25JZCA9IGNvbmZpZy5tdXRhdGlvbklkO1xuICAgIHRoaXMubXV0YXRpb25DYWNoZSA9IGNvbmZpZy5tdXRhdGlvbkNhY2hlO1xuICAgIHRoaXMubG9nZ2VyID0gY29uZmlnLmxvZ2dlciB8fCBkZWZhdWx0TG9nZ2VyO1xuICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XG4gICAgdGhpcy5zdGF0ZSA9IGNvbmZpZy5zdGF0ZSB8fCBnZXREZWZhdWx0U3RhdGUoKTtcbiAgICB0aGlzLnNldE9wdGlvbnMoY29uZmlnLm9wdGlvbnMpO1xuICAgIHRoaXMuc2NoZWR1bGVHYygpO1xuICB9XG5cbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0geyAuLi50aGlzLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gICAgdGhpcy51cGRhdGVDYWNoZVRpbWUodGhpcy5vcHRpb25zLmNhY2hlVGltZSk7XG4gIH1cblxuICBnZXQgbWV0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLm1ldGE7XG4gIH1cblxuICBzZXRTdGF0ZShzdGF0ZSkge1xuICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ3NldFN0YXRlJyxcbiAgICAgIHN0YXRlXG4gICAgfSk7XG4gIH1cblxuICBhZGRPYnNlcnZlcihvYnNlcnZlcikge1xuICAgIGlmICghdGhpcy5vYnNlcnZlcnMuaW5jbHVkZXMob2JzZXJ2ZXIpKSB7XG4gICAgICB0aGlzLm9ic2VydmVycy5wdXNoKG9ic2VydmVyKTsgLy8gU3RvcCB0aGUgbXV0YXRpb24gZnJvbSBiZWluZyBnYXJiYWdlIGNvbGxlY3RlZFxuXG4gICAgICB0aGlzLmNsZWFyR2NUaW1lb3V0KCk7XG4gICAgICB0aGlzLm11dGF0aW9uQ2FjaGUubm90aWZ5KHtcbiAgICAgICAgdHlwZTogJ29ic2VydmVyQWRkZWQnLFxuICAgICAgICBtdXRhdGlvbjogdGhpcyxcbiAgICAgICAgb2JzZXJ2ZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZU9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgdGhpcy5vYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVycy5maWx0ZXIoeCA9PiB4ICE9PSBvYnNlcnZlcik7XG4gICAgdGhpcy5zY2hlZHVsZUdjKCk7XG4gICAgdGhpcy5tdXRhdGlvbkNhY2hlLm5vdGlmeSh7XG4gICAgICB0eXBlOiAnb2JzZXJ2ZXJSZW1vdmVkJyxcbiAgICAgIG11dGF0aW9uOiB0aGlzLFxuICAgICAgb2JzZXJ2ZXJcbiAgICB9KTtcbiAgfVxuXG4gIG9wdGlvbmFsUmVtb3ZlKCkge1xuICAgIGlmICghdGhpcy5vYnNlcnZlcnMubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgPT09ICdsb2FkaW5nJykge1xuICAgICAgICB0aGlzLnNjaGVkdWxlR2MoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubXV0YXRpb25DYWNoZS5yZW1vdmUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29udGludWUoKSB7XG4gICAgdmFyIF90aGlzJHJldHJ5ZXIkY29udGludSwgX3RoaXMkcmV0cnllcjtcblxuICAgIHJldHVybiAoX3RoaXMkcmV0cnllciRjb250aW51ID0gKF90aGlzJHJldHJ5ZXIgPSB0aGlzLnJldHJ5ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRyZXRyeWVyLmNvbnRpbnVlKCkpICE9IG51bGwgPyBfdGhpcyRyZXRyeWVyJGNvbnRpbnUgOiB0aGlzLmV4ZWN1dGUoKTtcbiAgfVxuXG4gIGFzeW5jIGV4ZWN1dGUoKSB7XG4gICAgY29uc3QgZXhlY3V0ZU11dGF0aW9uID0gKCkgPT4ge1xuICAgICAgdmFyIF90aGlzJG9wdGlvbnMkcmV0cnk7XG5cbiAgICAgIHRoaXMucmV0cnllciA9IGNyZWF0ZVJldHJ5ZXIoe1xuICAgICAgICBmbjogKCkgPT4ge1xuICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLm11dGF0aW9uRm4pIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnTm8gbXV0YXRpb25GbiBmb3VuZCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubXV0YXRpb25Gbih0aGlzLnN0YXRlLnZhcmlhYmxlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRmFpbDogKGZhaWx1cmVDb3VudCwgZXJyb3IpID0+IHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdmYWlsZWQnLFxuICAgICAgICAgICAgZmFpbHVyZUNvdW50LFxuICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25QYXVzZTogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ3BhdXNlJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkNvbnRpbnVlOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnY29udGludWUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJldHJ5OiAoX3RoaXMkb3B0aW9ucyRyZXRyeSA9IHRoaXMub3B0aW9ucy5yZXRyeSkgIT0gbnVsbCA/IF90aGlzJG9wdGlvbnMkcmV0cnkgOiAwLFxuICAgICAgICByZXRyeURlbGF5OiB0aGlzLm9wdGlvbnMucmV0cnlEZWxheSxcbiAgICAgICAgbmV0d29ya01vZGU6IHRoaXMub3B0aW9ucy5uZXR3b3JrTW9kZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5yZXRyeWVyLnByb21pc2U7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlc3RvcmVkID0gdGhpcy5zdGF0ZS5zdGF0dXMgPT09ICdsb2FkaW5nJztcblxuICAgIHRyeSB7XG4gICAgICB2YXIgX3RoaXMkbXV0YXRpb25DYWNoZSRjMywgX3RoaXMkbXV0YXRpb25DYWNoZSRjNCwgX3RoaXMkb3B0aW9ucyRvblN1Y2NlLCBfdGhpcyRvcHRpb25zMiwgX3RoaXMkbXV0YXRpb25DYWNoZSRjNSwgX3RoaXMkbXV0YXRpb25DYWNoZSRjNiwgX3RoaXMkb3B0aW9ucyRvblNldHRsLCBfdGhpcyRvcHRpb25zMztcblxuICAgICAgaWYgKCFyZXN0b3JlZCkge1xuICAgICAgICB2YXIgX3RoaXMkbXV0YXRpb25DYWNoZSRjLCBfdGhpcyRtdXRhdGlvbkNhY2hlJGMyLCBfdGhpcyRvcHRpb25zJG9uTXV0YXQsIF90aGlzJG9wdGlvbnM7XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogJ2xvYWRpbmcnLFxuICAgICAgICAgIHZhcmlhYmxlczogdGhpcy5vcHRpb25zLnZhcmlhYmxlc1xuICAgICAgICB9KTsgLy8gTm90aWZ5IGNhY2hlIGNhbGxiYWNrXG5cbiAgICAgICAgYXdhaXQgKChfdGhpcyRtdXRhdGlvbkNhY2hlJGMgPSAoX3RoaXMkbXV0YXRpb25DYWNoZSRjMiA9IHRoaXMubXV0YXRpb25DYWNoZS5jb25maWcpLm9uTXV0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbXV0YXRpb25DYWNoZSRjLmNhbGwoX3RoaXMkbXV0YXRpb25DYWNoZSRjMiwgdGhpcy5zdGF0ZS52YXJpYWJsZXMsIHRoaXMpKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGF3YWl0ICgoX3RoaXMkb3B0aW9ucyRvbk11dGF0ID0gKF90aGlzJG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMpLm9uTXV0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9ucyRvbk11dGF0LmNhbGwoX3RoaXMkb3B0aW9ucywgdGhpcy5zdGF0ZS52YXJpYWJsZXMpKTtcblxuICAgICAgICBpZiAoY29udGV4dCAhPT0gdGhpcy5zdGF0ZS5jb250ZXh0KSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnbG9hZGluZycsXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgdmFyaWFibGVzOiB0aGlzLnN0YXRlLnZhcmlhYmxlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBleGVjdXRlTXV0YXRpb24oKTsgLy8gTm90aWZ5IGNhY2hlIGNhbGxiYWNrXG5cbiAgICAgIGF3YWl0ICgoX3RoaXMkbXV0YXRpb25DYWNoZSRjMyA9IChfdGhpcyRtdXRhdGlvbkNhY2hlJGM0ID0gdGhpcy5tdXRhdGlvbkNhY2hlLmNvbmZpZykub25TdWNjZXNzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbXV0YXRpb25DYWNoZSRjMy5jYWxsKF90aGlzJG11dGF0aW9uQ2FjaGUkYzQsIGRhdGEsIHRoaXMuc3RhdGUudmFyaWFibGVzLCB0aGlzLnN0YXRlLmNvbnRleHQsIHRoaXMpKTtcbiAgICAgIGF3YWl0ICgoX3RoaXMkb3B0aW9ucyRvblN1Y2NlID0gKF90aGlzJG9wdGlvbnMyID0gdGhpcy5vcHRpb25zKS5vblN1Y2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zJG9uU3VjY2UuY2FsbChfdGhpcyRvcHRpb25zMiwgZGF0YSwgdGhpcy5zdGF0ZS52YXJpYWJsZXMsIHRoaXMuc3RhdGUuY29udGV4dCkpOyAvLyBOb3RpZnkgY2FjaGUgY2FsbGJhY2tcblxuICAgICAgYXdhaXQgKChfdGhpcyRtdXRhdGlvbkNhY2hlJGM1ID0gKF90aGlzJG11dGF0aW9uQ2FjaGUkYzYgPSB0aGlzLm11dGF0aW9uQ2FjaGUuY29uZmlnKS5vblNldHRsZWQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRtdXRhdGlvbkNhY2hlJGM1LmNhbGwoX3RoaXMkbXV0YXRpb25DYWNoZSRjNiwgZGF0YSwgbnVsbCwgdGhpcy5zdGF0ZS52YXJpYWJsZXMsIHRoaXMuc3RhdGUuY29udGV4dCwgdGhpcykpO1xuICAgICAgYXdhaXQgKChfdGhpcyRvcHRpb25zJG9uU2V0dGwgPSAoX3RoaXMkb3B0aW9uczMgPSB0aGlzLm9wdGlvbnMpLm9uU2V0dGxlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnMkb25TZXR0bC5jYWxsKF90aGlzJG9wdGlvbnMzLCBkYXRhLCBudWxsLCB0aGlzLnN0YXRlLnZhcmlhYmxlcywgdGhpcy5zdGF0ZS5jb250ZXh0KSk7XG4gICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogJ3N1Y2Nlc3MnLFxuICAgICAgICBkYXRhXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgX3RoaXMkbXV0YXRpb25DYWNoZSRjNywgX3RoaXMkbXV0YXRpb25DYWNoZSRjOCwgX3RoaXMkb3B0aW9ucyRvbkVycm9yLCBfdGhpcyRvcHRpb25zNCwgX3RoaXMkbXV0YXRpb25DYWNoZSRjOSwgX3RoaXMkbXV0YXRpb25DYWNoZSRjMTAsIF90aGlzJG9wdGlvbnMkb25TZXR0bDIsIF90aGlzJG9wdGlvbnM1O1xuXG4gICAgICAgIC8vIE5vdGlmeSBjYWNoZSBjYWxsYmFja1xuICAgICAgICBhd2FpdCAoKF90aGlzJG11dGF0aW9uQ2FjaGUkYzcgPSAoX3RoaXMkbXV0YXRpb25DYWNoZSRjOCA9IHRoaXMubXV0YXRpb25DYWNoZS5jb25maWcpLm9uRXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRtdXRhdGlvbkNhY2hlJGM3LmNhbGwoX3RoaXMkbXV0YXRpb25DYWNoZSRjOCwgZXJyb3IsIHRoaXMuc3RhdGUudmFyaWFibGVzLCB0aGlzLnN0YXRlLmNvbnRleHQsIHRoaXMpKTtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0ICgoX3RoaXMkb3B0aW9ucyRvbkVycm9yID0gKF90aGlzJG9wdGlvbnM0ID0gdGhpcy5vcHRpb25zKS5vbkVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9ucyRvbkVycm9yLmNhbGwoX3RoaXMkb3B0aW9uczQsIGVycm9yLCB0aGlzLnN0YXRlLnZhcmlhYmxlcywgdGhpcy5zdGF0ZS5jb250ZXh0KSk7IC8vIE5vdGlmeSBjYWNoZSBjYWxsYmFja1xuXG4gICAgICAgIGF3YWl0ICgoX3RoaXMkbXV0YXRpb25DYWNoZSRjOSA9IChfdGhpcyRtdXRhdGlvbkNhY2hlJGMxMCA9IHRoaXMubXV0YXRpb25DYWNoZS5jb25maWcpLm9uU2V0dGxlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG11dGF0aW9uQ2FjaGUkYzkuY2FsbChfdGhpcyRtdXRhdGlvbkNhY2hlJGMxMCwgdW5kZWZpbmVkLCBlcnJvciwgdGhpcy5zdGF0ZS52YXJpYWJsZXMsIHRoaXMuc3RhdGUuY29udGV4dCwgdGhpcykpO1xuICAgICAgICBhd2FpdCAoKF90aGlzJG9wdGlvbnMkb25TZXR0bDIgPSAoX3RoaXMkb3B0aW9uczUgPSB0aGlzLm9wdGlvbnMpLm9uU2V0dGxlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnMkb25TZXR0bDIuY2FsbChfdGhpcyRvcHRpb25zNSwgdW5kZWZpbmVkLCBlcnJvciwgdGhpcy5zdGF0ZS52YXJpYWJsZXMsIHRoaXMuc3RhdGUuY29udGV4dCkpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRpc3BhdGNoKGFjdGlvbikge1xuICAgIGNvbnN0IHJlZHVjZXIgPSBzdGF0ZSA9PiB7XG4gICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgICAgICAgICBmYWlsdXJlQ291bnQ6IGFjdGlvbi5mYWlsdXJlQ291bnQsXG4gICAgICAgICAgICBmYWlsdXJlUmVhc29uOiBhY3Rpb24uZXJyb3JcbiAgICAgICAgICB9O1xuXG4gICAgICAgIGNhc2UgJ3BhdXNlJzpcbiAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGlzUGF1c2VkOiB0cnVlXG4gICAgICAgICAgfTtcblxuICAgICAgICBjYXNlICdjb250aW51ZSc6XG4gICAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgICAgICAgICBpc1BhdXNlZDogZmFsc2VcbiAgICAgICAgICB9O1xuXG4gICAgICAgIGNhc2UgJ2xvYWRpbmcnOlxuICAgICAgICAgIHJldHVybiB7IC4uLnN0YXRlLFxuICAgICAgICAgICAgY29udGV4dDogYWN0aW9uLmNvbnRleHQsXG4gICAgICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBmYWlsdXJlQ291bnQ6IDAsXG4gICAgICAgICAgICBmYWlsdXJlUmVhc29uOiBudWxsLFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICBpc1BhdXNlZDogIWNhbkZldGNoKHRoaXMub3B0aW9ucy5uZXR3b3JrTW9kZSksXG4gICAgICAgICAgICBzdGF0dXM6ICdsb2FkaW5nJyxcbiAgICAgICAgICAgIHZhcmlhYmxlczogYWN0aW9uLnZhcmlhYmxlc1xuICAgICAgICAgIH07XG5cbiAgICAgICAgY2FzZSAnc3VjY2Vzcyc6XG4gICAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgICAgICAgICBkYXRhOiBhY3Rpb24uZGF0YSxcbiAgICAgICAgICAgIGZhaWx1cmVDb3VudDogMCxcbiAgICAgICAgICAgIGZhaWx1cmVSZWFzb246IG51bGwsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIHN0YXR1czogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgaXNQYXVzZWQ6IGZhbHNlXG4gICAgICAgICAgfTtcblxuICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBlcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICAgICAgZmFpbHVyZUNvdW50OiBzdGF0ZS5mYWlsdXJlQ291bnQgKyAxLFxuICAgICAgICAgICAgZmFpbHVyZVJlYXNvbjogYWN0aW9uLmVycm9yLFxuICAgICAgICAgICAgaXNQYXVzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgc3RhdHVzOiAnZXJyb3InXG4gICAgICAgICAgfTtcblxuICAgICAgICBjYXNlICdzZXRTdGF0ZSc6XG4gICAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgICAgICAgICAuLi5hY3Rpb24uc3RhdGVcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnN0YXRlID0gcmVkdWNlcih0aGlzLnN0YXRlKTtcbiAgICBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzLmZvckVhY2gob2JzZXJ2ZXIgPT4ge1xuICAgICAgICBvYnNlcnZlci5vbk11dGF0aW9uVXBkYXRlKGFjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubXV0YXRpb25DYWNoZS5ub3RpZnkoe1xuICAgICAgICBtdXRhdGlvbjogdGhpcyxcbiAgICAgICAgdHlwZTogJ3VwZGF0ZWQnLFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRTdGF0ZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBjb250ZXh0OiB1bmRlZmluZWQsXG4gICAgZGF0YTogdW5kZWZpbmVkLFxuICAgIGVycm9yOiBudWxsLFxuICAgIGZhaWx1cmVDb3VudDogMCxcbiAgICBmYWlsdXJlUmVhc29uOiBudWxsLFxuICAgIGlzUGF1c2VkOiBmYWxzZSxcbiAgICBzdGF0dXM6ICdpZGxlJyxcbiAgICB2YXJpYWJsZXM6IHVuZGVmaW5lZFxuICB9O1xufVxuXG5leHBvcnQgeyBNdXRhdGlvbiwgZ2V0RGVmYXVsdFN0YXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdXRhdGlvbi5tanMubWFwXG4iLCJpbXBvcnQgeyBub3RpZnlNYW5hZ2VyIH0gZnJvbSAnLi9ub3RpZnlNYW5hZ2VyLm1qcyc7XG5pbXBvcnQgeyBNdXRhdGlvbiB9IGZyb20gJy4vbXV0YXRpb24ubWpzJztcbmltcG9ydCB7IG1hdGNoTXV0YXRpb24sIG5vb3AgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG5pbXBvcnQgeyBTdWJzY3JpYmFibGUgfSBmcm9tICcuL3N1YnNjcmliYWJsZS5tanMnO1xuXG4vLyBDTEFTU1xuY2xhc3MgTXV0YXRpb25DYWNoZSBleHRlbmRzIFN1YnNjcmliYWJsZSB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWcgfHwge307XG4gICAgdGhpcy5tdXRhdGlvbnMgPSBbXTtcbiAgICB0aGlzLm11dGF0aW9uSWQgPSAwO1xuICB9XG5cbiAgYnVpbGQoY2xpZW50LCBvcHRpb25zLCBzdGF0ZSkge1xuICAgIGNvbnN0IG11dGF0aW9uID0gbmV3IE11dGF0aW9uKHtcbiAgICAgIG11dGF0aW9uQ2FjaGU6IHRoaXMsXG4gICAgICBsb2dnZXI6IGNsaWVudC5nZXRMb2dnZXIoKSxcbiAgICAgIG11dGF0aW9uSWQ6ICsrdGhpcy5tdXRhdGlvbklkLFxuICAgICAgb3B0aW9uczogY2xpZW50LmRlZmF1bHRNdXRhdGlvbk9wdGlvbnMob3B0aW9ucyksXG4gICAgICBzdGF0ZSxcbiAgICAgIGRlZmF1bHRPcHRpb25zOiBvcHRpb25zLm11dGF0aW9uS2V5ID8gY2xpZW50LmdldE11dGF0aW9uRGVmYXVsdHMob3B0aW9ucy5tdXRhdGlvbktleSkgOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgICB0aGlzLmFkZChtdXRhdGlvbik7XG4gICAgcmV0dXJuIG11dGF0aW9uO1xuICB9XG5cbiAgYWRkKG11dGF0aW9uKSB7XG4gICAgdGhpcy5tdXRhdGlvbnMucHVzaChtdXRhdGlvbik7XG4gICAgdGhpcy5ub3RpZnkoe1xuICAgICAgdHlwZTogJ2FkZGVkJyxcbiAgICAgIG11dGF0aW9uXG4gICAgfSk7XG4gIH1cblxuICByZW1vdmUobXV0YXRpb24pIHtcbiAgICB0aGlzLm11dGF0aW9ucyA9IHRoaXMubXV0YXRpb25zLmZpbHRlcih4ID0+IHggIT09IG11dGF0aW9uKTtcbiAgICB0aGlzLm5vdGlmeSh7XG4gICAgICB0eXBlOiAncmVtb3ZlZCcsXG4gICAgICBtdXRhdGlvblxuICAgIH0pO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLm11dGF0aW9ucy5mb3JFYWNoKG11dGF0aW9uID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmUobXV0YXRpb24pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBnZXRBbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMubXV0YXRpb25zO1xuICB9XG5cbiAgZmluZChmaWx0ZXJzKSB7XG4gICAgaWYgKHR5cGVvZiBmaWx0ZXJzLmV4YWN0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZmlsdGVycy5leGFjdCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubXV0YXRpb25zLmZpbmQobXV0YXRpb24gPT4gbWF0Y2hNdXRhdGlvbihmaWx0ZXJzLCBtdXRhdGlvbikpO1xuICB9XG5cbiAgZmluZEFsbChmaWx0ZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMubXV0YXRpb25zLmZpbHRlcihtdXRhdGlvbiA9PiBtYXRjaE11dGF0aW9uKGZpbHRlcnMsIG11dGF0aW9uKSk7XG4gIH1cblxuICBub3RpZnkoZXZlbnQpIHtcbiAgICBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKHtcbiAgICAgICAgbGlzdGVuZXJcbiAgICAgIH0pID0+IHtcbiAgICAgICAgbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXN1bWVQYXVzZWRNdXRhdGlvbnMoKSB7XG4gICAgdmFyIF90aGlzJHJlc3VtaW5nO1xuXG4gICAgdGhpcy5yZXN1bWluZyA9ICgoX3RoaXMkcmVzdW1pbmcgPSB0aGlzLnJlc3VtaW5nKSAhPSBudWxsID8gX3RoaXMkcmVzdW1pbmcgOiBQcm9taXNlLnJlc29sdmUoKSkudGhlbigoKSA9PiB7XG4gICAgICBjb25zdCBwYXVzZWRNdXRhdGlvbnMgPSB0aGlzLm11dGF0aW9ucy5maWx0ZXIoeCA9PiB4LnN0YXRlLmlzUGF1c2VkKTtcbiAgICAgIHJldHVybiBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHBhdXNlZE11dGF0aW9ucy5yZWR1Y2UoKHByb21pc2UsIG11dGF0aW9uKSA9PiBwcm9taXNlLnRoZW4oKCkgPT4gbXV0YXRpb24uY29udGludWUoKS5jYXRjaChub29wKSksIFByb21pc2UucmVzb2x2ZSgpKSk7XG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLnJlc3VtaW5nID0gdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnJlc3VtaW5nO1xuICB9XG5cbn1cblxuZXhwb3J0IHsgTXV0YXRpb25DYWNoZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXV0YXRpb25DYWNoZS5tanMubWFwXG4iLCJmdW5jdGlvbiBpbmZpbml0ZVF1ZXJ5QmVoYXZpb3IoKSB7XG4gIHJldHVybiB7XG4gICAgb25GZXRjaDogY29udGV4dCA9PiB7XG4gICAgICBjb250ZXh0LmZldGNoRm4gPSAoKSA9PiB7XG4gICAgICAgIHZhciBfY29udGV4dCRmZXRjaE9wdGlvbnMsIF9jb250ZXh0JGZldGNoT3B0aW9uczIsIF9jb250ZXh0JGZldGNoT3B0aW9uczMsIF9jb250ZXh0JGZldGNoT3B0aW9uczQsIF9jb250ZXh0JHN0YXRlJGRhdGEsIF9jb250ZXh0JHN0YXRlJGRhdGEyO1xuXG4gICAgICAgIGNvbnN0IHJlZmV0Y2hQYWdlID0gKF9jb250ZXh0JGZldGNoT3B0aW9ucyA9IGNvbnRleHQuZmV0Y2hPcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogKF9jb250ZXh0JGZldGNoT3B0aW9uczIgPSBfY29udGV4dCRmZXRjaE9wdGlvbnMubWV0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jb250ZXh0JGZldGNoT3B0aW9uczIucmVmZXRjaFBhZ2U7XG4gICAgICAgIGNvbnN0IGZldGNoTW9yZSA9IChfY29udGV4dCRmZXRjaE9wdGlvbnMzID0gY29udGV4dC5mZXRjaE9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiAoX2NvbnRleHQkZmV0Y2hPcHRpb25zNCA9IF9jb250ZXh0JGZldGNoT3B0aW9uczMubWV0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jb250ZXh0JGZldGNoT3B0aW9uczQuZmV0Y2hNb3JlO1xuICAgICAgICBjb25zdCBwYWdlUGFyYW0gPSBmZXRjaE1vcmUgPT0gbnVsbCA/IHZvaWQgMCA6IGZldGNoTW9yZS5wYWdlUGFyYW07XG4gICAgICAgIGNvbnN0IGlzRmV0Y2hpbmdOZXh0UGFnZSA9IChmZXRjaE1vcmUgPT0gbnVsbCA/IHZvaWQgMCA6IGZldGNoTW9yZS5kaXJlY3Rpb24pID09PSAnZm9yd2FyZCc7XG4gICAgICAgIGNvbnN0IGlzRmV0Y2hpbmdQcmV2aW91c1BhZ2UgPSAoZmV0Y2hNb3JlID09IG51bGwgPyB2b2lkIDAgOiBmZXRjaE1vcmUuZGlyZWN0aW9uKSA9PT0gJ2JhY2t3YXJkJztcbiAgICAgICAgY29uc3Qgb2xkUGFnZXMgPSAoKF9jb250ZXh0JHN0YXRlJGRhdGEgPSBjb250ZXh0LnN0YXRlLmRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfY29udGV4dCRzdGF0ZSRkYXRhLnBhZ2VzKSB8fCBbXTtcbiAgICAgICAgY29uc3Qgb2xkUGFnZVBhcmFtcyA9ICgoX2NvbnRleHQkc3RhdGUkZGF0YTIgPSBjb250ZXh0LnN0YXRlLmRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfY29udGV4dCRzdGF0ZSRkYXRhMi5wYWdlUGFyYW1zKSB8fCBbXTtcbiAgICAgICAgbGV0IG5ld1BhZ2VQYXJhbXMgPSBvbGRQYWdlUGFyYW1zO1xuICAgICAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgYWRkU2lnbmFsUHJvcGVydHkgPSBvYmplY3QgPT4ge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdzaWduYWwnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfY29udGV4dCRzaWduYWw7XG5cbiAgICAgICAgICAgICAgaWYgKChfY29udGV4dCRzaWduYWwgPSBjb250ZXh0LnNpZ25hbCkgIT0gbnVsbCAmJiBfY29udGV4dCRzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jb250ZXh0JHNpZ25hbDI7XG5cbiAgICAgICAgICAgICAgICAoX2NvbnRleHQkc2lnbmFsMiA9IGNvbnRleHQuc2lnbmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2NvbnRleHQkc2lnbmFsMi5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5zaWduYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07IC8vIEdldCBxdWVyeSBmdW5jdGlvblxuXG5cbiAgICAgICAgY29uc3QgcXVlcnlGbiA9IGNvbnRleHQub3B0aW9ucy5xdWVyeUZuIHx8ICgoKSA9PiBQcm9taXNlLnJlamVjdChcIk1pc3NpbmcgcXVlcnlGbiBmb3IgcXVlcnlLZXkgJ1wiICsgY29udGV4dC5vcHRpb25zLnF1ZXJ5SGFzaCArIFwiJ1wiKSk7XG5cbiAgICAgICAgY29uc3QgYnVpbGROZXdQYWdlcyA9IChwYWdlcywgcGFyYW0sIHBhZ2UsIHByZXZpb3VzKSA9PiB7XG4gICAgICAgICAgbmV3UGFnZVBhcmFtcyA9IHByZXZpb3VzID8gW3BhcmFtLCAuLi5uZXdQYWdlUGFyYW1zXSA6IFsuLi5uZXdQYWdlUGFyYW1zLCBwYXJhbV07XG4gICAgICAgICAgcmV0dXJuIHByZXZpb3VzID8gW3BhZ2UsIC4uLnBhZ2VzXSA6IFsuLi5wYWdlcywgcGFnZV07XG4gICAgICAgIH07IC8vIENyZWF0ZSBmdW5jdGlvbiB0byBmZXRjaCBhIHBhZ2VcblxuXG4gICAgICAgIGNvbnN0IGZldGNoUGFnZSA9IChwYWdlcywgbWFudWFsLCBwYXJhbSwgcHJldmlvdXMpID0+IHtcbiAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGxlZCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW0gPT09ICd1bmRlZmluZWQnICYmICFtYW51YWwgJiYgcGFnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBhZ2VzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBxdWVyeUZuQ29udGV4dCA9IHtcbiAgICAgICAgICAgIHF1ZXJ5S2V5OiBjb250ZXh0LnF1ZXJ5S2V5LFxuICAgICAgICAgICAgcGFnZVBhcmFtOiBwYXJhbSxcbiAgICAgICAgICAgIG1ldGE6IGNvbnRleHQub3B0aW9ucy5tZXRhXG4gICAgICAgICAgfTtcbiAgICAgICAgICBhZGRTaWduYWxQcm9wZXJ0eShxdWVyeUZuQ29udGV4dCk7XG4gICAgICAgICAgY29uc3QgcXVlcnlGblJlc3VsdCA9IHF1ZXJ5Rm4ocXVlcnlGbkNvbnRleHQpO1xuICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUocXVlcnlGblJlc3VsdCkudGhlbihwYWdlID0+IGJ1aWxkTmV3UGFnZXMocGFnZXMsIHBhcmFtLCBwYWdlLCBwcmV2aW91cykpO1xuICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIGxldCBwcm9taXNlOyAvLyBGZXRjaCBmaXJzdCBwYWdlP1xuXG4gICAgICAgIGlmICghb2xkUGFnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcHJvbWlzZSA9IGZldGNoUGFnZShbXSk7XG4gICAgICAgIH0gLy8gRmV0Y2ggbmV4dCBwYWdlP1xuICAgICAgICBlbHNlIGlmIChpc0ZldGNoaW5nTmV4dFBhZ2UpIHtcbiAgICAgICAgICBjb25zdCBtYW51YWwgPSB0eXBlb2YgcGFnZVBhcmFtICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgICBjb25zdCBwYXJhbSA9IG1hbnVhbCA/IHBhZ2VQYXJhbSA6IGdldE5leHRQYWdlUGFyYW0oY29udGV4dC5vcHRpb25zLCBvbGRQYWdlcyk7XG4gICAgICAgICAgcHJvbWlzZSA9IGZldGNoUGFnZShvbGRQYWdlcywgbWFudWFsLCBwYXJhbSk7XG4gICAgICAgIH0gLy8gRmV0Y2ggcHJldmlvdXMgcGFnZT9cbiAgICAgICAgZWxzZSBpZiAoaXNGZXRjaGluZ1ByZXZpb3VzUGFnZSkge1xuICAgICAgICAgIGNvbnN0IG1hbnVhbCA9IHR5cGVvZiBwYWdlUGFyYW0gIT09ICd1bmRlZmluZWQnO1xuICAgICAgICAgIGNvbnN0IHBhcmFtID0gbWFudWFsID8gcGFnZVBhcmFtIDogZ2V0UHJldmlvdXNQYWdlUGFyYW0oY29udGV4dC5vcHRpb25zLCBvbGRQYWdlcyk7XG4gICAgICAgICAgcHJvbWlzZSA9IGZldGNoUGFnZShvbGRQYWdlcywgbWFudWFsLCBwYXJhbSwgdHJ1ZSk7XG4gICAgICAgIH0gLy8gUmVmZXRjaCBwYWdlc1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBuZXdQYWdlUGFyYW1zID0gW107XG4gICAgICAgICAgY29uc3QgbWFudWFsID0gdHlwZW9mIGNvbnRleHQub3B0aW9ucy5nZXROZXh0UGFnZVBhcmFtID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgICBjb25zdCBzaG91bGRGZXRjaEZpcnN0UGFnZSA9IHJlZmV0Y2hQYWdlICYmIG9sZFBhZ2VzWzBdID8gcmVmZXRjaFBhZ2Uob2xkUGFnZXNbMF0sIDAsIG9sZFBhZ2VzKSA6IHRydWU7IC8vIEZldGNoIGZpcnN0IHBhZ2VcblxuICAgICAgICAgIHByb21pc2UgPSBzaG91bGRGZXRjaEZpcnN0UGFnZSA/IGZldGNoUGFnZShbXSwgbWFudWFsLCBvbGRQYWdlUGFyYW1zWzBdKSA6IFByb21pc2UucmVzb2x2ZShidWlsZE5ld1BhZ2VzKFtdLCBvbGRQYWdlUGFyYW1zWzBdLCBvbGRQYWdlc1swXSkpOyAvLyBGZXRjaCByZW1haW5pbmcgcGFnZXNcblxuICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgb2xkUGFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4ocGFnZXMgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBzaG91bGRGZXRjaE5leHRQYWdlID0gcmVmZXRjaFBhZ2UgJiYgb2xkUGFnZXNbaV0gPyByZWZldGNoUGFnZShvbGRQYWdlc1tpXSwgaSwgb2xkUGFnZXMpIDogdHJ1ZTtcblxuICAgICAgICAgICAgICBpZiAoc2hvdWxkRmV0Y2hOZXh0UGFnZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtID0gbWFudWFsID8gb2xkUGFnZVBhcmFtc1tpXSA6IGdldE5leHRQYWdlUGFyYW0oY29udGV4dC5vcHRpb25zLCBwYWdlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoUGFnZShwYWdlcywgbWFudWFsLCBwYXJhbSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGJ1aWxkTmV3UGFnZXMocGFnZXMsIG9sZFBhZ2VQYXJhbXNbaV0sIG9sZFBhZ2VzW2ldKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmaW5hbFByb21pc2UgPSBwcm9taXNlLnRoZW4ocGFnZXMgPT4gKHtcbiAgICAgICAgICBwYWdlcyxcbiAgICAgICAgICBwYWdlUGFyYW1zOiBuZXdQYWdlUGFyYW1zXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIGZpbmFsUHJvbWlzZTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0TmV4dFBhZ2VQYXJhbShvcHRpb25zLCBwYWdlcykge1xuICByZXR1cm4gb3B0aW9ucy5nZXROZXh0UGFnZVBhcmFtID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmdldE5leHRQYWdlUGFyYW0ocGFnZXNbcGFnZXMubGVuZ3RoIC0gMV0sIHBhZ2VzKTtcbn1cbmZ1bmN0aW9uIGdldFByZXZpb3VzUGFnZVBhcmFtKG9wdGlvbnMsIHBhZ2VzKSB7XG4gIHJldHVybiBvcHRpb25zLmdldFByZXZpb3VzUGFnZVBhcmFtID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmdldFByZXZpb3VzUGFnZVBhcmFtKHBhZ2VzWzBdLCBwYWdlcyk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGVyZSBpcyBhIG5leHQgcGFnZS5cbiAqIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgaXQgY2Fubm90IGJlIGRldGVybWluZWQuXG4gKi9cblxuZnVuY3Rpb24gaGFzTmV4dFBhZ2Uob3B0aW9ucywgcGFnZXMpIHtcbiAgaWYgKG9wdGlvbnMuZ2V0TmV4dFBhZ2VQYXJhbSAmJiBBcnJheS5pc0FycmF5KHBhZ2VzKSkge1xuICAgIGNvbnN0IG5leHRQYWdlUGFyYW0gPSBnZXROZXh0UGFnZVBhcmFtKG9wdGlvbnMsIHBhZ2VzKTtcbiAgICByZXR1cm4gdHlwZW9mIG5leHRQYWdlUGFyYW0gIT09ICd1bmRlZmluZWQnICYmIG5leHRQYWdlUGFyYW0gIT09IG51bGwgJiYgbmV4dFBhZ2VQYXJhbSAhPT0gZmFsc2U7XG4gIH1cblxuICByZXR1cm47XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGVyZSBpcyBhIHByZXZpb3VzIHBhZ2UuXG4gKiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIGl0IGNhbm5vdCBiZSBkZXRlcm1pbmVkLlxuICovXG5cbmZ1bmN0aW9uIGhhc1ByZXZpb3VzUGFnZShvcHRpb25zLCBwYWdlcykge1xuICBpZiAob3B0aW9ucy5nZXRQcmV2aW91c1BhZ2VQYXJhbSAmJiBBcnJheS5pc0FycmF5KHBhZ2VzKSkge1xuICAgIGNvbnN0IHByZXZpb3VzUGFnZVBhcmFtID0gZ2V0UHJldmlvdXNQYWdlUGFyYW0ob3B0aW9ucywgcGFnZXMpO1xuICAgIHJldHVybiB0eXBlb2YgcHJldmlvdXNQYWdlUGFyYW0gIT09ICd1bmRlZmluZWQnICYmIHByZXZpb3VzUGFnZVBhcmFtICE9PSBudWxsICYmIHByZXZpb3VzUGFnZVBhcmFtICE9PSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybjtcbn1cblxuZXhwb3J0IHsgZ2V0TmV4dFBhZ2VQYXJhbSwgZ2V0UHJldmlvdXNQYWdlUGFyYW0sIGhhc05leHRQYWdlLCBoYXNQcmV2aW91c1BhZ2UsIGluZmluaXRlUXVlcnlCZWhhdmlvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5maW5pdGVRdWVyeUJlaGF2aW9yLm1qcy5tYXBcbiIsImltcG9ydCB7IHBhcnNlRmlsdGVyQXJncywgcGFyc2VRdWVyeUFyZ3MsIGZ1bmN0aW9uYWxVcGRhdGUsIG5vb3AsIGhhc2hRdWVyeUtleSwgcGFydGlhbE1hdGNoS2V5LCBoYXNoUXVlcnlLZXlCeU9wdGlvbnMgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG5pbXBvcnQgeyBRdWVyeUNhY2hlIH0gZnJvbSAnLi9xdWVyeUNhY2hlLm1qcyc7XG5pbXBvcnQgeyBNdXRhdGlvbkNhY2hlIH0gZnJvbSAnLi9tdXRhdGlvbkNhY2hlLm1qcyc7XG5pbXBvcnQgeyBmb2N1c01hbmFnZXIgfSBmcm9tICcuL2ZvY3VzTWFuYWdlci5tanMnO1xuaW1wb3J0IHsgb25saW5lTWFuYWdlciB9IGZyb20gJy4vb25saW5lTWFuYWdlci5tanMnO1xuaW1wb3J0IHsgbm90aWZ5TWFuYWdlciB9IGZyb20gJy4vbm90aWZ5TWFuYWdlci5tanMnO1xuaW1wb3J0IHsgaW5maW5pdGVRdWVyeUJlaGF2aW9yIH0gZnJvbSAnLi9pbmZpbml0ZVF1ZXJ5QmVoYXZpb3IubWpzJztcbmltcG9ydCB7IGRlZmF1bHRMb2dnZXIgfSBmcm9tICcuL2xvZ2dlci5tanMnO1xuXG4vLyBDTEFTU1xuY2xhc3MgUXVlcnlDbGllbnQge1xuICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgIHRoaXMucXVlcnlDYWNoZSA9IGNvbmZpZy5xdWVyeUNhY2hlIHx8IG5ldyBRdWVyeUNhY2hlKCk7XG4gICAgdGhpcy5tdXRhdGlvbkNhY2hlID0gY29uZmlnLm11dGF0aW9uQ2FjaGUgfHwgbmV3IE11dGF0aW9uQ2FjaGUoKTtcbiAgICB0aGlzLmxvZ2dlciA9IGNvbmZpZy5sb2dnZXIgfHwgZGVmYXVsdExvZ2dlcjtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0gY29uZmlnLmRlZmF1bHRPcHRpb25zIHx8IHt9O1xuICAgIHRoaXMucXVlcnlEZWZhdWx0cyA9IFtdO1xuICAgIHRoaXMubXV0YXRpb25EZWZhdWx0cyA9IFtdO1xuICAgIHRoaXMubW91bnRDb3VudCA9IDA7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcubG9nZ2VyKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlBhc3NpbmcgYSBjdXN0b20gbG9nZ2VyIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlwiKTtcbiAgICB9XG4gIH1cblxuICBtb3VudCgpIHtcbiAgICB0aGlzLm1vdW50Q291bnQrKztcbiAgICBpZiAodGhpcy5tb3VudENvdW50ICE9PSAxKSByZXR1cm47XG4gICAgdGhpcy51bnN1YnNjcmliZUZvY3VzID0gZm9jdXNNYW5hZ2VyLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICBpZiAoZm9jdXNNYW5hZ2VyLmlzRm9jdXNlZCgpKSB7XG4gICAgICAgIHRoaXMucmVzdW1lUGF1c2VkTXV0YXRpb25zKCk7XG4gICAgICAgIHRoaXMucXVlcnlDYWNoZS5vbkZvY3VzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy51bnN1YnNjcmliZU9ubGluZSA9IG9ubGluZU1hbmFnZXIuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIGlmIChvbmxpbmVNYW5hZ2VyLmlzT25saW5lKCkpIHtcbiAgICAgICAgdGhpcy5yZXN1bWVQYXVzZWRNdXRhdGlvbnMoKTtcbiAgICAgICAgdGhpcy5xdWVyeUNhY2hlLm9uT25saW5lKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB1bm1vdW50KCkge1xuICAgIHZhciBfdGhpcyR1bnN1YnNjcmliZUZvY3UsIF90aGlzJHVuc3Vic2NyaWJlT25saTtcblxuICAgIHRoaXMubW91bnRDb3VudC0tO1xuICAgIGlmICh0aGlzLm1vdW50Q291bnQgIT09IDApIHJldHVybjtcbiAgICAoX3RoaXMkdW5zdWJzY3JpYmVGb2N1ID0gdGhpcy51bnN1YnNjcmliZUZvY3VzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkdW5zdWJzY3JpYmVGb2N1LmNhbGwodGhpcyk7XG4gICAgdGhpcy51bnN1YnNjcmliZUZvY3VzID0gdW5kZWZpbmVkO1xuICAgIChfdGhpcyR1bnN1YnNjcmliZU9ubGkgPSB0aGlzLnVuc3Vic2NyaWJlT25saW5lKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkdW5zdWJzY3JpYmVPbmxpLmNhbGwodGhpcyk7XG4gICAgdGhpcy51bnN1YnNjcmliZU9ubGluZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlzRmV0Y2hpbmcoYXJnMSwgYXJnMikge1xuICAgIGNvbnN0IFtmaWx0ZXJzXSA9IHBhcnNlRmlsdGVyQXJncyhhcmcxLCBhcmcyKTtcbiAgICBmaWx0ZXJzLmZldGNoU3RhdHVzID0gJ2ZldGNoaW5nJztcbiAgICByZXR1cm4gdGhpcy5xdWVyeUNhY2hlLmZpbmRBbGwoZmlsdGVycykubGVuZ3RoO1xuICB9XG5cbiAgaXNNdXRhdGluZyhmaWx0ZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMubXV0YXRpb25DYWNoZS5maW5kQWxsKHsgLi4uZmlsdGVycyxcbiAgICAgIGZldGNoaW5nOiB0cnVlXG4gICAgfSkubGVuZ3RoO1xuICB9XG5cbiAgZ2V0UXVlcnlEYXRhKHF1ZXJ5S2V5LCBmaWx0ZXJzKSB7XG4gICAgdmFyIF90aGlzJHF1ZXJ5Q2FjaGUkZmluZDtcblxuICAgIHJldHVybiAoX3RoaXMkcXVlcnlDYWNoZSRmaW5kID0gdGhpcy5xdWVyeUNhY2hlLmZpbmQocXVlcnlLZXksIGZpbHRlcnMpKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcXVlcnlDYWNoZSRmaW5kLnN0YXRlLmRhdGE7XG4gIH1cblxuICBlbnN1cmVRdWVyeURhdGEoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGNvbnN0IHBhcnNlZE9wdGlvbnMgPSBwYXJzZVF1ZXJ5QXJncyhhcmcxLCBhcmcyLCBhcmczKTtcbiAgICBjb25zdCBjYWNoZWREYXRhID0gdGhpcy5nZXRRdWVyeURhdGEocGFyc2VkT3B0aW9ucy5xdWVyeUtleSk7XG4gICAgcmV0dXJuIGNhY2hlZERhdGEgPyBQcm9taXNlLnJlc29sdmUoY2FjaGVkRGF0YSkgOiB0aGlzLmZldGNoUXVlcnkocGFyc2VkT3B0aW9ucyk7XG4gIH1cblxuICBnZXRRdWVyaWVzRGF0YShxdWVyeUtleU9yRmlsdGVycykge1xuICAgIHJldHVybiB0aGlzLmdldFF1ZXJ5Q2FjaGUoKS5maW5kQWxsKHF1ZXJ5S2V5T3JGaWx0ZXJzKS5tYXAoKHtcbiAgICAgIHF1ZXJ5S2V5LFxuICAgICAgc3RhdGVcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gc3RhdGUuZGF0YTtcbiAgICAgIHJldHVybiBbcXVlcnlLZXksIGRhdGFdO1xuICAgIH0pO1xuICB9XG5cbiAgc2V0UXVlcnlEYXRhKHF1ZXJ5S2V5LCB1cGRhdGVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLnF1ZXJ5Q2FjaGUuZmluZChxdWVyeUtleSk7XG4gICAgY29uc3QgcHJldkRhdGEgPSBxdWVyeSA9PSBudWxsID8gdm9pZCAwIDogcXVlcnkuc3RhdGUuZGF0YTtcbiAgICBjb25zdCBkYXRhID0gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBwcmV2RGF0YSk7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcnNlZE9wdGlvbnMgPSBwYXJzZVF1ZXJ5QXJncyhxdWVyeUtleSk7XG4gICAgY29uc3QgZGVmYXVsdGVkT3B0aW9ucyA9IHRoaXMuZGVmYXVsdFF1ZXJ5T3B0aW9ucyhwYXJzZWRPcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5xdWVyeUNhY2hlLmJ1aWxkKHRoaXMsIGRlZmF1bHRlZE9wdGlvbnMpLnNldERhdGEoZGF0YSwgeyAuLi5vcHRpb25zLFxuICAgICAgbWFudWFsOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBzZXRRdWVyaWVzRGF0YShxdWVyeUtleU9yRmlsdGVycywgdXBkYXRlciwgb3B0aW9ucykge1xuICAgIHJldHVybiBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHRoaXMuZ2V0UXVlcnlDYWNoZSgpLmZpbmRBbGwocXVlcnlLZXlPckZpbHRlcnMpLm1hcCgoe1xuICAgICAgcXVlcnlLZXlcbiAgICB9KSA9PiBbcXVlcnlLZXksIHRoaXMuc2V0UXVlcnlEYXRhKHF1ZXJ5S2V5LCB1cGRhdGVyLCBvcHRpb25zKV0pKTtcbiAgfVxuXG4gIGdldFF1ZXJ5U3RhdGUocXVlcnlLZXksIGZpbHRlcnMpIHtcbiAgICB2YXIgX3RoaXMkcXVlcnlDYWNoZSRmaW5kMjtcblxuICAgIHJldHVybiAoX3RoaXMkcXVlcnlDYWNoZSRmaW5kMiA9IHRoaXMucXVlcnlDYWNoZS5maW5kKHF1ZXJ5S2V5LCBmaWx0ZXJzKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHF1ZXJ5Q2FjaGUkZmluZDIuc3RhdGU7XG4gIH1cblxuICByZW1vdmVRdWVyaWVzKGFyZzEsIGFyZzIpIHtcbiAgICBjb25zdCBbZmlsdGVyc10gPSBwYXJzZUZpbHRlckFyZ3MoYXJnMSwgYXJnMik7XG4gICAgY29uc3QgcXVlcnlDYWNoZSA9IHRoaXMucXVlcnlDYWNoZTtcbiAgICBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHtcbiAgICAgIHF1ZXJ5Q2FjaGUuZmluZEFsbChmaWx0ZXJzKS5mb3JFYWNoKHF1ZXJ5ID0+IHtcbiAgICAgICAgcXVlcnlDYWNoZS5yZW1vdmUocXVlcnkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXNldFF1ZXJpZXMoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGNvbnN0IFtmaWx0ZXJzLCBvcHRpb25zXSA9IHBhcnNlRmlsdGVyQXJncyhhcmcxLCBhcmcyLCBhcmczKTtcbiAgICBjb25zdCBxdWVyeUNhY2hlID0gdGhpcy5xdWVyeUNhY2hlO1xuICAgIGNvbnN0IHJlZmV0Y2hGaWx0ZXJzID0ge1xuICAgICAgdHlwZTogJ2FjdGl2ZScsXG4gICAgICAuLi5maWx0ZXJzXG4gICAgfTtcbiAgICByZXR1cm4gbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB7XG4gICAgICBxdWVyeUNhY2hlLmZpbmRBbGwoZmlsdGVycykuZm9yRWFjaChxdWVyeSA9PiB7XG4gICAgICAgIHF1ZXJ5LnJlc2V0KCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLnJlZmV0Y2hRdWVyaWVzKHJlZmV0Y2hGaWx0ZXJzLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNhbmNlbFF1ZXJpZXMoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGNvbnN0IFtmaWx0ZXJzLCBjYW5jZWxPcHRpb25zID0ge31dID0gcGFyc2VGaWx0ZXJBcmdzKGFyZzEsIGFyZzIsIGFyZzMpO1xuXG4gICAgaWYgKHR5cGVvZiBjYW5jZWxPcHRpb25zLnJldmVydCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNhbmNlbE9wdGlvbnMucmV2ZXJ0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9taXNlcyA9IG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4gdGhpcy5xdWVyeUNhY2hlLmZpbmRBbGwoZmlsdGVycykubWFwKHF1ZXJ5ID0+IHF1ZXJ5LmNhbmNlbChjYW5jZWxPcHRpb25zKSkpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihub29wKS5jYXRjaChub29wKTtcbiAgfVxuXG4gIGludmFsaWRhdGVRdWVyaWVzKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBjb25zdCBbZmlsdGVycywgb3B0aW9uc10gPSBwYXJzZUZpbHRlckFyZ3MoYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgcmV0dXJuIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4ge1xuICAgICAgdmFyIF9yZWYsIF9maWx0ZXJzJHJlZmV0Y2hUeXBlO1xuXG4gICAgICB0aGlzLnF1ZXJ5Q2FjaGUuZmluZEFsbChmaWx0ZXJzKS5mb3JFYWNoKHF1ZXJ5ID0+IHtcbiAgICAgICAgcXVlcnkuaW52YWxpZGF0ZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChmaWx0ZXJzLnJlZmV0Y2hUeXBlID09PSAnbm9uZScpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZWZldGNoRmlsdGVycyA9IHsgLi4uZmlsdGVycyxcbiAgICAgICAgdHlwZTogKF9yZWYgPSAoX2ZpbHRlcnMkcmVmZXRjaFR5cGUgPSBmaWx0ZXJzLnJlZmV0Y2hUeXBlKSAhPSBudWxsID8gX2ZpbHRlcnMkcmVmZXRjaFR5cGUgOiBmaWx0ZXJzLnR5cGUpICE9IG51bGwgPyBfcmVmIDogJ2FjdGl2ZSdcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5yZWZldGNoUXVlcmllcyhyZWZldGNoRmlsdGVycywgb3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cblxuICByZWZldGNoUXVlcmllcyhhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgY29uc3QgW2ZpbHRlcnMsIG9wdGlvbnNdID0gcGFyc2VGaWx0ZXJBcmdzKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIGNvbnN0IHByb21pc2VzID0gbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB0aGlzLnF1ZXJ5Q2FjaGUuZmluZEFsbChmaWx0ZXJzKS5maWx0ZXIocXVlcnkgPT4gIXF1ZXJ5LmlzRGlzYWJsZWQoKSkubWFwKHF1ZXJ5ID0+IHtcbiAgICAgIHZhciBfb3B0aW9ucyRjYW5jZWxSZWZldGM7XG5cbiAgICAgIHJldHVybiBxdWVyeS5mZXRjaCh1bmRlZmluZWQsIHsgLi4ub3B0aW9ucyxcbiAgICAgICAgY2FuY2VsUmVmZXRjaDogKF9vcHRpb25zJGNhbmNlbFJlZmV0YyA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FuY2VsUmVmZXRjaCkgIT0gbnVsbCA/IF9vcHRpb25zJGNhbmNlbFJlZmV0YyA6IHRydWUsXG4gICAgICAgIG1ldGE6IHtcbiAgICAgICAgICByZWZldGNoUGFnZTogZmlsdGVycy5yZWZldGNoUGFnZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSk7XG4gICAgbGV0IHByb21pc2UgPSBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihub29wKTtcblxuICAgIGlmICghKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLnRocm93T25FcnJvcikpIHtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLmNhdGNoKG5vb3ApO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgZmV0Y2hRdWVyeShhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgY29uc3QgcGFyc2VkT3B0aW9ucyA9IHBhcnNlUXVlcnlBcmdzKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIGNvbnN0IGRlZmF1bHRlZE9wdGlvbnMgPSB0aGlzLmRlZmF1bHRRdWVyeU9wdGlvbnMocGFyc2VkT3B0aW9ucyk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YW5uZXJsaW5zbGV5L3JlYWN0LXF1ZXJ5L2lzc3Vlcy82NTJcblxuICAgIGlmICh0eXBlb2YgZGVmYXVsdGVkT3B0aW9ucy5yZXRyeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRlZmF1bHRlZE9wdGlvbnMucmV0cnkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBxdWVyeSA9IHRoaXMucXVlcnlDYWNoZS5idWlsZCh0aGlzLCBkZWZhdWx0ZWRPcHRpb25zKTtcbiAgICByZXR1cm4gcXVlcnkuaXNTdGFsZUJ5VGltZShkZWZhdWx0ZWRPcHRpb25zLnN0YWxlVGltZSkgPyBxdWVyeS5mZXRjaChkZWZhdWx0ZWRPcHRpb25zKSA6IFByb21pc2UucmVzb2x2ZShxdWVyeS5zdGF0ZS5kYXRhKTtcbiAgfVxuXG4gIHByZWZldGNoUXVlcnkoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIHJldHVybiB0aGlzLmZldGNoUXVlcnkoYXJnMSwgYXJnMiwgYXJnMykudGhlbihub29wKS5jYXRjaChub29wKTtcbiAgfVxuXG4gIGZldGNoSW5maW5pdGVRdWVyeShhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgY29uc3QgcGFyc2VkT3B0aW9ucyA9IHBhcnNlUXVlcnlBcmdzKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIHBhcnNlZE9wdGlvbnMuYmVoYXZpb3IgPSBpbmZpbml0ZVF1ZXJ5QmVoYXZpb3IoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaFF1ZXJ5KHBhcnNlZE9wdGlvbnMpO1xuICB9XG5cbiAgcHJlZmV0Y2hJbmZpbml0ZVF1ZXJ5KGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEluZmluaXRlUXVlcnkoYXJnMSwgYXJnMiwgYXJnMykudGhlbihub29wKS5jYXRjaChub29wKTtcbiAgfVxuXG4gIHJlc3VtZVBhdXNlZE11dGF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5tdXRhdGlvbkNhY2hlLnJlc3VtZVBhdXNlZE11dGF0aW9ucygpO1xuICB9XG5cbiAgZ2V0UXVlcnlDYWNoZSgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeUNhY2hlO1xuICB9XG5cbiAgZ2V0TXV0YXRpb25DYWNoZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tdXRhdGlvbkNhY2hlO1xuICB9XG5cbiAgZ2V0TG9nZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLmxvZ2dlcjtcbiAgfVxuXG4gIGdldERlZmF1bHRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmF1bHRPcHRpb25zO1xuICB9XG5cbiAgc2V0RGVmYXVsdE9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG5cbiAgc2V0UXVlcnlEZWZhdWx0cyhxdWVyeUtleSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucXVlcnlEZWZhdWx0cy5maW5kKHggPT4gaGFzaFF1ZXJ5S2V5KHF1ZXJ5S2V5KSA9PT0gaGFzaFF1ZXJ5S2V5KHgucXVlcnlLZXkpKTtcblxuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHJlc3VsdC5kZWZhdWx0T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucXVlcnlEZWZhdWx0cy5wdXNoKHtcbiAgICAgICAgcXVlcnlLZXksXG4gICAgICAgIGRlZmF1bHRPcHRpb25zOiBvcHRpb25zXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBnZXRRdWVyeURlZmF1bHRzKHF1ZXJ5S2V5KSB7XG4gICAgaWYgKCFxdWVyeUtleSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IC8vIEdldCB0aGUgZmlyc3QgbWF0Y2hpbmcgZGVmYXVsdHNcblxuXG4gICAgY29uc3QgZmlyc3RNYXRjaGluZ0RlZmF1bHRzID0gdGhpcy5xdWVyeURlZmF1bHRzLmZpbmQoeCA9PiBwYXJ0aWFsTWF0Y2hLZXkocXVlcnlLZXksIHgucXVlcnlLZXkpKTsgLy8gQWRkaXRpb25hbCBjaGVja3MgYW5kIGVycm9yIGluIGRldiBtb2RlXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gUmV0cmlldmUgYWxsIG1hdGNoaW5nIGRlZmF1bHRzIGZvciB0aGUgZ2l2ZW4ga2V5XG4gICAgICBjb25zdCBtYXRjaGluZ0RlZmF1bHRzID0gdGhpcy5xdWVyeURlZmF1bHRzLmZpbHRlcih4ID0+IHBhcnRpYWxNYXRjaEtleShxdWVyeUtleSwgeC5xdWVyeUtleSkpOyAvLyBJdCBpcyBvayBub3QgaGF2aW5nIGRlZmF1bHRzLCBidXQgaXQgaXMgZXJyb3IgcHJvbmUgdG8gaGF2ZSBtb3JlIHRoYW4gMSBkZWZhdWx0IGZvciBhIGdpdmVuIGtleVxuXG4gICAgICBpZiAobWF0Y2hpbmdEZWZhdWx0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiW1F1ZXJ5Q2xpZW50XSBTZXZlcmFsIHF1ZXJ5IGRlZmF1bHRzIG1hdGNoIHdpdGgga2V5ICdcIiArIEpTT04uc3RyaW5naWZ5KHF1ZXJ5S2V5KSArIFwiJy4gVGhlIGZpcnN0IG1hdGNoaW5nIHF1ZXJ5IGRlZmF1bHRzIGFyZSB1c2VkLiBQbGVhc2UgY2hlY2sgaG93IHF1ZXJ5IGRlZmF1bHRzIGFyZSByZWdpc3RlcmVkLiBPcmRlciBkb2VzIG1hdHRlciBoZXJlLiBjZi4gaHR0cHM6Ly9yZWFjdC1xdWVyeS50YW5zdGFjay5jb20vcmVmZXJlbmNlL1F1ZXJ5Q2xpZW50I3F1ZXJ5Y2xpZW50c2V0cXVlcnlkZWZhdWx0cy5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpcnN0TWF0Y2hpbmdEZWZhdWx0cyA9PSBudWxsID8gdm9pZCAwIDogZmlyc3RNYXRjaGluZ0RlZmF1bHRzLmRlZmF1bHRPcHRpb25zO1xuICB9XG5cbiAgc2V0TXV0YXRpb25EZWZhdWx0cyhtdXRhdGlvbktleSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMubXV0YXRpb25EZWZhdWx0cy5maW5kKHggPT4gaGFzaFF1ZXJ5S2V5KG11dGF0aW9uS2V5KSA9PT0gaGFzaFF1ZXJ5S2V5KHgubXV0YXRpb25LZXkpKTtcblxuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHJlc3VsdC5kZWZhdWx0T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubXV0YXRpb25EZWZhdWx0cy5wdXNoKHtcbiAgICAgICAgbXV0YXRpb25LZXksXG4gICAgICAgIGRlZmF1bHRPcHRpb25zOiBvcHRpb25zXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBnZXRNdXRhdGlvbkRlZmF1bHRzKG11dGF0aW9uS2V5KSB7XG4gICAgaWYgKCFtdXRhdGlvbktleSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IC8vIEdldCB0aGUgZmlyc3QgbWF0Y2hpbmcgZGVmYXVsdHNcblxuXG4gICAgY29uc3QgZmlyc3RNYXRjaGluZ0RlZmF1bHRzID0gdGhpcy5tdXRhdGlvbkRlZmF1bHRzLmZpbmQoeCA9PiBwYXJ0aWFsTWF0Y2hLZXkobXV0YXRpb25LZXksIHgubXV0YXRpb25LZXkpKTsgLy8gQWRkaXRpb25hbCBjaGVja3MgYW5kIGVycm9yIGluIGRldiBtb2RlXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gUmV0cmlldmUgYWxsIG1hdGNoaW5nIGRlZmF1bHRzIGZvciB0aGUgZ2l2ZW4ga2V5XG4gICAgICBjb25zdCBtYXRjaGluZ0RlZmF1bHRzID0gdGhpcy5tdXRhdGlvbkRlZmF1bHRzLmZpbHRlcih4ID0+IHBhcnRpYWxNYXRjaEtleShtdXRhdGlvbktleSwgeC5tdXRhdGlvbktleSkpOyAvLyBJdCBpcyBvayBub3QgaGF2aW5nIGRlZmF1bHRzLCBidXQgaXQgaXMgZXJyb3IgcHJvbmUgdG8gaGF2ZSBtb3JlIHRoYW4gMSBkZWZhdWx0IGZvciBhIGdpdmVuIGtleVxuXG4gICAgICBpZiAobWF0Y2hpbmdEZWZhdWx0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiW1F1ZXJ5Q2xpZW50XSBTZXZlcmFsIG11dGF0aW9uIGRlZmF1bHRzIG1hdGNoIHdpdGgga2V5ICdcIiArIEpTT04uc3RyaW5naWZ5KG11dGF0aW9uS2V5KSArIFwiJy4gVGhlIGZpcnN0IG1hdGNoaW5nIG11dGF0aW9uIGRlZmF1bHRzIGFyZSB1c2VkLiBQbGVhc2UgY2hlY2sgaG93IG11dGF0aW9uIGRlZmF1bHRzIGFyZSByZWdpc3RlcmVkLiBPcmRlciBkb2VzIG1hdHRlciBoZXJlLiBjZi4gaHR0cHM6Ly9yZWFjdC1xdWVyeS50YW5zdGFjay5jb20vcmVmZXJlbmNlL1F1ZXJ5Q2xpZW50I3F1ZXJ5Y2xpZW50c2V0bXV0YXRpb25kZWZhdWx0cy5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpcnN0TWF0Y2hpbmdEZWZhdWx0cyA9PSBudWxsID8gdm9pZCAwIDogZmlyc3RNYXRjaGluZ0RlZmF1bHRzLmRlZmF1bHRPcHRpb25zO1xuICB9XG5cbiAgZGVmYXVsdFF1ZXJ5T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLl9kZWZhdWx0ZWQpIHtcbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIGNvbnN0IGRlZmF1bHRlZE9wdGlvbnMgPSB7IC4uLnRoaXMuZGVmYXVsdE9wdGlvbnMucXVlcmllcyxcbiAgICAgIC4uLnRoaXMuZ2V0UXVlcnlEZWZhdWx0cyhvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnF1ZXJ5S2V5KSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBfZGVmYXVsdGVkOiB0cnVlXG4gICAgfTtcblxuICAgIGlmICghZGVmYXVsdGVkT3B0aW9ucy5xdWVyeUhhc2ggJiYgZGVmYXVsdGVkT3B0aW9ucy5xdWVyeUtleSkge1xuICAgICAgZGVmYXVsdGVkT3B0aW9ucy5xdWVyeUhhc2ggPSBoYXNoUXVlcnlLZXlCeU9wdGlvbnMoZGVmYXVsdGVkT3B0aW9ucy5xdWVyeUtleSwgZGVmYXVsdGVkT3B0aW9ucyk7XG4gICAgfSAvLyBkZXBlbmRlbnQgZGVmYXVsdCB2YWx1ZXNcblxuXG4gICAgaWYgKHR5cGVvZiBkZWZhdWx0ZWRPcHRpb25zLnJlZmV0Y2hPblJlY29ubmVjdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRlZmF1bHRlZE9wdGlvbnMucmVmZXRjaE9uUmVjb25uZWN0ID0gZGVmYXVsdGVkT3B0aW9ucy5uZXR3b3JrTW9kZSAhPT0gJ2Fsd2F5cyc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkZWZhdWx0ZWRPcHRpb25zLnVzZUVycm9yQm91bmRhcnkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkZWZhdWx0ZWRPcHRpb25zLnVzZUVycm9yQm91bmRhcnkgPSAhIWRlZmF1bHRlZE9wdGlvbnMuc3VzcGVuc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRlZE9wdGlvbnM7XG4gIH1cblxuICBkZWZhdWx0TXV0YXRpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuX2RlZmF1bHRlZCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgLi4udGhpcy5kZWZhdWx0T3B0aW9ucy5tdXRhdGlvbnMsXG4gICAgICAuLi50aGlzLmdldE11dGF0aW9uRGVmYXVsdHMob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5tdXRhdGlvbktleSksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgX2RlZmF1bHRlZDogdHJ1ZVxuICAgIH07XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aGlzLnF1ZXJ5Q2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLm11dGF0aW9uQ2FjaGUuY2xlYXIoKTtcbiAgfVxuXG59XG5cbmV4cG9ydCB7IFF1ZXJ5Q2xpZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeUNsaWVudC5tanMubWFwXG4iLCJpbXBvcnQgUmVhY3QsIHsgUHJvcHNXaXRoQ2hpbGRyZW4gfSBmcm9tICdyZWFjdCc7XG4vLyBAdHMtZXhwZWN0LWVycm9yIGBAZGVyaXYvZGVyaXYtYXBpYCBpcyBub3QgaW4gVHlwZVNjcmlwdCwgSGVuY2Ugd2UgaWdub3JlIHRoZSBUUyBlcnJvci5cbmltcG9ydCBEZXJpdkFQSUJhc2ljIGZyb20gJ0BkZXJpdi9kZXJpdi1hcGkvZGlzdC9EZXJpdkFQSUJhc2ljJztcbmltcG9ydCB7IGdldEFwcElkLCBnZXRTb2NrZXRVUkwsIHVzZVdTIH0gZnJvbSAnQGRlcml2L3NoYXJlZCc7XG5pbXBvcnQgeyBRdWVyeUNsaWVudCwgUXVlcnlDbGllbnRQcm92aWRlciB9IGZyb20gJ0B0YW5zdGFjay9yZWFjdC1xdWVyeSc7XG4vLyBpbXBvcnQgeyBSZWFjdFF1ZXJ5RGV2dG9vbHMgfSBmcm9tICdAdGFuc3RhY2svcmVhY3QtcXVlcnktZGV2dG9vbHMnO1xuaW1wb3J0IEFQSUNvbnRleHQgZnJvbSAnLi9BUElDb250ZXh0JztcblxuZGVjbGFyZSBnbG9iYWwge1xuICAgIGludGVyZmFjZSBXaW5kb3cge1xuICAgICAgICBSZWFjdFF1ZXJ5Q2xpZW50PzogUXVlcnlDbGllbnQ7XG4gICAgICAgIERlcml2QVBJPzogUmVjb3JkPHN0cmluZywgRGVyaXZBUElCYXNpYz47XG4gICAgfVxufVxuXG4vLyBUaGlzIGlzIGEgdGVtcG9yYXJ5IHdvcmthcm91bmQgdG8gc2hhcmUgYSBzaW5nbGUgYFF1ZXJ5Q2xpZW50YCBpbnN0YW5jZSBiZXR3ZWVuIGFsbCB0aGUgcGFja2FnZXMuXG4vLyBMYXRlciBvbmNlIHdlIGhhdmUgZWFjaCBwYWNrYWdlIHNlcGFyYXRlZCB3ZSB3b24ndCBuZWVkIHRoaXMgYW55bW9yZSBhbmQgY2FuIHJlbW92ZSB0aGlzLlxuY29uc3QgZ2V0U2hhcmVkUXVlcnlDbGllbnRDb250ZXh0ID0gKCk6IFF1ZXJ5Q2xpZW50ID0+IHtcbiAgICBpZiAoIXdpbmRvdy5SZWFjdFF1ZXJ5Q2xpZW50KSB7XG4gICAgICAgIHdpbmRvdy5SZWFjdFF1ZXJ5Q2xpZW50ID0gbmV3IFF1ZXJ5Q2xpZW50KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdpbmRvdy5SZWFjdFF1ZXJ5Q2xpZW50O1xufTtcblxuLy8gVGhpcyBpcyBhIHRlbXBvcmFyeSB3b3JrYXJvdW5kIHRvIHNoYXJlIGEgc2luZ2xlIGBEZXJpdkFQSUJhc2ljYCBpbnN0YW5jZSBmb3IgZXZlcnkgdW5pcXVlIFVSTC5cbi8vIExhdGVyIG9uY2Ugd2UgaGF2ZSBlYWNoIHBhY2thZ2Ugc2VwYXJhdGVkIHdlIHdvbid0IG5lZWQgdGhpcyBhbnltb3JlIGFuZCBjYW4gcmVtb3ZlIHRoaXMuXG5jb25zdCBnZXREZXJpdkFQSUluc3RhbmNlID0gKCk6IERlcml2QVBJQmFzaWMgPT4ge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gZ2V0U29ja2V0VVJMKCk7XG4gICAgY29uc3QgYXBwX2lkID0gZ2V0QXBwSWQoKTtcbiAgICBjb25zdCBsYW5ndWFnZSA9ICdFTic7IC8vIE5lZWQgdG8gdXNlIHRoZSBsYW5ndWFnZSBmcm9tIHRoZSBhcHAgY29udGV4dC5cbiAgICBjb25zdCBicmFuZCA9ICdkZXJpdic7XG4gICAgY29uc3Qgd3NzID0gYHdzczovLyR7ZW5kcG9pbnR9L3dlYnNvY2tldHMvdjM/YXBwX2lkPSR7YXBwX2lkfSZsPSR7bGFuZ3VhZ2V9JmJyYW5kPSR7YnJhbmR9YDtcblxuICAgIGlmICghd2luZG93LkRlcml2QVBJKSB7XG4gICAgICAgIHdpbmRvdy5EZXJpdkFQSSA9IHt9O1xuICAgIH1cblxuICAgIGlmICghd2luZG93LkRlcml2QVBJPy5bd3NzXSkge1xuICAgICAgICB3aW5kb3cuRGVyaXZBUElbd3NzXSA9IG5ldyBEZXJpdkFQSUJhc2ljKHsgY29ubmVjdGlvbjogbmV3IFdlYlNvY2tldCh3c3MpIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB3aW5kb3cuRGVyaXZBUEk/Llt3c3NdO1xufTtcblxuY29uc3QgcXVlcnlDbGllbnQgPSBnZXRTaGFyZWRRdWVyeUNsaWVudENvbnRleHQoKTtcblxudHlwZSBUUHJvcHMgPSB7XG4gICAgLyoqIElmIHNldCB0byB0cnVlLCB0aGUgQVBJUHJvdmlkZXIgd2lsbCBpbnN0YW50aWF0ZSBpdCdzIG93biBzb2NrZXQgY29ubmVjdGlvbi4gKi9cbiAgICBzdGFuZGFsb25lPzogYm9vbGVhbjtcbn07XG5cbmNvbnN0IEFQSVByb3ZpZGVyID0gKHsgY2hpbGRyZW4sIHN0YW5kYWxvbmUgPSBmYWxzZSB9OiBQcm9wc1dpdGhDaGlsZHJlbjxUUHJvcHM+KSA9PiB7XG4gICAgY29uc3QgV1MgPSB1c2VXUygpO1xuICAgIC8vIFVzZSB0aGUgbmV3IEFQSSBpbnN0YW5jZSBpZiB0aGUgYHN0YW5kYWxvbmVgIHByb3AgaXMgc2V0IHRvIHRydWUsXG4gICAgLy8gZWxzZSB1c2UgdGhlIGxlZ2FjeSBzb2NrZXQgY29ubmVjdGlvbi5cbiAgICBjb25zdCBhY3RpdmVfY29ubmVjdGlvbiA9IHN0YW5kYWxvbmUgPyBnZXREZXJpdkFQSUluc3RhbmNlKCkgOiBXUztcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxBUElDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXthY3RpdmVfY29ubmVjdGlvbn0+XG4gICAgICAgICAgICA8UXVlcnlDbGllbnRQcm92aWRlciBjbGllbnQ9e3F1ZXJ5Q2xpZW50fT5cbiAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICAgICAgey8qIDxSZWFjdFF1ZXJ5RGV2dG9vbHMgLz4gKi99XG4gICAgICAgICAgICA8L1F1ZXJ5Q2xpZW50UHJvdmlkZXI+XG4gICAgICAgIDwvQVBJQ29udGV4dC5Qcm92aWRlcj5cbiAgICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQVBJUHJvdmlkZXI7XG4iLCJpbXBvcnQgZ3JvdXBCeSBmcm9tICdsb2Rhc2guZ3JvdXBieSc7XG5pbXBvcnQgcGlja0J5IGZyb20gJ2xvZGFzaC5waWNrYnknO1xuaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgU3RhdGVtZW50IH0gZnJvbSAnQGRlcml2L2FwaS10eXBlcyc7XG5cbmNvbnN0IGdyb3VwVHJhbnNhY3Rpb25zQnlEYXkgPSAodHJhbnNhY3Rpb25zOiBTdGF0ZW1lbnRbJ3RyYW5zYWN0aW9ucyddKSA9PiB7XG4gICAgY29uc3QgZ3JvdXBlZF90cmFuc2FjdGlvbnMgPSBwaWNrQnkoXG4gICAgICAgIGdyb3VwQnkodHJhbnNhY3Rpb25zLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb24udHJhbnNhY3Rpb25fdGltZVxuICAgICAgICAgICAgICAgID8gbW9tZW50KHRyYW5zYWN0aW9uLnRyYW5zYWN0aW9uX3RpbWUgKiAxMDAwKVxuICAgICAgICAgICAgICAgICAgICAgIC5zdGFydE9mKCdkYXknKVxuICAgICAgICAgICAgICAgICAgICAgIC5mb3JtYXQoJ0REIE1NTSBZWVlZJylcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIH0pLFxuICAgICAgICAodmFsdWUsIGtleSkgPT4ga2V5ICE9PSBudWxsXG4gICAgKTtcblxuICAgIHJldHVybiBncm91cGVkX3RyYW5zYWN0aW9ucztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGdyb3VwVHJhbnNhY3Rpb25zQnlEYXk7XG4iLCJleHBvcnQgeyBkZWZhdWx0IGFzIGdldEFjY291bnRzRnJvbUxvY2FsU3RvcmFnZSB9IGZyb20gJy4vZ2V0QWNjb3VudHNGcm9tTG9jYWxTdG9yYWdlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZ2V0QWN0aXZlQXV0aFRva2VuSURGcm9tTG9jYWxTdG9yYWdlIH0gZnJvbSAnLi9nZXRBY3RpdmVBdXRoVG9rZW5JREZyb21Mb2NhbFN0b3JhZ2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBnZXRBY3RpdmVMb2dpbklERnJvbUxvY2FsU3RvcmFnZSB9IGZyb20gJy4vZ2V0QWN0aXZlTG9naW5JREZyb21Mb2NhbFN0b3JhZ2UnO1xuZXhwb3J0IHsgZ2V0TG9jYWxTdG9yYWdlIH0gZnJvbSAnLi9nZXRMb2NhbFN0b3JhZ2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBnZXRXYWxsZXRDdXJyZW5jeUljb24gfSBmcm9tICcuL2dldFdhbGxldEN1cnJlbmN5SWNvbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGdyb3VwVHJhbnNhY3Rpb25zQnlEYXkgfSBmcm9tICcuL2dyb3VwVHJhbnNhY3Rpb25zQnlEYXknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBnZXRUcnVuY2F0ZWRTdHJpbmcgfSBmcm9tICcuL2dldFRydW5jYXRlZFN0cmluZyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVuRm9ybWF0TG9jYWxlU3RyaW5nIH0gZnJvbSAnLi91bkZvcm1hdExvY2FsZVN0cmluZyc7XG5leHBvcnQgKiBmcm9tICcuL3BhcnNlLXVybCc7XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVF1ZXJ5Q2xpZW50IH0gZnJvbSAnQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5JztcbmltcG9ydCB7IFRTb2NrZXRFbmRwb2ludE5hbWVzIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG50eXBlIFRPcHRpb25zID0gUGFyYW1ldGVyczxSZXR1cm5UeXBlPHR5cGVvZiB1c2VRdWVyeUNsaWVudD5bJ2ludmFsaWRhdGVRdWVyaWVzJ10+WzFdO1xuXG5jb25zdCB1c2VJbnZhbGlkYXRlUXVlcnkgPSAoKSA9PiB7XG4gICAgY29uc3QgcXVlcnlDbGllbnQgPSB1c2VRdWVyeUNsaWVudCgpO1xuXG4gICAgY29uc3QgaW52YWxpZGF0ZSA9IHVzZUNhbGxiYWNrKFxuICAgICAgICA8VCBleHRlbmRzIFRTb2NrZXRFbmRwb2ludE5hbWVzPihuYW1lOiBUIHwgVFtdLCBvcHRpb25zPzogVE9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBxdWVyeUNsaWVudC5pbnZhbGlkYXRlUXVlcmllcyhBcnJheS5pc0FycmF5KG5hbWUpID8gbmFtZSA6IFtuYW1lXSwgb3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIFtxdWVyeUNsaWVudF1cbiAgICApO1xuXG4gICAgcmV0dXJuIGludmFsaWRhdGU7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VJbnZhbGlkYXRlUXVlcnk7XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGdldEFjdGl2ZUF1dGhUb2tlbklERnJvbUxvY2FsU3RvcmFnZSwgZ2V0QWN0aXZlTG9naW5JREZyb21Mb2NhbFN0b3JhZ2UgfSBmcm9tICdAZGVyaXYvdXRpbHMnO1xuaW1wb3J0IHVzZUludmFsaWRhdGVRdWVyeSBmcm9tICcuLi91c2VJbnZhbGlkYXRlUXVlcnknO1xuaW1wb3J0IHVzZVF1ZXJ5IGZyb20gJy4uL3VzZVF1ZXJ5JztcblxuLyoqIEEgY3VzdG9tIGhvb2sgdGhhdCBhdXRob3JpemUgdGhlIHVzZXIgd2l0aCB0aGUgZ2l2ZW4gdG9rZW4uIElmIG5vIHRva2VuIGlzIGdpdmVuLFxuICogaXQgd2lsbCB1c2UgdGhlIGN1cnJlbnQgdG9rZW4gZnJvbSBsb2NhbFN0b3JhZ2UuXG4gKi9cbmNvbnN0IHVzZUF1dGhvcml6ZSA9ICgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50X3Rva2VuID0gZ2V0QWN0aXZlQXV0aFRva2VuSURGcm9tTG9jYWxTdG9yYWdlKCk7XG4gICAgY29uc3QgaW52YWxpZGF0ZSA9IHVzZUludmFsaWRhdGVRdWVyeSgpO1xuXG4gICAgY29uc3QgeyBkYXRhLCAuLi5yZXN0IH0gPSB1c2VRdWVyeSgnYXV0aG9yaXplJywge1xuICAgICAgICBwYXlsb2FkOiB7IGF1dGhvcml6ZTogY3VycmVudF90b2tlbiB8fCAnJyB9LFxuICAgICAgICBvcHRpb25zOiB7IGVuYWJsZWQ6IEJvb2xlYW4oY3VycmVudF90b2tlbikgfSxcbiAgICB9KTtcblxuICAgIC8vIEFkZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHRvIHRoZSBhdXRob3JpemUgcmVzcG9uc2UuXG4gICAgY29uc3QgbW9kaWZpZWRfYXV0aG9yaXplID0gdXNlTWVtbygoKSA9PiAoeyAuLi5kYXRhPy5hdXRob3JpemUgfSksIFtkYXRhPy5hdXRob3JpemVdKTtcblxuICAgIGNvbnN0IHN3aXRjaEFjY291bnQgPSB1c2VDYWxsYmFjayhcbiAgICAgICAgKGxvZ2luaWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlX2xvZ2luaWQgPSBnZXRBY3RpdmVMb2dpbklERnJvbUxvY2FsU3RvcmFnZSgpO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZV9sb2dpbmlkICE9PSBsb2dpbmlkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2FjdGl2ZV9sb2dpbmlkJywgbG9naW5pZCk7XG4gICAgICAgICAgICAgICAgaW52YWxpZGF0ZSgnYXV0aG9yaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFtpbnZhbGlkYXRlXVxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKiogVGhlIGF1dGhvcml6ZSByZXNwb25zZS4gKi9cbiAgICAgICAgZGF0YTogbW9kaWZpZWRfYXV0aG9yaXplLFxuICAgICAgICAvKiogRnVuY3Rpb24gdG8gc3dpdGNoIHRvIGFub3RoZXIgYWNjb3VudCAqL1xuICAgICAgICBzd2l0Y2hBY2NvdW50LFxuICAgICAgICAuLi5yZXN0LFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VBdXRob3JpemU7XG4iLCJpbXBvcnQgdXNlUXVlcnkgZnJvbSAnLi4vdXNlUXVlcnknO1xuaW1wb3J0IHVzZUF1dGhvcml6ZSBmcm9tICcuL3VzZUF1dGhvcml6ZSc7XG5cbi8qKiBBIGN1c3RvbSBob29rIHRvIGdldCBhY2NvdW50IGxpbWl0cyAqL1xuY29uc3QgdXNlQWNjb3VudExpbWl0cyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGlzU3VjY2VzcyB9ID0gdXNlQXV0aG9yaXplKCk7XG4gICAgY29uc3QgeyBkYXRhLCAuLi5yZXN0IH0gPSB1c2VRdWVyeSgnZ2V0X2xpbWl0cycsIHsgb3B0aW9uczogeyBlbmFibGVkOiBpc1N1Y2Nlc3MgfSB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKiBBY2NvdW50IGxpbWl0cyByZXNwb25zZSAqL1xuICAgICAgICBkYXRhOiBkYXRhPy5nZXRfbGltaXRzLFxuICAgICAgICAuLi5yZXN0LFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VBY2NvdW50TGltaXRzO1xuIiwiaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VRdWVyeSBmcm9tICcuLi91c2VRdWVyeSc7XG5cbi8qKiBBIGN1c3RvbSBob29rIHRvIHJldHJpZXZlcyB0aGUgYWNjb3VudCBzdGF0dXMgZm9yIHRoZSBjdXJyZW50IHVzZXIuICovXG5jb25zdCB1c2VHZXRBY2NvdW50U3RhdHVzID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgZGF0YTogZ2V0X2FjY291bnRfc3RhdHVzX2RhdGEsIC4uLnJlc3QgfSA9IHVzZVF1ZXJ5KCdnZXRfYWNjb3VudF9zdGF0dXMnKTtcblxuICAgIC8vIEFkZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHRvIHRoZSBhY2NvdW50IHN0YXR1cyByZXNwb25zZS5cbiAgICBjb25zdCBtb2RpZmllZF9hY2NvdW50X3N0YXR1cyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoIWdldF9hY2NvdW50X3N0YXR1c19kYXRhPy5nZXRfYWNjb3VudF9zdGF0dXMpIHJldHVybjtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZ2V0X2FjY291bnRfc3RhdHVzX2RhdGEuZ2V0X2FjY291bnRfc3RhdHVzLFxuICAgICAgICAgICAgLyoqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBjbGllbnQgc2hvdWxkIGJlIHByb21wdGVkIHRvIGF1dGhlbnRpY2F0ZSB0aGVpciBhY2NvdW50LiAqL1xuICAgICAgICAgICAgc2hvdWxkX3Byb21wdF9jbGllbnRfdG9fYXV0aGVudGljYXRlOiBCb29sZWFuKFxuICAgICAgICAgICAgICAgIGdldF9hY2NvdW50X3N0YXR1c19kYXRhLmdldF9hY2NvdW50X3N0YXR1cy5wcm9tcHRfY2xpZW50X3RvX2F1dGhlbnRpY2F0ZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgfTtcbiAgICB9LCBbZ2V0X2FjY291bnRfc3RhdHVzX2RhdGE/LmdldF9hY2NvdW50X3N0YXR1c10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqIFRoZSBhY2NvdW50IHN0YXR1cyByZXNwb25zZS4gKi9cbiAgICAgICAgZGF0YTogbW9kaWZpZWRfYWNjb3VudF9zdGF0dXMsXG4gICAgICAgIC4uLnJlc3QsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUdldEFjY291bnRTdGF0dXM7XG4iLCJpbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZUdldEFjY291bnRTdGF0dXMgZnJvbSAnLi91c2VHZXRBY2NvdW50U3RhdHVzJztcblxuLyoqIEEgY3VzdG9tIGhvb2sgdG8gY2hlY2sgdGhlIGFjY291bnQgc3RhdHVzIGZvciB0aGUgY3VycmVudCB1c2VyLiAqL1xuY29uc3QgdXNlQWNjb3VudFN0YXR1cyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGRhdGE6IGdldF9hY2NvdW50X3N0YXR1c19kYXRhLCAuLi5yZXN0IH0gPSB1c2VHZXRBY2NvdW50U3RhdHVzKCk7XG5cbiAgICAvLyBBZGQgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0byB0aGUgYWNjb3VudCBzdGF0dXMgcmVzcG9uc2UuXG4gICAgY29uc3QgbW9kaWZpZWRfYWNjb3VudF9zdGF0dXMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFnZXRfYWNjb3VudF9zdGF0dXNfZGF0YT8uc3RhdHVzKSByZXR1cm47XG5cbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFNldChnZXRfYWNjb3VudF9zdGF0dXNfZGF0YT8uc3RhdHVzKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLyoqIEFjY291bnQgc3RhdHVzLiAqL1xuICAgICAgICAgICAgc3RhdHVzOiBnZXRfYWNjb3VudF9zdGF0dXNfZGF0YT8uc3RhdHVzLFxuICAgICAgICAgICAgLyoqIGNsaWVudCdzIGFkZHJlc3MgaXMgdmVyaWZpZWQgYnkgdGhpcmQgcGFydHkgc2VydmljZXMuICovXG4gICAgICAgICAgICBpc19hZGRyZXNzX3ZlcmlmaWVkOiBzdGF0dXMuaGFzKCdhZGRyZXNzX3ZlcmlmaWVkJyksXG4gICAgICAgICAgICAvKiogY2xpZW50IGlzIGFsbG93ZWQgdG8gdXBsb2FkIGRvY3VtZW50cy4gKi9cbiAgICAgICAgICAgIGlzX2FsbG93X2RvY3VtZW50X3VwbG9hZDogc3RhdHVzLmhhcygnYWxsb3dfZG9jdW1lbnRfdXBsb2FkJyksXG4gICAgICAgICAgICAvKiogY2xpZW50IGlzIGFnZS12ZXJpZmllZC4gKi9cbiAgICAgICAgICAgIGlzX2FnZV92ZXJpZmljYXRpb246IHN0YXR1cy5oYXMoJ2FnZV92ZXJpZmljYXRpb24nKSxcbiAgICAgICAgICAgIC8qKiBjbGllbnQgaXMgZnVsbHkgYXV0aGVudGljYXRlZC4gKi9cbiAgICAgICAgICAgIGlzX2F1dGhlbnRpY2F0ZWQ6IHN0YXR1cy5oYXMoJ2F1dGhlbnRpY2F0ZWQnKSxcbiAgICAgICAgICAgIC8qKiBjYXNoaWVyIGlzIGxvY2tlZC4gKi9cbiAgICAgICAgICAgIGlzX2Nhc2hpZXJfbG9ja2VkOiBzdGF0dXMuaGFzKCdjYXNoaWVyX2xvY2tlZCcpLFxuICAgICAgICAgICAgLyoqIGNsaWVudCBoYXMgdXBkYXRlZCB0YXggcmVsYXRlZCBpbmZvcm1hdGlvbi4gKi9cbiAgICAgICAgICAgIGlzX2Nyc190aW5faW5mb3JtYXRpb246IHN0YXR1cy5oYXMoJ2Nyc190aW5faW5mb3JtYXRpb24nKSxcbiAgICAgICAgICAgIC8qKiBkZXBvc2l0IGlzIG5vdCBhbGxvd2VkLiAqL1xuICAgICAgICAgICAgaXNfZGVwb3NpdF9sb2NrZWQ6IHN0YXR1cy5oYXMoJ2RlcG9zaXRfbG9ja2VkJyksXG4gICAgICAgICAgICAvKiogYWNjb3VudCBpcyBkaXNhYmxlZC4gKi9cbiAgICAgICAgICAgIGlzX2Rpc2FibGVkOiBzdGF0dXMuaGFzKCdkaXNhYmxlZCcpLFxuICAgICAgICAgICAgLyoqIGNsaWVudCdzIHN1Ym1pdHRlZCBwcm9vZi1vZi1pZGVudGl0eSBkb2N1bWVudHMgaGF2ZSBleHBpcmVkLiAqL1xuICAgICAgICAgICAgaXNfZG9jdW1lbnRfZXhwaXJlZDogc3RhdHVzLmhhcygnZG9jdW1lbnRfZXhwaXJlZCcpLFxuICAgICAgICAgICAgLyoqIGNsaWVudCdzIHN1Ym1pdHRlZCBwcm9vZi1vZi1pZGVudGl0eSBkb2N1bWVudHMgYXJlIGV4cGlyaW5nIHdpdGhpbiBhIG1vbnRoLiAqL1xuICAgICAgICAgICAgaXNfZG9jdW1lbnRfZXhwaXJpbmdfc29vbjogc3RhdHVzLmhhcygnZG9jdW1lbnRfZXhwaXJpbmdfc29vbicpLFxuICAgICAgICAgICAgLyoqIERlcml2IFggcGFzc3dvcmQgaXMgbm90IHNldC4gKi9cbiAgICAgICAgICAgIGlzX2R4dHJhZGVfcGFzc3dvcmRfbm90X3NldDogc3RhdHVzLmhhcygnZHh0cmFkZV9wYXNzd29yZF9ub3Rfc2V0JyksXG4gICAgICAgICAgICAvKiogY2xpZW50IHNob3VsZCBjb21wbGV0ZSB0aGVpciBmaW5hbmNpYWwgYXNzZXNzbWVudC4gKi9cbiAgICAgICAgICAgIGlzX2ZpbmFuY2lhbF9hc3Nlc3NtZW50X25vdF9jb21wbGV0ZTogc3RhdHVzLmhhcygnZmluYW5jaWFsX2Fzc2Vzc21lbnRfbm90X2NvbXBsZXRlJyksXG4gICAgICAgICAgICAvKiogY2xpZW50IGhhcyBub3QgY29tcGxldGVkIGZpbmFuY2lhbCBhc3Nlc3NtZW50LiAqL1xuICAgICAgICAgICAgaXNfZmluYW5jaWFsX2luZm9ybWF0aW9uX25vdF9jb21wbGV0ZTogc3RhdHVzLmhhcygnZmluYW5jaWFsX2luZm9ybWF0aW9uX25vdF9jb21wbGV0ZScpLFxuICAgICAgICAgICAgLyoqIGNsaWVudCBoYXMgYWNjZXB0ZWQgZmluYW5jaWFsIHJpc2sgZGlzY2xvc3VyZS4gKi9cbiAgICAgICAgICAgIGlzX2ZpbmFuY2lhbF9yaXNrX2FwcHJvdmFsOiBzdGF0dXMuaGFzKCdmaW5hbmNpYWxfcmlza19hcHByb3ZhbCcpLFxuICAgICAgICAgICAgLyoqIGNsaWVudCBoYXMgbm90IHNldCBmaW5hbmNpYWwgbGltaXRzIG9uIHRoZWlyIGFjY291bnQuIEFwcGxpZXMgdG8gVUsgYW5kIE1hbHRhIGNsaWVudHMuICovXG4gICAgICAgICAgICBpc19tYXhfdHVybm92ZXJfbGltaXRfbm90X3NldDogc3RhdHVzLmhhcygnbWF4X3R1cm5vdmVyX2xpbWl0X25vdF9zZXQnKSxcbiAgICAgICAgICAgIC8qKiBNVDUgcGFzc3dvcmQgaXMgbm90IHNldC4gKi9cbiAgICAgICAgICAgIGlzX210NV9wYXNzd29yZF9ub3Rfc2V0OiBzdGF0dXMuaGFzKCdtdDVfcGFzc3dvcmRfbm90X3NldCcpLFxuICAgICAgICAgICAgLyoqIE1UNSBkZXBvc2l0cyBhbGxvd2VkLCBidXQgd2l0aGRyYXdhbCBpcyBub3QgYWxsb3dlZC4gKi9cbiAgICAgICAgICAgIGlzX210NV93aXRoZHJhd2FsX2xvY2tlZDogc3RhdHVzLmhhcygnbXQ1X3dpdGhkcmF3YWxfbG9ja2VkJyksXG4gICAgICAgICAgICAvKiogdXNlciBtdXN0IGFwcHJvdmUgdGhlIEFmZmlsaWF0ZSdzIENvZGUgb2YgQ29uZHVjdCBBZ3JlZW1lbnQuICovXG4gICAgICAgICAgICBpc19uZWVkc19hZmZpbGlhdGVfY29jX2FwcHJvdmFsOiBzdGF0dXMuaGFzKCduZWVkc19hZmZpbGlhdGVfY29jX2FwcHJvdmFsJyksXG4gICAgICAgICAgICAvKiogdHJhZGluZyBpcyBkaXNhYmxlZC4gKi9cbiAgICAgICAgICAgIGlzX25vX3RyYWRpbmc6IHN0YXR1cy5oYXMoJ25vX3RyYWRpbmcnKSxcbiAgICAgICAgICAgIC8qKiBjbGllbnQgY2Fubm90IHRyYWRlIG9yIHdpdGhkcmF3IGJ1dCBjYW4gZGVwb3NpdC4gKi9cbiAgICAgICAgICAgIGlzX25vX3dpdGhkcmF3YWxfb3JfdHJhZGluZzogc3RhdHVzLmhhcygnbm9fd2l0aGRyYXdhbF9vcl90cmFkaW5nJyksXG4gICAgICAgICAgICAvKiogcDJwIGlzIGJsb2NrZWQgZm9yIHRoZSBjdXJyZW50IHBheW1lbnQgYWdlbnQgY2xpZW50LiAqL1xuICAgICAgICAgICAgaXNfcDJwX2Jsb2NrZWRfZm9yX3BhOiBzdGF0dXMuaGFzKCdwMnBfYmxvY2tlZF9mb3JfcGEnKSxcbiAgICAgICAgICAgIC8qKiB3aXRoZHJhd2FsIHRocm91Z2ggcGF5bWVudCBhZ2VudCBpcyBhbGxvd2VkLiAqL1xuICAgICAgICAgICAgaXNfcGFfd2l0aGRyYXdhbF9leHBsaWNpdGx5X2FsbG93ZWQ6IHN0YXR1cy5oYXMoJ3BhX3dpdGhkcmF3YWxfZXhwbGljaXRseV9hbGxvd2VkJyksXG4gICAgICAgICAgICAvKiogdGhpcyBjbGllbnQgbXVzdCByZXNldCB0aGVpciBwYXNzd29yZC4gKi9cbiAgICAgICAgICAgIGlzX3Bhc3N3b3JkX3Jlc2V0X3JlcXVpcmVkOiBzdGF0dXMuaGFzKCdwYXNzd29yZF9yZXNldF9yZXF1aXJlZCcpLFxuICAgICAgICAgICAgLyoqIHRoaXMgY2xpZW50IGhhcyBvcHRlZCBmb3IgYSBwcm9mZXNzaW9uYWwgYWNjb3VudC4gKi9cbiAgICAgICAgICAgIGlzX3Byb2Zlc3Npb25hbDogc3RhdHVzLmhhcygncHJvZmVzc2lvbmFsJyksXG4gICAgICAgICAgICAvKiogdGhpcyBjbGllbnQgaGFzIHJlcXVlc3RlZCBmb3IgYSBwcm9mZXNzaW9uYWwgYWNjb3VudC4gKi9cbiAgICAgICAgICAgIGlzX3Byb2Zlc3Npb25hbF9yZXF1ZXN0ZWQ6IHN0YXR1cy5oYXMoJ3Byb2Zlc3Npb25hbF9yZXF1ZXN0ZWQnKSxcbiAgICAgICAgICAgIC8qKiB0aGlzIGNsaWVudCdzIHJlcXVlc3QgZm9yIGEgcHJvZmVzc2lvbmFsIGFjY291bnQgaGFzIGJlZW4gcmVqZWN0ZWQuICovXG4gICAgICAgICAgICBpc19wcm9mZXNzaW9uYWxfcmVqZWN0ZWQ6IHN0YXR1cy5oYXMoJ3Byb2Zlc3Npb25hbF9yZWplY3RlZCcpLFxuICAgICAgICAgICAgLyoqIHRoaXMgY2xpZW50IGlzIHVzaW5nIHNvY2lhbCBzaWdudXAuICovXG4gICAgICAgICAgICBpc19zb2NpYWxfc2lnbnVwOiBzdGF0dXMuaGFzKCdzb2NpYWxfc2lnbnVwJyksXG4gICAgICAgICAgICAvKiogY2xpZW50IGhhcyBub3QgY29tcGxldGVkIHRoZSB0cmFkaW5nIGV4cGVyaWVuY2UgcXVlc3Rpb25uYWlyZS4gKi9cbiAgICAgICAgICAgIGlzX3RyYWRpbmdfZXhwZXJpZW5jZV9ub3RfY29tcGxldGU6IHN0YXR1cy5oYXMoJ3RyYWRpbmdfZXhwZXJpZW5jZV9ub3RfY29tcGxldGUnKSxcbiAgICAgICAgICAgIC8qKiBjbGllbnQgaGFzIGFja25vd2xlZGdlZCBVS0dDIGZ1bmRzIHByb3RlY3Rpb24gbm90aWNlLiAqL1xuICAgICAgICAgICAgaXNfdWtnY19mdW5kc19wcm90ZWN0aW9uOiBzdGF0dXMuaGFzKCd1a2djX2Z1bmRzX3Byb3RlY3Rpb24nKSxcbiAgICAgICAgICAgIC8qKiBjbGllbnQgY2Fubm90IGRlcG9zaXQgb3IgYnV5IGNvbnRyYWN0cywgYnV0IGNhbiB3aXRoZHJhdyBvciBzZWxsIGNvbnRyYWN0cy4gKi9cbiAgICAgICAgICAgIGlzX3Vud2VsY29tZTogc3RhdHVzLmhhcygndW53ZWxjb21lJyksXG4gICAgICAgICAgICAvKiogZGVwb3NpdHMgYWxsb3dlZCBidXQgd2l0aGRyYXdhbHMgYXJlIG5vdCBhbGxvd2VkLiAqL1xuICAgICAgICAgICAgaXNfd2l0aGRyYXdhbF9sb2NrZWQ6IHN0YXR1cy5oYXMoJ3dpdGhkcmF3YWxfbG9ja2VkJyksXG4gICAgICAgICAgICAvKiogdGhpcyBwcmV2ZW50IGEgY2xpZW50IGZyb20gY2hhbmdpbmcgdGhlIGFjY291bnQgY3VycmVuY3kgYWZ0ZXIgZGVwb3NpdCBhdHRlbXB0LiAqL1xuICAgICAgICAgICAgaXNfZGVwb3NpdF9hdHRlbXB0OiBzdGF0dXMuaGFzKCdkZXBvc2l0X2F0dGVtcHQnKSxcbiAgICAgICAgICAgIC8qKiBjbGllbnQgUE9JIGRvY3VtZW50cyBuYW1lIG1pc21hdGNoLiAqL1xuICAgICAgICAgICAgaXNfcG9pX25hbWVfbWlzbWF0Y2g6IHN0YXR1cy5oYXMoJ3BvaV9uYW1lX21pc21hdGNoJyksXG4gICAgICAgICAgICAvKiogdGhlIGNsaWVudCBjYW4gcmVzdWJtaXQgUE9BIGRvY3VtZW50cy4gKi9cbiAgICAgICAgICAgIGlzX2FsbG93X3BvYV9yZXN1Ym1pc3Npb246IHN0YXR1cy5oYXMoJ2FsbG93X3BvYV9yZXN1Ym1pc3Npb24nKSxcbiAgICAgICAgICAgIC8qKiB0aGUgY2xpZW50IGNhbiByZXN1Ym1pdCBQT0kgZG9jdW1lbnRzLiAqL1xuICAgICAgICAgICAgaXNfYWxsb3dfcG9pX3Jlc3VibWlzc2lvbjogc3RhdHVzLmhhcygnYWxsb3dfcG9pX3Jlc3VibWlzc2lvbicpLFxuICAgICAgICAgICAgLyoqIHRoZSBjbGllbnQgaGFzIGJlZW4gc2hhcmluZyBwYXltZW50IG1ldGhvZHMuICovXG4gICAgICAgICAgICBpc19zaGFyZWRfcGF5bWVudF9tZXRob2Q6IHN0YXR1cy5oYXMoJ3NoYXJlZF9wYXltZW50X21ldGhvZCcpLFxuICAgICAgICAgICAgLyoqIGNsaWVudCBpcyBub3QgYWxsb3dlZCB0byBlZGl0IHBlcnNvbmFsIHByb2ZpbGUgZGV0YWlscy4gKi9cbiAgICAgICAgICAgIGlzX3BlcnNvbmFsX2RldGFpbHNfbG9ja2VkOiBzdGF0dXMuaGFzKCdwZXJzb25hbF9kZXRhaWxzX2xvY2tlZCcpLFxuICAgICAgICAgICAgLyoqIGl0IGJsb2NrIGFueSB0cmFuc2ZlciBiZXR3ZWVuIHR3byBhY2NvdW50cy4gKi9cbiAgICAgICAgICAgIGlzX3RyYW5zZmVyc19ibG9ja2VkOiBzdGF0dXMuaGFzKCd0cmFuc2ZlcnNfYmxvY2tlZCcpLFxuICAgICAgICAgICAgLyoqIHRoZSBERiBkZXBvc2l0IHdpbGwgYmUgYmxvY2tlZCB1bnRpbCB0aGUgY2xpZW50IGdldHMgYWdlIHZlcmlmaWVkLiAqL1xuICAgICAgICAgICAgaXNfZGZfZGVwb3NpdF9yZXF1aXJlc19wb2k6IHN0YXR1cy5oYXMoJ2RmX2RlcG9zaXRfcmVxdWlyZXNfcG9pJyksXG4gICAgICAgICAgICAvKiogdGhlIGNsaWVudCBoYXMgYmVlbiBmdWxseSBhdXRoZW50aWNhdGVkIGJ5IElEVi4gKi9cbiAgICAgICAgICAgIGlzX2F1dGhlbnRpY2F0ZWRfd2l0aF9pZHZfcGhvdG9pZDogc3RhdHVzLmhhcygnYXV0aGVudGljYXRlZF93aXRoX2lkdl9waG90b2lkJyksXG4gICAgICAgICAgICAvKiogdGhlIGNsaWVudCB1c2VkIHRvIGJlIGZ1bGx5IGF1dGhlbnRpY2F0ZWQgYnkgSURWIGJ1dCBpdCB3YXMgdGFrZW4gYXdheSBkdWUgdG8gY29tcGxpYW5jZSBjcml0ZXJpYS4gKi9cbiAgICAgICAgICAgIGlzX2lkdl9yZXZva2VkOiBzdGF0dXMuaGFzKCdpZHZfcmV2b2tlZCcpLFxuICAgICAgICB9O1xuICAgIH0sIFtnZXRfYWNjb3VudF9zdGF0dXNfZGF0YT8uc3RhdHVzXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKiogVGhlIGFjY291bnQgc3RhdHVzIHJlc3BvbnNlLiAqL1xuICAgICAgICBkYXRhOiBtb2RpZmllZF9hY2NvdW50X3N0YXR1cyxcbiAgICAgICAgLi4ucmVzdCxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlQWNjb3VudFN0YXR1cztcbiIsImltcG9ydCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlUXVlcnkgZnJvbSAnLi4vdXNlUXVlcnknO1xuXG4vKiogQSBjdXN0b20gaG9vayB0byBnZXQgYXZhaWxhYmxlIGFjY291bnQgdHlwZXMgZm9yIGEgc3BlY2lmaWMgbGFuZGluZyBjb21wYW55LiAqL1xuY29uc3QgdXNlQWNjb3VudFR5cGVzID0gKGxhbmRpbmdfY29tcGFueT86IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHsgZGF0YSwgLi4ucmVzdCB9ID0gdXNlUXVlcnkoJ2dldF9hY2NvdW50X3R5cGVzJywge1xuICAgICAgICBwYXlsb2FkOiB7IGNvbXBhbnk6IGxhbmRpbmdfY29tcGFueSB9LFxuICAgICAgICBvcHRpb25zOiB7IGVuYWJsZWQ6IEJvb2xlYW4obGFuZGluZ19jb21wYW55KSB9LFxuICAgIH0pO1xuXG4gICAgLy8gQWRkIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gdGhlIGFjY291bnQgdHlwZXMgcmVzcG9uc2UuXG4gICAgY29uc3QgbW9kaWZpZWRfYWNjb3VudF90eXBlcyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoIWRhdGE/LmdldF9hY2NvdW50X3R5cGVzKSByZXR1cm47XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmRhdGEuZ2V0X2FjY291bnRfdHlwZXMsXG4gICAgICAgICAgICAvKiogTGFuZGluZyBjb21wYW55IGZvciB0aGUgYWNjb3VudCB0eXBlcyAqL1xuICAgICAgICAgICAgbGFuZGluZ19jb21wYW55LFxuICAgICAgICB9O1xuICAgIH0sIFtkYXRhPy5nZXRfYWNjb3VudF90eXBlcywgbGFuZGluZ19jb21wYW55XSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKiogVGhlIGFjY291bnQgdHlwZXMgcmVzcG9uc2UuICovXG4gICAgICAgIGRhdGE6IG1vZGlmaWVkX2FjY291bnRfdHlwZXMsXG4gICAgICAgIC4uLnJlc3QsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUFjY291bnRUeXBlcztcbiIsImltcG9ydCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlUXVlcnkgZnJvbSAnLi4vdXNlUXVlcnknO1xuaW1wb3J0IHVzZUF1dGhvcml6ZSBmcm9tICcuL3VzZUF1dGhvcml6ZSc7XG5cbi8qKiBBIGN1c3RvbSBob29rIHRoYXQgZ2V0cyB0aGUgYmFsYW5jZSBmb3IgYWxsIHRoZSB1c2VyIGFjY291bnRzLiAqL1xuY29uc3QgdXNlQmFsYW5jZSA9ICgpID0+IHtcbiAgICBjb25zdCB7IGlzU3VjY2VzcyB9ID0gdXNlQXV0aG9yaXplKCk7XG4gICAgY29uc3QgeyBkYXRhOiBiYWxhbmNlX2RhdGEsIC4uLnJlc3QgfSA9IHVzZVF1ZXJ5KCdiYWxhbmNlJywge1xuICAgICAgICBwYXlsb2FkOiB7IGFjY291bnQ6ICdhbGwnIH0sXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGlzU3VjY2VzcyxcbiAgICAgICAgICAgIHJlZmV0Y2hJbnRlcnZhbDogMzAwMDAsIC8vIFJlZmV0Y2ggZXZlcnkgMzAgc2Vjb25kcyB0byBzaW11bGF0ZSBzdWJzY3JpcHRpb24uXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0byB0aGUgYmFsYW5jZSBkYXRhLlxuICAgIGNvbnN0IG1vZGlmaWVkX2JhbGFuY2UgPSB1c2VNZW1vKCgpID0+ICh7IC4uLmJhbGFuY2VfZGF0YT8uYmFsYW5jZSB9KSwgW2JhbGFuY2VfZGF0YT8uYmFsYW5jZV0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqIFRoZSBiYWxhbmNlIHJlc3BvbnNlLiAqL1xuICAgICAgICBkYXRhOiBtb2RpZmllZF9iYWxhbmNlLFxuICAgICAgICAuLi5yZXN0LFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VCYWxhbmNlO1xuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlUXVlcnkgZnJvbSAnLi4vdXNlUXVlcnknO1xuXG4vKiogQSBjdXN0b20gaG9vayB0byBnZXQgdGhlIGN1cnJlbmN5IGNvbmZpZyBpbmZvcm1hdGlvbiBmcm9tIGB3ZWJzaXRlX3N0YXR1c2AgZW5kcG9pbnQgYW5kIGBjcnlwdG9fY29uZmlnYCBlbmRwb2ludC4gKi9cbmNvbnN0IHVzZUN1cnJlbmN5Q29uZmlnID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgZGF0YTogd2Vic2l0ZV9zdGF0dXNfZGF0YSwgLi4ucmVzdCB9ID0gdXNlUXVlcnkoJ3dlYnNpdGVfc3RhdHVzJyk7XG4gICAgY29uc3QgeyBkYXRhOiBjcnlwdG9fY29uZmlnX2RhdGEgfSA9IHVzZVF1ZXJ5KCdjcnlwdG9fY29uZmlnJyk7XG5cbiAgICAvLyBBZGQgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0byB0aGUgY3VycmVuY3kgY29uZmlnLlxuICAgIGNvbnN0IG1vZGlmaWVkX2N1cnJlbmNpZXNfY29uZmlnID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghd2Vic2l0ZV9zdGF0dXNfZGF0YT8ud2Vic2l0ZV9zdGF0dXM/LmN1cnJlbmNpZXNfY29uZmlnKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgICAgIGNvbnN0IHdlYnNpdGVfc3RhdHVzX2N1cnJlbmNpZXNfY29uZmlnID0gd2Vic2l0ZV9zdGF0dXNfZGF0YS53ZWJzaXRlX3N0YXR1cy5jdXJyZW5jaWVzX2NvbmZpZztcblxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMod2Vic2l0ZV9zdGF0dXNfY3VycmVuY2llc19jb25maWcpLm1hcChjdXJyZW5jeSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW5jeV9jb25maWcgPSB3ZWJzaXRlX3N0YXR1c19jdXJyZW5jaWVzX2NvbmZpZ1tjdXJyZW5jeV07XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY3VycmVuY3lfY29uZmlnLFxuICAgICAgICAgICAgICAgIC8qKiBkZXRlcm1pbmUgaWYgdGhlIGN1cnJlbmN5IGlzIGEgYGNyeXB0b2AgY3VycmVuY3kgKi9cbiAgICAgICAgICAgICAgICBpc19jcnlwdG86IGN1cnJlbmN5X2NvbmZpZz8udHlwZSA9PT0gJ2NyeXB0bycsXG4gICAgICAgICAgICAgICAgLyoqIGRldGVybWluZSBpZiB0aGUgY3VycmVuY3kgaXMgYSBgZmlhdGAgY3VycmVuY3kgKi9cbiAgICAgICAgICAgICAgICBpc19maWF0OiBjdXJyZW5jeV9jb25maWc/LnR5cGUgPT09ICdmaWF0JyxcbiAgICAgICAgICAgICAgICAvKiogZGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW5jeSBpcyBgQXVzdHJhbGlhbiBEb2xsYXJgICovXG4gICAgICAgICAgICAgICAgaXNfQVVEOiBjdXJyZW5jeSA9PT0gJ0FVRCcsXG4gICAgICAgICAgICAgICAgLyoqIGRldGVybWluZSBpZiB0aGUgY3VycmVuY3kgaXMgYFVTIERvbGxhcmAgKi9cbiAgICAgICAgICAgICAgICBpc19VU0Q6IGN1cnJlbmN5ID09PSAnVVNEJyxcbiAgICAgICAgICAgICAgICAvKiogZGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW5jeSBpcyBgRXVyb2AgKi9cbiAgICAgICAgICAgICAgICBpc19FVVI6IGN1cnJlbmN5ID09PSAnRVVSJyxcbiAgICAgICAgICAgICAgICAvKiogZGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW5jeSBpcyBgUG91bmQgU3RlcmxpbmdgICovXG4gICAgICAgICAgICAgICAgaXNfR0JQOiBjdXJyZW5jeSA9PT0gJ0dCUCcsXG4gICAgICAgICAgICAgICAgLyoqIGRldGVybWluZSBpZiB0aGUgY3VycmVuY3kgaXMgYEJpdGNvaW5gICovXG4gICAgICAgICAgICAgICAgaXNfQlRDOiBjdXJyZW5jeSA9PT0gJ0JUQycsXG4gICAgICAgICAgICAgICAgLyoqIGRldGVybWluZSBpZiB0aGUgY3VycmVuY3kgaXMgYEV0aGVyZXVtYCAqL1xuICAgICAgICAgICAgICAgIGlzX0VUSDogY3VycmVuY3kgPT09ICdFVEgnLFxuICAgICAgICAgICAgICAgIC8qKiBkZXRlcm1pbmUgaWYgdGhlIGN1cnJlbmN5IGlzIGBMaXRlY29pbmAgKi9cbiAgICAgICAgICAgICAgICBpc19MVEM6IGN1cnJlbmN5ID09PSAnTFRDJyxcbiAgICAgICAgICAgICAgICAvKiogZGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW5jeSBpcyBgTXVsdGktQ29sbGF0ZXJhbCBEQUlgICovXG4gICAgICAgICAgICAgICAgaXNfREFJOiBjdXJyZW5jeSA9PT0gJ0RBSScsXG4gICAgICAgICAgICAgICAgLyoqIGRldGVybWluZSBpZiB0aGUgY3VycmVuY3kgaXMgYElES2AgKi9cbiAgICAgICAgICAgICAgICBpc19JREs6IGN1cnJlbmN5ID09PSAnSURLJyxcbiAgICAgICAgICAgICAgICAvKiogZGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW5jeSBpcyBgUGF4b3MgU3RhbmRhcmRgICovXG4gICAgICAgICAgICAgICAgaXNfUEFYOiBjdXJyZW5jeSA9PT0gJ1BBWCcsXG4gICAgICAgICAgICAgICAgLyoqIGRldGVybWluZSBpZiB0aGUgY3VycmVuY3kgaXMgYEJpbmFyeSBDb2luYCAqL1xuICAgICAgICAgICAgICAgIGlzX1VTQjogY3VycmVuY3kgPT09ICdVU0InLFxuICAgICAgICAgICAgICAgIC8qKiBkZXRlcm1pbmUgaWYgdGhlIGN1cnJlbmN5IGlzIGBUZXRoZXIgT21uaWAgKi9cbiAgICAgICAgICAgICAgICBpc19VU0RUOiBjdXJyZW5jeSA9PT0gJ1VTVCcsXG4gICAgICAgICAgICAgICAgLyoqIGRldGVybWluZSBpZiB0aGUgY3VycmVuY3kgaXMgYFRydWUgVVNEYCAqL1xuICAgICAgICAgICAgICAgIGlzX1RVU0Q6IGN1cnJlbmN5ID09PSAnVFVTRCcsXG4gICAgICAgICAgICAgICAgLyoqIGRldGVybWluZSBpZiB0aGUgY3VycmVuY3kgaXMgYEJpbmFuY2UgVVNEYCAqL1xuICAgICAgICAgICAgICAgIGlzX0JVU0Q6IGN1cnJlbmN5ID09PSAnQlVTRCcsXG4gICAgICAgICAgICAgICAgLyoqIGRldGVybWluZSBpZiB0aGUgY3VycmVuY3kgaXMgYFNUQVRJUyBFdXJvYCAqL1xuICAgICAgICAgICAgICAgIGlzX0VVUlM6IGN1cnJlbmN5ID09PSAnRVVSUycsXG4gICAgICAgICAgICAgICAgLyoqIGRldGVybWluZSBpZiB0aGUgY3VycmVuY3kgaXMgYFRldGhlciBFUkMyMGAgKi9cbiAgICAgICAgICAgICAgICBpc19lVVNEVDogY3VycmVuY3kgPT09ICdlVVNEVCcsXG4gICAgICAgICAgICAgICAgLyoqIGRldGVybWluZSBpZiB0aGUgY3VycmVuY3kgaXMgYFRldGhlciBUUkMyMGAgKi9cbiAgICAgICAgICAgICAgICBpc190VVNEVDogY3VycmVuY3kgPT09ICd0VVNEVCcsXG4gICAgICAgICAgICAgICAgLyoqIGRldGVybWluZSBpZiB0aGUgY3VycmVuY3kgaXMgYFVTRCBDb2luYCAqL1xuICAgICAgICAgICAgICAgIGlzX1VTREM6IGN1cnJlbmN5ID09PSAnVVNEQycsXG4gICAgICAgICAgICAgICAgLyoqIGRldGVybWluZSBpZiB0aGUgY3VycmVuY3kgaXMgYFVTREtgICovXG4gICAgICAgICAgICAgICAgaXNfVVNESzogY3VycmVuY3kgPT09ICdVU0RLJyxcbiAgICAgICAgICAgICAgICAvKiogQ3VycmVuY3kgY29kZSAqL1xuICAgICAgICAgICAgICAgIGNvZGU6IGN1cnJlbmN5LFxuICAgICAgICAgICAgICAgIC8qKiBDdXJyZW5jeSBkaXNwbGF5IGNvZGUgKi9cbiAgICAgICAgICAgICAgICBkaXNwbGF5X2NvZGU6IGN1cnJlbmN5ID09PSAnVVNUJyA/ICdVU0RUJyA6IGN1cnJlbmN5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSwgW3dlYnNpdGVfc3RhdHVzX2RhdGE/LndlYnNpdGVfc3RhdHVzPy5jdXJyZW5jaWVzX2NvbmZpZ10pO1xuXG4gICAgLy8gQWRkIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gdGhlIGNyeXB0byBjb25maWcuXG4gICAgY29uc3QgbW9kaWZpZWRfY3J5cHRvX2NvbmZpZyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gbW9kaWZpZWRfY3VycmVuY2llc19jb25maWc/Lm1hcChjdXJyZW5jeV9jb25maWcgPT4gKHtcbiAgICAgICAgICAgIC4uLmN1cnJlbmN5X2NvbmZpZyxcbiAgICAgICAgICAgIC4uLmNyeXB0b19jb25maWdfZGF0YT8uY3J5cHRvX2NvbmZpZz8uY3VycmVuY2llc19jb25maWdbY3VycmVuY3lfY29uZmlnLmNvZGVdLFxuICAgICAgICB9KSk7XG4gICAgfSwgW2NyeXB0b19jb25maWdfZGF0YT8uY3J5cHRvX2NvbmZpZz8uY3VycmVuY2llc19jb25maWcsIG1vZGlmaWVkX2N1cnJlbmNpZXNfY29uZmlnXSk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gdGhlIGN1cnJlbmN5IGNvbmZpZyBhcnJheSBpbnRvIGEgcmVjb3JkIG9iamVjdC5cbiAgICBjb25zdCB0cmFuc2Zvcm1lZF9jdXJyZW5jaWVzX2NvbmZpZyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gbW9kaWZpZWRfY3J5cHRvX2NvbmZpZz8ucmVkdWNlPFJlY29yZDxzdHJpbmcsIHR5cGVvZiBtb2RpZmllZF9jcnlwdG9fY29uZmlnW251bWJlcl0+PihcbiAgICAgICAgICAgIChwcmV2aW91cywgY3VycmVudCkgPT4gKHsgLi4ucHJldmlvdXMsIFtjdXJyZW50LmNvZGVdOiBjdXJyZW50IH0pLFxuICAgICAgICAgICAge31cbiAgICAgICAgKTtcbiAgICB9LCBbbW9kaWZpZWRfY3J5cHRvX2NvbmZpZ10pO1xuXG4gICAgY29uc3QgZ2V0Q29uZmlnID0gdXNlQ2FsbGJhY2soXG4gICAgICAgIChjdXJyZW5jeTogc3RyaW5nKSA9PiB0cmFuc2Zvcm1lZF9jdXJyZW5jaWVzX2NvbmZpZz8uW2N1cnJlbmN5XSxcbiAgICAgICAgW3RyYW5zZm9ybWVkX2N1cnJlbmNpZXNfY29uZmlnXVxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKiogQXZhaWxhYmxlIGN1cnJlbmNpZXMgYW5kIHRoZWlyIGluZm9ybWF0aW9uICovXG4gICAgICAgIGRhdGE6IHRyYW5zZm9ybWVkX2N1cnJlbmNpZXNfY29uZmlnLFxuICAgICAgICAvKiogUmV0dXJucyB0aGUgY3VycmVuY3kgY29uZmlnIG9iamVjdCBmb3IgdGhlIGdpdmVuIGN1cnJlbmN5ICovXG4gICAgICAgIGdldENvbmZpZyxcbiAgICAgICAgLi4ucmVzdCxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlQ3VycmVuY3lDb25maWc7XG4iLCJpbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZUF1dGhvcml6ZSBmcm9tICcuL3VzZUF1dGhvcml6ZSc7XG5pbXBvcnQgdXNlQmFsYW5jZSBmcm9tICcuL3VzZUJhbGFuY2UnO1xuaW1wb3J0IHVzZUN1cnJlbmN5Q29uZmlnIGZyb20gJy4vdXNlQ3VycmVuY3lDb25maWcnO1xuXG4vKiogQSBjdXN0b20gaG9vayB0aGF0IHJldHVybnMgdGhlIGxpc3Qgb2YgYWNjb3VudHMgZm9yIHRoZSBjdXJyZW50IHVzZXIuICovXG5jb25zdCB1c2VBY2NvdW50c0xpc3QgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBkYXRhOiBhdXRob3JpemVfZGF0YSwgLi4ucmVzdCB9ID0gdXNlQXV0aG9yaXplKCk7XG4gICAgY29uc3QgeyBkYXRhOiBiYWxhbmNlX2RhdGEgfSA9IHVzZUJhbGFuY2UoKTtcbiAgICBjb25zdCB7IGdldENvbmZpZyB9ID0gdXNlQ3VycmVuY3lDb25maWcoKTtcblxuICAgIC8vIEFkZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHRvIHRoZSBhdXRob3JpemUgcmVzcG9uc2UuXG4gICAgY29uc3QgbW9kaWZpZWRfYWNjb3VudHMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGF1dGhvcml6ZV9kYXRhLmFjY291bnRfbGlzdD8ubWFwKGFjY291bnQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5hY2NvdW50LFxuICAgICAgICAgICAgICAgIC8qKiBDcmVhdGlvbiB0aW1lIG9mIHRoZSBhY2NvdW50LiAqL1xuICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IGFjY291bnQuY3JlYXRlZF9hdCA/IG5ldyBEYXRlKGFjY291bnQuY3JlYXRlZF9hdCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgLyoqIERhdGUgdGlsbCBjbGllbnQgaGFzIGV4Y2x1ZGVkIGhpbS9oZXJzZWxmIGZyb20gdGhlIHdlYnNpdGUsIG9ubHkgcHJlc2VudCBpZiBjbGllbnQgaXMgc2VsZiBleGNsdWRlZC4gKi9cbiAgICAgICAgICAgICAgICBleGNsdWRlZF91bnRpbDogYWNjb3VudC5leGNsdWRlZF91bnRpbCA/IG5ldyBEYXRlKGFjY291bnQuZXhjbHVkZWRfdW50aWwpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIC8qKiBJbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHdhbGxldCBpcyB0aGUgY3VycmVudGx5IGFjdGl2ZSBhY2NvdW50LiAqL1xuICAgICAgICAgICAgICAgIGlzX2FjdGl2ZTogYWNjb3VudC5sb2dpbmlkID09PSBhdXRob3JpemVfZGF0YS5sb2dpbmlkLFxuICAgICAgICAgICAgICAgIC8qKiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGFjY291bnQgaXMgYSB2aXJ0dWFsLW1vbmV5IGFjY291bnQuICovXG4gICAgICAgICAgICAgICAgaXNfdmlydHVhbDogQm9vbGVhbihhY2NvdW50LmlzX3ZpcnR1YWwpLFxuICAgICAgICAgICAgICAgIC8qKiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGFjY291bnQgaXMgbWFya2VkIGFzIGRpc2FibGVkIG9yIG5vdC4gKi9cbiAgICAgICAgICAgICAgICBpc19kaXNhYmxlZDogQm9vbGVhbihhY2NvdW50LmlzX2Rpc2FibGVkKSxcbiAgICAgICAgICAgICAgICAvKiogaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBhY2NvdW50IGlzIGEgdHJhZGluZyBhY2NvdW50LiAqL1xuICAgICAgICAgICAgICAgIGlzX3RyYWRpbmc6IGFjY291bnQuYWNjb3VudF9jYXRlZ29yeSA9PT0gJ3RyYWRpbmcnLFxuICAgICAgICAgICAgICAgIC8qKiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGFjY291bnQgaXMgYSB3YWxsZXQgYWNjb3VudC4gKi9cbiAgICAgICAgICAgICAgICBpc193YWxsZXQ6IGFjY291bnQuYWNjb3VudF9jYXRlZ29yeSA9PT0gJ3dhbGxldCcsXG4gICAgICAgICAgICAgICAgLyoqIFRoZSBhY2NvdW50IElEIG9mIHNwZWNpZmllZCBhY2NvdW50LiAqL1xuICAgICAgICAgICAgICAgIGxvZ2luaWQ6IGAke2FjY291bnQubG9naW5pZH1gLFxuICAgICAgICAgICAgICAgIC8qKiBBY2NvdW50J3MgY3VycmVuY3kgY29uZmlnIGluZm9ybWF0aW9uICovXG4gICAgICAgICAgICAgICAgY3VycmVuY3lfY29uZmlnOiBhY2NvdW50LmN1cnJlbmN5ID8gZ2V0Q29uZmlnKGFjY291bnQuY3VycmVuY3kpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSBhcyBjb25zdDtcbiAgICAgICAgfSk7XG4gICAgfSwgW2F1dGhvcml6ZV9kYXRhLmFjY291bnRfbGlzdCwgYXV0aG9yaXplX2RhdGEubG9naW5pZCwgZ2V0Q29uZmlnXSk7XG5cbiAgICAvLyBBZGQgYmFsYW5jZSB0byBlYWNoIGFjY291bnRcbiAgICBjb25zdCBtb2RpZmllZF9hY2NvdW50c193aXRoX2JhbGFuY2UgPSB1c2VNZW1vKFxuICAgICAgICAoKSA9PlxuICAgICAgICAgICAgbW9kaWZpZWRfYWNjb3VudHM/Lm1hcChhY2NvdW50ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYWxhbmNlID0gYmFsYW5jZV9kYXRhPy5hY2NvdW50cz8uW2FjY291bnQubG9naW5pZF0/LmJhbGFuY2UgfHwgMDtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmFjY291bnQsXG4gICAgICAgICAgICAgICAgICAgIC8qKiBUaGUgYmFsYW5jZSBvZiB0aGUgYWNjb3VudC4gKi9cbiAgICAgICAgICAgICAgICAgICAgYmFsYW5jZSxcbiAgICAgICAgICAgICAgICAgICAgLyoqIFRoZSBiYWxhbmNlIG9mIHRoZSBhY2NvdW50IGluIGN1cnJlbmN5IGZvcm1hdC4gKi9cbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheV9iYWxhbmNlOiBgJHtJbnRsLk51bWJlckZvcm1hdChhdXRob3JpemVfZGF0YT8ucHJlZmVycmVkX2xhbmd1YWdlIHx8ICdlbi1VUycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogYWNjb3VudC5jdXJyZW5jeV9jb25maWc/LmZyYWN0aW9uYWxfZGlnaXRzIHx8IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IGFjY291bnQuY3VycmVuY3lfY29uZmlnPy5mcmFjdGlvbmFsX2RpZ2l0cyB8fCAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bUludGVnZXJEaWdpdHM6IDEsXG4gICAgICAgICAgICAgICAgICAgIH0pLmZvcm1hdChiYWxhbmNlKX0gJHthY2NvdW50LmN1cnJlbmN5X2NvbmZpZz8uZGlzcGxheV9jb2RlIHx8ICdVU0QnfWAsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBbYmFsYW5jZV9kYXRhPy5hY2NvdW50cywgbW9kaWZpZWRfYWNjb3VudHMsIGF1dGhvcml6ZV9kYXRhPy5wcmVmZXJyZWRfbGFuZ3VhZ2VdXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKiBUaGUgbGlzdCBvZiBhY2NvdW50cyBmb3IgdGhlIGN1cnJlbnQgdXNlci4gKi9cbiAgICAgICAgZGF0YTogbW9kaWZpZWRfYWNjb3VudHNfd2l0aF9iYWxhbmNlLFxuICAgICAgICAuLi5yZXN0LFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VBY2NvdW50c0xpc3Q7XG4iLCJpbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZUFjY291bnRzTGlzdCBmcm9tICcuL3VzZUFjY291bnRzTGlzdCc7XG5cbi8qKiBBIGN1c3RvbSBob29rIHRoYXQgcmV0dXJucyB0aGUgYWNjb3VudCBvYmplY3QgZm9yIHRoZSBjdXJyZW50IGFjdGl2ZSBhY2NvdW50LiAqL1xuY29uc3QgdXNlQWN0aXZlQWNjb3VudCA9ICgpID0+IHtcbiAgICBjb25zdCB7IGRhdGEsIC4uLnJlc3QgfSA9IHVzZUFjY291bnRzTGlzdCgpO1xuICAgIGNvbnN0IGFjdGl2ZV9hY2NvdW50ID0gdXNlTWVtbygoKSA9PiBkYXRhPy5maW5kKGFjY291bnQgPT4gYWNjb3VudC5pc19hY3RpdmUpLCBbZGF0YV0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqIFVzZXIncyBjdXJyZW50IGFjdGl2ZSBhY2NvdW50LiAqL1xuICAgICAgICBkYXRhOiBhY3RpdmVfYWNjb3VudCxcbiAgICAgICAgLi4ucmVzdCxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlQWN0aXZlQWNjb3VudDtcbiIsImltcG9ydCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlQWNjb3VudHNMaXN0IGZyb20gJy4vdXNlQWNjb3VudHNMaXN0JztcblxuLyoqIEEgY3VzdG9tIGhvb2sgdGhhdCBnZXRzIHRoZSBsaXN0IG9mIGFsbCB0cmFkaW5nIGFjY291bnRzIGZvciB0aGUgY3VycmVudCB1c2VyLiAqL1xuY29uc3QgdXNlVHJhZGluZ0FjY291bnRzTGlzdCA9ICgpID0+IHtcbiAgICBjb25zdCB7IGRhdGE6IGFjY291bnRfbGlzdF9kYXRhLCAuLi5yZXN0IH0gPSB1c2VBY2NvdW50c0xpc3QoKTtcblxuICAgIC8vIEZpbHRlciBvdXQgbm9uLXRyYWRpbmcgYWNjb3VudHMuXG4gICAgY29uc3QgZmlsdGVyZWRfYWNjb3VudHMgPSB1c2VNZW1vKFxuICAgICAgICAoKSA9PiBhY2NvdW50X2xpc3RfZGF0YT8uZmlsdGVyKGFjY291bnQgPT4gYWNjb3VudC5pc190cmFkaW5nKSxcbiAgICAgICAgW2FjY291bnRfbGlzdF9kYXRhXVxuICAgICk7XG5cbiAgICAvLyBBZGQgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0byBlYWNoIHRyYWRpbmcgYWNjb3VudC5cbiAgICBjb25zdCBtb2RpZmllZF9hY2NvdW50cyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gZmlsdGVyZWRfYWNjb3VudHM/Lm1hcCh0cmFkaW5nID0+ICh7IC4uLnRyYWRpbmcgfSkpO1xuICAgIH0sIFtmaWx0ZXJlZF9hY2NvdW50c10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqIFRoZSBsaXN0IG9mIHRyYWRpbmcgYWNjb3VudHMgZm9yIHRoZSBjdXJyZW50IHVzZXIuICovXG4gICAgICAgIGRhdGE6IG1vZGlmaWVkX2FjY291bnRzLFxuICAgICAgICAuLi5yZXN0LFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VUcmFkaW5nQWNjb3VudHNMaXN0O1xuIiwiaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VUcmFkaW5nQWNjb3VudHNMaXN0IGZyb20gJy4vdXNlVHJhZGluZ0FjY291bnRzTGlzdCc7XG5cbi8qKiBBIGN1c3RvbSBob29rIHRoYXQgcmV0dXJucyB0aGUgdHJhZGluZyBvYmplY3QgZm9yIHRoZSBjdXJyZW50IGFjdGl2ZSB0cmFkaW5nLiAqL1xuY29uc3QgdXNlQWN0aXZlVHJhZGluZ0FjY291bnQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBkYXRhLCAuLi5yZXN0IH0gPSB1c2VUcmFkaW5nQWNjb3VudHNMaXN0KCk7XG4gICAgY29uc3QgYWN0aXZlX3RyYWRpbmcgPSB1c2VNZW1vKCgpID0+IGRhdGE/LmZpbmQodHJhZGluZyA9PiB0cmFkaW5nLmlzX2FjdGl2ZSksIFtkYXRhXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKiogVXNlcidzIGN1cnJlbnQgYWN0aXZlIHRyYWRpbmcuICovXG4gICAgICAgIGRhdGE6IGFjdGl2ZV90cmFkaW5nLFxuICAgICAgICAuLi5yZXN0LFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VBY3RpdmVUcmFkaW5nQWNjb3VudDtcbiIsImltcG9ydCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlQWNjb3VudHNMaXN0IGZyb20gJy4vdXNlQWNjb3VudHNMaXN0JztcblxuLyoqIEEgY3VzdG9tIGhvb2sgdGhhdCBnZXRzIHRoZSBsaXN0IG9mIGFsbCB3YWxsZXQgYWNjb3VudHMgZm9yIHRoZSBjdXJyZW50IHVzZXIuICovXG5jb25zdCB1c2VXYWxsZXRBY2NvdW50c0xpc3QgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBkYXRhOiBhY2NvdW50X2xpc3RfZGF0YSwgLi4ucmVzdCB9ID0gdXNlQWNjb3VudHNMaXN0KCk7XG5cbiAgICAvLyBGaWx0ZXIgb3V0IG5vbi13YWxsZXQgYWNjb3VudHMuXG4gICAgY29uc3QgZmlsdGVyZWRfYWNjb3VudHMgPSB1c2VNZW1vKFxuICAgICAgICAoKSA9PiBhY2NvdW50X2xpc3RfZGF0YT8uZmlsdGVyKGFjY291bnQgPT4gYWNjb3VudC5pc193YWxsZXQpLFxuICAgICAgICBbYWNjb3VudF9saXN0X2RhdGFdXG4gICAgKTtcblxuICAgIC8vIEFkZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHRvIGVhY2ggd2FsbGV0IGFjY291bnQuXG4gICAgY29uc3QgbW9kaWZpZWRfYWNjb3VudHMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkX2FjY291bnRzPy5tYXAod2FsbGV0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHdhbGxldF9jdXJyZW5jeV90eXBlID0gd2FsbGV0LmlzX3ZpcnR1YWwgPyAnRGVtbycgOiB3YWxsZXQuY3VycmVuY3kgfHwgJyc7XG4gICAgICAgICAgICBjb25zdCBkdHJhZGVfbG9naW5pZCA9IHdhbGxldC5saW5rZWRfdG8/LmZpbmQoYWNjb3VudCA9PiBhY2NvdW50LnBsYXRmb3JtID09PSAnZHRyYWRlJyk/LmxvZ2luaWQ7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4ud2FsbGV0LFxuICAgICAgICAgICAgICAgIC8qKiBSZXR1cm5zIHRoZSB3YWxsZXQncyBjdXJyZW5jeSB0eXBlLiBleDogYERlbW9gLCBgVVNEYCwgZXRjLiAqL1xuICAgICAgICAgICAgICAgIHdhbGxldF9jdXJyZW5jeV90eXBlLFxuICAgICAgICAgICAgICAgIC8qKiBMYW5kaW5nIGNvbXBhbnkgc2hvcnRjb2RlIHRoZSBhY2NvdW50IGJlbG9uZ3MgdG8uICovXG4gICAgICAgICAgICAgICAgbGFuZGluZ19jb21wYW55X25hbWU6IHdhbGxldC5sYW5kaW5nX2NvbXBhbnlfbmFtZT8ucmVwbGFjZSgnbWFsdGFpbnZlc3QnLCAnbWFsdGEnKSxcbiAgICAgICAgICAgICAgICAvKiogSW5kaWNhdGluZyB3aGV0aGVyIHRoZSB3YWxsZXQgaXMgYSBtYWx0YWludmVzdCB3YWxsZXQuICovXG4gICAgICAgICAgICAgICAgaXNfbWFsdGFfd2FsbGV0OiB3YWxsZXQubGFuZGluZ19jb21wYW55X25hbWUgPT09ICdtYWx0YScsXG4gICAgICAgICAgICAgICAgLyoqIFRoZSBEVHJhZGUgYWNjb3VudCBJRCBvZiB0aGlzIHdhbGxldCAqL1xuICAgICAgICAgICAgICAgIGR0cmFkZV9sb2dpbmlkLFxuICAgICAgICAgICAgICAgIC8qKiBSZXR1cm5zIGlmIHRoZSB3YWxsZXQgaXMgYSBjcnlwdG8gd2FsbGV0LiAqL1xuICAgICAgICAgICAgICAgIGlzX2NyeXB0bzogd2FsbGV0LmN1cnJlbmN5X2NvbmZpZz8uaXNfY3J5cHRvLFxuICAgICAgICAgICAgfSBhcyBjb25zdDtcbiAgICAgICAgfSk7XG4gICAgfSwgW2ZpbHRlcmVkX2FjY291bnRzXSk7XG5cbiAgICAvLyBTb3J0IHdhbGxldCBhY2NvdW50cyBhbHBoYWJldGljYWxseSBieSBmaWF0LCBjcnlwdG8sIHRoZW4gdmlydHVhbC5cbiAgICBjb25zdCBzb3J0ZWRfYWNjb3VudHMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFtb2RpZmllZF9hY2NvdW50cykgcmV0dXJuO1xuXG4gICAgICAgIHJldHVybiBbLi4ubW9kaWZpZWRfYWNjb3VudHNdLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGlmIChhLmlzX3ZpcnR1YWwgIT09IGIuaXNfdmlydHVhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmlzX3ZpcnR1YWwgPyAxIDogLTE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGEuY3VycmVuY3lfY29uZmlnPy5pc19jcnlwdG8gIT09IGIuY3VycmVuY3lfY29uZmlnPy5pc19jcnlwdG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5jdXJyZW5jeV9jb25maWc/LmlzX2NyeXB0byA/IDEgOiAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIChhLmN1cnJlbmN5IHx8ICdVU0QnKS5sb2NhbGVDb21wYXJlKGIuY3VycmVuY3kgfHwgJ1VTRCcpO1xuICAgICAgICB9KTtcbiAgICB9LCBbbW9kaWZpZWRfYWNjb3VudHNdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKiBUaGUgbGlzdCBvZiB3YWxsZXQgYWNjb3VudHMgZm9yIHRoZSBjdXJyZW50IHVzZXIuICovXG4gICAgICAgIGRhdGE6IHNvcnRlZF9hY2NvdW50cyxcbiAgICAgICAgLi4ucmVzdCxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlV2FsbGV0QWNjb3VudHNMaXN0O1xuIiwiaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VXYWxsZXRBY2NvdW50c0xpc3QgZnJvbSAnLi91c2VXYWxsZXRBY2NvdW50c0xpc3QnO1xuXG4vKiogQSBjdXN0b20gaG9vayB0aGF0IHJldHVybnMgdGhlIHdhbGxldCBvYmplY3QgZm9yIHRoZSBjdXJyZW50IGFjdGl2ZSB3YWxsZXQuICovXG5jb25zdCB1c2VBY3RpdmVXYWxsZXRBY2NvdW50ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgZGF0YSwgLi4ucmVzdCB9ID0gdXNlV2FsbGV0QWNjb3VudHNMaXN0KCk7XG4gICAgY29uc3QgYWN0aXZlX3dhbGxldCA9IHVzZU1lbW8oKCkgPT4gZGF0YT8uZmluZCh3YWxsZXQgPT4gd2FsbGV0LmlzX2FjdGl2ZSksIFtkYXRhXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKiogVXNlcidzIGN1cnJlbnQgYWN0aXZlIHdhbGxldC4gKi9cbiAgICAgICAgZGF0YTogYWN0aXZlX3dhbGxldCxcbiAgICAgICAgLi4ucmVzdCxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlQWN0aXZlV2FsbGV0QWNjb3VudDtcbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZVF1ZXJ5IGZyb20gJy4uL3VzZVF1ZXJ5JztcbmltcG9ydCB1c2VJbnZhbGlkYXRlUXVlcnkgZnJvbSAnLi4vdXNlSW52YWxpZGF0ZVF1ZXJ5JztcbmltcG9ydCB1c2VNdXRhdGlvbiBmcm9tICcuLi91c2VNdXRhdGlvbic7XG5cbnR5cGUgVFNldFNldHRpbmdzUGF5bG9hZCA9IE5vbk51bGxhYmxlPFxuICAgIE5vbk51bGxhYmxlPE5vbk51bGxhYmxlPFBhcmFtZXRlcnM8UmV0dXJuVHlwZTx0eXBlb2YgdXNlTXV0YXRpb248J3NldF9zZXR0aW5ncyc+PlsnbXV0YXRlJ10+PlswXT5bJ3BheWxvYWQnXVxuPjtcblxuLyoqIEEgY3VzdG9tIGhvb2sgdG8gZ2V0IGFuZCB1cGRhdGUgdGhlIHVzZXIgc2V0dGluZ3MuICovXG5jb25zdCB1c2VTZXR0aW5ncyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGRhdGEsIC4uLnJlc3QgfSA9IHVzZVF1ZXJ5KCdnZXRfc2V0dGluZ3MnKTtcbiAgICBjb25zdCB7IG11dGF0ZSwgLi4ubXV0YXRlX3Jlc3QgfSA9IHVzZU11dGF0aW9uKCdzZXRfc2V0dGluZ3MnLCB7IG9uU3VjY2VzczogKCkgPT4gaW52YWxpZGF0ZSgnZ2V0X3NldHRpbmdzJykgfSk7XG4gICAgY29uc3QgaW52YWxpZGF0ZSA9IHVzZUludmFsaWRhdGVRdWVyeSgpO1xuXG4gICAgY29uc3QgdXBkYXRlID0gdXNlQ2FsbGJhY2soKHBheWxvYWQ6IFRTZXRTZXR0aW5nc1BheWxvYWQpID0+IG11dGF0ZSh7IHBheWxvYWQgfSksIFttdXRhdGVdKTtcblxuICAgIC8vIEFkZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHRvIHRoZSBzZXR0aW5ncyByZXNwb25zZS5cbiAgICBjb25zdCBtb2RpZmllZF9zZXR0aW5ncyA9IHVzZU1lbW8oKCkgPT4gKHsgLi4uZGF0YT8uZ2V0X3NldHRpbmdzIH0pLCBbZGF0YT8uZ2V0X3NldHRpbmdzXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKiogVGhlIHNldHRpbmdzIHJlc3BvbnNlLiAqL1xuICAgICAgICBkYXRhOiBtb2RpZmllZF9zZXR0aW5ncyxcbiAgICAgICAgLyoqIEZ1bmN0aW9uIHRvIHVwZGF0ZSB1c2VyIHNldHRpbmdzICovXG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgLyoqIFRoZSBtdXRhdGlvbiByZWxhdGVkIGluZm9ybWF0aW9uICovXG4gICAgICAgIG11dGF0aW9uOiBtdXRhdGVfcmVzdCxcbiAgICAgICAgLi4ucmVzdCxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlU2V0dGluZ3M7XG4iLCJpbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZVF1ZXJ5IGZyb20gJy4uL3VzZVF1ZXJ5JztcbmltcG9ydCB1c2VTZXR0aW5ncyBmcm9tICcuL3VzZVNldHRpbmdzJztcblxuLyoqIEEgY3VzdG9tIGhvb2sgdGhhdCByZXR1cm5zIHRoZSBhdmFpbGFibGUgbGFuZGluZyBjb21wYW5pZXMgb2YgdGhlIHVzZXIncyBjb3VudHJ5LiAqL1xuY29uc3QgdXNlTGFuZGluZ0NvbXBhbnkgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBkYXRhOiBzZXR0aW5nc19kYXRhIH0gPSB1c2VTZXR0aW5ncygpO1xuICAgIGNvbnN0IHsgZGF0YSwgLi4ucmVzdCB9ID0gdXNlUXVlcnkoJ2xhbmRpbmdfY29tcGFueScsIHtcbiAgICAgICAgcGF5bG9hZDogeyBsYW5kaW5nX2NvbXBhbnk6IHNldHRpbmdzX2RhdGE/LmNvdW50cnlfY29kZSB8fCAnJyB9LFxuICAgICAgICBvcHRpb25zOiB7IGVuYWJsZWQ6IEJvb2xlYW4oc2V0dGluZ3NfZGF0YT8uY291bnRyeV9jb2RlKSB9LFxuICAgIH0pO1xuXG4gICAgLy8gQWRkIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gdGhlIGxhbmRpbmcgY29tcGFueSByZXNwb25zZS5cbiAgICBjb25zdCBtb2RpZmllZF9sYW5kaW5nX2NvbXBhbnkgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFkYXRhPy5sYW5kaW5nX2NvbXBhbnkpIHJldHVybjtcblxuICAgICAgICByZXR1cm4geyAuLi5kYXRhLmxhbmRpbmdfY29tcGFueSB9O1xuICAgIH0sIFtkYXRhPy5sYW5kaW5nX2NvbXBhbnldKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKiBUaGUgbGFuZGluZyBjb21wYW55IHJlc3BvbnNlLiAqL1xuICAgICAgICBkYXRhOiBtb2RpZmllZF9sYW5kaW5nX2NvbXBhbnksXG4gICAgICAgIC4uLnJlc3QsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUxhbmRpbmdDb21wYW55O1xuIiwiaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VBY2NvdW50VHlwZXMgZnJvbSAnLi91c2VBY2NvdW50VHlwZXMnO1xuaW1wb3J0IHVzZUxhbmRpbmdDb21wYW55IGZyb20gJy4vdXNlTGFuZGluZ0NvbXBhbnknO1xuXG4vKiogQSBjdXN0b20gaG9vayB0byBnZXQgYWxsIGF2YWlsYWJsZSBhY2NvdW50cyB0aGF0IHVzZXIgY2FuIGhhdmUuICovXG5jb25zdCB1c2VBbGxBdmFpbGFibGVBY2NvdW50cyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGRhdGE6IGxhbmRpbmdfY29tcGFueV9kYXRhIH0gPSB1c2VMYW5kaW5nQ29tcGFueSgpO1xuICAgIGNvbnN0IHsgZGF0YTogYWNjb3VudF90eXBlc19kYXRhLCAuLi5yZXN0IH0gPSB1c2VBY2NvdW50VHlwZXMobGFuZGluZ19jb21wYW55X2RhdGE/LmZpbmFuY2lhbF9jb21wYW55Py5zaG9ydGNvZGUpO1xuXG4gICAgLy8gQWRkIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gdGhlIGFjY291bnQgdHlwZXMgcmVzcG9uc2UuXG4gICAgY29uc3QgbW9kaWZpZWRfYWNjb3VudF90eXBlc19kYXRhID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghYWNjb3VudF90eXBlc19kYXRhKSByZXR1cm47XG5cbiAgICAgICAgcmV0dXJuIHsgLi4uYWNjb3VudF90eXBlc19kYXRhIH07XG4gICAgfSwgW2FjY291bnRfdHlwZXNfZGF0YV0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqIFRoZSBhY2NvdW50IHR5cGVzIHJlc3BvbnNlLiAqL1xuICAgICAgICBkYXRhOiBtb2RpZmllZF9hY2NvdW50X3R5cGVzX2RhdGEsXG4gICAgICAgIC4uLnJlc3QsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUFsbEF2YWlsYWJsZUFjY291bnRzO1xuIiwiaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VHZXRBY2NvdW50U3RhdHVzIGZyb20gJy4vdXNlR2V0QWNjb3VudFN0YXR1cyc7XG5cbi8qKiBBIGN1c3RvbSBob29rIHRvIGdldCB0aGUgdmVyaWZpY2F0aW9uIHN0YXR1cyAoYmFzaWNhbGx5IGFueSBwb2ksIHBvYSwgcG9pbmMsIHBvbykgb2YgdGhlIGN1cnJlbnQgdXNlci4gKi9cbmNvbnN0IHVzZUF1dGhlbnRpY2F0aW9uID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgZGF0YTogZ2V0X2FjY291bnRfc3RhdHVzX2RhdGEsIC4uLnJlc3QgfSA9IHVzZUdldEFjY291bnRTdGF0dXMoKTtcblxuICAgIGNvbnN0IG1vZGlmaWVkX2FjY291bnRfc3RhdHVzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghZ2V0X2FjY291bnRfc3RhdHVzX2RhdGEpIHJldHVybjtcblxuICAgICAgICBjb25zdCBuZWVkc192ZXJpZmljYXRpb24gPSBuZXcgU2V0KGdldF9hY2NvdW50X3N0YXR1c19kYXRhLmF1dGhlbnRpY2F0aW9uPy5uZWVkc192ZXJpZmljYXRpb24pO1xuICAgICAgICBjb25zdCBhY2NvdW50X3N0YXR1cyA9IG5ldyBTZXQoZ2V0X2FjY291bnRfc3RhdHVzX2RhdGE/LnN0YXR1cyk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmdldF9hY2NvdW50X3N0YXR1c19kYXRhLmF1dGhlbnRpY2F0aW9uLFxuICAgICAgICAgICAgLyoqIGNsaWVudCBpcyByZXF1aXJlZCB0byB2ZXJpZnkgdGhlaXIgZG9jdW1lbnQgKHByb29mIG9mIGFkZHJlc3MpICovXG4gICAgICAgICAgICBpc19wb2FfbmVlZGVkOiBuZWVkc192ZXJpZmljYXRpb24uaGFzKCdkb2N1bWVudCcpLFxuICAgICAgICAgICAgLyoqIGNsaWVudCBpcyByZXF1aXJlZCB0byB2ZXJpZnkgdGhlaXIgaWRlbnRpdHkgKi9cbiAgICAgICAgICAgIGlzX3BvaV9uZWVkZWQ6IG5lZWRzX3ZlcmlmaWNhdGlvbi5oYXMoJ2lkZW50aXR5JyksXG4gICAgICAgICAgICAvKiogY2xpZW50IGhhcyBiZWVuIGFnZS12ZXJpZmllZCAqL1xuICAgICAgICAgICAgaXNfYWdlX3ZlcmlmaWVkOiBhY2NvdW50X3N0YXR1cy5oYXMoJ2FnZV92ZXJpZmljYXRpb24nKSxcbiAgICAgICAgICAgIC8qKiBjbGllbnQgaXMgcHJldmVudGVkIGZyb20gdmVyaWZ5aW5nIGZyb20gaWR2ICovXG4gICAgICAgICAgICBpc19pZHZfZGlzYWxsb3dlZDogYWNjb3VudF9zdGF0dXMuaGFzKCdpZHZfZGlzYWxsb3dlZCcpLFxuICAgICAgICAgICAgLyoqIGNsaWVudCBpcyBhbGxvd2VkIHRvIHBlcmZvcm0gUE9JIGFuZCBQT0EgKGFsbG93IHVwbG9hZGluZyBkb2N1bWVudHMpICovXG4gICAgICAgICAgICBpc19hbGxvd19kb2N1bWVudF91cGxvYWQ6IGFjY291bnRfc3RhdHVzLmhhcygnaXNfYWxsb3dfZG9jdW1lbnRfdXBsb2FkJyksXG4gICAgICAgICAgICAvKiogY2xpZW50IGNhbiByZXN1Ym1pdCBQT0kgZG9jdW1lbnRzICovXG4gICAgICAgICAgICBpc19wb2lfcmVzdWJtaXNzaW9uX2FsbG93ZWQ6IGFjY291bnRfc3RhdHVzLmhhcygnYWxsb3dfcG9pX3Jlc3VibWlzc2lvbicpLFxuICAgICAgICAgICAgLyoqIGNsaWVudCBjYW4gcmVzdWJtaXQgUE9BIGRvY3VtZW50cyAqL1xuICAgICAgICAgICAgaXNfcG9hX3Jlc3VibWlzc2lvbl9hbGxvd2VkOiBhY2NvdW50X3N0YXR1cy5oYXMoJ2FsbG93X3BvYV9yZXN1Ym1pc3Npb24nKSxcbiAgICAgICAgICAgIC8qKiBjbGllbnQncyBuYW1lIGluIFBPSSBkb2N1bWVudHMgZG9lcyBub3QgbWF0Y2ggKi9cbiAgICAgICAgICAgIGlzX3BvaV9uYW1lX21pc21hdGNoOiBhY2NvdW50X3N0YXR1cy5oYXMoJ3BvaV9uYW1lX21pc21hdGNoJyksXG4gICAgICAgICAgICAvKiogY2xpZW50J3MgbmFtZSBpbiBQT0EgZG9jdW1lbnRzIGRvZXMgbm90IG1hdGNoICovXG4gICAgICAgICAgICBpc19wb2FfYWRkcmVzc19taXNtYXRjaDogYWNjb3VudF9zdGF0dXMuaGFzKCdwb2FfYWRkcmVzc19taXNtYXRjaCcpLFxuICAgICAgICAgICAgLyoqIGNsaWVudCBoYXMgYXR0ZW1wdGVkIFBPSSBiZWZvcmUgKi9cbiAgICAgICAgICAgIGhhc19wb2FfYmVlbl9hdHRlbXB0ZWQ6IGdldF9hY2NvdW50X3N0YXR1c19kYXRhPy5hdXRoZW50aWNhdGlvbj8uZG9jdW1lbnQ/LnN0YXR1cyAhPT0gJ25vbmUnLFxuICAgICAgICAgICAgLyoqIGNsaWVudCBoYXMgYXR0ZW1wdGVkIFBPQSBiZWZvcmUgKi9cbiAgICAgICAgICAgIGhhc19wb2lfYmVlbl9hdHRlbXB0ZWQ6IGdldF9hY2NvdW50X3N0YXR1c19kYXRhPy5hdXRoZW50aWNhdGlvbj8uaWRlbnRpdHk/LnN0YXR1cyAhPT0gJ25vbmUnLFxuICAgICAgICAgICAgLyoqIGNsaWVudCdzIHBvaSB2ZXJpZmljYXRpb24gc3RhdHVzICovXG4gICAgICAgICAgICBwb2lfc3RhdHVzOiBnZXRfYWNjb3VudF9zdGF0dXNfZGF0YT8uYXV0aGVudGljYXRpb24/LmlkZW50aXR5Py5zdGF0dXMsXG4gICAgICAgICAgICAvKiogY2xpZW50J3MgcG9hIHZlcmlmaWNhdGlvbiBzdGF0dXMgKi9cbiAgICAgICAgICAgIHBvYV9zdGF0dXM6IGdldF9hY2NvdW50X3N0YXR1c19kYXRhPy5hdXRoZW50aWNhdGlvbj8uZG9jdW1lbnQ/LnN0YXR1cyxcbiAgICAgICAgfTtcbiAgICB9LCBbZ2V0X2FjY291bnRfc3RhdHVzX2RhdGFdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IG1vZGlmaWVkX2FjY291bnRfc3RhdHVzLFxuICAgICAgICAuLi5yZXN0LFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VBdXRoZW50aWNhdGlvbjtcbiIsImltcG9ydCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlUXVlcnkgZnJvbSAnLi4vdXNlUXVlcnknO1xuaW1wb3J0IHVzZUF1dGhvcml6ZSBmcm9tICcuL3VzZUF1dGhvcml6ZSc7XG5cbmNvbnN0IG1hcmtldF90eXBlX3RvX2xldmVyYWdlX21hcHBlcjogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHtcbiAgICBnYW1pbmc6IDUwMCxcbiAgICBmaW5hbmNpYWw6IDEwMDAsXG4gICAgYWxsOiAxMDAsXG59O1xuXG4vKiogQSBjdXN0b20gaG9vayB0byBnZXQgdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIE1UNSBhY2NvdW50cy4gKi9cbmNvbnN0IHVzZUF2YWlsYWJsZU1UNUFjY291bnRzID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgaXNTdWNjZXNzIH0gPSB1c2VBdXRob3JpemUoKTtcbiAgICBjb25zdCB7IGRhdGE6IG10NV9hdmFpbGFibGVfYWNjb3VudHMsIC4uLnJlc3QgfSA9IHVzZVF1ZXJ5KCd0cmFkaW5nX3BsYXRmb3JtX2F2YWlsYWJsZV9hY2NvdW50cycsIHtcbiAgICAgICAgcGF5bG9hZDogeyBwbGF0Zm9ybTogJ210NScgfSxcbiAgICAgICAgb3B0aW9uczogeyBlbmFibGVkOiBpc1N1Y2Nlc3MgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IG1vZGlmaWVkX210NV9hdmFpbGFibGVfYWNjb3VudHMgPSB1c2VNZW1vKFxuICAgICAgICAoKSA9PlxuICAgICAgICAgICAgbXQ1X2F2YWlsYWJsZV9hY2NvdW50cz8udHJhZGluZ19wbGF0Zm9ybV9hdmFpbGFibGVfYWNjb3VudHM/Lm1hcChhY2NvdW50ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5hY2NvdW50LFxuICAgICAgICAgICAgICAgICAgICAvKiogVGhlIG1hcmtldCB0eXBlIGZvciB0aGUgYWNjb3VudCAqL1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXRfdHlwZTogYWNjb3VudC5tYXJrZXRfdHlwZSA9PT0gJ2dhbWluZycgPyAnc3ludGhldGljJyA6IGFjY291bnQubWFya2V0X3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIC8qKiBUaGUgcGxhdGZvcm0gZm9yIHRoZSBhY2NvdW50ICovXG4gICAgICAgICAgICAgICAgICAgIHBsYXRmb3JtOiAnbXQ1JyxcbiAgICAgICAgICAgICAgICAgICAgLyoqIExldmVyYWdlIGZvciB0aGUgYWNjb3VudCAqL1xuICAgICAgICAgICAgICAgICAgICBsZXZlcmFnZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtldF90eXBlX3RvX2xldmVyYWdlX21hcHBlcltcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50Lm1hcmtldF90eXBlIGFzIGtleW9mIHR5cGVvZiBtYXJrZXRfdHlwZV90b19sZXZlcmFnZV9tYXBwZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSBhcyBjb25zdDtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBbbXQ1X2F2YWlsYWJsZV9hY2NvdW50cz8udHJhZGluZ19wbGF0Zm9ybV9hdmFpbGFibGVfYWNjb3VudHNdXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKiBUaGUgYXZhaWxhYmxlIE1UNSBhY2NvdW50cyAqL1xuICAgICAgICBkYXRhOiBtb2RpZmllZF9tdDVfYXZhaWxhYmxlX2FjY291bnRzLFxuICAgICAgICAuLi5yZXN0LFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VBdmFpbGFibGVNVDVBY2NvdW50cztcbiIsImltcG9ydCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlQWxsQXZhaWxhYmxlQWNjb3VudHMgZnJvbSAnLi91c2VBbGxBdmFpbGFibGVBY2NvdW50cyc7XG5pbXBvcnQgdXNlQ3VycmVuY3lDb25maWcgZnJvbSAnLi91c2VDdXJyZW5jeUNvbmZpZyc7XG5pbXBvcnQgdXNlV2FsbGV0QWNjb3VudHNMaXN0IGZyb20gJy4vdXNlV2FsbGV0QWNjb3VudHNMaXN0JztcblxuLyoqIEEgY3VzdG9tIGhvb2sgdGhhdCBnZXRzIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSB3YWxsZXRzLiAqL1xuY29uc3QgdXNlQXZhaWxhYmxlV2FsbGV0cyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGRhdGE6IGFjY291bnRfdHlwZV9kYXRhLCAuLi5yZXN0IH0gPSB1c2VBbGxBdmFpbGFibGVBY2NvdW50cygpO1xuICAgIGNvbnN0IHsgZGF0YTogYWRkZWRfd2FsbGV0cyB9ID0gdXNlV2FsbGV0QWNjb3VudHNMaXN0KCk7XG4gICAgY29uc3QgeyBnZXRDb25maWcgfSA9IHVzZUN1cnJlbmN5Q29uZmlnKCk7XG5cbiAgICAvKiogR2V0IHRoZSBhdmFpbGFibGUgd2FsbGV0cyBmb3IgdGhlIHdhbGxldCBhY2NvdW50IHR5cGUgKi9cbiAgICBjb25zdCBtb2RpZmllZF9hdmFpbGFibGVfd2FsbGV0cyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoIWFjY291bnRfdHlwZV9kYXRhKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgY3J5cHRvLCBkb3VnaGZsb3cgfSA9IGFjY291bnRfdHlwZV9kYXRhPy53YWxsZXQgfHwge307XG4gICAgICAgIGNvbnN0IGNyeXB0b19jdXJyZW5jaWVzID0gY3J5cHRvPy5jdXJyZW5jaWVzO1xuICAgICAgICBjb25zdCBmaWF0X2N1cnJlbmNpZXMgPSBkb3VnaGZsb3c/LmN1cnJlbmNpZXM7XG5cbiAgICAgICAgaWYgKCFjcnlwdG9fY3VycmVuY2llcyB8fCAhZmlhdF9jdXJyZW5jaWVzKSByZXR1cm4gW107XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZV9jdXJyZW5jaWVzID0gWy4uLmZpYXRfY3VycmVuY2llcywgLi4uY3J5cHRvX2N1cnJlbmNpZXNdO1xuICAgICAgICBjb25zdCBub25fdmlydHVhbF93YWxsZXRzID0gYWRkZWRfd2FsbGV0cz8uZmlsdGVyKHdhbGxldCA9PiAhd2FsbGV0LmlzX3ZpcnR1YWwpO1xuXG4gICAgICAgIC8qKiBDb21wYXJlIHRoZSBhdmFpbGFibGUgd2FsbGV0cyB3aXRoIHRoZSBhZGRlZCB3YWxsZXRzIGFuZCBhZGQgYGlzX2FkZGVkYCBmbGFnICovXG4gICAgICAgIGNvbnN0IG1vZGlmaWVkX3dhbGxldHMgPSBub25fdmlydHVhbF93YWxsZXRzPy5tYXAod2FsbGV0ID0+ICh7XG4gICAgICAgICAgICBjdXJyZW5jeTogd2FsbGV0LmN1cnJlbmN5LFxuICAgICAgICAgICAgbGFuZGluZ19jb21wYW55X25hbWU6IHdhbGxldC5sYW5kaW5nX2NvbXBhbnlfbmFtZSxcbiAgICAgICAgICAgIGlzX2FkZGVkOiB0cnVlLFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgLyoqIENvbXBhcmUgdGhlIGF2YWlsYWJsZSB3YWxsZXRzIHdpdGggdGhlIGFkZGVkIHdhbGxldHMgYW5kIGFkZCBgaXNfYWRkZWRgIGZsYWcgKi9cbiAgICAgICAgY29uc3QgYXZhaWxhYmxlX3dhbGxldHMgPSBhdmFpbGFibGVfY3VycmVuY2llc1xuICAgICAgICAgICAgLmZpbHRlcihjdXJyZW5jeSA9PiAhbW9kaWZpZWRfd2FsbGV0cz8uc29tZSh3YWxsZXQgPT4gd2FsbGV0LmN1cnJlbmN5ID09PSBjdXJyZW5jeSkpXG4gICAgICAgICAgICAubWFwKGN1cnJlbmN5ID0+ICh7XG4gICAgICAgICAgICAgICAgY3VycmVuY3ksXG4gICAgICAgICAgICAgICAgbGFuZGluZ19jb21wYW55X25hbWU6IGFjY291bnRfdHlwZV9kYXRhPy5sYW5kaW5nX2NvbXBhbnksXG4gICAgICAgICAgICAgICAgaXNfYWRkZWQ6IGZhbHNlLFxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIHJldHVybiBbLi4uYXZhaWxhYmxlX3dhbGxldHMsIC4uLihtb2RpZmllZF93YWxsZXRzIHx8IFtdKV07XG4gICAgfSwgW2FjY291bnRfdHlwZV9kYXRhLCBhZGRlZF93YWxsZXRzXSk7XG5cbiAgICAvKiogU29ydCB0aGUgYXZhaWxhYmxlIHdhbGxldHMgYnkgZmlhdCwgY3J5cHRvLCB0aGVuIHZpcnR1YWwgKi9cbiAgICBjb25zdCBzb3J0ZWRfYXZhaWxhYmxlX3dhbGxldHMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFtb2RpZmllZF9hdmFpbGFibGVfd2FsbGV0cykgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IGdldENvbmZpZ0lzQ3J5cHRvID0gKGN1cnJlbmN5OiBzdHJpbmcpID0+IGdldENvbmZpZyhjdXJyZW5jeSk/LmlzX2NyeXB0bztcblxuICAgICAgICAvLyBTb3J0IHRoZSBub24tYWRkZWQgd2FsbGV0cyBhbHBoYWJldGljYWxseSBieSBmaWF0LCBjcnlwdG8sIHRoZW4gdmlydHVhbFxuICAgICAgICBtb2RpZmllZF9hdmFpbGFibGVfd2FsbGV0cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhX2NvbmZpZyA9IGdldENvbmZpZ0lzQ3J5cHRvKGEuY3VycmVuY3kgfHwgJ0JUQycpO1xuICAgICAgICAgICAgY29uc3QgYl9jb25maWcgPSBnZXRDb25maWdJc0NyeXB0byhiLmN1cnJlbmN5IHx8ICdCVEMnKTtcblxuICAgICAgICAgICAgaWYgKGFfY29uZmlnICE9PSBiX2NvbmZpZykgcmV0dXJuIGEuY3VycmVuY3kgPyAxIDogLTE7XG5cbiAgICAgICAgICAgIHJldHVybiAoYS5jdXJyZW5jeSB8fCAnVVNEJykubG9jYWxlQ29tcGFyZShiLmN1cnJlbmN5IHx8ICdVU0QnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU29ydCB0aGUgYWRkZWQgd2FsbGV0cyBhbHBoYWJldGljYWxseSBieSBmaWF0LCBjcnlwdG8sIHRoZW4gdmlydHVhbCAoaWYgYW55KVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtb2RpZmllZF9hdmFpbGFibGVfd2FsbGV0cykpIHtcbiAgICAgICAgICAgIG1vZGlmaWVkX2F2YWlsYWJsZV93YWxsZXRzPy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYV9jb25maWcgPSBnZXRDb25maWdJc0NyeXB0byhhLmN1cnJlbmN5IHx8ICdCVEMnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiX2NvbmZpZyA9IGdldENvbmZpZ0lzQ3J5cHRvKGIuY3VycmVuY3kgfHwgJ0JUQycpO1xuICAgICAgICAgICAgICAgIGlmIChhX2NvbmZpZyAhPT0gYl9jb25maWcpIHJldHVybiBhX2NvbmZpZyA/IDEgOiAtMTtcblxuICAgICAgICAgICAgICAgIHJldHVybiAoYS5jdXJyZW5jeSB8fCAnVVNEJykubG9jYWxlQ29tcGFyZShiLmN1cnJlbmN5IHx8ICdVU0QnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFsuLi5tb2RpZmllZF9hdmFpbGFibGVfd2FsbGV0c107XG4gICAgfSwgW21vZGlmaWVkX2F2YWlsYWJsZV93YWxsZXRzLCBnZXRDb25maWddKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKiBTb3J0ZWQgYXZhaWxhYmxlIHdhbGxldHMgKi9cbiAgICAgICAgZGF0YTogc29ydGVkX2F2YWlsYWJsZV93YWxsZXRzLFxuICAgICAgICAuLi5yZXN0LFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VBdmFpbGFibGVXYWxsZXRzO1xuIiwiaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VRdWVyeSBmcm9tICcuLi91c2VRdWVyeSc7XG5pbXBvcnQgdXNlQWN0aXZlV2FsbGV0QWNjb3VudCBmcm9tICcuL3VzZUFjdGl2ZVdhbGxldEFjY291bnQnO1xuaW1wb3J0IHVzZUF1dGhvcml6ZSBmcm9tICcuL3VzZUF1dGhvcml6ZSc7XG5cbi8qKiBBIGN1c3RvbSBob29rIHRoYXQgZ2V0cyB0aGUgbGlzdCBjcmVhdGVkIE1UNSBhY2NvdW50cyBvZiB0aGUgdXNlci4gKi9cbmNvbnN0IHVzZU1UNUFjY291bnRzTGlzdCA9ICgpID0+IHtcbiAgICBjb25zdCB7IGRhdGE6IGF1dGhvcml6ZV9kYXRhLCBpc1N1Y2Nlc3MgfSA9IHVzZUF1dGhvcml6ZSgpO1xuICAgIGNvbnN0IHsgZGF0YTogd2FsbGV0IH0gPSB1c2VBY3RpdmVXYWxsZXRBY2NvdW50KCk7XG5cbiAgICBjb25zdCB7IGRhdGE6IG10NV9hY2NvdW50cywgLi4ubXQ1X2FjY291bnRzX3Jlc3QgfSA9IHVzZVF1ZXJ5KCdtdDVfbG9naW5fbGlzdCcsIHtcbiAgICAgICAgb3B0aW9uczogeyBlbmFibGVkOiBpc1N1Y2Nlc3MgfSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgbGlzdCBvZiBjcmVhdGVkIE1UNSBhY2NvdW50c1xuICAgICAqL1xuICAgIGNvbnN0IG1vZGlmaWVkX210NV9hY2NvdW50cyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICAvKiogQWRkaW5nIHRoZSBuZWNjZXNhcnkgcHJvcGVydGllcyB0byB0aGUgcmVzcG9uc2UgKi9cbiAgICAgICAgY29uc3QgZ2V0QWNjb3VudEluZm8gPSAobG9naW4/OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLyoqIFRoZSBwbGF0Zm9ybSBvZiB0aGUgYWNjb3VudCBsaW5rZWQgdG8gdGhlIHdhbGxldCAqL1xuICAgICAgICAgICAgICAgIHBsYXRmb3JtOiB3YWxsZXQ/LmxpbmtlZF90bz8uZmluZChsaW5rZWQgPT4gbGlua2VkLmxvZ2luaWQgPT09IGxvZ2luKT8ucGxhdGZvcm0sXG4gICAgICAgICAgICAgICAgLyoqIFRoZSBmb3JtYXR0ZWQgZGlzcGxheSBsb2dpbiBvZiB0aGUgYWNjb3VudCAqL1xuICAgICAgICAgICAgICAgIGRpc3BsYXlfbG9naW46IGxvZ2luPy5yZXBsYWNlKC9eKE1UW0RSXT8pLywgJycpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBkaXNwbGF5QmFsYW5jZUZvcm1hdCA9IChiYWxhbmNlOiBudW1iZXIsIGN1cnJlbmN5OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke0ludGwuTnVtYmVyRm9ybWF0KGF1dGhvcml6ZV9kYXRhPy5wcmVmZXJyZWRfbGFuZ3VhZ2UgfHwgJ2VuLVVTJywge1xuICAgICAgICAgICAgICAgICAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDIsXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMixcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bUludGVnZXJEaWdpdHM6IDEsXG4gICAgICAgICAgICAgICAgfSkuZm9ybWF0KGJhbGFuY2UpfSAke2N1cnJlbmN5IHx8ICdVU0QnfWA7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtiYWxhbmNlfSAke2N1cnJlbmN5IHx8ICdVU0QnfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG10NV9hY2NvdW50cz8ubXQ1X2xvZ2luX2xpc3Q/Lm1hcChhY2NvdW50ID0+ICh7XG4gICAgICAgICAgICAuLi5hY2NvdW50LFxuICAgICAgICAgICAgLi4uZ2V0QWNjb3VudEluZm8oYWNjb3VudC5sb2dpbiksXG4gICAgICAgICAgICAvKiogVGhlIGlkIG9mIHRoZSBhY2NvdW50ICovXG4gICAgICAgICAgICBsb2dpbmlkOiBhY2NvdW50LmxvZ2luLFxuICAgICAgICAgICAgLyoqIFRoZSBwbGF0Zm9ybSBvZiB0aGUgYWNjb3VudCAqL1xuICAgICAgICAgICAgcGxhdGZvcm06ICdtdDUnLFxuICAgICAgICAgICAgLyoqIFRoZSBiYWxhbmNlIG9mIHRoZSBhY2NvdW50IGluIGN1cnJlbmN5IGZvcm1hdC4gKi9cbiAgICAgICAgICAgIGRpc3BsYXlfYmFsYW5jZTogZGlzcGxheUJhbGFuY2VGb3JtYXQoYWNjb3VudC5iYWxhbmNlIHx8IDAsIGFjY291bnQuY3VycmVuY3kgfHwgJ1VTRCcpLFxuICAgICAgICB9KSk7XG4gICAgfSwgW2F1dGhvcml6ZV9kYXRhPy5wcmVmZXJyZWRfbGFuZ3VhZ2UsIG10NV9hY2NvdW50cz8ubXQ1X2xvZ2luX2xpc3QsIHdhbGxldD8ubGlua2VkX3RvXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKiogVGhlIGxpc3Qgb2YgY3JlYXRlZCBNVDUgYWNjb3VudHMgKi9cbiAgICAgICAgZGF0YTogbW9kaWZpZWRfbXQ1X2FjY291bnRzLFxuICAgICAgICAuLi5tdDVfYWNjb3VudHNfcmVzdCxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlTVQ1QWNjb3VudHNMaXN0O1xuIiwiaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VRdWVyeSBmcm9tICcuLi91c2VRdWVyeSc7XG5pbXBvcnQgdXNlQXV0aG9yaXplIGZyb20gJy4vdXNlQXV0aG9yaXplJztcblxuLyoqIEEgY3VzdG9tIGhvb2sgdGhhdCBnZXRzIHRoZSBsaXN0IG9mIGNyZWF0ZWQgRGVyaXYgWCBhY2NvdW50cy4gKi9cbmNvbnN0IHVzZUR4dHJhZGVBY2NvdW50c0xpc3QgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBkYXRhOiBhdXRob3JpemVfZGF0YSwgaXNTdWNjZXNzIH0gPSB1c2VBdXRob3JpemUoKTtcbiAgICBjb25zdCB7IGRhdGE6IGR4dHJhZGVfYWNjb3VudHMsIC4uLnJlc3QgfSA9IHVzZVF1ZXJ5KCd0cmFkaW5nX3BsYXRmb3JtX2FjY291bnRzJywge1xuICAgICAgICBwYXlsb2FkOiB7IHBsYXRmb3JtOiAnZHh0cmFkZScgfSxcbiAgICAgICAgb3B0aW9uczogeyBlbmFibGVkOiBpc1N1Y2Nlc3MgfSxcbiAgICB9KTtcblxuICAgIC8qKiBBZGRpbmcgbmVjZXNzYXJ5IHByb3BlcnRpZXMgdG8gRGVyaXYgWCBhY2NvdW50cyAqL1xuICAgIGNvbnN0IG1vZGlmaWVkX2R4dHJhZGVfYWNjb3VudHMgPSB1c2VNZW1vKFxuICAgICAgICAoKSA9PlxuICAgICAgICAgICAgZHh0cmFkZV9hY2NvdW50cz8udHJhZGluZ19wbGF0Zm9ybV9hY2NvdW50cz8ubWFwKGFjY291bnQgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi5hY2NvdW50LFxuICAgICAgICAgICAgICAgIC8qKiBUaGUgYmFsYW5jZSBvZiB0aGUgYWNjb3VudCBpbiBjdXJyZW5jeSBmb3JtYXQuICovXG4gICAgICAgICAgICAgICAgZGlzcGxheV9iYWxhbmNlOiBgJHtJbnRsLk51bWJlckZvcm1hdChhdXRob3JpemVfZGF0YT8ucHJlZmVycmVkX2xhbmd1YWdlIHx8ICdlbi1VUycsIHtcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiAyLFxuICAgICAgICAgICAgICAgICAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDIsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW1JbnRlZ2VyRGlnaXRzOiAxLFxuICAgICAgICAgICAgICAgIH0pLmZvcm1hdChhY2NvdW50Py5iYWxhbmNlIHx8IDApfSAke2FjY291bnQ/LmN1cnJlbmN5IHx8ICdVU0QnfWAsXG4gICAgICAgICAgICB9KSksXG4gICAgICAgIFthdXRob3JpemVfZGF0YT8ucHJlZmVycmVkX2xhbmd1YWdlLCBkeHRyYWRlX2FjY291bnRzPy50cmFkaW5nX3BsYXRmb3JtX2FjY291bnRzXVxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKiogTGlzdCBvZiBhbGwgY3JlYXRlZCBEZXJpdiBYIGFjY291bnRzICovXG4gICAgICAgIGRhdGE6IG1vZGlmaWVkX2R4dHJhZGVfYWNjb3VudHMsXG4gICAgICAgIC4uLnJlc3QsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUR4dHJhZGVBY2NvdW50c0xpc3Q7XG4iLCJpbXBvcnQgdXNlQWN0aXZlQWNjb3VudCBmcm9tICcuL3VzZUFjdGl2ZUFjY291bnQnO1xuaW1wb3J0IHVzZVF1ZXJ5IGZyb20gJy4uL3VzZVF1ZXJ5JztcblxuLyoqIEEgY3VzdG9tIGhvb2sgdGhhdCBnZXQgU2VydmljZSBUb2tlbiBmb3IgRGVyaXZFeiBQbGF0Zm9ybS4gKi9cbmNvbnN0IHVzZURlcml2ZXpTZXJ2aWNlVG9rZW4gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBkYXRhOiBhY2NvdW50IH0gPSB1c2VBY3RpdmVBY2NvdW50KCk7XG4gICAgY29uc3QgeyBkYXRhOiBkZXJpdmV6X3Rva2VuLCAuLi5yZXN0IH0gPSB1c2VRdWVyeSgnc2VydmljZV90b2tlbicsIHtcbiAgICAgICAgcGF5bG9hZDogeyBzZXJ2aWNlOiAncGFuZGF0cycsIHNlcnZlcjogYWNjb3VudD8uaXNfdmlydHVhbCA/ICdkZW1vJyA6ICdyZWFsJyB9LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqIHJldHVybiB0aGUgRGVyaXZFeiBhY2NvdW50IHRva2VuICovXG4gICAgICAgIGRhdGE6IGRlcml2ZXpfdG9rZW4/LnNlcnZpY2VfdG9rZW4/LnBhbmRhdHM/LnRva2VuLFxuICAgICAgICAuLi5yZXN0LFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VEZXJpdmV6U2VydmljZVRva2VuO1xuIiwiaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VRdWVyeSBmcm9tICcuLi91c2VRdWVyeSc7XG5pbXBvcnQgdXNlQXV0aG9yaXplIGZyb20gJy4vdXNlQXV0aG9yaXplJztcbmltcG9ydCB1c2VEZXJpdmV6U2VydmljZVRva2VuIGZyb20gJy4vdXNlRGVyaXZlelNlcnZpY2VUb2tlbic7XG5cbi8qKiBBIGN1c3RvbSBob29rIHRoYXQgZ2V0cyB0aGUgbGlzdCBvZiBjcmVhdGVkIERlcml2RXogYWNjb3VudHMuICovXG5jb25zdCB1c2VEZXJpdmV6QWNjb3VudHNMaXN0ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgaXNTdWNjZXNzIH0gPSB1c2VBdXRob3JpemUoKTtcbiAgICBjb25zdCB7IGRhdGE6IGRlcml2ZXpfYWNjb3VudHMgfSA9IHVzZVF1ZXJ5KCd0cmFkaW5nX3BsYXRmb3JtX2FjY291bnRzJywge1xuICAgICAgICBwYXlsb2FkOiB7IHBsYXRmb3JtOiAnZGVyaXZleicgfSxcbiAgICAgICAgb3B0aW9uczogeyBlbmFibGVkOiBpc1N1Y2Nlc3MgfSxcbiAgICB9KTtcbiAgICBjb25zdCB7IGRhdGE6IHRva2VuIH0gPSB1c2VEZXJpdmV6U2VydmljZVRva2VuKCk7XG5cbiAgICAvKiogQWRkaW5nIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzIHRvIERlcml2RXogYWNjb3VudHMgKi9cbiAgICBjb25zdCBtb2RpZmllZF9kZXJpdmV6X2FjY291bnRzID0gdXNlTWVtbyhcbiAgICAgICAgKCkgPT5cbiAgICAgICAgICAgIGRlcml2ZXpfYWNjb3VudHM/LnRyYWRpbmdfcGxhdGZvcm1fYWNjb3VudHM/Lm1hcChhY2NvdW50ID0+ICh7XG4gICAgICAgICAgICAgICAgLi4uYWNjb3VudCxcbiAgICAgICAgICAgICAgICAvKiogVGhlIGlkIGZvciB0aGUgYWNjb3VudCAqL1xuICAgICAgICAgICAgICAgIGxvZ2luaWQ6IGFjY291bnQuYWNjb3VudF9pZCxcbiAgICAgICAgICAgICAgICAvKiogVGhlIHRva2VuIGZvciB0aGUgYWNjb3VudCAqL1xuICAgICAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICBbZGVyaXZlel9hY2NvdW50cz8udHJhZGluZ19wbGF0Zm9ybV9hY2NvdW50cywgdG9rZW5dXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKiBMaXN0IG9mIGFsbCBjcmVhdGVkIERlcml2RXogYWNjb3VudHMgKi9cbiAgICAgICAgZGF0YTogbW9kaWZpZWRfZGVyaXZlel9hY2NvdW50cyxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlRGVyaXZlekFjY291bnRzTGlzdDtcbiIsImltcG9ydCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlUXVlcnkgZnJvbSAnLi4vdXNlUXVlcnknO1xuaW1wb3J0IHVzZUF1dGhvcml6ZSBmcm9tICcuL3VzZUF1dGhvcml6ZSc7XG5cbi8qKiBBIGN1c3RvbSBob29rIHRoYXQgZ2V0cyB0aGUgbGlzdCBvZiBjcmVhdGVkIGNUcmFkZXIgYWNjb3VudHMuICovXG5jb25zdCB1c2VDdHJhZGVyQWNjb3VudHNMaXN0ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgaXNTdWNjZXNzIH0gPSB1c2VBdXRob3JpemUoKTtcbiAgICBjb25zdCB7IGRhdGE6IGN0cmFkZXJfYWNjb3VudHMsIC4uLnJlc3QgfSA9IHVzZVF1ZXJ5KCd0cmFkaW5nX3BsYXRmb3JtX2FjY291bnRzJywge1xuICAgICAgICBwYXlsb2FkOiB7IHBsYXRmb3JtOiAnY3RyYWRlcicgfSxcbiAgICAgICAgb3B0aW9uczogeyBlbmFibGVkOiBpc1N1Y2Nlc3MgfSxcbiAgICB9KTtcblxuICAgIC8qKiBBZGRpbmcgbmVjY2VzYXJ5IHByb3BlcnRpZXMgdG8gY1RyYWRlciBhY2NvdW50cyAqL1xuICAgIGNvbnN0IG1vZGlmaWVkX2N0cmFkZXJfYWNjb3VudHMgPSB1c2VNZW1vKFxuICAgICAgICAoKSA9PlxuICAgICAgICAgICAgY3RyYWRlcl9hY2NvdW50cz8udHJhZGluZ19wbGF0Zm9ybV9hY2NvdW50cz8ubWFwKGFjY291bnQgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi5hY2NvdW50LFxuICAgICAgICAgICAgICAgIC8qKiBUaGUgaWQgb2YgdGhlIGNUcmFkZXIgYWNjb3VudCAqL1xuICAgICAgICAgICAgICAgIGlkOiBhY2NvdW50LmFjY291bnRfaWQsXG4gICAgICAgICAgICB9KSksXG4gICAgICAgIFtjdHJhZGVyX2FjY291bnRzPy50cmFkaW5nX3BsYXRmb3JtX2FjY291bnRzXVxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKiogTGlzdCBvZiBhbGwgY3JlYXRlZCBjVHJhZGVyIGFjY291bnRzICovXG4gICAgICAgIGRhdGE6IG1vZGlmaWVkX2N0cmFkZXJfYWNjb3VudHMsXG4gICAgICAgIC4uLnJlc3QsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUN0cmFkZXJBY2NvdW50c0xpc3Q7XG4iLCJpbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZU1UNUFjY291bnRzTGlzdCBmcm9tICcuL3VzZU1UNUFjY291bnRzTGlzdCc7XG5pbXBvcnQgdXNlRHh0cmFkZUFjY291bnRzTGlzdCBmcm9tICcuL3VzZUR4dHJhZGVBY2NvdW50c0xpc3QnO1xuaW1wb3J0IHVzZURlcml2ZXpBY2NvdW50c0xpc3QgZnJvbSAnLi91c2VEZXJpdmV6QWNjb3VudHNMaXN0JztcbmltcG9ydCB1c2VDdHJhZGVyQWNjb3VudHNMaXN0IGZyb20gJy4vdXNlQ3RyYWRlckFjY291bnRzTGlzdCc7XG5cbi8qKiBBIGN1c3RvbSBob29rIHRoYXQgZ2V0cyB0aGUgbGlzdCBhbGwgY3JlYXRlZCBDRkQgYWNjb3VudHMgb2YgdGhlIHVzZXIuICovXG5jb25zdCB1c2VDRkRBY2NvdW50c0xpc3QgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBkYXRhOiBtdDVfYWNjb3VudHMgfSA9IHVzZU1UNUFjY291bnRzTGlzdCgpO1xuICAgIGNvbnN0IHsgZGF0YTogZHh0cmFkZV9hY2NvdW50cyB9ID0gdXNlRHh0cmFkZUFjY291bnRzTGlzdCgpO1xuICAgIGNvbnN0IHsgZGF0YTogZGVyaXZlel9hY2NvdW50cyB9ID0gdXNlRGVyaXZlekFjY291bnRzTGlzdCgpO1xuICAgIGNvbnN0IHsgZGF0YTogY3RyYWRlcl9hY2NvdW50cyB9ID0gdXNlQ3RyYWRlckFjY291bnRzTGlzdCgpO1xuXG4gICAgY29uc3QgZGF0YSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoIW10NV9hY2NvdW50cyB8fCAhZHh0cmFkZV9hY2NvdW50cyB8fCAhZGVyaXZlel9hY2NvdW50cyB8fCAhY3RyYWRlcl9hY2NvdW50cykgcmV0dXJuO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtdDVfYWNjb3VudHM6IG10NV9hY2NvdW50cyB8fCBbXSxcbiAgICAgICAgICAgIGR4dHJhZGVfYWNjb3VudHM6IGR4dHJhZGVfYWNjb3VudHMgfHwgW10sXG4gICAgICAgICAgICBkZXJpdmV6X2FjY291bnRzOiBkZXJpdmV6X2FjY291bnRzIHx8IFtdLFxuICAgICAgICAgICAgY3RyYWRlcl9hY2NvdW50czogY3RyYWRlcl9hY2NvdW50cyB8fCBbXSxcbiAgICAgICAgfTtcbiAgICB9LCBbbXQ1X2FjY291bnRzLCBkeHRyYWRlX2FjY291bnRzLCBkZXJpdmV6X2FjY291bnRzLCBjdHJhZGVyX2FjY291bnRzXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKiogVGhlIGxpc3Qgb2YgY3JlYXRlZCBNVDUgYW5kIE5vbi1NVDUgYWNjb3VudHMgKi9cbiAgICAgICAgZGF0YSxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlQ0ZEQWNjb3VudHNMaXN0O1xuIiwiaW1wb3J0IHVzZU11dGF0aW9uIGZyb20gJy4uL3VzZU11dGF0aW9uJztcblxuLyoqIEEgY3VzdG9tIGhvb2tzIGZvciBjYW5jZWxsaW5nIGNyeXB0byB0cmFuc2FjdGlvbiAgKi9cbmNvbnN0IHVzZUNhbmNlbENyeXB0b1RyYW5zYWN0aW9uID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgZGF0YSwgbXV0YXRlLCAuLi5yZXN0IH0gPSB1c2VNdXRhdGlvbignY2FzaGllcl93aXRoZHJhd2FsX2NhbmNlbCcpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqIFRoZSBjYW5jZWwgY3J5cHRvIHRyYW5zYWN0aW9uIHJlc3BvbnNlICovXG4gICAgICAgIGRhdGE6IGRhdGE/LmNhc2hpZXJfd2l0aGRyYXdhbF9jYW5jZWwsXG4gICAgICAgIC8qKiBGdW5jdGlvbiB0byBjYW5jZWwgY3J5cHRvIHRyYW5zYWN0aW9uICovXG4gICAgICAgIG11dGF0ZSxcbiAgICAgICAgLi4ucmVzdCxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlQ2FuY2VsQ3J5cHRvVHJhbnNhY3Rpb247XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VNdXRhdGlvbiBmcm9tICcuLi91c2VNdXRhdGlvbic7XG5cbnR5cGUgVENhc2hpZXJQYXJhbSA9IE5vbk51bGxhYmxlPFxuICAgIFBhcmFtZXRlcnM8UmV0dXJuVHlwZTx0eXBlb2YgdXNlTXV0YXRpb248J2Nhc2hpZXInPj5bJ211dGF0ZSddPlxuPlswXVsncGF5bG9hZCddWydjYXNoaWVyJ107XG5cbnR5cGUgVFBhcmFtcyA9IE9taXQ8XG4gICAgTm9uTnVsbGFibGU8UGFyYW1ldGVyczxSZXR1cm5UeXBlPHR5cGVvZiB1c2VNdXRhdGlvbjwnY2FzaGllcic+PlsnbXV0YXRlJ10+PlswXVsncGF5bG9hZCddLFxuICAgICdjYXNoaWVyJyB8ICdwcm92aWRlcidcbj47XG5cbi8qKiBBIGN1c3RvbSBob29rIHRvIGdldCB0aGUgZGVwb3NpdCBhbmQgd2l0aGRyYXdhbCBmaWF0IGFkZHJlc3MuICovXG5jb25zdCB1c2VDYXNoaWVyRmlhdEFkZHJlc3MgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBkYXRhLCBtdXRhdGU6IF9tdXRhdGUsIC4uLnJlc3QgfSA9IHVzZU11dGF0aW9uKCdjYXNoaWVyJyk7XG4gICAgY29uc3QgaWZyYW1lX3VybCA9IHR5cGVvZiBkYXRhPy5jYXNoaWVyID09PSAnc3RyaW5nJyA/IGRhdGE/LmNhc2hpZXIgOiB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCBtdXRhdGUgPSB1c2VDYWxsYmFjayhcbiAgICAgICAgKGNhc2hpZXI6IFRDYXNoaWVyUGFyYW0sIHBheWxvYWQ/OiBUUGFyYW1zKSA9PlxuICAgICAgICAgICAgX211dGF0ZSh7IHBheWxvYWQ6IHsgY2FzaGllciwgcHJvdmlkZXI6ICdkb3VnaGZsb3cnLCAuLi5wYXlsb2FkIH0gfSksXG4gICAgICAgIFtfbXV0YXRlXVxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKiogVGhlIGRlcG9zaXQvd2l0aGRyYXdhbCBmaWF0IGlmcmFtZSAqL1xuICAgICAgICBkYXRhOiBpZnJhbWVfdXJsLFxuICAgICAgICAvKiogRnVuY3Rpb24gdG8gZ2V0IGRlcG9zaXQvd2l0aGRyYXdhbCBmaWF0IGFkZHJlc3MgKi9cbiAgICAgICAgbXV0YXRlLFxuICAgICAgICAuLi5yZXN0LFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VDYXNoaWVyRmlhdEFkZHJlc3M7XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VRdWVyeSBmcm9tICcuLi91c2VRdWVyeSc7XG5cbi8qKiBBIGN1c3RvbSBob29rIHRvIGdldCB0aGUgY291bnRyeSBjb25maWcgaW5mb3JtYXRpb24gZnJvbSBgcmVzaWRlbmNlX2xpc3RgIGVuZHBvaW50LiAqL1xuY29uc3QgdXNlQ291bnRyeUNvbmZpZyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGRhdGE6IHJlc2lkZW5jZV9saXN0X2RhdGEsIC4uLnJlc3QgfSA9IHVzZVF1ZXJ5KCdyZXNpZGVuY2VfbGlzdCcpO1xuXG4gICAgLy8gQWRkIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gdGhlIGNvdW50cnkgY29uZmlnLlxuICAgIGNvbnN0IG1vZGlmaWVkX3Jlc2lkZW5jZV9saXN0ID0gdXNlTWVtbyhcbiAgICAgICAgKCkgPT5cbiAgICAgICAgICAgIHJlc2lkZW5jZV9saXN0X2RhdGE/LnJlc2lkZW5jZV9saXN0Py5tYXAoY291bnRyeV9jb25maWcgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvdW50cnlfY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAvKiogRGV0ZXJtaW5lIGlmIHRoZSBjb3VudHJ5IGlzIGRpc2FibGVkICovXG4gICAgICAgICAgICAgICAgICAgIGlzX2Rpc2FibGVkOiBjb3VudHJ5X2NvbmZpZy5kaXNhYmxlZCAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAvKiogMi1sZXR0ZXIgY291bnRyeSBjb2RlICovXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGAke2NvdW50cnlfY29uZmlnLnZhbHVlfWAudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgLyoqIENvdW50cnkgbmFtZSAqL1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBgJHtjb3VudHJ5X2NvbmZpZy50ZXh0fWAsXG4gICAgICAgICAgICAgICAgICAgIC8qKiBEZXRlcm1pbmUgaWYgdGhlIElEViBzZXJ2aWNlIGlzIHN1cHBvcnRlZCBmb3IgdGhlIGNvdW50cnkgKi9cbiAgICAgICAgICAgICAgICAgICAgaXNfaWR2X3N1cHBvcnRlZDogY291bnRyeV9jb25maWcuaWRlbnRpdHk/LnNlcnZpY2VzPy5pZHY/LmlzX2NvdW50cnlfc3VwcG9ydGVkID09PSAxLFxuICAgICAgICAgICAgICAgICAgICAvKiogRGV0ZXJtaW5lIGlmIHRoZSBPbmZpZG8gc2VydmljZSBpcyBzdXBwb3J0ZWQgZm9yIHRoZSBjb3VudHJ5ICovXG4gICAgICAgICAgICAgICAgICAgIGlzX29uZmlkb19zdXBwb3J0ZWQ6IGNvdW50cnlfY29uZmlnLmlkZW50aXR5Py5zZXJ2aWNlcz8ub25maWRvPy5pc19jb3VudHJ5X3N1cHBvcnRlZCA9PT0gMSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSksXG4gICAgICAgIFtyZXNpZGVuY2VfbGlzdF9kYXRhPy5yZXNpZGVuY2VfbGlzdF1cbiAgICApO1xuXG4gICAgLy8gVHJhbnNmb3JtIHRoZSBjb3VudHJ5IGNvbmZpZyBhcnJheSBpbnRvIGEgcmVjb3JkIG9iamVjdC5cbiAgICBjb25zdCB0cmFuc2Zvcm1lZF9yZXNpZGVuY2VfbGlzdCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gbW9kaWZpZWRfcmVzaWRlbmNlX2xpc3Q/LnJlZHVjZTxSZWNvcmQ8c3RyaW5nLCB0eXBlb2YgbW9kaWZpZWRfcmVzaWRlbmNlX2xpc3RbbnVtYmVyXT4+KFxuICAgICAgICAgICAgKHByZXZpb3VzLCBjdXJyZW50KSA9PiAoeyAuLi5wcmV2aW91cywgW2N1cnJlbnQuY29kZV06IGN1cnJlbnQgfSksXG4gICAgICAgICAgICB7fVxuICAgICAgICApO1xuICAgIH0sIFttb2RpZmllZF9yZXNpZGVuY2VfbGlzdF0pO1xuXG4gICAgY29uc3QgZ2V0Q29uZmlnID0gdXNlQ2FsbGJhY2soXG4gICAgICAgIChjdXJyZW5jeTogc3RyaW5nKSA9PiB0cmFuc2Zvcm1lZF9yZXNpZGVuY2VfbGlzdD8uW2N1cnJlbmN5IGFzIHN0cmluZ10sXG4gICAgICAgIFt0cmFuc2Zvcm1lZF9yZXNpZGVuY2VfbGlzdF1cbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqIEF2YWlsYWJsZSBjb3VudHJpZXMgYW5kIHRoZWlyIGluZm9ybWF0aW9uICovXG4gICAgICAgIGRhdGE6IHRyYW5zZm9ybWVkX3Jlc2lkZW5jZV9saXN0LFxuICAgICAgICAvKiogUmV0dXJucyB0aGUgY291bnRyeSBjb25maWcgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gY291bnRyeSBjb2RlICovXG4gICAgICAgIGdldENvbmZpZyxcbiAgICAgICAgLi4ucmVzdCxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlQ291bnRyeUNvbmZpZztcbiIsImltcG9ydCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlTXV0YXRpb24gZnJvbSAnLi4vdXNlTXV0YXRpb24nO1xuaW1wb3J0IHVzZUludmFsaWRhdGVRdWVyeSBmcm9tICcuLi91c2VJbnZhbGlkYXRlUXVlcnknO1xuXG4vKiogQSBjdXN0b20gaG9vayB0byBjcmVhdGUgTVQ1IGFjY291bnRzLiAqL1xuY29uc3QgdXNlQ3JlYXRlTVQ1QWNjb3VudCA9ICgpID0+IHtcbiAgICBjb25zdCBpbnZhbGlkYXRlID0gdXNlSW52YWxpZGF0ZVF1ZXJ5KCk7XG4gICAgY29uc3QgeyBkYXRhLCAuLi5yZXN0IH0gPSB1c2VNdXRhdGlvbignbXQ1X25ld19hY2NvdW50Jywge1xuICAgICAgICBvblN1Y2Nlc3M6ICgpID0+IHtcbiAgICAgICAgICAgIGludmFsaWRhdGUoJ210NV9sb2dpbl9saXN0Jyk7XG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0byB0aGUgY3JlYXRlIE1UNSBhY2NvdW50IHJlc3BvbnNlLlxuICAgIGNvbnN0IG1vZGlmaWVkX2RhdGEgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFkYXRhPy5tdDVfbmV3X2FjY291bnQpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgICAgcmV0dXJuIHsgLi4uZGF0YT8ubXQ1X25ld19hY2NvdW50IH07XG4gICAgfSwgW2RhdGFdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKiBUaGUgcmVzcG9uc2UgYW5kIHRoZSBtdXRhdGlvbiBvZiB0aGUgY3JlYXRlIE1UNSBhY2NvdW50IEFQSSByZXF1ZXN0ICovXG4gICAgICAgIGRhdGE6IG1vZGlmaWVkX2RhdGEsXG4gICAgICAgIC4uLnJlc3QsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUNyZWF0ZU1UNUFjY291bnQ7XG4iLCJpbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZU11dGF0aW9uIGZyb20gJy4uL3VzZU11dGF0aW9uJztcbmltcG9ydCB1c2VJbnZhbGlkYXRlUXVlcnkgZnJvbSAnLi4vdXNlSW52YWxpZGF0ZVF1ZXJ5JztcblxuLyoqIEEgY3VzdG9tIGhvb2sgdGhhdCBjcmVhdGVzIGEgbmV3IHJlYWwgdHJhZGluZyBhY2NvdW50LiAqL1xuY29uc3QgdXNlQ3JlYXRlTmV3UmVhbEFjY291bnQgPSAoKSA9PiB7XG4gICAgY29uc3QgaW52YWxpZGF0ZSA9IHVzZUludmFsaWRhdGVRdWVyeSgpO1xuICAgIGNvbnN0IHsgZGF0YSwgLi4ucmVzdCB9ID0gdXNlTXV0YXRpb24oJ25ld19hY2NvdW50X3JlYWwnLCB7XG4gICAgICAgIG9uU3VjY2VzczogKCkgPT4ge1xuICAgICAgICAgICAgaW52YWxpZGF0ZSgnYXV0aG9yaXplJyk7XG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0byB0aGUgbmV3IHJlYWwgdHJhZGluZyBhY2NvdW50IHJlc3BvbnNlLlxuICAgIGNvbnN0IG1vZGlmaWVkX2RhdGEgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFkYXRhPy5uZXdfYWNjb3VudF9yZWFsKSByZXR1cm47XG5cbiAgICAgICAgcmV0dXJuIHsgLi4uZGF0YT8ubmV3X2FjY291bnRfcmVhbCB9O1xuICAgIH0sIFtkYXRhXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKiogVGhlIHJlc3BvbnNlIGFuZCB0aGUgbXV0YXRpb24gb2YgdGhlIG5ldyBhY2NvdW50IHJlYWwgQVBJIHJlcXVlc3QgKi9cbiAgICAgICAgZGF0YTogbW9kaWZpZWRfZGF0YSxcbiAgICAgICAgLi4ucmVzdCxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlQ3JlYXRlTmV3UmVhbEFjY291bnQ7XG4iLCJpbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZU11dGF0aW9uIGZyb20gJy4uL3VzZU11dGF0aW9uJztcbmltcG9ydCB1c2VJbnZhbGlkYXRlUXVlcnkgZnJvbSAnLi4vdXNlSW52YWxpZGF0ZVF1ZXJ5JztcblxuLyoqIEEgY3VzdG9tIGhvb2sgdG8gY3JlYXRlIHRoaXJkIHBhcnR5IENGRCBhY2NvdW50cy4gKi9cbmNvbnN0IHVzZUNyZWF0ZU90aGVyQ0ZEQWNjb3VudCA9ICgpID0+IHtcbiAgICBjb25zdCBpbnZhbGlkYXRlID0gdXNlSW52YWxpZGF0ZVF1ZXJ5KCk7XG4gICAgY29uc3QgeyBkYXRhLCAuLi5yZXN0IH0gPSB1c2VNdXRhdGlvbigndHJhZGluZ19wbGF0Zm9ybV9uZXdfYWNjb3VudCcsIHtcbiAgICAgICAgb25TdWNjZXNzOiAoKSA9PiB7XG4gICAgICAgICAgICBpbnZhbGlkYXRlKCd0cmFkaW5nX3BsYXRmb3JtX2FjY291bnRzJyk7XG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0byB0aGUgY3JlYXRlIE90aGVyIENGRCBhY2NvdW50IHJlc3BvbnNlLlxuICAgIGNvbnN0IG1vZGlmaWVkX2RhdGEgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFkYXRhKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgICAgIHJldHVybiB7IC4uLmRhdGEgfTtcbiAgICB9LCBbZGF0YV0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqIFRoZSByZXNwb25zZSBhbmQgdGhlIG11dGF0aW9uIG9mIHRoZSBjcmVhdGUgdGhpcmQgcGFydHkgQ0ZEcyBBUEkgcmVxdWVzdCAqL1xuICAgICAgICBkYXRhOiBtb2RpZmllZF9kYXRhLFxuICAgICAgICAuLi5yZXN0LFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VDcmVhdGVPdGhlckNGREFjY291bnQ7XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZUFQSSBmcm9tICcuL3VzZUFQSSc7XG5pbXBvcnQgdHlwZSB7XG4gICAgVFNvY2tldEFjY2VwdGFibGVQcm9wcyxcbiAgICBUU29ja2V0RXJyb3IsXG4gICAgVFNvY2tldFJlcXVlc3RQYXlsb2FkLFxuICAgIFRTb2NrZXRSZXNwb25zZURhdGEsXG4gICAgVFNvY2tldFN1YnNjcmliYWJsZUVuZHBvaW50TmFtZXMsXG59IGZyb20gJy4uL3R5cGVzJztcblxuY29uc3QgdXNlU3Vic2NyaXB0aW9uID0gPFQgZXh0ZW5kcyBUU29ja2V0U3Vic2NyaWJhYmxlRW5kcG9pbnROYW1lcz4obmFtZTogVCkgPT4ge1xuICAgIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2lzU3Vic2NyaWJlZCwgc2V0U3Vic2NyaWJlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxUU29ja2V0RXJyb3I8VD4+KCk7XG4gICAgY29uc3QgW2RhdGEsIHNldERhdGFdID0gdXNlU3RhdGU8VFNvY2tldFJlc3BvbnNlRGF0YTxUPj4oKTtcbiAgICBjb25zdCBzdWJzY3JpYmVyID0gdXNlUmVmPHsgdW5zdWJzY3JpYmU/OiBWb2lkRnVuY3Rpb24gfT4oKTtcbiAgICBjb25zdCB7IHN1YnNjcmliZTogX3N1YnNjcmliZSB9ID0gdXNlQVBJKCk7XG5cbiAgICBjb25zdCBzdWJzY3JpYmUgPSB1c2VDYWxsYmFjayhcbiAgICAgICAgKC4uLnByb3BzOiBUU29ja2V0QWNjZXB0YWJsZVByb3BzPFQ+KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9wID0gcHJvcHM/LlswXTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBwcm9wICYmICdwYXlsb2FkJyBpbiBwcm9wID8gKHByb3AucGF5bG9hZCBhcyBUU29ja2V0UmVxdWVzdFBheWxvYWQ8VD4pIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgICAgICBzZXRTdWJzY3JpYmVkKHRydWUpO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY3VycmVudCA9IF9zdWJzY3JpYmUobmFtZSwgcGF5bG9hZCkuc3Vic2NyaWJlKFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXREYXRhKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEVycm9yKHJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKGUgYXMgVFNvY2tldEVycm9yPFQ+KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW19zdWJzY3JpYmUsIG5hbWVdXG4gICAgKTtcblxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBzdWJzY3JpYmVyLmN1cnJlbnQ/LnVuc3Vic2NyaWJlPy4oKTtcbiAgICAgICAgc2V0U3Vic2NyaWJlZChmYWxzZSk7XG4gICAgfSwgW10pO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH07XG4gICAgfSwgW3Vuc3Vic2NyaWJlXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIHVuc3Vic2NyaWJlLFxuICAgICAgICBpc0xvYWRpbmcsXG4gICAgICAgIGlzU3Vic2NyaWJlZCxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGRhdGEsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZVN1YnNjcmlwdGlvbjtcbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZVN1YnNjcmlwdGlvbiBmcm9tICcuLi91c2VTdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgZ2V0VHJ1bmNhdGVkU3RyaW5nIH0gZnJvbSAnQGRlcml2L3V0aWxzJztcblxudHlwZSBUVHJhbnNhY3Rpb24gPSBOb25OdWxsYWJsZTxcbiAgICBOb25OdWxsYWJsZTxSZXR1cm5UeXBlPHR5cGVvZiB1c2VTdWJzY3JpcHRpb248J2Nhc2hpZXJfcGF5bWVudHMnPj5bJ2RhdGEnXT5bJ2Nhc2hpZXJfcGF5bWVudHMnXVxuPlsnY3J5cHRvJ11bbnVtYmVyXTtcblxudHlwZSBUU3RhdHVzID0gVFRyYW5zYWN0aW9uWydzdGF0dXNfY29kZSddO1xuXG50eXBlIFREZXBvc2l0U3RhdHVzID0gJ1BFTkRJTkcnIHwgJ0NPTkZJUk1FRCcgfCAnRVJST1InO1xuXG50eXBlIFRXaXRoZHJhd2FsU3RhdHVzID0gRXhjbHVkZTxUU3RhdHVzLCBURGVwb3NpdFN0YXR1cz47XG5cbi8vIFNpbmNlIEJFIHNlbmRzIHRoZSBgc3RhdHVzX2NvZGVgIGZvciBib3RoIGBkZXBvc2l0YCBhbmQgYHdpdGhkcmF3YWxgIGluIHRoZSBzYW1lIGZpZWxkLFxuLy8gSGVyZSB3ZSBtb2RpZnkgdGhlIEJFIHR5cGUgdG8gbWFrZSBgc3RhdHVzX2NvZGVgIHR5cGUgbW9yZSBzcGVjaWZpYyB0byB0aGUgYHRyYW5zYWN0aW9uX3R5cGVgIGZpZWxkLlxudHlwZSBUTW9kaWZpZWRUcmFuc2FjdGlvbiA9IE9taXQ8VFRyYW5zYWN0aW9uLCAnc3RhdHVzX2NvZGUnIHwgJ3RyYW5zYWN0aW9uX3R5cGUnPiAmXG4gICAgKFxuICAgICAgICB8IHsgdHJhbnNhY3Rpb25fdHlwZTogJ2RlcG9zaXQnOyBzdGF0dXNfY29kZTogVERlcG9zaXRTdGF0dXMgfVxuICAgICAgICB8IHsgdHJhbnNhY3Rpb25fdHlwZTogJ3dpdGhkcmF3YWwnOyBzdGF0dXNfY29kZTogVFdpdGhkcmF3YWxTdGF0dXMgfVxuICAgICk7XG5cbi8qKiBBIGN1c3RvbSBob29rIHRoYXQgcmV0dXJucyB0aGUgbGlzdCBvZiBwZW5kaW5nIGNyeXB0byB0cmFuc2FjdGlvbnMgZm9yIHRoZSBjdXJyZW50IHVzZXIuICovXG5jb25zdCB1c2VDcnlwdG9UcmFuc2FjdGlvbnMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBzdWJzY3JpYmUsIGRhdGEsIC4uLnJlc3QgfSA9IHVzZVN1YnNjcmlwdGlvbignY2FzaGllcl9wYXltZW50cycpO1xuICAgIGNvbnN0IFt0cmFuc2FjdGlvbnMsIHNldFRyYW5zYWN0aW9uc10gPSB1c2VTdGF0ZTxUTW9kaWZpZWRUcmFuc2FjdGlvbltdPigpO1xuXG4gICAgLy8gUmVzZXQgdHJhbnNhY3Rpb25zIGRhdGFcbiAgICBjb25zdCByZXNldERhdGEgPSB1c2VDYWxsYmFjaygoKSA9PiBzZXRUcmFuc2FjdGlvbnModW5kZWZpbmVkKSwgW10pO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2V0VHJhbnNhY3Rpb25zKG9sZF90cmFuc2FjdGlvbnMgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3X3RyYW5zYWN0aW9ucyA9IGRhdGE/LmNhc2hpZXJfcGF5bWVudHM/LmNyeXB0byBhcyBUTW9kaWZpZWRUcmFuc2FjdGlvbltdIHwgdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBpZiAoIW5ld190cmFuc2FjdGlvbnMpIHJldHVybiBvbGRfdHJhbnNhY3Rpb25zO1xuXG4gICAgICAgICAgICBpZiAoIW9sZF90cmFuc2FjdGlvbnMpIHJldHVybiBuZXdfdHJhbnNhY3Rpb25zO1xuXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkX3RyYW5zYWN0aW9ucyA9IFsuLi5vbGRfdHJhbnNhY3Rpb25zXTtcblxuICAgICAgICAgICAgLy8gRm9yIGVhY2ggbmV3IHRyYW5zYWN0aW9uLCBjaGVjayBpZiBpdCBleGlzdHMgaW4gdGhlIG9sZCB0cmFuc2FjdGlvbnMuXG4gICAgICAgICAgICBuZXdfdHJhbnNhY3Rpb25zLmZvckVhY2gobmV3X3RyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgbmV3IHRyYW5zYWN0aW9uIGluIHRoZSBvbGQgdHJhbnNhY3Rpb25zIGlmIGV4aXN0cy5cbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHVwZGF0ZWRfdHJhbnNhY3Rpb25zLmZpbmRJbmRleChcbiAgICAgICAgICAgICAgICAgICAgb2xkX3RyYW5zYWN0aW9uID0+IG9sZF90cmFuc2FjdGlvbi5pZCA9PT0gbmV3X3RyYW5zYWN0aW9uLmlkXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBuZXcgdHJhbnNhY3Rpb24gZG9lcyBub3QgZXhpc3QgaW4gdGhlIG9sZCB0cmFuc2FjdGlvbnMsIGFkZCBpdCwgb3RoZXJ3aXNlIHVwZGF0ZSBpdC5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRfdHJhbnNhY3Rpb25zLnB1c2gobmV3X3RyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkX3RyYW5zYWN0aW9uc1tpbmRleF0gPSBuZXdfdHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVkX3RyYW5zYWN0aW9ucztcbiAgICAgICAgfSk7XG4gICAgfSwgW2RhdGE/LmNhc2hpZXJfcGF5bWVudHM/LmNyeXB0b10pO1xuXG4gICAgLy8gQWRkIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gZWFjaCB0cmFuc2FjdGlvbi5cbiAgICBjb25zdCBtb2RpZmllZF90cmFuc2FjdGlvbnMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCF0cmFuc2FjdGlvbnMgfHwgIXRyYW5zYWN0aW9ucy5sZW5ndGgpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9ucy5tYXAodHJhbnNhY3Rpb24gPT4gKHtcbiAgICAgICAgICAgIC4uLnRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgLyoqIEZvcm1hdHRlZCB0cmFuc2FjdGlvbiBoYXNoICovXG4gICAgICAgICAgICBmb3JtYXR0ZWRfdHJhbnNhY3Rpb25faGFzaDogdHJhbnNhY3Rpb24udHJhbnNhY3Rpb25faGFzaFxuICAgICAgICAgICAgICAgID8gZ2V0VHJ1bmNhdGVkU3RyaW5nKHRyYW5zYWN0aW9uLnRyYW5zYWN0aW9uX2hhc2gsIHsgdHlwZTogJ21pZGRsZScgfSlcbiAgICAgICAgICAgICAgICA6ICdOQScsXG4gICAgICAgICAgICAvKiogRm9ybWF0dGVkIGFkZHJlc3MgaGFzaCAqL1xuICAgICAgICAgICAgZm9ybWF0dGVkX2FkZHJlc3NfaGFzaDogdHJhbnNhY3Rpb24uYWRkcmVzc19oYXNoXG4gICAgICAgICAgICAgICAgPyBnZXRUcnVuY2F0ZWRTdHJpbmcodHJhbnNhY3Rpb24uYWRkcmVzc19oYXNoLCB7IHR5cGU6ICdtaWRkbGUnIH0pXG4gICAgICAgICAgICAgICAgOiAnTkEnLFxuICAgICAgICAgICAgLyoqIEZvcm1hdHRlZCBjb25maXJtYXRpb25zIHN0YXR1cyAqL1xuICAgICAgICAgICAgZm9ybWF0dGVkX2NvbmZpcm1hdGlvbnM6XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uc3RhdHVzX2NvZGUgPT09ICdDT05GSVJNRUQnID8gJ0NvbmZpcm1lZCcgOiB0cmFuc2FjdGlvbi5jb25maXJtYXRpb25zIHx8ICdQZW5kaW5nJyxcbiAgICAgICAgICAgIC8qKiBEZXRlcm1pbmUgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGEgZGVwb3NpdCBvciBub3QuICovXG4gICAgICAgICAgICBpc19kZXBvc2l0OiB0cmFuc2FjdGlvbi50cmFuc2FjdGlvbl90eXBlID09PSAnZGVwb3NpdCcsXG4gICAgICAgICAgICAvKiogRGV0ZXJtaW5lIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhIHdpdGhkcmF3YWwgb3Igbm90LiAqL1xuICAgICAgICAgICAgaXNfd2l0aGRyYXdhbDogdHJhbnNhY3Rpb24udHJhbnNhY3Rpb25fdHlwZSA9PT0gJ3dpdGhkcmF3YWwnLFxuICAgICAgICB9KSk7XG4gICAgfSwgW3RyYW5zYWN0aW9uc10pO1xuXG4gICAgLy8gU29ydCB0cmFuc2FjdGlvbnMgYnkgc3VibWl0IHRpbWUuXG4gICAgY29uc3Qgc29ydGVkX3RyYW5zYWN0aW9ucyA9IHVzZU1lbW8oXG4gICAgICAgICgpID0+IG1vZGlmaWVkX3RyYW5zYWN0aW9ucz8uc29ydCgoYSwgYikgPT4gYi5zdWJtaXRfZGF0ZSAtIGEuc3VibWl0X2RhdGUpLFxuICAgICAgICBbbW9kaWZpZWRfdHJhbnNhY3Rpb25zXVxuICAgICk7XG4gICAgLy8gR2V0IHRoZSBsYXN0IHRyYW5zYWN0aW9uIGlmIGV4aXN0cy5cbiAgICBjb25zdCBsYXN0X3RyYW5zYWN0aW9uID0gbW9kaWZpZWRfdHJhbnNhY3Rpb25zPy5bMF07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKiogTGlzdCBvZiB1c2VyIHRyYW5zYWN0aW9ucyBzb3J0ZWQgYnkgc3VibWl0IHRpbWUuICovXG4gICAgICAgIGRhdGE6IHNvcnRlZF90cmFuc2FjdGlvbnMsXG4gICAgICAgIC8qKiBSZXR1cm5zIHRoZSBsYXN0IHRyYW5zYWN0aW9uIGlmIGV4aXN0cy4gKi9cbiAgICAgICAgbGFzdF90cmFuc2FjdGlvbixcbiAgICAgICAgLyoqIFJlc2V0IHRyYW5zYWN0aW9ucyBkYXRhICovXG4gICAgICAgIHJlc2V0RGF0YSxcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAuLi5yZXN0LFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VDcnlwdG9UcmFuc2FjdGlvbnM7XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VNdXRhdGlvbiBmcm9tICcuLi91c2VNdXRhdGlvbic7XG5cbnR5cGUgVFBheWxvYWQgPSBPbWl0PFxuICAgIE5vbk51bGxhYmxlPFBhcmFtZXRlcnM8UmV0dXJuVHlwZTx0eXBlb2YgdXNlTXV0YXRpb248J2Nhc2hpZXInPj5bJ211dGF0ZSddPj5bMF1bJ3BheWxvYWQnXSxcbiAgICAnY2FzaGllcicgfCAncHJvdmlkZXInIHwgJ3R5cGUnXG4+O1xuXG4vKiogQSBjdXN0b20gaG9vayB0aGF0IHVzZWQgZm9yIGNyeXB0byB3aXRoZHJhd2FsICovXG5jb25zdCB1c2VDcnlwdG9XaXRoZHJhd2FsID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgbXV0YXRlOiBfbXV0YXRlLCAuLi5yZXN0IH0gPSB1c2VNdXRhdGlvbignY2FzaGllcicpO1xuXG4gICAgY29uc3QgbXV0YXRlID0gdXNlQ2FsbGJhY2soXG4gICAgICAgIChwYXlsb2FkOiBUUGF5bG9hZCkgPT5cbiAgICAgICAgICAgIF9tdXRhdGUoeyBwYXlsb2FkOiB7IGNhc2hpZXI6ICd3aXRoZHJhdycsIHByb3ZpZGVyOiAnY3J5cHRvJywgdHlwZTogJ2FwaScsIC4uLnBheWxvYWQgfSB9KSxcbiAgICAgICAgW19tdXRhdGVdXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKiBGdW5jdGlvbiB0byByZXF1ZXN0IGZvciBjcnlwdG8gd2l0aGRyYXdhbCAqL1xuICAgICAgICBtdXRhdGUsXG4gICAgICAgIC4uLnJlc3QsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUNyeXB0b1dpdGhkcmF3YWw7XG4iLCJpbXBvcnQgdXNlUXVlcnkgZnJvbSAnLi4vdXNlUXVlcnknO1xuaW1wb3J0IHVzZUFjdGl2ZUFjY291bnQgZnJvbSAnLi91c2VBY3RpdmVBY2NvdW50JztcblxuLyoqIEEgY3VzdG9tIGhvb2sgdGhhdCBnZXQgU2VydmljZSBUb2tlbiBmb3IgQ1RyYWRlciBQbGF0Zm9ybS4gKi9cbmNvbnN0IHVzZUN0cmFkZXJTZXJ2aWNlVG9rZW4gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBkYXRhOiBhY2NvdW50IH0gPSB1c2VBY3RpdmVBY2NvdW50KCk7XG4gICAgY29uc3QgeyBkYXRhOiBjdHJhZGVyX3Rva2VuLCAuLi5yZXN0IH0gPSB1c2VRdWVyeSgnc2VydmljZV90b2tlbicsIHtcbiAgICAgICAgcGF5bG9hZDogeyBzZXJ2aWNlOiAnY3RyYWRlcicsIHNlcnZlcjogYWNjb3VudD8uaXNfdmlydHVhbCA/ICdkZW1vJyA6ICdyZWFsJyB9LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqIHJldHVybiB0aGUgY3RyYWRlciBhY2NvdW50IHRva2VuICovXG4gICAgICAgIGRhdGE6IGN0cmFkZXJfdG9rZW4/LnNlcnZpY2VfdG9rZW4/LmN0cmFkZXI/LnRva2VuLFxuICAgICAgICAuLi5yZXN0LFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VDdHJhZGVyU2VydmljZVRva2VuO1xuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlTXV0YXRpb24gZnJvbSAnLi4vdXNlTXV0YXRpb24nO1xuXG4vKiogQSBjdXN0b20gaG9vayB0byBnZXQgdGhlIGRlcG9zaXQgY3J5cHRvIGFkZHJlc3MuICovXG5jb25zdCB1c2VEZXBvc2l0Q3J5cHRvQWRkcmVzcyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGRhdGEsIG11dGF0ZTogX211dGF0ZSwgLi4ucmVzdCB9ID0gdXNlTXV0YXRpb24oJ2Nhc2hpZXInKTtcbiAgICBjb25zdCBkZXBvc2l0X2FkZHJlc3MgPSB0eXBlb2YgZGF0YT8uY2FzaGllciAhPT0gJ3N0cmluZycgPyBkYXRhPy5jYXNoaWVyPy5kZXBvc2l0Py5hZGRyZXNzIDogdW5kZWZpbmVkO1xuXG4gICAgY29uc3QgbXV0YXRlID0gdXNlQ2FsbGJhY2soXG4gICAgICAgICgpID0+IF9tdXRhdGUoeyBwYXlsb2FkOiB7IGNhc2hpZXI6ICdkZXBvc2l0JywgcHJvdmlkZXI6ICdjcnlwdG8nLCB0eXBlOiAnYXBpJyB9IH0pLFxuICAgICAgICBbX211dGF0ZV1cbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgbXV0YXRlLFxuICAgICAgICBkYXRhOiBkZXBvc2l0X2FkZHJlc3MsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZURlcG9zaXRDcnlwdG9BZGRyZXNzO1xuIiwiLy8gVE9ETzogaGFyZGNvZGVkIGR5bmFtaWMgbGV2ZXJhZ2UgdmFsdWVzLCB0byBiZSByZXBsYWNlZCB3aXRoIEFQSSBjYWxsXG5jb25zdCBkeW5hbWljX2xldmVyYWdlcyA9IFtcbiAgICB7XG4gICAgICAgIGtleTogJ2ZvcmV4JyxcbiAgICAgICAgdGl0bGU6ICdGb3JleCBtYWpvcnMnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJycsXG4gICAgICAgIGxldmVyYWdlOiAnVXAgdG8gMToxNTAwJyxcbiAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZyb206IDAuMDEsXG4gICAgICAgICAgICAgICAgdG86IDEsXG4gICAgICAgICAgICAgICAgbGV2ZXJhZ2U6IDE1MDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZyb206IDEuMDEsXG4gICAgICAgICAgICAgICAgdG86IDUsXG4gICAgICAgICAgICAgICAgbGV2ZXJhZ2U6IDEwMDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZyb206IDUuMDEsXG4gICAgICAgICAgICAgICAgdG86IDEwLFxuICAgICAgICAgICAgICAgIGxldmVyYWdlOiA1MDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZyb206IDEwLjAxLFxuICAgICAgICAgICAgICAgIHRvOiAxNSxcbiAgICAgICAgICAgICAgICBsZXZlcmFnZTogMTAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAga2V5OiAnbWV0YWxzJyxcbiAgICAgICAgdGl0bGU6ICdNZXRhbHMnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJyhYQVVVU0QsIFhBR1VTRCknLFxuICAgICAgICBsZXZlcmFnZTogJ1VwIHRvIDE6MTAwMCcsXG4gICAgICAgIGRhdGE6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmcm9tOiAwLjAxLFxuICAgICAgICAgICAgICAgIHRvOiAxLFxuICAgICAgICAgICAgICAgIGxldmVyYWdlOiAxMDAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmcm9tOiAxLjAxLFxuICAgICAgICAgICAgICAgIHRvOiA1LFxuICAgICAgICAgICAgICAgIGxldmVyYWdlOiA1MDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZyb206IDUuMDEsXG4gICAgICAgICAgICAgICAgdG86IDEwLFxuICAgICAgICAgICAgICAgIGxldmVyYWdlOiAxMDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZyb206IDEwLjAxLFxuICAgICAgICAgICAgICAgIHRvOiAxNSxcbiAgICAgICAgICAgICAgICBsZXZlcmFnZTogNTAsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgIH0sXG4gICAge1xuICAgICAgICBrZXk6ICdjcnlwdG9jdXJyZW5jaWVzJyxcbiAgICAgICAgdGl0bGU6ICdDcnlwdG9jdXJyZW5jaWVzJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICcoQlRDVVNELCBFVEhVU0QpJyxcbiAgICAgICAgbGV2ZXJhZ2U6ICdVcCB0byAxOjMwMCcsXG4gICAgICAgIGRhdGE6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmcm9tOiAwLjAxLFxuICAgICAgICAgICAgICAgIHRvOiAxLFxuICAgICAgICAgICAgICAgIGxldmVyYWdlOiAzMDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZyb206IDEuMDEsXG4gICAgICAgICAgICAgICAgdG86IDMsXG4gICAgICAgICAgICAgICAgbGV2ZXJhZ2U6IDIwMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZnJvbTogMy4wMSxcbiAgICAgICAgICAgICAgICB0bzogNSxcbiAgICAgICAgICAgICAgICBsZXZlcmFnZTogMTAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmcm9tOiA1LjAxLFxuICAgICAgICAgICAgICAgIHRvOiAxMCxcbiAgICAgICAgICAgICAgICBsZXZlcmFnZTogNTAsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgIH0sXG4gICAge1xuICAgICAgICBrZXk6ICdzdG9ja19pbmRpY2VzJyxcbiAgICAgICAgdGl0bGU6ICdTdG9jayBpbmRpY2VzJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICcoVVNfMzAsIFVTXzEwMCwgVVNfNTAwKScsXG4gICAgICAgIGxldmVyYWdlOiAnVXAgdG8gMTozMDAnLFxuICAgICAgICBkYXRhOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZnJvbTogMC4xLFxuICAgICAgICAgICAgICAgIHRvOiA1LFxuICAgICAgICAgICAgICAgIGxldmVyYWdlOiAzMDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZyb206IDUuMSxcbiAgICAgICAgICAgICAgICB0bzogNTAsXG4gICAgICAgICAgICAgICAgbGV2ZXJhZ2U6IDIwMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZnJvbTogNTAuMSxcbiAgICAgICAgICAgICAgICB0bzogNSxcbiAgICAgICAgICAgICAgICBsZXZlcmFnZTogMTAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICB9LFxuXTtcblxuLyoqIEEgY3VzdG9tIGhvb2sgdGhhdCBnZXRzIGR5bmFtaWMgbGV2ZXJhZ2UgdmFsdWVzLiAqL1xuY29uc3QgdXNlRHluYW1pY0xldmVyYWdlID0gKCkgPT4ge1xuICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBBUEkgY2FsbCBvbmNlIHRoZSBlbmRwb2ludCBpcyByZWFkeS5cblxuICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IGR5bmFtaWNfbGV2ZXJhZ2VzLFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VEeW5hbWljTGV2ZXJhZ2U7XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VTdWJzY3JpcHRpb24gZnJvbSAnLi4vdXNlU3Vic2NyaXB0aW9uJztcblxudHlwZSBUUGF5bG9hZCA9IFJlcXVpcmVkPFxuICAgIE5vbk51bGxhYmxlPFBhcmFtZXRlcnM8UmV0dXJuVHlwZTx0eXBlb2YgdXNlU3Vic2NyaXB0aW9uPCdleGNoYW5nZV9yYXRlcyc+Plsnc3Vic2NyaWJlJ10+PlswXVsncGF5bG9hZCddXG4+O1xuXG4vKiogQSBjdXN0b20gaG9vayB0aGF0IGdldHMgZXhjaGFuZ2UgcmF0ZXMgZnJvbSBiYXNlIGN1cnJlbmN5IHRvIHRhcmdldCBjdXJyZW5jeSAqL1xuY29uc3QgdXNlRXhjaGFuZ2VSYXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgZGF0YSwgc3Vic2NyaWJlOiBfc3Vic2NyaWJlLCAuLi5yZXN0IH0gPSB1c2VTdWJzY3JpcHRpb24oJ2V4Y2hhbmdlX3JhdGVzJyk7XG5cbiAgICBjb25zdCBzdWJzY3JpYmUgPSB1c2VDYWxsYmFjayhcbiAgICAgICAgKHBheWxvYWQ6IFRQYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBfc3Vic2NyaWJlKHsgcGF5bG9hZCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgW19zdWJzY3JpYmVdXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKiBUaGUgZXhjaGFuZ2UgcmF0ZXMgcmVzcG9uc2UgKi9cbiAgICAgICAgZGF0YTogZGF0YT8uZXhjaGFuZ2VfcmF0ZXMsXG4gICAgICAgIC8qKiBGdW5jdGlvbiB0byBzdWJzY3JpYmUgdG8gZXhjaGFuZ2UgcmF0ZXMgKi9cbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAuLi5yZXN0LFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VFeGNoYW5nZVJhdGU7XG4iLCJpbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgdXNlUXVlcnkgZnJvbSAnLi4vdXNlUXVlcnknO1xuXG4vKiogQSBjdXN0b20gaG9vayB0aGF0IGdldHMgdGhlIHJlc2lkZW5jZSBsaXN0LiAqL1xuY29uc3QgdXNlUmVzaWRlbmNlTGlzdCA9ICgpID0+IHtcbiAgICBjb25zdCB7IGRhdGEsIC4uLnJlc2lkZW5jZV9saXN0X3Jlc3QgfSA9IHVzZVF1ZXJ5KCdyZXNpZGVuY2VfbGlzdCcpO1xuXG4gICAgLyoqIE1vZGlmeSB0aGUgcmVzaWRlbmNlIGxpc3QgZGF0YS4gKi9cbiAgICBjb25zdCBtb2RpZmllZF9yZXNpZGVuY2VfbGlzdCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEucmVzaWRlbmNlX2xpc3QpIHJldHVybiBbXTtcblxuICAgICAgICByZXR1cm4gZGF0YS5yZXNpZGVuY2VfbGlzdC5tYXAocmVzaWRlbmNlID0+ICh7XG4gICAgICAgICAgICAuLi5yZXNpZGVuY2UsXG4gICAgICAgIH0pKTtcbiAgICB9LCBbZGF0YV0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqIFRoZSByZXNpZGVuY2UgbGlzdCAqL1xuICAgICAgICBkYXRhOiBtb2RpZmllZF9yZXNpZGVuY2VfbGlzdCxcbiAgICAgICAgLi4ucmVzaWRlbmNlX2xpc3RfcmVzdCxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlUmVzaWRlbmNlTGlzdDtcbiIsImltcG9ydCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlQXV0aGVudGljYXRpb24gZnJvbSAnLi91c2VBdXRoZW50aWNhdGlvbic7XG5pbXBvcnQgdXNlUmVzaWRlbmNlTGlzdCBmcm9tICcuL3VzZVJlc2lkZW5jZUxpc3QnO1xuaW1wb3J0IHVzZVNldHRpbmdzIGZyb20gJy4vdXNlU2V0dGluZ3MnO1xuXG4vKiogQSBjdXN0b20gaG9vayB0byBnZXQgdGhlIHByb29mIG9mIGlkZW50aXR5IHZlcmlmaWNhdGlvbiBpbmZvIG9mIHRoZSBjdXJyZW50IHVzZXIuICovXG5jb25zdCB1c2VQT0kgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBkYXRhOiBhdXRoZW50aWNhdGlvbl9kYXRhLCAuLi5yZXN0IH0gPSB1c2VBdXRoZW50aWNhdGlvbigpO1xuICAgIGNvbnN0IHsgZGF0YTogcmVzaWRlbmNlX2xpc3RfZGF0YSB9ID0gdXNlUmVzaWRlbmNlTGlzdCgpO1xuICAgIGNvbnN0IHsgZGF0YTogZ2V0X3NldHRpbmdzX2RhdGEgfSA9IHVzZVNldHRpbmdzKCk7XG5cbiAgICBjb25zdCBwcmV2aW91c19zZXJ2aWNlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxhdGVzdF9wb2lfYXR0ZW1wdCA9IGF1dGhlbnRpY2F0aW9uX2RhdGE/LmF0dGVtcHRzPy5sYXRlc3Q7XG4gICAgICAgIHJldHVybiBsYXRlc3RfcG9pX2F0dGVtcHQ/LnNlcnZpY2U7XG4gICAgfSwgW2F1dGhlbnRpY2F0aW9uX2RhdGE/LmF0dGVtcHRzPy5sYXRlc3RdKTtcblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgdGhlIHByZXZpb3VzIFBPSSBhdHRlbXB0cyBkZXRhaWxzIChpZiBhbnkpXG4gICAgICovXG4gICAgY29uc3QgcHJldmlvdXNfcG9pID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghcHJldmlvdXNfc2VydmljZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZXJ2aWNlcyA9IGF1dGhlbnRpY2F0aW9uX2RhdGE/LmlkZW50aXR5Py5zZXJ2aWNlcztcbiAgICAgICAgaWYgKHNlcnZpY2VzICYmIHNlcnZpY2VzLm1hbnVhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzZXJ2aWNlOiBwcmV2aW91c19zZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogc2VydmljZXMubWFudWFsLnN0YXR1cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjdXJyZW50X3NlcnZpY2UgPSBzZXJ2aWNlcz8uW3ByZXZpb3VzX3NlcnZpY2UgYXMgJ2lkdicgfCAnb25maWRvJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXJ2aWNlOiBwcmV2aW91c19zZXJ2aWNlLFxuICAgICAgICAgICAgc3RhdHVzOiBjdXJyZW50X3NlcnZpY2U/LnN0YXR1cyxcbiAgICAgICAgICAgIHJlcG9ydGVkX3Byb3BlcnRpZXM6IGN1cnJlbnRfc2VydmljZT8ucmVwb3J0ZWRfcHJvcGVydGllcyxcbiAgICAgICAgICAgIGxhc3RfcmVqZWN0ZWQ6IGN1cnJlbnRfc2VydmljZT8ubGFzdF9yZWplY3RlZCxcbiAgICAgICAgICAgIHN1Ym1pc3Npb25zX2xlZnQ6IGN1cnJlbnRfc2VydmljZT8uc3VibWlzc2lvbnNfbGVmdCB8fCAwLFxuICAgICAgICB9O1xuICAgIH0sIFtwcmV2aW91c19zZXJ2aWNlLCBhdXRoZW50aWNhdGlvbl9kYXRhPy5pZGVudGl0eT8uc2VydmljZXNdKTtcblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgdGhlIG5leHQgc3RlcCBiYXNlZCBvbiBhIGZldyBjaGVjay4gUmV0dXJucyBjb25maWd1cmF0aW9uIGZvciBkb2N1bWVudCB2YWxpZGF0aW9uIGFzIHdlbGxcbiAgICAgKi9cbiAgICBjb25zdCBuZXh0X3BvaSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCB1c2VyX2NvdW50cnlfY29kZSA9IGdldF9zZXR0aW5nc19kYXRhPy5jaXRpemVuIHx8IGdldF9zZXR0aW5nc19kYXRhPy5jb3VudHJ5X2NvZGU7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nX3Jlc2lkZW5jZV9kYXRhID0gcmVzaWRlbmNlX2xpc3RfZGF0YT8uZmluZChyID0+IHIudmFsdWUgPT09IHVzZXJfY291bnRyeV9jb2RlKTtcbiAgICAgICAgY29uc3QgaXNfaWR2X3N1cHBvcnRlZCA9IG1hdGNoaW5nX3Jlc2lkZW5jZV9kYXRhPy5pZGVudGl0eT8uc2VydmljZXM/Lmlkdj8uaXNfY291bnRyeV9zdXBwb3J0ZWQ7XG4gICAgICAgIGNvbnN0IGlzX29uZmlkb19zdXBwb3J0ZWQgPSBtYXRjaGluZ19yZXNpZGVuY2VfZGF0YT8uaWRlbnRpdHk/LnNlcnZpY2VzPy5vbmZpZG8/LmRvY3VtZW50c19zdXBwb3J0ZWQ7XG4gICAgICAgIGNvbnN0IHNlcnZpY2VzID0gYXV0aGVudGljYXRpb25fZGF0YT8uaWRlbnRpdHk/LnNlcnZpY2VzO1xuICAgICAgICBjb25zdCBpZHZfc3VibWlzc2lvbl9sZWZ0ID0gc2VydmljZXM/Lmlkdj8uc3VibWlzc2lvbnNfbGVmdCA/PyAwO1xuICAgICAgICBjb25zdCBvbmZpZG9fc3VibWlzc2lvbl9sZWZ0ID0gc2VydmljZXM/Lm9uZmlkbz8uc3VibWlzc2lvbnNfbGVmdCA/PyAwO1xuICAgICAgICBpZiAoaXNfaWR2X3N1cHBvcnRlZCAmJiBpZHZfc3VibWlzc2lvbl9sZWZ0ICYmICFhdXRoZW50aWNhdGlvbl9kYXRhPy5pc19pZHZfZGlzYWxsb3dlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzZXJ2aWNlOiAnaWR2JyxcbiAgICAgICAgICAgICAgICBzdWJtaXNzaW9uX2xlZnQ6IGlkdl9zdWJtaXNzaW9uX2xlZnQsXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRfc3VwcG9ydGVkOiBtYXRjaGluZ19yZXNpZGVuY2VfZGF0YT8uaWRlbnRpdHk/LnNlcnZpY2VzPy5pZHY/LmRvY3VtZW50c19zdXBwb3J0ZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGlzX29uZmlkb19zdXBwb3J0ZWQgJiYgb25maWRvX3N1Ym1pc3Npb25fbGVmdCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzZXJ2aWNlOiAnb25maWRvJyxcbiAgICAgICAgICAgICAgICBzdWJtaXNzaW9uX2xlZnQ6IG9uZmlkb19zdWJtaXNzaW9uX2xlZnQsXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRfc3VwcG9ydGVkOiBtYXRjaGluZ19yZXNpZGVuY2VfZGF0YT8uaWRlbnRpdHk/LnNlcnZpY2VzPy5vbmZpZG8/LmRvY3VtZW50c19zdXBwb3J0ZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXJ2aWNlOiAnbWFudWFsJyxcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGdldF9zZXR0aW5nc19kYXRhPy5jaXRpemVuLFxuICAgICAgICBnZXRfc2V0dGluZ3NfZGF0YT8uY291bnRyeV9jb2RlLFxuICAgICAgICByZXNpZGVuY2VfbGlzdF9kYXRhLFxuICAgICAgICBhdXRoZW50aWNhdGlvbl9kYXRhPy5pZGVudGl0eT8uc2VydmljZXMsXG4gICAgICAgIGF1dGhlbnRpY2F0aW9uX2RhdGE/LmlzX2lkdl9kaXNhbGxvd2VkLFxuICAgIF0pO1xuXG4gICAgY29uc3QgbW9kaWZpZWRfdmVyaWZpY2F0aW9uX2RhdGEgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFhdXRoZW50aWNhdGlvbl9kYXRhKSByZXR1cm47XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmF1dGhlbnRpY2F0aW9uX2RhdGE/LmlkZW50aXR5LFxuICAgICAgICAgICAgcHJldmlvdXM6IHByZXZpb3VzX3BvaSxcbiAgICAgICAgICAgIG5leHQ6IG5leHRfcG9pLFxuICAgICAgICB9O1xuICAgIH0sIFthdXRoZW50aWNhdGlvbl9kYXRhLCBuZXh0X3BvaSwgcHJldmlvdXNfcG9pXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBtb2RpZmllZF92ZXJpZmljYXRpb25fZGF0YSxcbiAgICAgICAgLi4ucmVzdCxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlUE9JO1xuIiwiaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VNVDVBY2NvdW50c0xpc3QgZnJvbSAnLi91c2VNVDVBY2NvdW50c0xpc3QnO1xuaW1wb3J0IHVzZUF2YWlsYWJsZU1UNUFjY291bnRzIGZyb20gJy4vdXNlQXZhaWxhYmxlTVQ1QWNjb3VudHMnO1xuXG4vKiogQSBjdXN0b20gaG9vayB0byBnZXQgdGhlIHNvcnRlZCBhZGRlZCBhbmQgbm9uLWFkZGVkIE1UNSBhY2NvdW50cy4gKi9cbmNvbnN0IHVzZVNvcnRlZE1UNUFjY291bnRzID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgZGF0YTogYWxsX2F2YWlsYWJsZV9tdDVfYWNjb3VudHMgfSA9IHVzZUF2YWlsYWJsZU1UNUFjY291bnRzKCk7XG4gICAgY29uc3QgeyBkYXRhOiBtdDVfYWNjb3VudHMsIC4uLnJlc3QgfSA9IHVzZU1UNUFjY291bnRzTGlzdCgpO1xuXG4gICAgY29uc3QgbW9kaWZpZWRfZGF0YSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoIWFsbF9hdmFpbGFibGVfbXQ1X2FjY291bnRzIHx8ICFtdDVfYWNjb3VudHMpIHJldHVybjtcblxuICAgICAgICByZXR1cm4gYWxsX2F2YWlsYWJsZV9tdDVfYWNjb3VudHM/Lm1hcChhdmFpbGFibGVfYWNjb3VudCA9PiB7XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVkX2FjY291bnQgPSBtdDVfYWNjb3VudHM/LmZpbmQoYWNjb3VudCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlX2FjY291bnQubWFya2V0X3R5cGUgPT09IGFjY291bnQubWFya2V0X3R5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlX2FjY291bnQuc2hvcnRjb2RlID09PSBhY2NvdW50LmxhbmRpbmdfY29tcGFueV9zaG9ydFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjcmVhdGVkX2FjY291bnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY3JlYXRlZF9hY2NvdW50LFxuICAgICAgICAgICAgICAgICAgICAvKiogRGV0ZXJtaW5lIGlmIHRoZSBhY2NvdW50IGlzIGFkZGVkIG9yIG5vdCAqL1xuICAgICAgICAgICAgICAgICAgICBpc19hZGRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9IGFzIGNvbnN0O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmF2YWlsYWJsZV9hY2NvdW50LFxuICAgICAgICAgICAgICAgIC8qKiBEZXRlcm1pbmUgaWYgdGhlIGFjY291bnQgaXMgYWRkZWQgb3Igbm90ICovXG4gICAgICAgICAgICAgICAgaXNfYWRkZWQ6IGZhbHNlLFxuICAgICAgICAgICAgfSBhcyBjb25zdDtcbiAgICAgICAgfSk7XG4gICAgfSwgW2FsbF9hdmFpbGFibGVfbXQ1X2FjY291bnRzLCBtdDVfYWNjb3VudHNdKTtcblxuICAgIC8vIC8vIFJlZHVjZSBvdXQgdGhlIGFkZGVkIGFuZCBub24gYWRkZWQgYWNjb3VudHMgdG8gbWFrZSBzdXJlIG9ubHkgb25lIG9mIGVhY2ggbWFya2V0X3R5cGUgaXMgc2hvd24gZm9yIG5vdCBhZGRlZFxuICAgIGNvbnN0IGZpbHRlcmVkX2RhdGEgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFtb2RpZmllZF9kYXRhKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgYWRkZWRfYWNjb3VudHMgPSBtb2RpZmllZF9kYXRhLmZpbHRlcihhY2NvdW50ID0+IGFjY291bnQuaXNfYWRkZWQpO1xuICAgICAgICBjb25zdCBub25fYWRkZWRfYWNjb3VudHMgPSBtb2RpZmllZF9kYXRhLmZpbHRlcihhY2NvdW50ID0+ICFhY2NvdW50LmlzX2FkZGVkKTtcblxuICAgICAgICBjb25zdCBmaWx0ZXJlZF9ub25fYWRkZWRfYWNjb3VudHMgPSBub25fYWRkZWRfYWNjb3VudHMucmVkdWNlKChhY2MsIGFjY291bnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nX2FjY291bnQgPSBhY2MuZmluZChhY2NfYWNjb3VudCA9PiBhY2NfYWNjb3VudC5tYXJrZXRfdHlwZSA9PT0gYWNjb3VudC5tYXJrZXRfdHlwZSk7XG4gICAgICAgICAgICBjb25zdCBhZGRlZF9hY2NvdW50ID0gYWRkZWRfYWNjb3VudHMuZmluZChhY2NfYWNjb3VudCA9PiBhY2NfYWNjb3VudC5tYXJrZXRfdHlwZSA9PT0gYWNjb3VudC5tYXJrZXRfdHlwZSk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdfYWNjb3VudCB8fCBhZGRlZF9hY2NvdW50KSByZXR1cm4gYWNjO1xuXG4gICAgICAgICAgICByZXR1cm4gWy4uLmFjYywgYWNjb3VudF07XG4gICAgICAgIH0sIFtdIGFzIHR5cGVvZiBub25fYWRkZWRfYWNjb3VudHMpO1xuXG4gICAgICAgIHJldHVybiBbLi4uYWRkZWRfYWNjb3VudHMsIC4uLmZpbHRlcmVkX25vbl9hZGRlZF9hY2NvdW50c107XG4gICAgfSwgW21vZGlmaWVkX2RhdGFdKTtcblxuICAgIC8vIFNvcnQgdGhlIGRhdGEgYnkgbWFya2V0X3R5cGUgdG8gbWFrZSBzdXJlIHRoZSBvcmRlciBpcyAnc3ludGhldGljJywgJ2ZpbmFuY2lhbCcsICdhbGwnXG4gICAgY29uc3Qgc29ydGVkX2RhdGEgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3QgbWFya2V0X3R5cGVfb3JkZXIgPSBbJ3N5bnRoZXRpYycsICdmaW5hbmNpYWwnLCAnYWxsJ107XG5cbiAgICAgICAgaWYgKCFmaWx0ZXJlZF9kYXRhKSByZXR1cm47XG5cbiAgICAgICAgY29uc3Qgc29ydGVkX2RhdGEgPSBtYXJrZXRfdHlwZV9vcmRlci5yZWR1Y2UoKGFjYywgbWFya2V0X3R5cGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gZmlsdGVyZWRfZGF0YS5maWx0ZXIoYWNjb3VudCA9PiBhY2NvdW50Lm1hcmtldF90eXBlID09PSBtYXJrZXRfdHlwZSk7XG4gICAgICAgICAgICBpZiAoIWFjY291bnRzLmxlbmd0aCkgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIHJldHVybiBbLi4uYWNjLCAuLi5hY2NvdW50c107XG4gICAgICAgIH0sIFtdIGFzIHR5cGVvZiBmaWx0ZXJlZF9kYXRhKTtcblxuICAgICAgICByZXR1cm4gc29ydGVkX2RhdGE7XG4gICAgfSwgW2ZpbHRlcmVkX2RhdGFdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHNvcnRlZF9kYXRhLFxuICAgICAgICAuLi5yZXN0LFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VTb3J0ZWRNVDVBY2NvdW50cztcbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZU11dGF0aW9uIGZyb20gJy4uL3VzZU11dGF0aW9uJztcblxudHlwZSBUUGF5bG9hZCA9IFBhcmFtZXRlcnM8XG4gICAgUmV0dXJuVHlwZTx0eXBlb2YgdXNlTXV0YXRpb248J3RyYWRpbmdfcGxhdGZvcm1faW52ZXN0b3JfcGFzc3dvcmRfY2hhbmdlJz4+WydtdXRhdGUnXVxuPlswXVsncGF5bG9hZCddO1xuXG4vKiogQSBjdXN0b20gaG9vayB0aGF0IGNoYW5nZSB0aGUgVHJhZGluZyBQbGF0Zm9ybSBJbnZlc3RvciBQYXNzd29yZC4gKi9cbmNvbnN0IHVzZVRyYWRpbmdQbGF0Zm9ybUludmVzdG9yUGFzc3dvcmRDaGFuZ2UgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBtdXRhdGU6IF9tdXRhdGUsIC4uLnJlc3QgfSA9IHVzZU11dGF0aW9uKCd0cmFkaW5nX3BsYXRmb3JtX2ludmVzdG9yX3Bhc3N3b3JkX2NoYW5nZScpO1xuXG4gICAgY29uc3QgbXV0YXRlID0gdXNlQ2FsbGJhY2soKHBheWxvYWQ6IFRQYXlsb2FkKSA9PiBfbXV0YXRlKHsgcGF5bG9hZCB9KSwgW19tdXRhdGVdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKiBUaGUgbXV0YXRpb24gZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgcGF5bG9hZCBhbmQgc2VuZHMgaXQgdG8gdGhlIHNlcnZlciAqL1xuICAgICAgICBtdXRhdGUsXG4gICAgICAgIC4uLnJlc3QsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZVRyYWRpbmdQbGF0Zm9ybUludmVzdG9yUGFzc3dvcmRDaGFuZ2U7XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VNdXRhdGlvbiBmcm9tICcuLi91c2VNdXRhdGlvbic7XG5cbnR5cGUgVFBheWxvYWQgPSBQYXJhbWV0ZXJzPFxuICAgIFJldHVyblR5cGU8dHlwZW9mIHVzZU11dGF0aW9uPCd0cmFkaW5nX3BsYXRmb3JtX2ludmVzdG9yX3Bhc3N3b3JkX3Jlc2V0Jz4+WydtdXRhdGUnXVxuPlswXVsncGF5bG9hZCddO1xuXG4vKiogQSBjdXN0b20gaG9vayB0aGF0IHJlc2V0IHRoZSBUcmFkaW5nIFBsYXRmb3JtIEludmVzdG9yIFBhc3N3b3JkLiAqL1xuY29uc3QgdXNlVHJhZGluZ1BsYXRmb3JtSW52ZXN0b3JQYXNzd29yZFJlc2V0ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgbXV0YXRlOiBfbXV0YXRlLCAuLi5yZXN0IH0gPSB1c2VNdXRhdGlvbigndHJhZGluZ19wbGF0Zm9ybV9pbnZlc3Rvcl9wYXNzd29yZF9yZXNldCcpO1xuXG4gICAgY29uc3QgbXV0YXRlID0gdXNlQ2FsbGJhY2soKHBheWxvYWQ6IFRQYXlsb2FkKSA9PiBfbXV0YXRlKHsgcGF5bG9hZCB9KSwgW19tdXRhdGVdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKiBUaGUgbXV0YXRpb24gZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgcGF5bG9hZCBhbmQgc2VuZHMgaXQgdG8gdGhlIHNlcnZlciAqL1xuICAgICAgICBtdXRhdGUsXG4gICAgICAgIC4uLnJlc3QsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZVRyYWRpbmdQbGF0Zm9ybUludmVzdG9yUGFzc3dvcmRSZXNldDtcbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZU11dGF0aW9uIGZyb20gJy4uL3VzZU11dGF0aW9uJztcblxudHlwZSBUUGF5bG9hZCA9IFBhcmFtZXRlcnM8UmV0dXJuVHlwZTx0eXBlb2YgdXNlTXV0YXRpb248J3RyYWRpbmdfcGxhdGZvcm1fcGFzc3dvcmRfY2hhbmdlJz4+WydtdXRhdGUnXT5bMF1bJ3BheWxvYWQnXTtcblxuLyoqIEEgY3VzdG9tIGhvb2sgdGhhdCBjaGFuZ2UgdGhlIFRyYWRpbmcgUGxhdGZvcm0gUGFzc3dvcmQuICovXG5jb25zdCB1c2VUcmFkaW5nUGxhdGZvcm1QYXNzd29yZENoYW5nZSA9ICgpID0+IHtcbiAgICBjb25zdCB7IG11dGF0ZTogX211dGF0ZSwgLi4ucmVzdCB9ID0gdXNlTXV0YXRpb24oJ3RyYWRpbmdfcGxhdGZvcm1fcGFzc3dvcmRfY2hhbmdlJyk7XG5cbiAgICBjb25zdCBtdXRhdGUgPSB1c2VDYWxsYmFjaygocGF5bG9hZDogVFBheWxvYWQpID0+IF9tdXRhdGUoeyBwYXlsb2FkIH0pLCBbX211dGF0ZV0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqIFRoZSBtdXRhdGlvbiBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYSBwYXlsb2FkIGFuZCBzZW5kcyBpdCB0byB0aGUgc2VydmVyICovXG4gICAgICAgIG11dGF0ZSxcbiAgICAgICAgLi4ucmVzdCxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlVHJhZGluZ1BsYXRmb3JtUGFzc3dvcmRDaGFuZ2U7XG4iLCJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZUluZmluaXRlUXVlcnkgZnJvbSAnLi4vdXNlSW5maW5pdGVRdWVyeSc7XG5pbXBvcnQgeyBUU29ja2V0UmVxdWVzdFBheWxvYWQgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgdXNlQXV0aG9yaXplIGZyb20gJy4vdXNlQXV0aG9yaXplJztcbmltcG9ydCB1c2VJbnZhbGlkYXRlUXVlcnkgZnJvbSAnLi4vdXNlSW52YWxpZGF0ZVF1ZXJ5JztcblxudHlwZSBURmlsdGVyID0gTm9uTnVsbGFibGU8VFNvY2tldFJlcXVlc3RQYXlsb2FkPCdzdGF0ZW1lbnQnPlsncGF5bG9hZCddPlsnYWN0aW9uX3R5cGUnXTtcblxuLyoqIEEgY3VzdG9tIGhvb2sgdG8gZ2V0IHRoZSBzdW1tYXJ5IG9mIGFjY291bnQgdHJhbnNhY3Rpb25zICovXG5jb25zdCB1c2VUcmFuc2FjdGlvbnMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBpc0ZldGNoaW5nLCBpc1N1Y2Nlc3MgfSA9IHVzZUF1dGhvcml6ZSgpO1xuICAgIGNvbnN0IFtmaWx0ZXIsIHNldEZpbHRlcl0gPSB1c2VTdGF0ZTxURmlsdGVyPigpO1xuICAgIGNvbnN0IGludmFsaWRhdGUgPSB1c2VJbnZhbGlkYXRlUXVlcnkoKTtcbiAgICBjb25zdCB7IGRhdGEsIGZldGNoTmV4dFBhZ2UsIHJlbW92ZSwgLi4ucmVzdCB9ID0gdXNlSW5maW5pdGVRdWVyeSgnc3RhdGVtZW50Jywge1xuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBlbmFibGVkOiAhaXNGZXRjaGluZyAmJiBpc1N1Y2Nlc3MsXG4gICAgICAgICAgICBnZXROZXh0UGFnZVBhcmFtOiAobGFzdFBhZ2UsIHBhZ2VzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFsYXN0UGFnZT8uc3RhdGVtZW50Py5jb3VudCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhZ2VzLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgIGFjdGlvbl90eXBlOiBmaWx0ZXIsXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpbnZhbGlkYXRlKCdzdGF0ZW1lbnQnKTtcbiAgICB9LCBbZmlsdGVyLCBpbnZhbGlkYXRlXSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVtb3ZlKCk7XG4gICAgICAgIH07XG4gICAgfSwgW3JlbW92ZV0pO1xuXG4gICAgLy8gRmxhdHRlbiB0aGUgZGF0YSBhcnJheS5cbiAgICBjb25zdCBmbGF0dGVuX2RhdGEgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFkYXRhPy5wYWdlcz8ubGVuZ3RoKSByZXR1cm47XG5cbiAgICAgICAgcmV0dXJuIGRhdGE/LnBhZ2VzPy5mbGF0TWFwKHBhZ2UgPT4gcGFnZT8uc3RhdGVtZW50Py50cmFuc2FjdGlvbnMpO1xuICAgIH0sIFtkYXRhPy5wYWdlc10pO1xuXG4gICAgLy8gTW9kaWZ5IHRoZSBkYXRhLlxuICAgIGNvbnN0IG1vZGlmaWVkX2RhdGEgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFmbGF0dGVuX2RhdGE/Lmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgICAgIHJldHVybiBmbGF0dGVuX2RhdGE/Lm1hcCh0cmFuc2FjdGlvbiA9PiAoe1xuICAgICAgICAgICAgLi4udHJhbnNhY3Rpb24sXG4gICAgICAgIH0pKTtcbiAgICB9LCBbZmxhdHRlbl9kYXRhXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKiogTGlzdCBvZiBhY2NvdW50IHRyYW5zYWN0aW9ucyAqL1xuICAgICAgICBkYXRhOiBtb2RpZmllZF9kYXRhLFxuICAgICAgICAvKiogRmV0Y2ggdGhlIG5leHQgcGFnZSBvZiB0cmFuc2FjdGlvbnMgKi9cbiAgICAgICAgZmV0Y2hOZXh0UGFnZSxcbiAgICAgICAgLyoqIEZpbHRlciB0aGUgdHJhbnNhY3Rpb25zIGJ5IHR5cGUgKi9cbiAgICAgICAgc2V0RmlsdGVyLFxuICAgICAgICAuLi5yZXN0LFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VUcmFuc2FjdGlvbnM7XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VNdXRhdGlvbiBmcm9tICcuLi91c2VNdXRhdGlvbic7XG5cbnR5cGUgVFBheWxvYWQgPSBOb25OdWxsYWJsZTxcbiAgICBOb25OdWxsYWJsZTxQYXJhbWV0ZXJzPFJldHVyblR5cGU8dHlwZW9mIHVzZU11dGF0aW9uPCd0cmFuc2Zlcl9iZXR3ZWVuX2FjY291bnRzJz4+WydtdXRhdGUnXT5bMF0+WydwYXlsb2FkJ11cbj47XG5cbi8qKiBBIGN1c3RvbSBob29rIHVzZWQgdG8gdHJhbnNmZXIgbW9uZXkgYmV0d2VlbiBjbGllbnQgYWNjb3VudHMgKi9cbmNvbnN0IHVzZVRyYW5zZmVyQmV0d2VlbkFjY291bnRzID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgbXV0YXRlOiBfbXV0YXRlLCAuLi5yZXN0IH0gPSB1c2VNdXRhdGlvbigndHJhbnNmZXJfYmV0d2Vlbl9hY2NvdW50cycpO1xuXG4gICAgY29uc3QgbXV0YXRlID0gdXNlQ2FsbGJhY2soKHBheWxvYWQ6IFRQYXlsb2FkKSA9PiBfbXV0YXRlKHsgcGF5bG9hZCB9KSwgW19tdXRhdGVdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKiBUaGUgbXV0YXRpb24gZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgcGF5bG9hZCBhbmQgc2VuZHMgaXQgdG8gdGhlIHNlcnZlciAqL1xuICAgICAgICBtdXRhdGUsXG4gICAgICAgIC4uLnJlc3QsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZVRyYW5zZmVyQmV0d2VlbkFjY291bnRzO1xuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlTXV0YXRpb24gZnJvbSAnLi4vdXNlTXV0YXRpb24nO1xuXG50eXBlIFRQYXlsb2FkID0gUGFyYW1ldGVyczxSZXR1cm5UeXBlPHR5cGVvZiB1c2VNdXRhdGlvbjwndmVyaWZ5X2VtYWlsJz4+WydtdXRhdGUnXT5bMF1bJ3BheWxvYWQnXTtcblxuLyoqIEEgY3VzdG9tIGhvb2sgZm9yIHZlcmlmeWluZyBlbWFpbCBhZGRyZXNzICovXG5jb25zdCB1c2VWZXJpZnlFbWFpbCA9ICgpID0+IHtcbiAgICBjb25zdCB7IG11dGF0ZTogX211dGF0ZSwgLi4ucmVzdCB9ID0gdXNlTXV0YXRpb24oJ3ZlcmlmeV9lbWFpbCcpO1xuXG4gICAgY29uc3QgbXV0YXRlID0gdXNlQ2FsbGJhY2soKHBheWxvYWQ6IFRQYXlsb2FkKSA9PiBfbXV0YXRlKHsgcGF5bG9hZCB9KSwgW19tdXRhdGVdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKiBUaGUgbXV0YXRpb24gZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgcGF5bG9hZCBhbmQgc2VuZHMgaXQgdG8gdGhlIHNlcnZlciAqL1xuICAgICAgICBtdXRhdGUsXG4gICAgICAgIC4uLnJlc3QsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZVZlcmlmeUVtYWlsO1xuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlQXV0aG9yaXplIGZyb20gJy4vdXNlQXV0aG9yaXplJztcbmltcG9ydCB1c2VJbnZhbGlkYXRlUXVlcnkgZnJvbSAnLi4vdXNlSW52YWxpZGF0ZVF1ZXJ5JztcbmltcG9ydCB1c2VNdXRhdGlvbiBmcm9tICcuLi91c2VNdXRhdGlvbic7XG5pbXBvcnQgdXNlUXVlcnkgZnJvbSAnLi4vdXNlUXVlcnknO1xuXG4vKiogQSBjdXN0b20gaG9vayB0byBnZXQgdGhlIHN0YXR1cyBvZiB3YWxsZXRfbWlncmF0aW9uIEFQSSBhbmQgdG8gc3RhcnQvcmVzZXQgdGhlIG1pZ3JhdGlvbiBwcm9jZXNzICovXG5jb25zdCB1c2VXYWxsZXRNaWdyYXRpb24gPSAoKSA9PiB7XG4gICAgY29uc3QgaW52YWxpZGF0ZSA9IHVzZUludmFsaWRhdGVRdWVyeSgpO1xuXG4gICAgLyoqIE1ha2UgYSByZXF1ZXN0IHRvIHdhbGxldF9taWdyYXRpb24gQVBJIGFuZCBvblN1Y2Nlc3MgaXQgd2lsbCBpbnZhbGlkYXRlIHRoZSBjYWNoZWQgZGF0YSAgKi9cbiAgICBjb25zdCB7IG11dGF0ZSB9ID0gdXNlTXV0YXRpb24oJ3dhbGxldF9taWdyYXRpb24nLCB7IG9uU3VjY2VzczogKCkgPT4gaW52YWxpZGF0ZSgnd2FsbGV0X21pZ3JhdGlvbicpIH0pO1xuXG4gICAgY29uc3QgeyBpc1N1Y2Nlc3MgfSA9IHVzZUF1dGhvcml6ZSgpO1xuXG4gICAgLyoqIEZldGNoIHRoZSB3YWxsZXRfbWlncmF0aW9uIEFQSSBhbmQgcmVmZXRjaCBpdCBldmVyeSBzZWNvbmQgaWYgdGhlIHN0YXR1cyBpcyBpbl9wcm9ncmVzcyAqL1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gdXNlUXVlcnkoJ3dhbGxldF9taWdyYXRpb24nLCB7XG4gICAgICAgIHBheWxvYWQ6IHsgd2FsbGV0X21pZ3JhdGlvbjogJ3N0YXRlJyB9LFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICByZWZldGNoSW50ZXJ2YWw6IHJlc3BvbnNlID0+IChyZXNwb25zZT8ud2FsbGV0X21pZ3JhdGlvbj8uc3RhdGUgPT09ICdpbl9wcm9ncmVzcycgPyA1MDAgOiBmYWxzZSksXG4gICAgICAgICAgICBlbmFibGVkOiBpc1N1Y2Nlc3MsXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBzdGFydE1pZ3JhdGlvbiA9IHVzZUNhbGxiYWNrKCgpID0+IG11dGF0ZSh7IHBheWxvYWQ6IHsgd2FsbGV0X21pZ3JhdGlvbjogJ3N0YXJ0JyB9IH0pLCBbbXV0YXRlXSk7XG5cbiAgICBjb25zdCByZXNldE1pZ3JhdGlvbiA9IHVzZUNhbGxiYWNrKCgpID0+IG11dGF0ZSh7IHBheWxvYWQ6IHsgd2FsbGV0X21pZ3JhdGlvbjogJ3Jlc2V0JyB9IH0pLCBbbXV0YXRlXSk7XG5cbiAgICBjb25zdCBzdGF0ZSA9IGRhdGE/LndhbGxldF9taWdyYXRpb24/LnN0YXRlO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqIFRoZSBzdGF0dXMgb2YgdGhlIHdhbGxldF9taWdyYXRpb24gQVBJICovXG4gICAgICAgIHN0YXRlLFxuICAgICAgICAvKiogQSBib29sZWFuIHRvIGNoZWNrIGlmIHRoZSBzdGF0dXMgaXMgbm90X2VsaWdpYmxlICovXG4gICAgICAgIGlzX2luZWxpZ2libGU6IHN0YXRlID09PSAnaW5lbGlnaWJsZScsXG4gICAgICAgIC8qKiBBIGJvb2xlYW4gdG8gY2hlY2sgaWYgdGhlIHN0YXR1cyBpcyBlbGlnaWJsZSAqL1xuICAgICAgICBpc19lbGlnaWJsZTogc3RhdGUgPT09ICdlbGlnaWJsZScsXG4gICAgICAgIC8qKiBBIGJvb2xlYW4gdG8gY2hlY2sgaWYgdGhlIHN0YXR1cyBpcyBpbl9wcm9ncmVzcyAqL1xuICAgICAgICBpc19pbl9wcm9ncmVzczogc3RhdGUgPT09ICdpbl9wcm9ncmVzcycsXG4gICAgICAgIC8qKiBBIGJvb2xlYW4gdG8gY2hlY2sgaWYgdGhlIHN0YXR1cyBpcyBjb21wbGV0ZWQgKi9cbiAgICAgICAgaXNfbWlncmF0ZWQ6IHN0YXRlID09PSAnbWlncmF0ZWQnLFxuICAgICAgICAvKiogQSBib29sZWFuIHRvIGNoZWNrIGlmIHRoZSBzdGF0dXMgaXMgZmFpbGVkICovXG4gICAgICAgIGlzX2ZhaWxlZDogc3RhdGUgPT09ICdmYWlsZWQnLFxuICAgICAgICAvKiogU2VuZHMgYSByZXF1ZXN0IHRvIHdhbGxldF9taWdyYXRpb24gQVBJIHRvIHN0YXJ0IHRoZSBtaWdyYXRpb24gcHJvY2VzcyAqL1xuICAgICAgICBzdGFydE1pZ3JhdGlvbixcbiAgICAgICAgLyoqIFNlbmRzIGEgcmVxdWVzdCB0byB3YWxsZXRfbWlncmF0aW9uIEFQSSB0byByZXNldCB0aGUgbWlncmF0aW9uIHByb2Nlc3MgKi9cbiAgICAgICAgcmVzZXRNaWdyYXRpb24sXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZVdhbGxldE1pZ3JhdGlvbjtcbiIsImltcG9ydCB1c2VRdWVyeSBmcm9tICcuLi91c2VRdWVyeSc7XG5pbXBvcnQgdXNlQWN0aXZlQWNjb3VudCBmcm9tICcuL3VzZUFjdGl2ZUFjY291bnQnO1xuXG4vKiogQSBjdXN0b20gaG9vayB0aGF0IGdldCBTZXJ2aWNlIFRva2VuIGZvciBEZXJpdiBYIFBsYXRmb3JtLiAqL1xuY29uc3QgdXNlRHh0cmFkZVNlcnZpY2VUb2tlbiA9ICgpID0+IHtcbiAgICBjb25zdCB7IGRhdGE6IGFjY291bnQgfSA9IHVzZUFjdGl2ZUFjY291bnQoKTtcbiAgICBjb25zdCB7IGRhdGE6IGR4dHJhZGVfdG9rZW4sIC4uLnJlc3QgfSA9IHVzZVF1ZXJ5KCdzZXJ2aWNlX3Rva2VuJywge1xuICAgICAgICBwYXlsb2FkOiB7IHNlcnZpY2U6ICdkeHRyYWRlJywgc2VydmVyOiBhY2NvdW50Py5pc192aXJ0dWFsID8gJ2RlbW8nIDogJ3JlYWwnIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKiogcmV0dXJuIHRoZSBEZXJpdiBYIGFjY291bnQgdG9rZW4gKi9cbiAgICAgICAgZGF0YTogZHh0cmFkZV90b2tlbj8uc2VydmljZV90b2tlbj8uZHh0cmFkZT8udG9rZW4sXG4gICAgICAgIC4uLnJlc3QsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUR4dHJhZGVTZXJ2aWNlVG9rZW47XG4iLCJleHBvcnQgeyBkZWZhdWx0IGFzIHVzZUFjY291bnRMaW1pdHMgfSBmcm9tICcuL3VzZUFjY291bnRMaW1pdHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VBY2NvdW50U3RhdHVzIH0gZnJvbSAnLi91c2VBY2NvdW50U3RhdHVzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlQWNjb3VudFR5cGVzIH0gZnJvbSAnLi91c2VBY2NvdW50VHlwZXMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VBY2NvdW50c0xpc3QgfSBmcm9tICcuL3VzZUFjY291bnRzTGlzdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZUFjdGl2ZUFjY291bnQgfSBmcm9tICcuL3VzZUFjdGl2ZUFjY291bnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VBY3RpdmVUcmFkaW5nQWNjb3VudCB9IGZyb20gJy4vdXNlQWN0aXZlVHJhZGluZ0FjY291bnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VBY3RpdmVXYWxsZXRBY2NvdW50IH0gZnJvbSAnLi91c2VBY3RpdmVXYWxsZXRBY2NvdW50JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlQWxsQXZhaWxhYmxlQWNjb3VudHMgfSBmcm9tICcuL3VzZUFsbEF2YWlsYWJsZUFjY291bnRzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlQXV0aGVudGljYXRpb24gfSBmcm9tICcuL3VzZUF1dGhlbnRpY2F0aW9uJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlQXV0aG9yaXplIH0gZnJvbSAnLi91c2VBdXRob3JpemUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VBdmFpbGFibGVNVDVBY2NvdW50cyB9IGZyb20gJy4vdXNlQXZhaWxhYmxlTVQ1QWNjb3VudHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VBdmFpbGFibGVXYWxsZXRzIH0gZnJvbSAnLi91c2VBdmFpbGFibGVXYWxsZXRzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlQmFsYW5jZSB9IGZyb20gJy4vdXNlQmFsYW5jZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZUNGREFjY291bnRzTGlzdCB9IGZyb20gJy4vdXNlQ0ZEQWNjb3VudHNMaXN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlQ2FuY2VsQ3J5cHRvVHJhbnNhY3Rpb24gfSBmcm9tICcuL3VzZUNhbmNlbENyeXB0b1RyYW5zYWN0aW9uJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlQ2FzaGllckZpYXRBZGRyZXNzIH0gZnJvbSAnLi91c2VDYXNoaWVyRmlhdEFkZHJlc3MnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VDb3VudHJ5Q29uZmlnIH0gZnJvbSAnLi91c2VDb3VudHJ5Q29uZmlnJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlQ3JlYXRlTVQ1QWNjb3VudCB9IGZyb20gJy4vdXNlQ3JlYXRlTVQ1QWNjb3VudCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZUNyZWF0ZU5ld1JlYWxBY2NvdW50IH0gZnJvbSAnLi91c2VDcmVhdGVOZXdSZWFsQWNjb3VudCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZUNyZWF0ZU90aGVyQ0ZEQWNjb3VudCB9IGZyb20gJy4vdXNlQ3JlYXRlT3RoZXJDRkRBY2NvdW50JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlQ3J5cHRvVHJhbnNhY3Rpb25zIH0gZnJvbSAnLi91c2VDcnlwdG9UcmFuc2FjdGlvbnMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VDcnlwdG9XaXRoZHJhd2FsIH0gZnJvbSAnLi91c2VDcnlwdG9XaXRoZHJhd2FsJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlQ3RyYWRlckFjY291bnRzTGlzdCB9IGZyb20gJy4vdXNlQ3RyYWRlckFjY291bnRzTGlzdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZUN0cmFkZXJTZXJ2aWNlVG9rZW4gfSBmcm9tICcuL3VzZUN0cmFkZXJTZXJ2aWNlVG9rZW4nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VDdXJyZW5jeUNvbmZpZyB9IGZyb20gJy4vdXNlQ3VycmVuY3lDb25maWcnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VEZXBvc2l0Q3J5cHRvQWRkcmVzcyB9IGZyb20gJy4vdXNlRGVwb3NpdENyeXB0b0FkZHJlc3MnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VEZXJpdmV6QWNjb3VudHNMaXN0IH0gZnJvbSAnLi91c2VEZXJpdmV6QWNjb3VudHNMaXN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlRGVyaXZlelNlcnZpY2VUb2tlbiB9IGZyb20gJy4vdXNlRGVyaXZlelNlcnZpY2VUb2tlbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZUR4dHJhZGVBY2NvdW50c0xpc3QgfSBmcm9tICcuL3VzZUR4dHJhZGVBY2NvdW50c0xpc3QnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VEeW5hbWljTGV2ZXJhZ2UgfSBmcm9tICcuL3VzZUR5bmFtaWNMZXZlcmFnZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZUV4Y2hhbmdlUmF0ZSB9IGZyb20gJy4vdXNlRXhjaGFuZ2VSYXRlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlR2V0QWNjb3VudFN0YXR1cyB9IGZyb20gJy4vdXNlR2V0QWNjb3VudFN0YXR1cyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZUxhbmRpbmdDb21wYW55IH0gZnJvbSAnLi91c2VMYW5kaW5nQ29tcGFueSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZU1UNUFjY291bnRzTGlzdCB9IGZyb20gJy4vdXNlTVQ1QWNjb3VudHNMaXN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlUE9JIH0gZnJvbSAnLi91c2VQT0knO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VSZXNpZGVuY2VMaXN0IH0gZnJvbSAnLi91c2VSZXNpZGVuY2VMaXN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlU2V0dGluZ3MgfSBmcm9tICcuL3VzZVNldHRpbmdzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlU29ydGVkTVQ1QWNjb3VudHMgfSBmcm9tICcuL3VzZVNvcnRlZE1UNUFjY291bnRzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlVHJhZGluZ0FjY291bnRzTGlzdCB9IGZyb20gJy4vdXNlVHJhZGluZ0FjY291bnRzTGlzdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZVRyYWRpbmdQbGF0Zm9ybUludmVzdG9yUGFzc3dvcmRDaGFuZ2UgfSBmcm9tICcuL3VzZVRyYWRpbmdQbGF0Zm9ybUludmVzdG9yUGFzc3dvcmRDaGFuZ2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VUcmFkaW5nUGxhdGZvcm1JbnZlc3RvclBhc3N3b3JkUmVzZXQgfSBmcm9tICcuL3VzZVRyYWRpbmdQbGF0Zm9ybUludmVzdG9yUGFzc3dvcmRSZXNldCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZVRyYWRpbmdQbGF0Zm9ybVBhc3N3b3JkQ2hhbmdlIH0gZnJvbSAnLi91c2VUcmFkaW5nUGxhdGZvcm1QYXNzd29yZENoYW5nZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZVRyYW5zYWN0aW9ucyB9IGZyb20gJy4vdXNlVHJhbnNhY3Rpb25zJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlVHJhbnNmZXJCZXR3ZWVuQWNjb3VudHMgfSBmcm9tICcuL3VzZVRyYW5zZmVyQmV0d2VlbkFjY291bnRzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlVmVyaWZ5RW1haWwgfSBmcm9tICcuL3VzZVZlcmlmeUVtYWlsJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlV2FsbGV0QWNjb3VudHNMaXN0IH0gZnJvbSAnLi91c2VXYWxsZXRBY2NvdW50c0xpc3QnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VXYWxsZXRNaWdyYXRpb24gfSBmcm9tICcuL3VzZVdhbGxldE1pZ3JhdGlvbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZUR4dHJhZGVTZXJ2aWNlVG9rZW4gfSBmcm9tICcuL3VzZUR4dHJhZGVTZXJ2aWNlVG9rZW4nO1xuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgdHlwZSB7XG4gICAgVFNvY2tldEFjY2VwdGFibGVQcm9wcyxcbiAgICBUU29ja2V0UGFnaW5hdGVhYmxlRW5kcG9pbnROYW1lcyxcbiAgICBUU29ja2V0UmVxdWVzdFBheWxvYWQsXG4gICAgVFNvY2tldFJlcXVlc3RRdWVyeU9wdGlvbnMsXG59IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHVzZVF1ZXJ5IGZyb20gJy4vdXNlUXVlcnknO1xuXG5jb25zdCB1c2VQYWdpbmF0ZWRGZXRjaCA9IDxUIGV4dGVuZHMgVFNvY2tldFBhZ2luYXRlYWJsZUVuZHBvaW50TmFtZXM+KFxuICAgIG5hbWU6IFQsXG4gICAgLi4ucHJvcHM6IFRTb2NrZXRBY2NlcHRhYmxlUHJvcHM8VCwgdHJ1ZT5cbikgPT4ge1xuICAgIGNvbnN0IHByb3AgPSBwcm9wcz8uWzBdO1xuICAgIGNvbnN0IHBheWxvYWQgPSBwcm9wICYmICdwYXlsb2FkJyBpbiBwcm9wID8gKHByb3AucGF5bG9hZCBhcyBUU29ja2V0UmVxdWVzdFBheWxvYWQ8VD4pIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBwcm9wICYmICdvcHRpb25zJyBpbiBwcm9wID8gKHByb3Aub3B0aW9ucyBhcyBUU29ja2V0UmVxdWVzdFF1ZXJ5T3B0aW9uczxUPikgOiB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCBsaW1pdDogbnVtYmVyID0gcGF5bG9hZD8ucGF5bG9hZD8ubGltaXQgfHwgMTA7XG4gICAgY29uc3QgW29mZnNldCwgc2V0T2Zmc2V0XSA9IHVzZVN0YXRlPG51bWJlcj4ocGF5bG9hZD8ucGF5bG9hZD8ub2Zmc2V0IHx8IDApO1xuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBJdCdzIHNhZmUgdG8gaWdub3JlIHRoZSBUUyBlcnJvciBoZXJlIHNpbmNlIHRoZVxuICAgIC8vIGV4YWN0IHR5cGUgb2YgdGhlIHBheWxvYWQgaXMgbm90IGRldGVybWluZWQgYXQgdGhpcyBwb2ludC5cbiAgICBjb25zdCB7IHJlbW92ZSwgLi4ucmVzdCB9ID0gdXNlUXVlcnkobmFtZSwge1xuICAgICAgICBwYXlsb2FkOiB7IC4uLnBheWxvYWQsIG9mZnNldCwgbGltaXQgfSxcbiAgICAgICAgb3B0aW9uczogeyAuLi5vcHRpb25zLCBrZWVwUHJldmlvdXNEYXRhOiAhIW9mZnNldCB9LFxuICAgIH0pO1xuXG4gICAgY29uc3QgbG9hZE1vcmUgPSB1c2VDYWxsYmFjaygoKSA9PiBzZXRPZmZzZXQocHJldiA9PiBwcmV2ICsgbGltaXQpLCBbbGltaXRdKTtcblxuICAgIGNvbnN0IHJlc2V0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgc2V0T2Zmc2V0KDApO1xuICAgIH0sIFtyZW1vdmVdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIHJlbW92ZSxcbiAgICAgICAgbG9hZE1vcmUsXG4gICAgICAgIHJlc2V0LFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VQYWdpbmF0ZWRGZXRjaDtcbiIsImltcG9ydCB1c2VJbmZpbml0ZVF1ZXJ5IGZyb20gJy4vdXNlSW5maW5pdGVRdWVyeSc7XG5pbXBvcnQgdXNlTXV0YXRpb24gZnJvbSAnLi91c2VNdXRhdGlvbic7XG5pbXBvcnQgdXNlUXVlcnkgZnJvbSAnLi91c2VRdWVyeSc7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgQVBJUHJvdmlkZXIgfSBmcm9tICcuL0FQSVByb3ZpZGVyJztcbmV4cG9ydCAqIGZyb20gJy4vaG9va3MnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VJbnZhbGlkYXRlUXVlcnkgfSBmcm9tICcuL3VzZUludmFsaWRhdGVRdWVyeSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZVBhZ2luYXRlZEZldGNoIH0gZnJvbSAnLi91c2VQYWdpbmF0ZWRGZXRjaCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZVN1YnNjcmlwdGlvbiB9IGZyb20gJy4vdXNlU3Vic2NyaXB0aW9uJztcblxuZXhwb3J0IHtcbiAgICB1c2VJbmZpbml0ZVF1ZXJ5LFxuICAgIHVzZU11dGF0aW9uLFxuICAgIHVzZVF1ZXJ5LFxuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgYHVzZVF1ZXJ5YCBpbnN0ZWFkICovXG4gICAgdXNlUXVlcnkgYXMgdXNlRmV0Y2gsXG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBgdXNlTXV0YXRpb25gIGluc3RlYWQgKi9cbiAgICB1c2VNdXRhdGlvbiBhcyB1c2VSZXF1ZXN0LFxufTtcbiIsImltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgU3RvcmVDb250ZXh0IGZyb20gJy4vc3RvcmVDb250ZXh0JztcblxuY29uc3QgdXNlU3RvcmUgPSAoKSA9PiB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VDb250ZXh0KFN0b3JlQ29udGV4dCk7XG5cbiAgICBpZiAoIXN0b3JlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndXNlU3RvcmUgbXVzdCBiZSB1c2VkIHdpdGhpbiBTdG9yZVByb3ZpZGVyJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0b3JlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlU3RvcmU7XG4iLCJpbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlU3Vic2NyaXB0aW9uIH0gZnJvbSAnQGRlcml2L2FwaSc7XG5pbXBvcnQgbWVyZ2UgZnJvbSAnbG9kYXNoLm1lcmdlJztcbmltcG9ydCB7IG9ic2VydmVyIH0gZnJvbSAnbW9ieC1yZWFjdC1saXRlJztcbmltcG9ydCB1c2VTdG9yZSBmcm9tICcuLi91c2VTdG9yZSc7XG5cbmNvbnN0IEV4Y2hhbmdlUmF0ZXNQcm92aWRlciA9IG9ic2VydmVyKCh7IGNoaWxkcmVuIH06IFJlYWN0LlByb3BzV2l0aENoaWxkcmVuPHVua25vd24+KSA9PiB7XG4gICAgY29uc3QgeyBkYXRhLCBzdWJzY3JpYmUgfSA9IHVzZVN1YnNjcmlwdGlvbignZXhjaGFuZ2VfcmF0ZXMnKTtcbiAgICBjb25zdCB7XG4gICAgICAgIGV4Y2hhbmdlX3JhdGVzOiB7IHVwZGF0ZSB9LFxuICAgIH0gPSB1c2VTdG9yZSgpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc3Vic2NyaWJlKHsgcGF5bG9hZDogeyBiYXNlX2N1cnJlbmN5OiAnVVNEJyB9IH0pO1xuICAgIH0sIFtzdWJzY3JpYmVdKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCB7IGV4Y2hhbmdlX3JhdGVzIH0gPSBkYXRhO1xuXG4gICAgICAgICAgICBpZiAoZXhjaGFuZ2VfcmF0ZXMpIHVwZGF0ZShwcmV2ID0+IG1lcmdlKHByZXYsIGV4Y2hhbmdlX3JhdGVzKSk7XG4gICAgICAgIH1cbiAgICB9LCBbdXBkYXRlLCBkYXRhXSk7XG5cbiAgICByZXR1cm4gPD57Y2hpbGRyZW59PC8+O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEV4Y2hhbmdlUmF0ZXNQcm92aWRlcjtcbiIsImV4cG9ydCB7IGRlZmF1bHQgYXMgRXhjaGFuZ2VSYXRlc1Byb3ZpZGVyIH0gZnJvbSAnLi9FeGNoYW5nZVJhdGVzUHJvdmlkZXInO1xuIiwiLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmV4cG9ydCB2YXIgUGVyc2lzdFN0b3JlTWFwID0gbmV3IE1hcCgpO1xuIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbmltcG9ydCB7IFBlcnNpc3RTdG9yZU1hcCB9IGZyb20gJy4vUGVyc2lzdFN0b3JlTWFwJztcbmV4cG9ydCB2YXIgY2xlYXJQZXJzaXN0ZWRTdG9yZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCAoKF9hID0gUGVyc2lzdFN0b3JlTWFwLmdldCh0YXJnZXQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xlYXJQZXJzaXN0ZWRTdG9yZSgpKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG4iLCJleHBvcnQgdmFyIG1wc0NvbmZpZyA9IHt9O1xuZXhwb3J0IHZhciBtcHNSZWFjdGlvbk9wdGlvbnMgPSB7fTtcbmV4cG9ydCB2YXIgY29uZmlndXJlUGVyc2lzdGFibGUgPSBmdW5jdGlvbiAoY29uZmlnLCByZWFjdGlvbk9wdGlvbnMpIHtcbiAgICBpZiAocmVhY3Rpb25PcHRpb25zID09PSB2b2lkIDApIHsgcmVhY3Rpb25PcHRpb25zID0ge307IH1cbiAgICBtcHNDb25maWcgPSBjb25maWc7XG4gICAgbXBzUmVhY3Rpb25PcHRpb25zID0gcmVhY3Rpb25PcHRpb25zO1xufTtcbiIsInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5pbXBvcnQgeyBQZXJzaXN0U3RvcmVNYXAgfSBmcm9tICcuL1BlcnNpc3RTdG9yZU1hcCc7XG5leHBvcnQgdmFyIGdldFBlcnNpc3RlZFN0b3JlID0gZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIChfYiA9IChfYSA9IFBlcnNpc3RTdG9yZU1hcC5nZXQodGFyZ2V0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBlcnNpc3RlZFN0b3JlKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGxdO1xuICAgIH0pO1xufSk7IH07XG4iLCJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuaW1wb3J0IHsgUGVyc2lzdFN0b3JlTWFwIH0gZnJvbSAnLi9QZXJzaXN0U3RvcmVNYXAnO1xuZXhwb3J0IHZhciBoeWRyYXRlU3RvcmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgKChfYSA9IFBlcnNpc3RTdG9yZU1hcC5nZXQodGFyZ2V0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh5ZHJhdGVTdG9yZSgpKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG4iLCJpbXBvcnQgeyBQZXJzaXN0U3RvcmVNYXAgfSBmcm9tICcuL1BlcnNpc3RTdG9yZU1hcCc7XG5leHBvcnQgdmFyIGlzSHlkcmF0ZWQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gUGVyc2lzdFN0b3JlTWFwLmdldCh0YXJnZXQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNIeWRyYXRlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG59O1xuIiwiaW1wb3J0IHsgUGVyc2lzdFN0b3JlTWFwIH0gZnJvbSAnLi9QZXJzaXN0U3RvcmVNYXAnO1xuZXhwb3J0IHZhciBpc1BlcnNpc3RpbmcgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gUGVyc2lzdFN0b3JlTWFwLmdldCh0YXJnZXQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNQZXJzaXN0aW5nKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcbn07XG4iLCJleHBvcnQgdmFyIGJ1aWxkRXhwaXJlVGltZXN0YW1wID0gZnVuY3Rpb24gKG1pbGxpc2Vjb25kcykge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIG1pbGxpc2Vjb25kcztcbn07XG5leHBvcnQgdmFyIGhhc1RpbWVzdGFtcEV4cGlyZWQgPSBmdW5jdGlvbiAobWlsbGlzZWNvbmRzKSB7XG4gICAgdmFyIGRhdGVUaW1lTm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdmFyIGRhdGVUaW1lRXhwaXJhdGlvbiA9IG5ldyBEYXRlKG1pbGxpc2Vjb25kcykuZ2V0VGltZSgpO1xuICAgIHJldHVybiBkYXRlVGltZUV4cGlyYXRpb24gPD0gZGF0ZVRpbWVOb3c7XG59O1xuZXhwb3J0IHZhciBpc0RlZmluZWQgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCAhPSBudWxsOyB9O1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZGF0YSBpcyBhbiBvYmplY3QuXG4gKi9cbmV4cG9ydCB2YXIgaXNPYmplY3QgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBCb29sZWFuKGRhdGEpICYmIEFycmF5LmlzQXJyYXkoZGF0YSkgPT09IGZhbHNlICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jztcbn07XG4vKipcbiAqIENoZWNrIHRoZSBkYXRhIGlzIGFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMuXG4gKi9cbmV4cG9ydCB2YXIgaXNPYmplY3RXaXRoUHJvcGVydGllcyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGRhdGEpICYmIE9iamVjdC5rZXlzKGRhdGEpLmxlbmd0aCA+IDA7XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmV4cG9ydCB2YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIChmdW5jdGlvblRvQ2hlY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb25Ub0NoZWNrICYmIGZ1bmN0aW9uVG9DaGVjayBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xufTtcbmV4cG9ydCB2YXIgaXNTdG9yYWdlQ29udHJvbGxlckxpa2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBcInR5cGVvZiBTdG9yYWdlXCIgZml4ZXMgaXNzdWUgd2l0aCBSZWFjdCBOYXRpdmVcbiAgICBpZiAodHlwZW9mIFN0b3JhZ2UgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgU3RvcmFnZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLmhhc093blByb3BlcnR5KCdnZXRJdGVtJyksXG4gICAgICAgIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgncmVtb3ZlSXRlbScpLFxuICAgICAgICB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUuaGFzT3duUHJvcGVydHkoJ3NldEl0ZW0nKSxcbiAgICAgICAgaXNGdW5jdGlvbih2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUuZ2V0SXRlbSksXG4gICAgICAgIGlzRnVuY3Rpb24odmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLnJlbW92ZUl0ZW0pLFxuICAgICAgICBpc0Z1bmN0aW9uKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS5zZXRJdGVtKSxcbiAgICBdLmV2ZXJ5KEJvb2xlYW4pO1xufTtcbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbnZhciBpc05vdFByb2R1Y3Rpb25CdWlsZCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbic7XG5leHBvcnQgdmFyIGludmFsaWRTdG9yYWdlQWRhcHRvcldhcm5pbmdJZiA9IGZ1bmN0aW9uIChzdG9yYWdlQWRhcHRvciwgc3RvcmFnZU5hbWUpIHtcbiAgICBpZiAoaXNCcm93c2VyICYmIGlzTm90UHJvZHVjdGlvbkJ1aWxkICYmICFpc1N0b3JhZ2VDb250cm9sbGVyTGlrZShzdG9yYWdlQWRhcHRvcikpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwibW9ieC1wZXJzaXN0LXN0b3JlOiBcIi5jb25jYXQoc3RvcmFnZU5hbWUsIFwiIGRvZXMgbm90IGhhdmUgYSB2YWxpZCBzdG9yYWdlIGFkYXB0b3IuXFxuXFxuKiBNYWtlIHN1cmUgdGhlIHN0b3JhZ2UgY29udHJvbGxlciBoYXMgJ2dldEl0ZW0nLCAnc2V0SXRlbScgYW5kICdyZW1vdmVJdGVtJyBtZXRob2RzLlxcXCJcIikpO1xuICAgIH1cbn07XG5leHBvcnQgdmFyIGR1cGxpY2F0ZWRTdG9yZVdhcm5pbmdJZiA9IGZ1bmN0aW9uIChoYXNQZXJzaXN0ZWRTdG9yZUFscmVhZHksIHN0b3JhZ2VOYW1lKSB7XG4gICAgaWYgKGlzQnJvd3NlciAmJiBpc05vdFByb2R1Y3Rpb25CdWlsZCAmJiBoYXNQZXJzaXN0ZWRTdG9yZUFscmVhZHkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwibW9ieC1wZXJzaXN0LXN0b3JlOiAnbWFrZVBlcnNpc3RhYmxlJyB3YXMgY2FsbGVkIHdhcyBjYWxsZWQgd2l0aCB0aGUgc2FtZSBzdG9yYWdlIG5hbWUgXFxcIlwiLmNvbmNhdChzdG9yYWdlTmFtZSwgXCJcXFwiLlxcblxcbiAqIE1ha2Ugc3VyZSB5b3UgY2FsbCBcXFwic3RvcFBlcnNpc3RpbmdcXFwiIGJlZm9yZSByZWNyZWF0aW5nIFxcXCJcIikuY29uY2F0KHN0b3JhZ2VOYW1lLCBcIlxcXCIgdG8gYXZvaWQgbWVtb3J5IGxlYWtzLiBcXG4gKiBPciBkb3VibGUgY2hlY2sgeW91IGRpZCBub3QgaGF2ZSB0d28gc3RvcmVzIHdpdGggdGhlIHNhbWUgbmFtZS5cIikpO1xuICAgIH1cbn07XG5leHBvcnQgdmFyIGNvbXB1dGVkUGVyc2lzdFdhcm5pbmdJZiA9IGZ1bmN0aW9uIChpc0NvbXB1dGVkUHJvcGVydHksIHByb3BlcnR5TmFtZSkge1xuICAgIGlmIChpc0Jyb3dzZXIgJiYgaXNOb3RQcm9kdWN0aW9uQnVpbGQgJiYgaXNDb21wdXRlZFByb3BlcnR5KSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIm1vYngtcGVyc2lzdC1zdG9yZTogVGhlIHByb3BlcnR5ICdcIi5jb25jYXQocHJvcGVydHlOYW1lLCBcIicgaXMgY29tcHV0ZWQgYW5kIHdpbGwgbm90IHBlcnNpc3QuXCIpKTtcbiAgICB9XG59O1xuZXhwb3J0IHZhciBhY3Rpb25QZXJzaXN0V2FybmluZ0lmID0gZnVuY3Rpb24gKGlzQ29tcHV0ZWRQcm9wZXJ0eSwgcHJvcGVydHlOYW1lKSB7XG4gICAgaWYgKGlzQnJvd3NlciAmJiBpc05vdFByb2R1Y3Rpb25CdWlsZCAmJiBpc0NvbXB1dGVkUHJvcGVydHkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwibW9ieC1wZXJzaXN0LXN0b3JlOiBUaGUgcHJvcGVydHkgJ1wiLmNvbmNhdChwcm9wZXJ0eU5hbWUsIFwiJyBpcyBhbiBhY3Rpb24gYW5kIHdpbGwgbm90IHBlcnNpc3QuXCIpKTtcbiAgICB9XG59O1xuZXhwb3J0IHZhciBjb25zb2xlRGVidWcgPSBmdW5jdGlvbiAoaXNEZWJ1Z01vZGUsIG1lc3NhZ2UsIGNvbnRlbnQpIHtcbiAgICBpZiAoY29udGVudCA9PT0gdm9pZCAwKSB7IGNvbnRlbnQgPSAnJzsgfVxuICAgIGlmIChpc0RlYnVnTW9kZSAmJiBpc0Jyb3dzZXIgJiYgaXNOb3RQcm9kdWN0aW9uQnVpbGQpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiJWMgbW9ieC1wZXJzaXN0LXN0b3JlOiAoRGVidWcgTW9kZSkgXCIuY29uY2F0KG1lc3NhZ2UsIFwiIFwiKSwgJ2JhY2tncm91bmQ6ICM0QjhDQzU7IGNvbG9yOiBibGFjazsgZGlzcGxheTogYmxvY2s7JywgY29udGVudCk7XG4gICAgfVxufTtcbmV4cG9ydCB2YXIgaXNBcnJheUZvck1hcCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIEFycmF5LmlzQXJyYXkodik7IH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbmltcG9ydCB7IGJ1aWxkRXhwaXJlVGltZXN0YW1wLCBjb25zb2xlRGVidWcsIGhhc1RpbWVzdGFtcEV4cGlyZWQgfSBmcm9tICcuL3V0aWxzJztcbnZhciBTdG9yYWdlQWRhcHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdG9yYWdlQWRhcHRlcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIFN0b3JhZ2VBZGFwdGVyLnByb3RvdHlwZS5zZXRJdGVtID0gZnVuY3Rpb24gKGtleSwgaXRlbSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYiwgX2MsIHN0cmluZ2lmeSwgX2QsIGRlYnVnTW9kZSwgZGF0YSwgY29udGVudDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9lLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gdGhpcy5vcHRpb25zLCBfYyA9IF9iLnN0cmluZ2lmeSwgc3RyaW5naWZ5ID0gX2MgPT09IHZvaWQgMCA/IHRydWUgOiBfYywgX2QgPSBfYi5kZWJ1Z01vZGUsIGRlYnVnTW9kZSA9IF9kID09PSB2b2lkIDAgPyBmYWxzZSA6IF9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMub3B0aW9ucy5leHBpcmVJblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbih7fSwgaXRlbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX21wc19fOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBpcmVJblRpbWVzdGFtcDogYnVpbGRFeHBpcmVUaW1lc3RhbXAodGhpcy5vcHRpb25zLmV4cGlyZUluKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBzdHJpbmdpZnkgPyBKU09OLnN0cmluZ2lmeShkYXRhKSA6IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlRGVidWcoZGVidWdNb2RlLCBcIlwiLmNvbmNhdChrZXksIFwiIC0gc2V0SXRlbTpcIiksIGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKChfYSA9IHRoaXMub3B0aW9ucy5zdG9yYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0SXRlbShrZXksIGNvbnRlbnQpKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdG9yYWdlQWRhcHRlci5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9jLCBfZCwgcmVtb3ZlT25FeHBpcmF0aW9uLCBfZSwgZGVidWdNb2RlLCBzdG9yYWdlRGF0YSwgcGFyc2VkRGF0YSwgaGFzRXhwaXJlZDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2YpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9mLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jID0gdGhpcy5vcHRpb25zLCBfZCA9IF9jLnJlbW92ZU9uRXhwaXJhdGlvbiwgcmVtb3ZlT25FeHBpcmF0aW9uID0gX2QgPT09IHZvaWQgMCA/IHRydWUgOiBfZCwgX2UgPSBfYy5kZWJ1Z01vZGUsIGRlYnVnTW9kZSA9IF9lID09PSB2b2lkIDAgPyBmYWxzZSA6IF9lO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKChfYSA9IHRoaXMub3B0aW9ucy5zdG9yYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0SXRlbShrZXkpKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2VEYXRhID0gX2Yuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRhID0gSlNPTi5wYXJzZShzdG9yYWdlRGF0YSkgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRhID0gc3RvcmFnZURhdGEgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNFeHBpcmVkID0gaGFzVGltZXN0YW1wRXhwaXJlZCgoX2IgPSBwYXJzZWREYXRhLl9fbXBzX18pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5leHBpcmVJblRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlRGVidWcoZGVidWdNb2RlLCBcIlwiLmNvbmNhdChrZXksIFwiIC0gaGFzRXhwaXJlZFwiKSwgaGFzRXhwaXJlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShoYXNFeHBpcmVkICYmIHJlbW92ZU9uRXhwaXJhdGlvbikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZW1vdmVJdGVtKGtleSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfZi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZi5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGEgPSBoYXNFeHBpcmVkID8ge30gOiBwYXJzZWREYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZURlYnVnKGRlYnVnTW9kZSwgXCJcIi5jb25jYXQoa2V5LCBcIiAtIChnZXRJdGVtKTpcIiksIHBhcnNlZERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHBhcnNlZERhdGFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN0b3JhZ2VBZGFwdGVyLnByb3RvdHlwZS5yZW1vdmVJdGVtID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYiwgZGVidWdNb2RlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSB0aGlzLm9wdGlvbnMuZGVidWdNb2RlLCBkZWJ1Z01vZGUgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGVEZWJ1ZyhkZWJ1Z01vZGUsIFwiXCIuY29uY2F0KGtleSwgXCIgLSAocmVtb3ZlSXRlbSk6IHN0b3JhZ2Ugd2FzIHJlbW92ZWRcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKChfYSA9IHRoaXMub3B0aW9ucy5zdG9yYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlSXRlbShrZXkpKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3RvcmFnZUFkYXB0ZXI7XG59KCkpO1xuZXhwb3J0IHsgU3RvcmFnZUFkYXB0ZXIgfTtcbiIsImltcG9ydCB7IG1wc0NvbmZpZyB9IGZyb20gJy4vY29uZmlndXJlUGVyc2lzdGFibGUnO1xuaW1wb3J0IHsgY29uc29sZURlYnVnLCBpc09iamVjdCB9IGZyb20gJy4vdXRpbHMnO1xudmFyIGlzU2VyaWFsaXphYmxlUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGtleXMgPSBbJ2tleScsICdzZXJpYWxpemUnLCAnZGVzZXJpYWxpemUnXTtcbiAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgY29uc29sZURlYnVnKCEhbXBzQ29uZmlnLmRlYnVnTW9kZSwgJ3Bhc3NlZCB2YWx1ZSBpcyBub3QgYW4gb2JqZWN0JywgeyBvYmo6IG9iaiB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSAmJiB0eXBlb2Yga2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBjb25zb2xlRGVidWcoISFtcHNDb25maWcuZGVidWdNb2RlLCBcIlwiLmNvbmNhdChrZXksIFwiIG5vdCBmb3VuZCBpbiBTZXJpYWxpemFibGVQcm9wZXJ0eVwiKSwgeyBrZXk6IGtleSwgb2JqOiBvYmogfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbn07XG5leHBvcnQgdmFyIG1ha2VTZXJpYWxpemFibGVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4gcHJvcGVydGllcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY3Vycikge1xuICAgICAgICBpZiAodHlwZW9mIGN1cnIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBhY2MucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiBjdXJyLFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfSxcbiAgICAgICAgICAgICAgICBkZXNlcmlhbGl6ZTogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1NlcmlhbGl6YWJsZVByb3BlcnR5KGN1cnIpKSB7XG4gICAgICAgICAgICBhY2MucHVzaChjdXJyKTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG59O1xuIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbmltcG9ydCB7IGFjdGlvbiwgaXNBY3Rpb24sIGlzQ29tcHV0ZWRQcm9wLCBtYWtlT2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZSwgT2JzZXJ2YWJsZU1hcCwgcmVhY3Rpb24sIHJ1bkluQWN0aW9uLCB0b0pTLCB9IGZyb20gJ21vYngnO1xuaW1wb3J0IHsgUGVyc2lzdFN0b3JlTWFwIH0gZnJvbSAnLi9QZXJzaXN0U3RvcmVNYXAnO1xuaW1wb3J0IHsgU3RvcmFnZUFkYXB0ZXIgfSBmcm9tICcuL1N0b3JhZ2VBZGFwdGVyJztcbmltcG9ydCB7IG1wc0NvbmZpZywgbXBzUmVhY3Rpb25PcHRpb25zIH0gZnJvbSAnLi9jb25maWd1cmVQZXJzaXN0YWJsZSc7XG5pbXBvcnQgeyBtYWtlU2VyaWFsaXphYmxlUHJvcGVydGllcyB9IGZyb20gJy4vc2VyaWFsaXphYmxlUHJvcGVydHknO1xuaW1wb3J0IHsgYWN0aW9uUGVyc2lzdFdhcm5pbmdJZiwgY29tcHV0ZWRQZXJzaXN0V2FybmluZ0lmLCBjb25zb2xlRGVidWcsIGludmFsaWRTdG9yYWdlQWRhcHRvcldhcm5pbmdJZiwgaXNBcnJheUZvck1hcCwgfSBmcm9tICcuL3V0aWxzJztcbnZhciBQZXJzaXN0U3RvcmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGVyc2lzdFN0b3JlKHRhcmdldCwgb3B0aW9ucywgcmVhY3Rpb25PcHRpb25zKSB7XG4gICAgICAgIGlmIChyZWFjdGlvbk9wdGlvbnMgPT09IHZvaWQgMCkgeyByZWFjdGlvbk9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgIHRoaXMuY2FuY2VsV2F0Y2ggPSBudWxsO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgdGhpcy5yZWFjdGlvbk9wdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5zdG9yYWdlQWRhcHRlciA9IG51bGw7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZWJ1Z01vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0h5ZHJhdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNQZXJzaXN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RvcmFnZU5hbWUgPSAnJztcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMuc3RvcmFnZU5hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IG1ha2VTZXJpYWxpemFibGVQcm9wZXJ0aWVzKG9wdGlvbnMucHJvcGVydGllcyk7XG4gICAgICAgIHRoaXMucmVhY3Rpb25PcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGZpcmVJbW1lZGlhdGVseTogdHJ1ZSB9LCBtcHNSZWFjdGlvbk9wdGlvbnMsIHJlYWN0aW9uT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZGVidWdNb2RlID0gKF9iID0gKF9hID0gb3B0aW9ucy5kZWJ1Z01vZGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG1wc0NvbmZpZy5kZWJ1Z01vZGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICAgICAgICB0aGlzLnN0b3JhZ2VBZGFwdGVyID0gbmV3IFN0b3JhZ2VBZGFwdGVyKHtcbiAgICAgICAgICAgIGV4cGlyZUluOiAoX2MgPSBvcHRpb25zLmV4cGlyZUluKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBtcHNDb25maWcuZXhwaXJlSW4sXG4gICAgICAgICAgICByZW1vdmVPbkV4cGlyYXRpb246IChfZSA9IChfZCA9IG9wdGlvbnMucmVtb3ZlT25FeHBpcmF0aW9uKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBtcHNDb25maWcucmVtb3ZlT25FeHBpcmF0aW9uKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB0cnVlLFxuICAgICAgICAgICAgc3RyaW5naWZ5OiAoX2cgPSAoX2YgPSBvcHRpb25zLnN0cmluZ2lmeSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogbXBzQ29uZmlnLnN0cmluZ2lmeSkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogdHJ1ZSxcbiAgICAgICAgICAgIHN0b3JhZ2U6IG9wdGlvbnMuc3RvcmFnZSA/IG9wdGlvbnMuc3RvcmFnZSA6IG1wc0NvbmZpZy5zdG9yYWdlLFxuICAgICAgICAgICAgZGVidWdNb2RlOiB0aGlzLmRlYnVnTW9kZSxcbiAgICAgICAgfSk7XG4gICAgICAgIG1ha2VPYnNlcnZhYmxlKHRoaXMsIHtcbiAgICAgICAgICAgIGNsZWFyUGVyc2lzdGVkU3RvcmU6IGFjdGlvbixcbiAgICAgICAgICAgIGh5ZHJhdGVTdG9yZTogYWN0aW9uLFxuICAgICAgICAgICAgaXNIeWRyYXRlZDogb2JzZXJ2YWJsZSxcbiAgICAgICAgICAgIGlzUGVyc2lzdGluZzogb2JzZXJ2YWJsZSxcbiAgICAgICAgICAgIHBhdXNlUGVyc2lzdGluZzogYWN0aW9uLFxuICAgICAgICAgICAgc3RhcnRQZXJzaXN0aW5nOiBhY3Rpb24sXG4gICAgICAgICAgICBzdG9wUGVyc2lzdGluZzogYWN0aW9uLFxuICAgICAgICB9LCB7IGF1dG9CaW5kOiB0cnVlLCBkZWVwOiBmYWxzZSB9KTtcbiAgICAgICAgaW52YWxpZFN0b3JhZ2VBZGFwdG9yV2FybmluZ0lmKHRoaXMuc3RvcmFnZUFkYXB0ZXIub3B0aW9ucy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VOYW1lKTtcbiAgICAgICAgY29uc29sZURlYnVnKHRoaXMuZGVidWdNb2RlLCBcIlwiLmNvbmNhdCh0aGlzLnN0b3JhZ2VOYW1lLCBcIiAtIChtYWtlUGVyc2lzdGFibGUpXCIpLCB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB0aGlzLnByb3BlcnRpZXMsXG4gICAgICAgICAgICBzdG9yYWdlQWRhcHRlcjogdGhpcy5zdG9yYWdlQWRhcHRlcixcbiAgICAgICAgICAgIHJlYWN0aW9uT3B0aW9uczogdGhpcy5yZWFjdGlvbk9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBQZXJzaXN0U3RvcmUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5oeWRyYXRlU3RvcmUoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRQZXJzaXN0aW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUGVyc2lzdFN0b3JlLnByb3RvdHlwZS5oeWRyYXRlU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpc0JlaW5nV2F0Y2hlZCwgZGF0YV8xLCB0YXJnZXRfMTtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0JlaW5nV2F0Y2hlZCA9IEJvb2xlYW4odGhpcy5jYW5jZWxXYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1BlcnNpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdXNlUGVyc2lzdGluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVuSW5BY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmlzSHlkcmF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlRGVidWcoX3RoaXMuZGVidWdNb2RlLCBcIlwiLmNvbmNhdChfdGhpcy5zdG9yYWdlTmFtZSwgXCIgLSAoaHlkcmF0ZVN0b3JlKSBpc0h5ZHJhdGVkOlwiKSwgX3RoaXMuaXNIeWRyYXRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMuc3RvcmFnZUFkYXB0ZXIgJiYgdGhpcy50YXJnZXQpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuc3RvcmFnZUFkYXB0ZXIuZ2V0SXRlbSh0aGlzLnN0b3JhZ2VOYW1lKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldF8xID0gdGhpcy50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YV8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuSW5BY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxsb3dQcm9wZXJ0eUh5ZHJhdGlvbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRfMS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eS5rZXkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhXzFbcHJvcGVydHkua2V5XSAhPT0gJ3VuZGVmaW5lZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLmV2ZXJ5KEJvb2xlYW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsbG93UHJvcGVydHlIeWRyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlEYXRhID0gZGF0YV8xW3Byb3BlcnR5LmtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldF8xW3Byb3BlcnR5LmtleV0gaW5zdGFuY2VvZiBPYnNlcnZhYmxlTWFwICYmIGlzQXJyYXlGb3JNYXAocHJvcGVydHlEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRfMVtwcm9wZXJ0eS5rZXldID0gcHJvcGVydHkuZGVzZXJpYWxpemUobmV3IE1hcChwcm9wZXJ0eURhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldF8xW3Byb3BlcnR5LmtleV0gPSBwcm9wZXJ0eS5kZXNlcmlhbGl6ZShwcm9wZXJ0eURhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bkluQWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pc0h5ZHJhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlRGVidWcoX3RoaXMuZGVidWdNb2RlLCBcIlwiLmNvbmNhdChfdGhpcy5zdG9yYWdlTmFtZSwgXCIgLSBpc0h5ZHJhdGVkOlwiKSwgX3RoaXMuaXNIeWRyYXRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0JlaW5nV2F0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRQZXJzaXN0aW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUGVyc2lzdFN0b3JlLnByb3RvdHlwZS5zdGFydFBlcnNpc3RpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5zdG9yYWdlQWRhcHRlciB8fCAhdGhpcy50YXJnZXQgfHwgdGhpcy5jYW5jZWxXYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlYXNzaWduaW5nIHNvIFR5cGVTY3JpcHQgZG9lc24ndCBjb21wbGFpbiAoT2JqZWN0IGlzIHBvc3NpYmx5ICdudWxsJykgYWJvdXQgYW5kIHRoaXMudGFyZ2V0IHdpdGhpbiByZWFjdGlvblxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG4gICAgICAgIHRoaXMuY2FuY2VsV2F0Y2ggPSByZWFjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcHJvcGVydGllc1RvV2F0Y2ggPSB7fTtcbiAgICAgICAgICAgIF90aGlzLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNDb21wdXRlZFByb3BlcnR5ID0gaXNDb21wdXRlZFByb3AodGFyZ2V0LCBwcm9wZXJ0eS5rZXkpO1xuICAgICAgICAgICAgICAgIHZhciBpc0FjdGlvblByb3BlcnR5ID0gaXNBY3Rpb24odGFyZ2V0W3Byb3BlcnR5LmtleV0pO1xuICAgICAgICAgICAgICAgIGNvbXB1dGVkUGVyc2lzdFdhcm5pbmdJZihpc0NvbXB1dGVkUHJvcGVydHksIFN0cmluZyhwcm9wZXJ0eS5rZXkpKTtcbiAgICAgICAgICAgICAgICBhY3Rpb25QZXJzaXN0V2FybmluZ0lmKGlzQWN0aW9uUHJvcGVydHksIFN0cmluZyhwcm9wZXJ0eS5rZXkpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ29tcHV0ZWRQcm9wZXJ0eSAmJiAhaXNBY3Rpb25Qcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlEYXRhID0gcHJvcGVydHkuc2VyaWFsaXplKHRhcmdldFtwcm9wZXJ0eS5rZXldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5RGF0YSBpbnN0YW5jZW9mIE9ic2VydmFibGVNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXBBcnJheV8xID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eURhdGEuZm9yRWFjaChmdW5jdGlvbiAodiwgaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcEFycmF5XzEucHVzaChbaywgdG9KUyh2KV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eURhdGEgPSBtYXBBcnJheV8xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXNUb1dhdGNoW3Byb3BlcnR5LmtleV0gPSB0b0pTKHByb3BlcnR5RGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvcGVydGllc1RvV2F0Y2g7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChkYXRhVG9TYXZlKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RvcmFnZUFkYXB0ZXIpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5zdG9yYWdlQWRhcHRlci5zZXRJdGVtKHRoaXMuc3RvcmFnZU5hbWUsIGRhdGFUb1NhdmUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7IH0sIHRoaXMucmVhY3Rpb25PcHRpb25zKTtcbiAgICAgICAgdGhpcy5pc1BlcnNpc3RpbmcgPSB0cnVlO1xuICAgICAgICBjb25zb2xlRGVidWcodGhpcy5kZWJ1Z01vZGUsIFwiXCIuY29uY2F0KHRoaXMuc3RvcmFnZU5hbWUsIFwiIC0gKHN0YXJ0UGVyc2lzdGluZykgaXNQZXJzaXN0aW5nOlwiKSwgdGhpcy5pc1BlcnNpc3RpbmcpO1xuICAgIH07XG4gICAgUGVyc2lzdFN0b3JlLnByb3RvdHlwZS5wYXVzZVBlcnNpc3RpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNQZXJzaXN0aW5nID0gZmFsc2U7XG4gICAgICAgIGNvbnNvbGVEZWJ1Zyh0aGlzLmRlYnVnTW9kZSwgXCJcIi5jb25jYXQodGhpcy5zdG9yYWdlTmFtZSwgXCIgLSBwYXVzZVBlcnNpc3RpbmcgKGlzUGVyc2lzdGluZyk6XCIpLCB0aGlzLmlzUGVyc2lzdGluZyk7XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbFdhdGNoKSB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbFdhdGNoKCk7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbFdhdGNoID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGVyc2lzdFN0b3JlLnByb3RvdHlwZS5zdG9wUGVyc2lzdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wYXVzZVBlcnNpc3RpbmcoKTtcbiAgICAgICAgY29uc29sZURlYnVnKHRoaXMuZGVidWdNb2RlLCBcIlwiLmNvbmNhdCh0aGlzLnN0b3JhZ2VOYW1lLCBcIiAtIChzdG9wUGVyc2lzdGluZylcIikpO1xuICAgICAgICBQZXJzaXN0U3RvcmVNYXAuZGVsZXRlKHRoaXMudGFyZ2V0KTtcbiAgICAgICAgdGhpcy5jYW5jZWxXYXRjaCA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IFtdO1xuICAgICAgICB0aGlzLnJlYWN0aW9uT3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLnN0b3JhZ2VBZGFwdGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgIH07XG4gICAgUGVyc2lzdFN0b3JlLnByb3RvdHlwZS5jbGVhclBlcnNpc3RlZFN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RvcmFnZUFkYXB0ZXIpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZURlYnVnKHRoaXMuZGVidWdNb2RlLCBcIlwiLmNvbmNhdCh0aGlzLnN0b3JhZ2VOYW1lLCBcIiAtIChjbGVhclBlcnNpc3RlZFN0b3JlKVwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnN0b3JhZ2VBZGFwdGVyLnJlbW92ZUl0ZW0odGhpcy5zdG9yYWdlTmFtZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBlcnNpc3RTdG9yZS5wcm90b3R5cGUuZ2V0UGVyc2lzdGVkU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdG9yYWdlQWRhcHRlcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlRGVidWcodGhpcy5kZWJ1Z01vZGUsIFwiXCIuY29uY2F0KHRoaXMuc3RvcmFnZU5hbWUsIFwiIC0gKGdldFBlcnNpc3RlZFN0b3JlKVwiKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuc3RvcmFnZUFkYXB0ZXIuZ2V0SXRlbSh0aGlzLnN0b3JhZ2VOYW1lKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBQZXJzaXN0U3RvcmU7XG59KCkpO1xuZXhwb3J0IHsgUGVyc2lzdFN0b3JlIH07XG4iLCJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuaW1wb3J0IHsgUGVyc2lzdFN0b3JlIH0gZnJvbSAnLi9QZXJzaXN0U3RvcmUnO1xuaW1wb3J0IHsgUGVyc2lzdFN0b3JlTWFwIH0gZnJvbSAnLi9QZXJzaXN0U3RvcmVNYXAnO1xuaW1wb3J0IHsgZHVwbGljYXRlZFN0b3JlV2FybmluZ0lmIH0gZnJvbSAnLi91dGlscyc7XG5leHBvcnQgdmFyIG1ha2VQZXJzaXN0YWJsZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHN0b3JhZ2VPcHRpb25zLCByZWFjdGlvbk9wdGlvbnMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vYnhQZXJzaXN0U3RvcmUsIGhhc1BlcnNpc3RlZFN0b3JlQWxyZWFkeTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIG1vYnhQZXJzaXN0U3RvcmUgPSBuZXcgUGVyc2lzdFN0b3JlKHRhcmdldCwgc3RvcmFnZU9wdGlvbnMsIHJlYWN0aW9uT3B0aW9ucyk7XG4gICAgICAgIGhhc1BlcnNpc3RlZFN0b3JlQWxyZWFkeSA9IEFycmF5LmZyb20oUGVyc2lzdFN0b3JlTWFwLnZhbHVlcygpKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5zdG9yYWdlTmFtZTsgfSlcbiAgICAgICAgICAgIC5pbmNsdWRlcyhtb2J4UGVyc2lzdFN0b3JlLnN0b3JhZ2VOYW1lKTtcbiAgICAgICAgZHVwbGljYXRlZFN0b3JlV2FybmluZ0lmKGhhc1BlcnNpc3RlZFN0b3JlQWxyZWFkeSwgbW9ieFBlcnNpc3RTdG9yZS5zdG9yYWdlTmFtZSk7XG4gICAgICAgIFBlcnNpc3RTdG9yZU1hcC5zZXQodGFyZ2V0LCBtb2J4UGVyc2lzdFN0b3JlKTtcbiAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG1vYnhQZXJzaXN0U3RvcmUuaW5pdCgpXTtcbiAgICB9KTtcbn0pOyB9O1xuIiwiaW1wb3J0IHsgUGVyc2lzdFN0b3JlTWFwIH0gZnJvbSAnLi9QZXJzaXN0U3RvcmVNYXAnO1xuZXhwb3J0IHZhciBwYXVzZVBlcnNpc3RpbmcgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IFBlcnNpc3RTdG9yZU1hcC5nZXQodGFyZ2V0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdXNlUGVyc2lzdGluZygpO1xufTtcbiIsImltcG9ydCB7IFBlcnNpc3RTdG9yZU1hcCB9IGZyb20gJy4vUGVyc2lzdFN0b3JlTWFwJztcbmV4cG9ydCB2YXIgc3RhcnRQZXJzaXN0aW5nID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSBQZXJzaXN0U3RvcmVNYXAuZ2V0KHRhcmdldCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGFydFBlcnNpc3RpbmcoKTtcbn07XG4iLCJpbXBvcnQgeyBQZXJzaXN0U3RvcmVNYXAgfSBmcm9tICcuL1BlcnNpc3RTdG9yZU1hcCc7XG5leHBvcnQgdmFyIHN0b3BQZXJzaXN0aW5nID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSBQZXJzaXN0U3RvcmVNYXAuZ2V0KHRhcmdldCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdG9wUGVyc2lzdGluZygpO1xufTtcbiIsImV4cG9ydCAqIGZyb20gJy4vY2xlYXJQZXJzaXN0ZWRTdG9yZSc7XG5leHBvcnQgKiBmcm9tICcuL2NvbmZpZ3VyZVBlcnNpc3RhYmxlJztcbmV4cG9ydCAqIGZyb20gJy4vZ2V0UGVyc2lzdGVkU3RvcmUnO1xuZXhwb3J0ICogZnJvbSAnLi9oeWRyYXRlU3RvcmUnO1xuZXhwb3J0ICogZnJvbSAnLi9pc0h5ZHJhdGVkJztcbmV4cG9ydCAqIGZyb20gJy4vaXNQZXJzaXN0aW5nJztcbmV4cG9ydCAqIGZyb20gJy4vbWFrZVBlcnNpc3RhYmxlJztcbmV4cG9ydCAqIGZyb20gJy4vcGF1c2VQZXJzaXN0aW5nJztcbmV4cG9ydCAqIGZyb20gJy4vUGVyc2lzdFN0b3JlJztcbmV4cG9ydCAqIGZyb20gJy4vUGVyc2lzdFN0b3JlTWFwJztcbmV4cG9ydCAqIGZyb20gJy4vc3RhcnRQZXJzaXN0aW5nJztcbmV4cG9ydCAqIGZyb20gJy4vc3RvcFBlcnNpc3RpbmcnO1xuZXhwb3J0ICogZnJvbSAnLi9TdG9yYWdlQWRhcHRlcic7XG5leHBvcnQgKiBmcm9tICcuL3R5cGVzJztcbiIsImltcG9ydCB7IGFjdGlvbiwgbWFrZU9ic2VydmFibGUsIG9ic2VydmFibGUgfSBmcm9tICdtb2J4JztcbmltcG9ydCB7IG1ha2VQZXJzaXN0YWJsZSwgc3RvcFBlcnNpc3RpbmcgfSBmcm9tICdtb2J4LXBlcnNpc3Qtc3RvcmUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlU3RvcmU8VD4ge1xuICAgIGRhdGE6IFQgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbiAgICBjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcsIG9uSHlkcmF0aW9uRG9uZT86IFZvaWRGdW5jdGlvbikge1xuICAgICAgICBtYWtlT2JzZXJ2YWJsZSh0aGlzLCB7XG4gICAgICAgICAgICBkYXRhOiBvYnNlcnZhYmxlLFxuICAgICAgICAgICAgdXBkYXRlOiBhY3Rpb24uYm91bmQsXG4gICAgICAgICAgICB1bm1vdW50OiBhY3Rpb24uYm91bmQsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1ha2VQZXJzaXN0YWJsZSh0aGlzLCB7IG5hbWUsIHByb3BlcnRpZXM6IFsnZGF0YSddLCBzdG9yYWdlOiB3aW5kb3cubG9jYWxTdG9yYWdlIH0pLnRoZW4oKCkgPT5cbiAgICAgICAgICAgIG9uSHlkcmF0aW9uRG9uZT8uKClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoZGF0YTogTm9uTnVsbGFibGU8VD4gfCAoKHByZXZpb3VzPzogVCkgPT4gTm9uTnVsbGFibGU8VD4pKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGEgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGRhdGEodGhpcy5kYXRhKSA6IGRhdGE7XG4gICAgfVxuXG4gICAgdW5tb3VudCgpIHtcbiAgICAgICAgc3RvcFBlcnNpc3RpbmcodGhpcyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IEJhc2VTdG9yZSBmcm9tICcuL0Jhc2VTdG9yZSc7XG5pbXBvcnQgdHlwZSB7IEV4Y2hhbmdlUmF0ZXNSZXNwb25zZSB9IGZyb20gJ0BkZXJpdi9hcGktdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFeGNoYW5nZVJhdGVzU3RvcmUgZXh0ZW5kcyBCYXNlU3RvcmU8RXhjaGFuZ2VSYXRlc1Jlc3BvbnNlWydleGNoYW5nZV9yYXRlcyddPiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdFeGNoYW5nZVJhdGVzU3RvcmUnKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQmFzZVN0b3JlIGZyb20gJy4vQmFzZVN0b3JlJztcblxuY29uc3QgRkxBR1MgPSB7XG4gICAgd2FsbGV0OiBmYWxzZSxcbiAgICBuZXh0X3dhbGxldDogZmFsc2UsXG4gICAgc2hhcmtmaW46IGZhbHNlLFxufSBzYXRpc2ZpZXMgUmVjb3JkPHN0cmluZywgYm9vbGVhbj47XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZlYXR1cmVGbGFnc1N0b3JlIGV4dGVuZHMgQmFzZVN0b3JlPHsgW2sgaW4ga2V5b2YgdHlwZW9mIEZMQUdTXTogYm9vbGVhbiB9PiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdGZWF0dXJlRmxhZ3NTdG9yZScsICgpID0+IHtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgZGVmYXVsdCB2YWx1ZXMgZm9yIHRoZSBmaXJzdCB0aW1lLlxuICAgICAgICAgICAgaWYgKCF0aGlzLmRhdGEpIHRoaXMudXBkYXRlKEZMQUdTKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzdG9yZSBkYXRhIGlmIGEgbmV3IGZsYWcgd2FzIGFkZGVkIG9yIHJlbW92ZWQuXG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhICYmIE9iamVjdC5rZXlzKHRoaXMuZGF0YSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhGTEFHUykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUob2xkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEZMQUdTO1xuXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKEZMQUdTKS5mb3JFYWNoKGZsYWcgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBmbGFnIGtleSBpcyBhbHdheXMgcHJlc2VudCBpbiB0aGUgb2JqZWN0LCBIZW5jZSBjYW4gaWdub3JlIHRoZSBUUyBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGRbZmxhZ10gIT09IHVuZGVmaW5lZCkgZGF0YVtmbGFnXSA9IG9sZFtmbGFnXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZGF0YSA9IEZMQUdTO1xuICAgIH1cbn1cbiIsImV4cG9ydCB7IGRlZmF1bHQgYXMgRXhjaGFuZ2VSYXRlc1N0b3JlIH0gZnJvbSAnLi9FeGNoYW5nZVJhdGVzU3RvcmUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGZWF0dXJlRmxhZ3NTdG9yZSB9IGZyb20gJy4vRmVhdHVyZUZsYWdzU3RvcmUnO1xuIiwiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEFQSVByb3ZpZGVyIH0gZnJvbSAnQGRlcml2L2FwaSc7XG5pbXBvcnQgeyBFeGNoYW5nZVJhdGVzUHJvdmlkZXIgfSBmcm9tICcuL3Byb3ZpZGVycyc7XG5pbXBvcnQgU3RvcmVDb250ZXh0IGZyb20gJy4vc3RvcmVDb250ZXh0JztcbmltcG9ydCB7IEV4Y2hhbmdlUmF0ZXNTdG9yZSwgRmVhdHVyZUZsYWdzU3RvcmUgfSBmcm9tICcuL3N0b3Jlcyc7XG5pbXBvcnQgdHlwZSB7IFRDb3JlU3RvcmVzLCBUU3RvcmVzIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5jb25zdCBTdG9yZVByb3ZpZGVyID0gKHsgY2hpbGRyZW4sIHN0b3JlIH06IFJlYWN0LlByb3BzV2l0aENoaWxkcmVuPHsgc3RvcmU6IFRDb3JlU3RvcmVzIH0+KSA9PiB7XG4gICAgY29uc3QgbWVtb2l6ZWRWYWx1ZTogVFN0b3JlcyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICAvLyBJZiB0aGUgc3RvcmUgaXMgbW9ja2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB0aGVuIHJldHVybiB0aGUgbW9ja2VkIHZhbHVlLlxuICAgICAgICBpZiAoJ2lzX21vY2snIGluIHN0b3JlICYmIHN0b3JlLmlzX21vY2spIHJldHVybiBzdG9yZSBhcyB1bmtub3duIGFzIFRTdG9yZXM7XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpbnN0YW50aWF0ZSBzdG9yZSBhbmQgcmV0dXJuIGl0LlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RvcmUsXG4gICAgICAgICAgICBleGNoYW5nZV9yYXRlczogbmV3IEV4Y2hhbmdlUmF0ZXNTdG9yZSgpLFxuICAgICAgICAgICAgZmVhdHVyZV9mbGFnczogbmV3IEZlYXR1cmVGbGFnc1N0b3JlKCksXG4gICAgICAgIH07XG4gICAgfSwgW3N0b3JlXSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyhtZW1vaXplZFZhbHVlKS5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAndW5tb3VudCcgaW4gdmFsdWUpIHZhbHVlLnVubW91bnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH0sIFttZW1vaXplZFZhbHVlXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QVBJUHJvdmlkZXI+XG4gICAgICAgICAgICA8U3RvcmVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXttZW1vaXplZFZhbHVlfT5cbiAgICAgICAgICAgICAgICA8RXhjaGFuZ2VSYXRlc1Byb3ZpZGVyPntjaGlsZHJlbn08L0V4Y2hhbmdlUmF0ZXNQcm92aWRlcj5cbiAgICAgICAgICAgIDwvU3RvcmVDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICA8L0FQSVByb3ZpZGVyPlxuICAgICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTdG9yZVByb3ZpZGVyO1xuIiwiZXhwb3J0IHsgb2JzZXJ2ZXIgfSBmcm9tICdtb2J4LXJlYWN0LWxpdGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBtb2NrU3RvcmUgfSBmcm9tICcuL21vY2tTdG9yZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFN0b3JlQ29udGV4dCB9IGZyb20gJy4vc3RvcmVDb250ZXh0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3RvcmVQcm92aWRlciB9IGZyb20gJy4vc3RvcmVQcm92aWRlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZVN0b3JlIH0gZnJvbSAnLi91c2VTdG9yZSc7XG4iLCJpbXBvcnQgeyB1c2VTdG9yZSB9IGZyb20gJ0BkZXJpdi9zdG9yZXMnO1xuXG5jb25zdCB1c2VIYXNNYWx0YUludmVzdEFjY291bnQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjbGllbnQgfSA9IHVzZVN0b3JlKCk7XG4gICAgY29uc3QgeyBhY3RpdmVfYWNjb3VudHMgfSA9IGNsaWVudDtcbiAgICBjb25zdCBoYXNfbWFsdGFfaW52ZXN0X2FjY291bnQgPSBhY3RpdmVfYWNjb3VudHMuc29tZShcbiAgICAgICAgYWNjb3VudCA9PiBhY2NvdW50LmxhbmRpbmdfY29tcGFueV9zaG9ydGNvZGUgPT09ICdtYWx0YWludmVzdCdcbiAgICApO1xuXG4gICAgcmV0dXJuIGhhc19tYWx0YV9pbnZlc3RfYWNjb3VudDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUhhc01hbHRhSW52ZXN0QWNjb3VudDtcbiIsImltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnQGRlcml2L3N0b3Jlcyc7XG5pbXBvcnQgdXNlSGFzTWFsdGFJbnZlc3RBY2NvdW50IGZyb20gJy4vdXNlSGFzTWFsdGFJbnZlc3RBY2NvdW50JztcblxuY29uc3QgdXNlQWNjb3VudFRyYW5zZmVyVmlzaWJsZSA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNsaWVudCB9ID0gdXNlU3RvcmUoKTtcbiAgICBjb25zdCB7IGxhbmRpbmdfY29tcGFueV9zaG9ydGNvZGUsIHJlc2lkZW5jZSB9ID0gY2xpZW50O1xuICAgIGNvbnN0IGhhc19tYWx0YV9pbnZlc3RfYWNjb3VudCA9IHVzZUhhc01hbHRhSW52ZXN0QWNjb3VudCgpO1xuICAgIGNvbnN0IGlzX2FjY291bnRfdHJhbnNmZXJfdmlzaWJsZSA9XG4gICAgICAgIHJlc2lkZW5jZSAhPT0gJ2ltJyAmJiAobGFuZGluZ19jb21wYW55X3Nob3J0Y29kZSAhPT0gJ21hbHRhJyB8fCBoYXNfbWFsdGFfaW52ZXN0X2FjY291bnQpO1xuXG4gICAgcmV0dXJuIGlzX2FjY291bnRfdHJhbnNmZXJfdmlzaWJsZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUFjY291bnRUcmFuc2ZlclZpc2libGU7XG4iLCJpbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlRmV0Y2ggfSBmcm9tICdAZGVyaXYvYXBpJztcbmltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnQGRlcml2L3N0b3Jlcyc7XG5cbi8qKiBBIGN1c3RvbSBob29rIHRoYXQgYXV0aG9yaXplIHRoZSB1c2VyIHdpdGggdGhlIGdpdmVuIHRva2VuLiBJZiBubyB0b2tlbiBpcyBnaXZlbiwgaXQgd2lsbCB1c2UgdGhlIGN1cnJlbnQgdG9rZW4uICovXG5jb25zdCB1c2VBdXRob3JpemUgPSAodG9rZW4/OiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCB7IGNsaWVudCB9ID0gdXNlU3RvcmUoKTtcbiAgICBjb25zdCB7IGFjY291bnRzLCBsb2dpbmlkID0gJycgfSA9IGNsaWVudDtcbiAgICBjb25zdCBjdXJyZW50X3Rva2VuID0gYWNjb3VudHNbbG9naW5pZCB8fCAnJ10/LnRva2VuO1xuXG4gICAgY29uc3QgeyBkYXRhLCAuLi5yZXN0IH0gPSB1c2VGZXRjaCgnYXV0aG9yaXplJywge1xuICAgICAgICBwYXlsb2FkOiB7IGF1dGhvcml6ZTogdG9rZW4gPz8gY3VycmVudF90b2tlbiB9LFxuICAgICAgICBvcHRpb25zOiB7IGVuYWJsZWQ6IEJvb2xlYW4odG9rZW4gPz8gY3VycmVudF90b2tlbikgfSxcbiAgICB9KTtcblxuICAgIC8vIEFkZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHRvIHRoZSBhdXRob3JpemUgcmVzcG9uc2UuXG4gICAgY29uc3QgbW9kaWZpZWRfYXV0aG9yaXplID0gdXNlTWVtbygoKSA9PiAoeyAuLi5kYXRhPy5hdXRob3JpemUgfSksIFtkYXRhPy5hdXRob3JpemVdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKiBUaGUgYXV0aG9yaXplIHJlc3BvbnNlLiAqL1xuICAgICAgICBkYXRhOiBtb2RpZmllZF9hdXRob3JpemUsXG4gICAgICAgIC4uLnJlc3QsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUF1dGhvcml6ZTtcbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlRmV0Y2ggfSBmcm9tICdAZGVyaXYvYXBpJztcblxuLyoqIEBkZXByZWNhdGVkIFVzZSBgdXNlQ3VycmVuY3lDb25maWdgIGZyb20gYEBkZXJpdi9hcGlgIHBhY2thZ2UgaW5zdGVhZC4gKi9cbmNvbnN0IHVzZUN1cnJlbmN5Q29uZmlnID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgZGF0YTogd2Vic2l0ZV9zdGF0dXNfZGF0YSB9ID0gdXNlRmV0Y2goJ3dlYnNpdGVfc3RhdHVzJyk7XG4gICAgY29uc3QgeyBkYXRhOiBjcnlwdG9fY29uZmlnX2RhdGEsIC4uLnJlc3QgfSA9IHVzZUZldGNoKCdjcnlwdG9fY29uZmlnJyk7XG5cbiAgICBjb25zdCBjdXJyZW5jaWVzX2NvbmZpZyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoIXdlYnNpdGVfc3RhdHVzX2RhdGE/LndlYnNpdGVfc3RhdHVzPy5jdXJyZW5jaWVzX2NvbmZpZykgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgICAgICBjb25zdCB3ZWJzaXRlX3N0YXR1c19jdXJyZW5jaWVzX2NvbmZpZyA9IHdlYnNpdGVfc3RhdHVzX2RhdGEud2Vic2l0ZV9zdGF0dXMuY3VycmVuY2llc19jb25maWc7XG5cbiAgICAgICAgY29uc3QgbW9kaWZpZWRfY3VycmVuY2llc19jb25maWcgPSBPYmplY3Qua2V5cyh3ZWJzaXRlX3N0YXR1c19jdXJyZW5jaWVzX2NvbmZpZykubWFwKGN1cnJlbmN5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbmN5X2NvbmZpZyA9IHdlYnNpdGVfc3RhdHVzX2N1cnJlbmNpZXNfY29uZmlnW2N1cnJlbmN5XTtcbiAgICAgICAgICAgIGNvbnN0IGNyeXB0b19jb25maWcgPSBjcnlwdG9fY29uZmlnX2RhdGE/LmNyeXB0b19jb25maWc/LmN1cnJlbmNpZXNfY29uZmlnW2N1cnJlbmN5XTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5jdXJyZW5jeV9jb25maWcsXG4gICAgICAgICAgICAgICAgLi4uY3J5cHRvX2NvbmZpZyxcbiAgICAgICAgICAgICAgICAvKiogZGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW5jeSBpcyBhIGBjcnlwdG9gIGN1cnJlbmN5ICovXG4gICAgICAgICAgICAgICAgaXNfY3J5cHRvOiBjdXJyZW5jeV9jb25maWc/LnR5cGUgPT09ICdjcnlwdG8nLFxuICAgICAgICAgICAgICAgIC8qKiBkZXRlcm1pbmUgaWYgdGhlIGN1cnJlbmN5IGlzIGEgYGZpYXRgIGN1cnJlbmN5ICovXG4gICAgICAgICAgICAgICAgaXNfZmlhdDogY3VycmVuY3lfY29uZmlnPy50eXBlID09PSAnZmlhdCcsXG4gICAgICAgICAgICAgICAgLyoqIGRldGVybWluZSBpZiB0aGUgY3VycmVuY3kgaXMgYEF1c3RyYWxpYW4gRG9sbGFyYCAqL1xuICAgICAgICAgICAgICAgIGlzX0FVRDogY3VycmVuY3kgPT09ICdBVUQnLFxuICAgICAgICAgICAgICAgIC8qKiBkZXRlcm1pbmUgaWYgdGhlIGN1cnJlbmN5IGlzIGBVUyBEb2xsYXJgICovXG4gICAgICAgICAgICAgICAgaXNfVVNEOiBjdXJyZW5jeSA9PT0gJ1VTRCcsXG4gICAgICAgICAgICAgICAgLyoqIGRldGVybWluZSBpZiB0aGUgY3VycmVuY3kgaXMgYEV1cm9gICovXG4gICAgICAgICAgICAgICAgaXNfRVVSOiBjdXJyZW5jeSA9PT0gJ0VVUicsXG4gICAgICAgICAgICAgICAgLyoqIGRldGVybWluZSBpZiB0aGUgY3VycmVuY3kgaXMgYFBvdW5kIFN0ZXJsaW5nYCAqL1xuICAgICAgICAgICAgICAgIGlzX0dCUDogY3VycmVuY3kgPT09ICdHQlAnLFxuICAgICAgICAgICAgICAgIC8qKiBkZXRlcm1pbmUgaWYgdGhlIGN1cnJlbmN5IGlzIGBCaXRjb2luYCAqL1xuICAgICAgICAgICAgICAgIGlzX0JUQzogY3VycmVuY3kgPT09ICdCVEMnLFxuICAgICAgICAgICAgICAgIC8qKiBkZXRlcm1pbmUgaWYgdGhlIGN1cnJlbmN5IGlzIGBFdGhlcmV1bWAgKi9cbiAgICAgICAgICAgICAgICBpc19FVEg6IGN1cnJlbmN5ID09PSAnRVRIJyxcbiAgICAgICAgICAgICAgICAvKiogZGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW5jeSBpcyBgTGl0ZWNvaW5gICovXG4gICAgICAgICAgICAgICAgaXNfTFRDOiBjdXJyZW5jeSA9PT0gJ0xUQycsXG4gICAgICAgICAgICAgICAgLyoqIGRldGVybWluZSBpZiB0aGUgY3VycmVuY3kgaXMgYE11bHRpLUNvbGxhdGVyYWwgREFJYCAqL1xuICAgICAgICAgICAgICAgIGlzX0RBSTogY3VycmVuY3kgPT09ICdEQUknLFxuICAgICAgICAgICAgICAgIC8qKiBkZXRlcm1pbmUgaWYgdGhlIGN1cnJlbmN5IGlzIGBJREtgICovXG4gICAgICAgICAgICAgICAgaXNfSURLOiBjdXJyZW5jeSA9PT0gJ0lESycsXG4gICAgICAgICAgICAgICAgLyoqIGRldGVybWluZSBpZiB0aGUgY3VycmVuY3kgaXMgYFBheG9zIFN0YW5kYXJkYCAqL1xuICAgICAgICAgICAgICAgIGlzX1BBWDogY3VycmVuY3kgPT09ICdQQVgnLFxuICAgICAgICAgICAgICAgIC8qKiBkZXRlcm1pbmUgaWYgdGhlIGN1cnJlbmN5IGlzIGBCaW5hcnkgQ29pbmAgKi9cbiAgICAgICAgICAgICAgICBpc19VU0I6IGN1cnJlbmN5ID09PSAnVVNCJyxcbiAgICAgICAgICAgICAgICAvKiogZGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW5jeSBpcyBgVGV0aGVyIE9tbmlgICovXG4gICAgICAgICAgICAgICAgaXNfVVNEVDogY3VycmVuY3kgPT09ICdVU1QnLFxuICAgICAgICAgICAgICAgIC8qKiBkZXRlcm1pbmUgaWYgdGhlIGN1cnJlbmN5IGlzIGBUcnVlIFVTRGAgKi9cbiAgICAgICAgICAgICAgICBpc19UVVNEOiBjdXJyZW5jeSA9PT0gJ1RVU0QnLFxuICAgICAgICAgICAgICAgIC8qKiBkZXRlcm1pbmUgaWYgdGhlIGN1cnJlbmN5IGlzIGBCaW5hbmNlIFVTRGAgKi9cbiAgICAgICAgICAgICAgICBpc19CVVNEOiBjdXJyZW5jeSA9PT0gJ0JVU0QnLFxuICAgICAgICAgICAgICAgIC8qKiBkZXRlcm1pbmUgaWYgdGhlIGN1cnJlbmN5IGlzIGBTVEFUSVMgRXVyb2AgKi9cbiAgICAgICAgICAgICAgICBpc19FVVJTOiBjdXJyZW5jeSA9PT0gJ0VVUlMnLFxuICAgICAgICAgICAgICAgIC8qKiBkZXRlcm1pbmUgaWYgdGhlIGN1cnJlbmN5IGlzIGBUZXRoZXIgRVJDMjBgICovXG4gICAgICAgICAgICAgICAgaXNfZVVTRFQ6IGN1cnJlbmN5ID09PSAnZVVTRFQnLFxuICAgICAgICAgICAgICAgIC8qKiBkZXRlcm1pbmUgaWYgdGhlIGN1cnJlbmN5IGlzIGBUZXRoZXIgVFJDMjBgICovXG4gICAgICAgICAgICAgICAgaXNfdFVTRFQ6IGN1cnJlbmN5ID09PSAndFVTRFQnLFxuICAgICAgICAgICAgICAgIC8qKiBkZXRlcm1pbmUgaWYgdGhlIGN1cnJlbmN5IGlzIGBVU0QgQ29pbmAgKi9cbiAgICAgICAgICAgICAgICBpc19VU0RDOiBjdXJyZW5jeSA9PT0gJ1VTREMnLFxuICAgICAgICAgICAgICAgIC8qKiBkZXRlcm1pbmUgaWYgdGhlIGN1cnJlbmN5IGlzIGBVU0RLYCAqL1xuICAgICAgICAgICAgICAgIGlzX1VTREs6IGN1cnJlbmN5ID09PSAnVVNESycsXG4gICAgICAgICAgICAgICAgLyoqIEN1cnJlbmN5IGNvZGUgKi9cbiAgICAgICAgICAgICAgICBjb2RlOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAvKiogQ3VycmVuY3kgZGlzcGxheSBjb2RlICovXG4gICAgICAgICAgICAgICAgZGlzcGxheV9jb2RlOiBjdXJyZW5jeSA9PT0gJ1VTVCcgPyAnVVNEVCcgOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAvKiogTG9jYWwgYXNzZXQgbmFtZSBmb3IgdGhlIGN1cnJlbmN5IGljb24uIGV4OiBgSWNDdXJyZW5jeVVzZGAgZm9yIGBVU0RgICovXG4gICAgICAgICAgICAgICAgaWNvbjogYEljQ3VycmVuY3kke2N1cnJlbmN5WzBdLnRvVXBwZXJDYXNlKCkgKyBjdXJyZW5jeS5zbGljZSgxKS50b0xvd2VyQ2FzZSgpfWAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbW9kaWZpZWRfY3VycmVuY2llc19jb25maWcucmVkdWNlPFJlY29yZDxzdHJpbmcsIHR5cGVvZiBtb2RpZmllZF9jdXJyZW5jaWVzX2NvbmZpZ1tudW1iZXJdPj4oXG4gICAgICAgICAgICAocHJldmlvdXMsIGN1cnJlbnQpID0+ICh7IC4uLnByZXZpb3VzLCBbY3VycmVudC5jb2RlXTogY3VycmVudCB9KSxcbiAgICAgICAgICAgIHt9XG4gICAgICAgICk7XG4gICAgfSwgW2NyeXB0b19jb25maWdfZGF0YT8uY3J5cHRvX2NvbmZpZz8uY3VycmVuY2llc19jb25maWcsIHdlYnNpdGVfc3RhdHVzX2RhdGE/LndlYnNpdGVfc3RhdHVzPy5jdXJyZW5jaWVzX2NvbmZpZ10pO1xuXG4gICAgY29uc3QgZ2V0Q29uZmlnID0gdXNlQ2FsbGJhY2soKGN1cnJlbmN5OiBzdHJpbmcpID0+IGN1cnJlbmNpZXNfY29uZmlnPy5bY3VycmVuY3ldLCBbY3VycmVuY2llc19jb25maWddKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKiBSZXR1cm5zIHRoZSBjdXJyZW5jeSBjb25maWcgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gY3VycmVuY3kgKi9cbiAgICAgICAgZ2V0Q29uZmlnLFxuICAgICAgICAvKiogQXZhaWxhYmxlIGN1cnJlbmNpZXMgYW5kIHRoZWlyIGluZm9ybWF0aW9uICovXG4gICAgICAgIGN1cnJlbmNpZXNfY29uZmlnLFxuICAgICAgICAuLi5yZXN0LFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VDdXJyZW5jeUNvbmZpZztcbiIsImltcG9ydCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VGZXRjaCB9IGZyb20gJ0BkZXJpdi9hcGknO1xuaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICdAZGVyaXYvc3RvcmVzJztcbmltcG9ydCB1c2VBdXRob3JpemUgZnJvbSAnLi91c2VBdXRob3JpemUnO1xuaW1wb3J0IHVzZUN1cnJlbmN5Q29uZmlnIGZyb20gJy4vdXNlQ3VycmVuY3lDb25maWcnO1xuXG5jb25zdCBjdXJyZW5jeV90b19pY29uX21hcHBlcjogUmVjb3JkPHN0cmluZywgUmVjb3JkPCdsaWdodCcgfCAnZGFyaycsIHN0cmluZz4+ID0ge1xuICAgIERlbW86IHtcbiAgICAgICAgZGFyazogJ0ljV2FsbGV0RGVyaXZEZW1vRGFyaycsXG4gICAgICAgIGxpZ2h0OiAnSWNXYWxsZXREZXJpdkRlbW9MaWdodCcsXG4gICAgfSxcbiAgICBVU0Q6IHtcbiAgICAgICAgZGFyazogJ0ljV2FsbGV0Q3VycmVuY3lVc2QnLFxuICAgICAgICBsaWdodDogJ0ljV2FsbGV0Q3VycmVuY3lVc2QnLFxuICAgIH0sXG4gICAgRVVSOiB7XG4gICAgICAgIGRhcms6ICdJY1dhbGxldEN1cnJlbmN5RXVyJyxcbiAgICAgICAgbGlnaHQ6ICdJY1dhbGxldEN1cnJlbmN5RXVyJyxcbiAgICB9LFxuICAgIEFVRDoge1xuICAgICAgICBkYXJrOiAnSWNXYWxsZXRDdXJyZW5jeUF1ZCcsXG4gICAgICAgIGxpZ2h0OiAnSWNXYWxsZXRDdXJyZW5jeUF1ZCcsXG4gICAgfSxcbiAgICBHQlA6IHtcbiAgICAgICAgZGFyazogJ0ljV2FsbGV0Q3VycmVuY3lHYnAnLFxuICAgICAgICBsaWdodDogJ0ljV2FsbGV0Q3VycmVuY3lHYnAnLFxuICAgIH0sXG4gICAgQlRDOiB7XG4gICAgICAgIGRhcms6ICdJY1dhbGxldEJpdGNvaW5EYXJrJyxcbiAgICAgICAgbGlnaHQ6ICdJY1dhbGxldEJpdGNvaW5MaWdodCcsXG4gICAgfSxcbiAgICBFVEg6IHtcbiAgICAgICAgZGFyazogJ0ljV2FsbGV0RXRoZXJldW1EYXJrJyxcbiAgICAgICAgbGlnaHQ6ICdJY1dhbGxldEV0aGVyZXVtTGlnaHQnLFxuICAgIH0sXG4gICAgVVNEVDoge1xuICAgICAgICBkYXJrOiAnSWNXYWxsZXRUZXRoZXJEYXJrJyxcbiAgICAgICAgbGlnaHQ6ICdJY1dhbGxldFRldGhlckxpZ2h0JyxcbiAgICB9LFxuICAgIGVVU0RUOiB7XG4gICAgICAgIGRhcms6ICdJY1dhbGxldFRldGhlckRhcmsnLFxuICAgICAgICBsaWdodDogJ0ljV2FsbGV0VGV0aGVyTGlnaHQnLFxuICAgIH0sXG4gICAgdFVTRFQ6IHtcbiAgICAgICAgZGFyazogJ0ljV2FsbGV0VGV0aGVyRGFyaycsXG4gICAgICAgIGxpZ2h0OiAnSWNXYWxsZXRUZXRoZXJMaWdodCcsXG4gICAgfSxcbiAgICBVU1Q6IHtcbiAgICAgICAgZGFyazogJ0ljV2FsbGV0VGV0aGVyRGFyaycsXG4gICAgICAgIGxpZ2h0OiAnSWNXYWxsZXRUZXRoZXJMaWdodCcsXG4gICAgfSxcbiAgICBMVEM6IHtcbiAgICAgICAgZGFyazogJ0ljV2FsbGV0TGl0ZUNvaW5EYXJrJyxcbiAgICAgICAgbGlnaHQ6ICdJY1dhbGxldExpdGVDb2luTGlnaHQnLFxuICAgIH0sXG4gICAgVVNEQzoge1xuICAgICAgICBkYXJrOiAnSWNXYWxsZXRVc2RDb2luRGFyaycsXG4gICAgICAgIGxpZ2h0OiAnSWNXYWxsZXRVc2RDb2luTGlnaHQnLFxuICAgIH0sXG59O1xuXG4vKiogQSBjdXN0b20gaG9vayB0byBnZXQgdGhlIGxpc3Qgb2Ygd2FsbGV0cyBmb3IgdGhlIGN1cnJlbnQgdXNlci4gKi9cbmNvbnN0IHVzZVdhbGxldHNMaXN0ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgdWksIGNsaWVudCB9ID0gdXNlU3RvcmUoKTtcbiAgICBjb25zdCB7IGlzX2RhcmtfbW9kZV9vbiB9ID0gdWk7XG4gICAgY29uc3QgeyBpc19hdXRob3JpemUgfSA9IGNsaWVudDtcbiAgICBjb25zdCB7IGdldENvbmZpZyB9ID0gdXNlQ3VycmVuY3lDb25maWcoKTtcblxuICAgIGNvbnN0IHsgZGF0YTogYXV0aG9yaXplX2RhdGEsIGlzU3VjY2VzcywgLi4ucmVzdCB9ID0gdXNlQXV0aG9yaXplKCk7XG4gICAgY29uc3QgeyBkYXRhOiBiYWxhbmNlX2RhdGEgfSA9IHVzZUZldGNoKCdiYWxhbmNlJywge1xuICAgICAgICBwYXlsb2FkOiB7IGFjY291bnQ6ICdhbGwnIH0sXG4gICAgICAgIG9wdGlvbnM6IHsgZW5hYmxlZDogaXNfYXV0aG9yaXplICYmIGlzU3VjY2VzcyB9LFxuICAgIH0pO1xuXG4gICAgLy8gRmlsdGVyIG91dCBub24td2FsbGV0IGFjY291bnRzLlxuICAgIGNvbnN0IHdhbGxldHMgPSB1c2VNZW1vKFxuICAgICAgICAoKSA9PiBhdXRob3JpemVfZGF0YT8uYWNjb3VudF9saXN0Py5maWx0ZXIoYWNjb3VudCA9PiBhY2NvdW50LmFjY291bnRfY2F0ZWdvcnkgPT09ICd3YWxsZXQnKSxcbiAgICAgICAgW2F1dGhvcml6ZV9kYXRhPy5hY2NvdW50X2xpc3RdXG4gICAgKTtcblxuICAgIC8vIEFkZCBiYWxhbmNlIHRvIGVhY2ggd2FsbGV0LlxuICAgIGNvbnN0IHdhbGxldHNfd2l0aF9iYWxhbmNlID0gdXNlTWVtbyhcbiAgICAgICAgKCkgPT5cbiAgICAgICAgICAgIHdhbGxldHM/Lm1hcCh3YWxsZXQgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi53YWxsZXQsXG4gICAgICAgICAgICAgICAgLyoqIFdhbGxldCBiYWxhbmNlICovXG4gICAgICAgICAgICAgICAgYmFsYW5jZTogYmFsYW5jZV9kYXRhPy5iYWxhbmNlPy5hY2NvdW50cz8uW3dhbGxldC5sb2dpbmlkIHx8ICcnXT8uYmFsYW5jZSB8fCAwLFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICBbYmFsYW5jZV9kYXRhPy5iYWxhbmNlPy5hY2NvdW50cywgd2FsbGV0c11cbiAgICApO1xuXG4gICAgLy8gQWRkIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gZWFjaCB3YWxsZXQuXG4gICAgY29uc3QgbW9kaWZpZWRfd2FsbGV0cyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gd2FsbGV0c193aXRoX2JhbGFuY2U/Lm1hcCh3YWxsZXQgPT4ge1xuICAgICAgICAgICAgY29uc3Qgd2FsbGV0X2N1cnJlbmN5X3R5cGUgPSB3YWxsZXQuaXNfdmlydHVhbCA9PT0gMSA/ICdEZW1vJyA6IHdhbGxldC5jdXJyZW5jeSB8fCAnJztcbiAgICAgICAgICAgIGNvbnN0IHdhbGxldF9ncmFkaWVudF9jbGFzc19uYW1lID0gYCR7d2FsbGV0X2N1cnJlbmN5X3R5cGUudG9Mb3dlckNhc2UoKX0tYmcke1xuICAgICAgICAgICAgICAgIGlzX2RhcmtfbW9kZV9vbiA/ICctLWRhcmsnIDogJydcbiAgICAgICAgICAgIH1gO1xuICAgICAgICAgICAgY29uc3Qgd2FsbGV0X2ljb24gPSBjdXJyZW5jeV90b19pY29uX21hcHBlclt3YWxsZXRfY3VycmVuY3lfdHlwZV07XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4ud2FsbGV0LFxuICAgICAgICAgICAgICAgIC8qKiBJbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHdhbGxldCBpcyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHdhbGxldC4gKi9cbiAgICAgICAgICAgICAgICBpc19zZWxlY3RlZDogd2FsbGV0LmxvZ2luaWQgPT09IGF1dGhvcml6ZV9kYXRhPy5sb2dpbmlkLFxuICAgICAgICAgICAgICAgIC8qKiBJbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHdhbGxldCBpcyBhIHZpcnR1YWwtbW9uZXkgd2FsbGV0LiAqL1xuICAgICAgICAgICAgICAgIGlzX2RlbW86IHdhbGxldC5pc192aXJ0dWFsID09PSAxLFxuICAgICAgICAgICAgICAgIC8qKiBSZXR1cm5zIHRoZSB3YWxsZXQncyBjdXJyZW5jeSB0eXBlLiBleDogYERlbW9gLCBgVVNEYCwgZXRjLiAqL1xuICAgICAgICAgICAgICAgIHdhbGxldF9jdXJyZW5jeV90eXBlLFxuICAgICAgICAgICAgICAgIC8qKiBMYW5kaW5nIGNvbXBhbnkgc2hvcnRjb2RlIHRoZSBhY2NvdW50IGJlbG9uZ3MgdG8uICovXG4gICAgICAgICAgICAgICAgbGFuZGluZ19jb21wYW55X25hbWU6IHdhbGxldC5sYW5kaW5nX2NvbXBhbnlfbmFtZT8ucmVwbGFjZSgnbWFsdGFpbnZlc3QnLCAnbWFsdGEnKSxcbiAgICAgICAgICAgICAgICAvKiogSW5kaWNhdGluZyB3aGV0aGVyIHRoZSB3YWxsZXQgaXMgYSBtYWx0YWludmVzdCB3YWxsZXQuICovXG4gICAgICAgICAgICAgICAgaXNfbWFsdGFfd2FsbGV0OiB3YWxsZXQubGFuZGluZ19jb21wYW55X25hbWUgPT09ICdtYWx0YScsXG4gICAgICAgICAgICAgICAgLyoqIFRoZSBncmFkaWVudCBjbGFzcyBuYW1lIGZvciB0aGUgd2FsbGV0IGhlYWRlciBiYWNrZ3JvdW5kLiAqL1xuICAgICAgICAgICAgICAgIGdyYWRpZW50X2hlYWRlcl9jbGFzczogYHdhbGxldC1oZWFkZXJfXyR7d2FsbGV0X2dyYWRpZW50X2NsYXNzX25hbWV9YCxcbiAgICAgICAgICAgICAgICAvKiogVGhlIGdyYWRpZW50IGNsYXNzIG5hbWUgZm9yIHRoZSB3YWxsZXQgY2FyZCBiYWNrZ3JvdW5kLiAqL1xuICAgICAgICAgICAgICAgIGdyYWRpZW50X2NhcmRfY2xhc3M6IGB3YWxsZXQtY2FyZF9fJHt3YWxsZXRfZ3JhZGllbnRfY2xhc3NfbmFtZX1gLFxuICAgICAgICAgICAgICAgIC8qKiBXYWxsZXQncyBjdXJyZW5jeSBjb25maWcgaW5mb3JtYXRpb24gKi9cbiAgICAgICAgICAgICAgICBjdXJyZW5jeV9jb25maWc6IHdhbGxldC5jdXJyZW5jeSA/IGdldENvbmZpZyh3YWxsZXQuY3VycmVuY3kpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIC8qKiBMb2NhbCBhc3NldCBuYW1lIGZvciB0aGUgd2FsbGV0IGljb24uIGV4OiBgSWNXYWxsZXRDdXJyZW5jeVVzZGAgZm9yIGBVU0RgICAqL1xuICAgICAgICAgICAgICAgIGljb246IGlzX2RhcmtfbW9kZV9vbiA/IHdhbGxldF9pY29uLmRhcmsgOiB3YWxsZXRfaWNvbi5saWdodCxcbiAgICAgICAgICAgIH0gYXMgY29uc3Q7XG4gICAgICAgIH0pO1xuICAgIH0sIFtnZXRDb25maWcsIGlzX2RhcmtfbW9kZV9vbiwgYXV0aG9yaXplX2RhdGE/LmxvZ2luaWQsIHdhbGxldHNfd2l0aF9iYWxhbmNlXSk7XG5cbiAgICAvLyBTb3J0IHdhbGxldHMgYWxwaGFiZXRpY2FsbHkgYnkgZmlhdCwgY3J5cHRvLCB0aGVuIHZpcnR1YWwuXG4gICAgY29uc3Qgc29ydGVkX3dhbGxldHMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFtb2RpZmllZF93YWxsZXRzKSByZXR1cm4gW107XG5cbiAgICAgICAgcmV0dXJuIFsuLi5tb2RpZmllZF93YWxsZXRzXS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICBpZiAoYS5pc192aXJ0dWFsICE9PSBiLmlzX3ZpcnR1YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5pc192aXJ0dWFsID8gMSA6IC0xO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhLmN1cnJlbmN5X2NvbmZpZz8uaXNfY3J5cHRvICE9PSBiLmN1cnJlbmN5X2NvbmZpZz8uaXNfY3J5cHRvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuY3VycmVuY3lfY29uZmlnPy5pc19jcnlwdG8gPyAxIDogLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoYS5jdXJyZW5jeSB8fCAnVVNEJykubG9jYWxlQ29tcGFyZShiLmN1cnJlbmN5IHx8ICdVU0QnKTtcbiAgICAgICAgfSk7XG4gICAgfSwgW21vZGlmaWVkX3dhbGxldHNdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKiBMaXN0IG9mIHdhbGxldHMgZm9yIGN1cnJlbnQgdXNlci4gKi9cbiAgICAgICAgZGF0YTogc29ydGVkX3dhbGxldHMsXG4gICAgICAgIC8qKiBJbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHVzZXIgaGFzIGEgd2FsbGV0ICovXG4gICAgICAgIGhhc193YWxsZXQ6IHNvcnRlZF93YWxsZXRzICYmIHNvcnRlZF93YWxsZXRzLmxlbmd0aCA+IDAsXG4gICAgICAgIC4uLnJlc3QsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZVdhbGxldHNMaXN0O1xuIiwiaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VXYWxsZXRzTGlzdCBmcm9tICcuL3VzZVdhbGxldHNMaXN0JztcblxuLyoqIEEgY3VzdG9tIGhvb2sgdGhhdCByZXR1cm5zIHRoZSB3YWxsZXQgb2JqZWN0IGZvciB0aGUgY3VycmVudCBhY3RpdmUgd2FsbGV0LiAqL1xuY29uc3QgdXNlQWN0aXZlV2FsbGV0ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gdXNlV2FsbGV0c0xpc3QoKTtcbiAgICBjb25zdCBhY3RpdmVfd2FsbGV0ID0gdXNlTWVtbygoKSA9PiBkYXRhPy5maW5kKHdhbGxldCA9PiB3YWxsZXQuaXNfc2VsZWN0ZWQpLCBbZGF0YV0pO1xuXG4gICAgLyoqIFVzZXIncyBjdXJyZW50IGFjdGl2ZSB3YWxsZXQuICovXG4gICAgcmV0dXJuIGFjdGl2ZV93YWxsZXQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VBY3RpdmVXYWxsZXQ7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlRmV0Y2ggfSBmcm9tICdAZGVyaXYvYXBpJztcbmltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnQGRlcml2L3N0b3Jlcyc7XG5pbXBvcnQgdXNlV2FsbGV0c0xpc3QgZnJvbSAnLi91c2VXYWxsZXRzTGlzdCc7XG5pbXBvcnQgdXNlQXV0aG9yaXplIGZyb20gJy4vdXNlQXV0aG9yaXplJztcblxuY29uc3QgdXNlQXZhaWxhYmxlV2FsbGV0cyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNsaWVudCwgdWkgfSA9IHVzZVN0b3JlKCk7XG4gICAgY29uc3QgeyBpc19kYXJrX21vZGVfb24gfSA9IHVpO1xuICAgIGNvbnN0IHsgaXNfY3J5cHRvIH0gPSBjbGllbnQ7XG4gICAgY29uc3QgeyBkYXRhIH0gPSB1c2VBdXRob3JpemUoKTtcblxuICAgIGNvbnN0IHsgZGF0YTogYWNjb3VudF90eXBlX2RhdGEsIC4uLnJlc3QgfSA9IHVzZUZldGNoKCdnZXRfYWNjb3VudF90eXBlcycsIHtcbiAgICAgICAgcGF5bG9hZDogeyBjb21wYW55OiBkYXRhPy5sYW5kaW5nX2NvbXBhbnlfbmFtZSA9PT0gJ3ZpcnR1YWwnID8gJ3N2ZycgOiBkYXRhPy5sYW5kaW5nX2NvbXBhbnlfbmFtZSB9LFxuICAgICAgICBvcHRpb25zOiB7IGVuYWJsZWQ6IEJvb2xlYW4oZGF0YT8ubGFuZGluZ19jb21wYW55X25hbWUpIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCB7IGRhdGE6IGFkZGVkX3dhbGxldHMgfSA9IHVzZVdhbGxldHNMaXN0KCk7XG5cbiAgICBjb25zdCBzb3J0ZWRXYWxsZXRzID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghYWNjb3VudF90eXBlX2RhdGEpIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCB7IGNyeXB0bywgZG91Z2hmbG93IH0gPSBhY2NvdW50X3R5cGVfZGF0YT8uZ2V0X2FjY291bnRfdHlwZXM/LndhbGxldCB8fCB7fTtcbiAgICAgICAgY29uc3QgY3J5cHRvX2N1cnJlbmNpZXMgPSBjcnlwdG8/LmN1cnJlbmNpZXM7XG4gICAgICAgIGNvbnN0IGZpYXRfY3VycmVuY2llcyA9IGRvdWdoZmxvdz8uY3VycmVuY2llcztcblxuICAgICAgICBpZiAoIWNyeXB0b19jdXJyZW5jaWVzIHx8ICFmaWF0X2N1cnJlbmNpZXMpIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBhdmFpbGFibGVfY3VycmVuY2llcyA9IFsuLi5maWF0X2N1cnJlbmNpZXMsIC4uLmNyeXB0b19jdXJyZW5jaWVzXTtcbiAgICAgICAgY29uc3Qgbm9uX3ZpcnR1YWxfd2FsbGV0cyA9IGFkZGVkX3dhbGxldHM/LmZpbHRlcih3YWxsZXQgPT4gIXdhbGxldC5pc192aXJ0dWFsKTtcblxuICAgICAgICBjb25zdCBtb2RpZmllZF93YWxsZXRzID0gbm9uX3ZpcnR1YWxfd2FsbGV0cz8ubWFwKHdhbGxldCA9PiAoe1xuICAgICAgICAgICAgY3VycmVuY3k6IHdhbGxldC5jdXJyZW5jeSxcbiAgICAgICAgICAgIGxhbmRpbmdfY29tcGFueV9uYW1lOiB3YWxsZXQubGFuZGluZ19jb21wYW55X25hbWUsXG4gICAgICAgICAgICBpc19hZGRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGdyYWRpZW50X2NhcmRfY2xhc3M6IHdhbGxldC5ncmFkaWVudF9jYXJkX2NsYXNzLFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgY29uc3QgYXZhaWxhYmxlX3dhbGxldHMgPSBhdmFpbGFibGVfY3VycmVuY2llc1xuICAgICAgICAgICAgLmZpbHRlcihjdXJyZW5jeSA9PiAhbW9kaWZpZWRfd2FsbGV0cz8uc29tZSh3YWxsZXQgPT4gd2FsbGV0LmN1cnJlbmN5ID09PSBjdXJyZW5jeSkpXG4gICAgICAgICAgICAubWFwKGN1cnJlbmN5ID0+ICh7XG4gICAgICAgICAgICAgICAgY3VycmVuY3ksXG4gICAgICAgICAgICAgICAgbGFuZGluZ19jb21wYW55X25hbWU6IGRhdGE/LmxhbmRpbmdfY29tcGFueV9uYW1lID09PSAndmlydHVhbCcgPyAnc3ZnJyA6IGRhdGE/LmxhbmRpbmdfY29tcGFueV9uYW1lLFxuICAgICAgICAgICAgICAgIGlzX2FkZGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBncmFkaWVudF9jYXJkX2NsYXNzOiBgd2FsbGV0LWNhcmRfXyR7Y3VycmVuY3kudG9Mb3dlckNhc2UoKX0tYmcke2lzX2RhcmtfbW9kZV9vbiA/ICctLWRhcmsnIDogJyd9YCxcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAvLyBTb3J0IHRoZSB1bmFkZGVkIHdhbGxldHMgYWxwaGFiZXRpY2FsbHkgYnkgZmlhdCwgY3J5cHRvLCB0aGVuIHZpcnR1YWxcbiAgICAgICAgYXZhaWxhYmxlX3dhbGxldHM/LnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGlmIChpc19jcnlwdG8oYS5jdXJyZW5jeSkgIT09IGlzX2NyeXB0byhiLmN1cnJlbmN5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc19jcnlwdG8oYS5jdXJyZW5jeSkgPyAxIDogLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoYS5jdXJyZW5jeSB8fCAnVVNEJykubG9jYWxlQ29tcGFyZShiLmN1cnJlbmN5IHx8ICdVU0QnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU29ydCB0aGUgYWRkZWQgd2FsbGV0cyBhbHBoYWJldGljYWxseSBieSBmaWF0LCBjcnlwdG8sIHRoZW4gdmlydHVhbCAoaWYgYW55KVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtb2RpZmllZF93YWxsZXRzKSkge1xuICAgICAgICAgICAgbW9kaWZpZWRfd2FsbGV0cz8uc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpc19jcnlwdG8oYS5jdXJyZW5jeSkgIT09IGlzX2NyeXB0byhiLmN1cnJlbmN5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNfY3J5cHRvKGEuY3VycmVuY3kpID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiAoYS5jdXJyZW5jeSB8fCAnVVNEJykubG9jYWxlQ29tcGFyZShiLmN1cnJlbmN5IHx8ICdVU0QnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5hdmFpbGFibGVfd2FsbGV0cywgLi4ubW9kaWZpZWRfd2FsbGV0c107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gWy4uLmF2YWlsYWJsZV93YWxsZXRzXTtcbiAgICB9LCBbYWRkZWRfd2FsbGV0cywgYWNjb3VudF90eXBlX2RhdGEsIGRhdGE/LmxhbmRpbmdfY29tcGFueV9uYW1lLCBpc19kYXJrX21vZGVfb24sIGlzX2NyeXB0b10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgZGF0YTogc29ydGVkV2FsbGV0cyxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlQXZhaWxhYmxlV2FsbGV0cztcbiIsImltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnQGRlcml2L3N0b3Jlcyc7XG5cbi8qKiBAZGVwcmVjYXRlZCBVc2UgYHVzZU1UNUFjY291bnRzTGlzdGAgZm9yIE1UNSBhY2NvdW50cyBhbmQgYHVzZUR4dHJhZGVBY2NvdW50c0xpc3RgIGZvciBPdGhlciBDRkQgYWNjb3VudHMgZnJvbSBgQGRlcml2L2FwaWAgaW5zdGVhZC4gKi9cbmNvbnN0IHVzZUNGREFsbEFjY291bnRzID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY2xpZW50IH0gPSB1c2VTdG9yZSgpO1xuICAgIGNvbnN0IHsgZHh0cmFkZV9hY2NvdW50c19saXN0LCBtdDVfbG9naW5fbGlzdCwgZGVyaXZlel9hY2NvdW50c19saXN0LCBjdHJhZGVyX2FjY291bnRzX2xpc3QgfSA9IGNsaWVudDtcblxuICAgIGxldCBjZmRfYWNjb3VudHM6IHR5cGVvZiBtdDVfbG9naW5fbGlzdCA9IFtdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG10NV9sb2dpbl9saXN0KSkge1xuICAgICAgICBjZmRfYWNjb3VudHMgPSBbLi4uY2ZkX2FjY291bnRzLCAuLi5tdDVfbG9naW5fbGlzdF07XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGR4dHJhZGVfYWNjb3VudHNfbGlzdCkpIHtcbiAgICAgICAgY2ZkX2FjY291bnRzID0gWy4uLmNmZF9hY2NvdW50cywgLi4uZHh0cmFkZV9hY2NvdW50c19saXN0XTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY3RyYWRlcl9hY2NvdW50c19saXN0KSkge1xuICAgICAgICBjZmRfYWNjb3VudHMgPSBbLi4uY2ZkX2FjY291bnRzLCAuLi5jdHJhZGVyX2FjY291bnRzX2xpc3RdO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZXJpdmV6X2FjY291bnRzX2xpc3QpKSB7XG4gICAgICAgIGNmZF9hY2NvdW50cyA9IFsuLi5jZmRfYWNjb3VudHMsIC4uLmRlcml2ZXpfYWNjb3VudHNfbGlzdF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGNmZF9hY2NvdW50cztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUNGREFsbEFjY291bnRzO1xuIiwiaW1wb3J0IHVzZUNGREFsbEFjY291bnRzIGZyb20gJy4vdXNlQ0ZEQWxsQWNjb3VudHMnO1xuXG4vKipcbiAqICB3ZSBjYW4gdXNlIHRoaXMgaG9vayB0byBnZXQgdGhlIENGRCBkZW1vIGFjY291bnRzLlxuICogIGl0IGxvb3BzIHRocm91Z2ggdGhlIGFsbCBvZiB1c2VyJ3MgQ0ZEIGFjY291bnRzLCBmaW5kcyBhbmQgcmV0dXJucyBkZW1vIGFjY291bnRzXG4gKi9cbmNvbnN0IHVzZUNGRERlbW9BY2NvdW50cyA9ICgpID0+IHtcbiAgICBjb25zdCBjZmRfYWNjb3VudHMgPSB1c2VDRkRBbGxBY2NvdW50cygpO1xuXG4gICAgY29uc3QgY2ZkX2RlbW9fYWNjb3VudHMgPSBjZmRfYWNjb3VudHMuZmlsdGVyKGFjY291bnQgPT4gYWNjb3VudC5hY2NvdW50X3R5cGUgPT09ICdkZW1vJyk7XG5cbiAgICByZXR1cm4gY2ZkX2RlbW9fYWNjb3VudHM7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VDRkREZW1vQWNjb3VudHM7XG4iLCJpbXBvcnQgeyB1c2VTdG9yZSB9IGZyb20gJ0BkZXJpdi9zdG9yZXMnO1xuaW1wb3J0IHVzZUNGREFsbEFjY291bnRzIGZyb20gJy4vdXNlQ0ZEQWxsQWNjb3VudHMnO1xuXG4vKipcbiAqIHdlIGNhbiB1c2UgdGhpcyBob29rIHRvIGdldCB0aGUgcmVhbCBDRkQgYWNjb3VudHMgZm9yIGJvdGggRXUgYW5kIE5vbi1FdSByZWdpb25zLlxuICogaXQgbG9vcHMgdGhyb3VnaCB0aGUgYWxsIG9mIHVzZXIncyBDRkQgYWNjb3VudHMsIGZpbmRzIGFuZCByZXR1cm5zIHJlYWwgYWNjb3VudHNcbiAqL1xuY29uc3QgdXNlQ0ZEUmVhbEFjY291bnRzID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgdHJhZGVyc19odWIgfSA9IHVzZVN0b3JlKCk7XG4gICAgY29uc3QgeyBpc19ldV91c2VyIH0gPSB0cmFkZXJzX2h1YjtcbiAgICBjb25zdCBjZmRfYWNjb3VudHMgPSB1c2VDRkRBbGxBY2NvdW50cygpO1xuXG4gICAgY29uc3QgY2ZkX3JlYWxfYWNjb3VudHMgPSBjZmRfYWNjb3VudHMuZmlsdGVyKGFjY291bnQgPT4ge1xuICAgICAgICBjb25zdCBpc19kZW1vID0gYWNjb3VudC5hY2NvdW50X3R5cGUgPT09ICdkZW1vJztcbiAgICAgICAgY29uc3QgaXNfbWFsdGFpbnZlc3QgPSBhY2NvdW50LmxhbmRpbmdfY29tcGFueV9zaG9ydCA9PT0gJ21hbHRhaW52ZXN0JztcblxuICAgICAgICBpZiAoaXNfZGVtbykgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWlzX2V1X3VzZXIpIHJldHVybiAhaXNfbWFsdGFpbnZlc3Q7XG5cbiAgICAgICAgcmV0dXJuIGlzX21hbHRhaW52ZXN0O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNmZF9yZWFsX2FjY291bnRzO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlQ0ZEUmVhbEFjY291bnRzO1xuIiwiaW1wb3J0IHVzZUNGREFsbEFjY291bnRzIGZyb20gJy4vdXNlQ0ZEQWxsQWNjb3VudHMnO1xuaW1wb3J0IHVzZUNGRERlbW9BY2NvdW50cyBmcm9tICcuL3VzZUNGRERlbW9BY2NvdW50cyc7XG5pbXBvcnQgdXNlQ0ZEUmVhbEFjY291bnRzIGZyb20gJy4vdXNlQ0ZEUmVhbEFjY291bnRzJztcblxuLyoqXG4gKiB0aGlzIGlzIGEgd3JhcHBlciBob29rIGZvciB1c2VDRkREZW1vQWNjb3VudHMgYW5kIHVzZUNGRFJlYWxBY2NvdW50c1xuICogYW5kIGl0IHJldHVybnMgZGlmZmVyZW50IGNmZCBhY2NvdW50IHR5cGVzIHdoaWNoIGFyZSBkZW1vLCByZWFsLCBhbmQgYWxsXG4gKi9cblxuY29uc3QgdXNlQ0ZEQWNjb3VudHMgPSAoKSA9PiB7XG4gICAgY29uc3QgYWxsX2NmZF9hY2NvdW50cyA9IHVzZUNGREFsbEFjY291bnRzKCk7XG4gICAgY29uc3QgY2ZkX2RlbW9fYWNjb3VudHMgPSB1c2VDRkREZW1vQWNjb3VudHMoKTtcbiAgICBjb25zdCBjZmRfcmVhbF9hY2NvdW50cyA9IHVzZUNGRFJlYWxBY2NvdW50cygpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWxsOiBhbGxfY2ZkX2FjY291bnRzLFxuICAgICAgICBkZW1vOiBjZmRfZGVtb19hY2NvdW50cyxcbiAgICAgICAgcmVhbDogY2ZkX3JlYWxfYWNjb3VudHMsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUNGREFjY291bnRzO1xuIiwiaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICdAZGVyaXYvc3RvcmVzJztcblxuY29uc3QgdXNlQ2FzaGllckxvY2tlZCA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNsaWVudCB9ID0gdXNlU3RvcmUoKTtcbiAgICBjb25zdCB7IGFjY291bnRfc3RhdHVzIH0gPSBjbGllbnQ7XG5cbiAgICBjb25zdCBpc19jYXNoaWVyX2xvY2tlZCA9IGFjY291bnRfc3RhdHVzLnN0YXR1cz8uc29tZShzdGF0dXMgPT4gc3RhdHVzID09PSAnY2FzaGllcl9sb2NrZWQnKSB8fCBmYWxzZTtcblxuICAgIHJldHVybiBpc19jYXNoaWVyX2xvY2tlZDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUNhc2hpZXJMb2NrZWQ7XG4iLCJpbXBvcnQgeyB1c2VTdG9yZSB9IGZyb20gJ0BkZXJpdi9zdG9yZXMnO1xuXG5jb25zdCB1c2VDb250ZW50RmxhZyA9ICgpID0+IHtcbiAgICBjb25zdCB7IHRyYWRlcnNfaHViIH0gPSB1c2VTdG9yZSgpO1xuICAgIGNvbnN0IHsgY29udGVudF9mbGFnIH0gPSB0cmFkZXJzX2h1YjtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGlzX2xvd19yaXNrX2NyX25vbl9ldTogY29udGVudF9mbGFnID09PSAnbG93X3Jpc2tfY3Jfbm9uX2V1JyxcbiAgICAgICAgaXNfbG93X3Jpc2tfY3JfZXU6IGNvbnRlbnRfZmxhZyA9PT0gJ2xvd19yaXNrX2NyX2V1JyxcbiAgICAgICAgaXNfaGlnaF9yaXNrX2NyOiBjb250ZW50X2ZsYWcgPT09ICdoaWdoX3Jpc2tfY3InLFxuICAgICAgICBpc19jcl9kZW1vOiBjb250ZW50X2ZsYWcgPT09ICdjcl9kZW1vJyxcbiAgICAgICAgaXNfZXVfZGVtbzogY29udGVudF9mbGFnID09PSAnZXVfZGVtbycsXG4gICAgICAgIGlzX2V1X3JlYWw6IGNvbnRlbnRfZmxhZyA9PT0gJ2V1X3JlYWwnLFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VDb250ZW50RmxhZztcbiIsImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IE9ORV9TRUNPTkQgPSAxMDAwO1xuXG5leHBvcnQgdHlwZSBUQ291bnRkb3duT3B0aW9ucyA9IHtcbiAgICBmcm9tOiBudW1iZXI7XG4gICAgdG8/OiBudW1iZXI7XG4gICAgaW5jcmVtZW50PzogYm9vbGVhbjtcbn07XG5cbmNvbnN0IHVzZUNvdW50ZG93biA9ICh7IGZyb20sIHRvID0gMCwgaW5jcmVtZW50ID0gZmFsc2UgfTogVENvdW50ZG93bk9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBbY291bnQsIHNldENvdW50XSA9IHVzZVN0YXRlKGZyb20pO1xuICAgIGNvbnN0IFtpc19ydW5uaW5nLCBzZXRJc1J1bm5pbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGV0IHRpbWVyOiBOb2RlSlMuVGltZW91dDtcblxuICAgICAgICBpZiAoaXNfcnVubmluZykge1xuICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdXNlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q291bnQob2xkID0+IChpbmNyZW1lbnQgPyBvbGQgKyAxIDogb2xkIC0gMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIE9ORV9TRUNPTkQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgfSwgW2NvdW50LCBpc19ydW5uaW5nLCB0bywgaW5jcmVtZW50XSk7XG5cbiAgICBjb25zdCBzdGFydCA9ICgpID0+IHNldElzUnVubmluZyh0cnVlKTtcblxuICAgIGNvbnN0IHBhdXNlID0gKCkgPT4gc2V0SXNSdW5uaW5nKGZhbHNlKTtcblxuICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4gc2V0Q291bnQoZnJvbSk7XG5cbiAgICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgICAgICBwYXVzZSgpO1xuICAgICAgICByZXNldCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjb3VudCxcbiAgICAgICAgaXNfcnVubmluZyxcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIHBhdXNlLFxuICAgICAgICByZXNldCxcbiAgICAgICAgc3RvcCxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlQ291bnRkb3duO1xuIiwiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVN1YnNjcmlwdGlvbiB9IGZyb20gJ0BkZXJpdi9hcGknO1xuXG50eXBlIFRUcmFuc2FjdGlvbiA9IE5vbk51bGxhYmxlPFxuICAgIE5vbk51bGxhYmxlPFJldHVyblR5cGU8dHlwZW9mIHVzZVN1YnNjcmlwdGlvbjwnY2FzaGllcl9wYXltZW50cyc+PlsnZGF0YSddPlsnY2FzaGllcl9wYXltZW50cyddXG4+WydjcnlwdG8nXVtudW1iZXJdO1xuXG50eXBlIFRTdGF0dXMgPSBUVHJhbnNhY3Rpb25bJ3N0YXR1c19jb2RlJ107XG5cbnR5cGUgVERlcG9zaXRTdGF0dXMgPSAnUEVORElORycgfCAnQ09ORklSTUVEJyB8ICdFUlJPUic7XG5cbnR5cGUgVFdpdGhkcmF3YWxTdGF0dXMgPSBFeGNsdWRlPFRTdGF0dXMsIFREZXBvc2l0U3RhdHVzPjtcblxuLy8gU2luY2UgQkUgc2VuZHMgdGhlIGBzdGF0dXNfY29kZWAgZm9yIGJvdGggYGRlcG9zaXRgIGFuZCBgd2l0aGRyYXdhbGAgaW4gdGhlIHNhbWUgZmllbGQsXG4vLyBIZXJlIHdlIG1vZGlmeSB0aGUgQkUgdHlwZSB0byBtYWtlIGBzdGF0dXNfY29kZWAgdHlwZSBtb3JlIHNwZWNpZmljIHRvIHRoZSBgdHJhbnNhY3Rpb25fdHlwZWAgZmllbGQuXG50eXBlIFRNb2RpZmllZFRyYW5zYWN0aW9uID0gT21pdDxUVHJhbnNhY3Rpb24sICdzdGF0dXNfY29kZScgfCAndHJhbnNhY3Rpb25fdHlwZSc+ICZcbiAgICAoXG4gICAgICAgIHwgeyB0cmFuc2FjdGlvbl90eXBlOiAnZGVwb3NpdCc7IHN0YXR1c19jb2RlOiBURGVwb3NpdFN0YXR1cyB9XG4gICAgICAgIHwgeyB0cmFuc2FjdGlvbl90eXBlOiAnd2l0aGRyYXdhbCc7IHN0YXR1c19jb2RlOiBUV2l0aGRyYXdhbFN0YXR1cyB9XG4gICAgKTtcblxuLyoqIEEgY3VzdG9tIGhvb2sgdGhhdCByZXR1cm5zIHRoZSBsaXN0IG9mIHBlbmRpbmcgY3J5cHRvIHRyYW5zYWN0aW9ucyBmb3IgdGhlIGN1cnJlbnQgdXNlci4gKi9cbmNvbnN0IHVzZUNyeXB0b1RyYW5zYWN0aW9ucyA9ICgpID0+IHtcbiAgICBjb25zdCB7IHN1YnNjcmliZSwgZGF0YSwgLi4ucmVzdCB9ID0gdXNlU3Vic2NyaXB0aW9uKCdjYXNoaWVyX3BheW1lbnRzJyk7XG4gICAgY29uc3QgW3RyYW5zYWN0aW9ucywgc2V0VHJhbnNhY3Rpb25zXSA9IHVzZVN0YXRlPFRNb2RpZmllZFRyYW5zYWN0aW9uW10+KCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdWJzY3JpYmUoKTtcbiAgICB9LCBbc3Vic2NyaWJlXSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzZXRUcmFuc2FjdGlvbnMob2xkX3RyYW5zYWN0aW9ucyA9PiB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGxpc3Qgb2YgdGhlIGNyeXB0byB0cmFuc2FjdGlvbnMuXG4gICAgICAgICAgICBjb25zdCBuZXdfdHJhbnNhY3Rpb25zID0gZGF0YT8uY2FzaGllcl9wYXltZW50cz8uY3J5cHRvIGFzIFRNb2RpZmllZFRyYW5zYWN0aW9uW10gfCB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBuZXcgdHJhbnNhY3Rpb25zLCByZXR1cm4gdGhlIG9sZCB0cmFuc2FjdGlvbnMuXG4gICAgICAgICAgICBpZiAoIW5ld190cmFuc2FjdGlvbnMpIHJldHVybiBvbGRfdHJhbnNhY3Rpb25zO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gb2xkIHRyYW5zYWN0aW9ucywgcmV0dXJuIHRoZSBuZXcgdHJhbnNhY3Rpb25zLlxuICAgICAgICAgICAgaWYgKCFvbGRfdHJhbnNhY3Rpb25zKSByZXR1cm4gbmV3X3RyYW5zYWN0aW9ucztcblxuICAgICAgICAgICAgLy8gTWFrZSBhIGNvcHkgb2YgdGhlIG9sZCB0cmFuc2FjdGlvbnMuXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkX3RyYW5zYWN0aW9ucyA9IFsuLi5vbGRfdHJhbnNhY3Rpb25zXTtcblxuICAgICAgICAgICAgLy8gRm9yIGVhY2ggbmV3IHRyYW5zYWN0aW9uLCBjaGVjayBpZiBpdCBleGlzdHMgaW4gdGhlIG9sZCB0cmFuc2FjdGlvbnMuXG4gICAgICAgICAgICBuZXdfdHJhbnNhY3Rpb25zLmZvckVhY2gobmV3X3RyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgbmV3IHRyYW5zYWN0aW9uIGluIHRoZSBvbGQgdHJhbnNhY3Rpb25zIGlmIGV4aXN0cy5cbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHVwZGF0ZWRfdHJhbnNhY3Rpb25zLmZpbmRJbmRleChcbiAgICAgICAgICAgICAgICAgICAgb2xkX3RyYW5zYWN0aW9uID0+IG9sZF90cmFuc2FjdGlvbi5pZCA9PT0gbmV3X3RyYW5zYWN0aW9uLmlkXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBuZXcgdHJhbnNhY3Rpb24gZG9lcyBub3QgZXhpc3QgaW4gdGhlIG9sZCB0cmFuc2FjdGlvbnMsIGFkZCBpdCwgb3RoZXJ3aXNlIHVwZGF0ZSBpdC5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRfdHJhbnNhY3Rpb25zLnB1c2gobmV3X3RyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkX3RyYW5zYWN0aW9uc1tpbmRleF0gPSBuZXdfdHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgdXBkYXRlZCB0cmFuc2FjdGlvbnMuXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlZF90cmFuc2FjdGlvbnM7XG4gICAgICAgIH0pO1xuICAgIH0sIFtkYXRhPy5jYXNoaWVyX3BheW1lbnRzPy5jcnlwdG9dKTtcblxuICAgIC8vIEFkZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHRvIGVhY2ggdHJhbnNhY3Rpb24uXG4gICAgY29uc3QgbW9kaWZpZWRfdHJhbnNhY3Rpb25zID0gdXNlTWVtbyhcbiAgICAgICAgKCkgPT5cbiAgICAgICAgICAgIHRyYW5zYWN0aW9ucz8ubWFwKHRyYW5zYWN0aW9uID0+ICh7XG4gICAgICAgICAgICAgICAgLi4udHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgLyoqIERldGVybWluZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYSBkZXBvc2l0IG9yIG5vdC4gKi9cbiAgICAgICAgICAgICAgICBpc19kZXBvc2l0OiB0cmFuc2FjdGlvbi50cmFuc2FjdGlvbl90eXBlID09PSAnZGVwb3NpdCcsXG4gICAgICAgICAgICAgICAgLyoqIERldGVybWluZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYSB3aXRoZHJhd2FsIG9yIG5vdC4gKi9cbiAgICAgICAgICAgICAgICBpc193aXRoZHJhd2FsOiB0cmFuc2FjdGlvbi50cmFuc2FjdGlvbl90eXBlID09PSAnd2l0aGRyYXdhbCcsXG4gICAgICAgICAgICB9KSksXG4gICAgICAgIFt0cmFuc2FjdGlvbnNdXG4gICAgKTtcblxuICAgIC8vIFNvcnQgdHJhbnNhY3Rpb25zIGJ5IHN1Ym1pdCB0aW1lLlxuICAgIGNvbnN0IHNvcnRlZF90cmFuc2FjdGlvbnMgPSB1c2VNZW1vKFxuICAgICAgICAoKSA9PiBtb2RpZmllZF90cmFuc2FjdGlvbnM/LnNvcnQoKGEsIGIpID0+IGIuc3VibWl0X2RhdGUgLSBhLnN1Ym1pdF9kYXRlKSxcbiAgICAgICAgW21vZGlmaWVkX3RyYW5zYWN0aW9uc11cbiAgICApO1xuXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSB1c2VyIGhhcyBhbnkgdHJhbnNhY3Rpb25zIG9yIG5vdC5cbiAgICBjb25zdCBoYXNfdHJhbnNhY3Rpb25zID0gbW9kaWZpZWRfdHJhbnNhY3Rpb25zICYmIG1vZGlmaWVkX3RyYW5zYWN0aW9ucy5sZW5ndGggPiAwO1xuXG4gICAgLy8gR2V0IHRoZSBsYXN0IHRyYW5zYWN0aW9uIGlmIGV4aXN0cy5cbiAgICBjb25zdCBsYXN0X3RyYW5zYWN0aW9uID0gbW9kaWZpZWRfdHJhbnNhY3Rpb25zPy5bMF07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKiogTGlzdCBvZiB1c2VyIHRyYW5zYWN0aW9ucyBzb3J0ZWQgYnkgc3VibWl0IHRpbWUuICovXG4gICAgICAgIGRhdGE6IHNvcnRlZF90cmFuc2FjdGlvbnMsXG4gICAgICAgIC8qKiBSZXR1cm5zIHRoZSBsYXN0IHRyYW5zYWN0aW9uIGlmIGV4aXN0cy4gKi9cbiAgICAgICAgbGFzdF90cmFuc2FjdGlvbixcbiAgICAgICAgLyoqIERldGVybWluZSBpcyB0aGUgdXNlciBoYXMgYW55IHRyYW5zYWN0aW9ucyBvciBub3QuICovXG4gICAgICAgIGhhc190cmFuc2FjdGlvbnMsXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgLi4ucmVzdCxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlQ3J5cHRvVHJhbnNhY3Rpb25zO1xuIiwiaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICdAZGVyaXYvc3RvcmVzJztcblxuY29uc3QgdXNlQ3VycmVudEFjY291bnREZXRhaWxzID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY2xpZW50IH0gPSB1c2VTdG9yZSgpO1xuICAgIGNvbnN0IHsgYWNjb3VudF9saXN0LCBsb2dpbmlkIH0gPSBjbGllbnQ7XG5cbiAgICByZXR1cm4gYWNjb3VudF9saXN0LmZpbmQoYWNjb3VudCA9PiBsb2dpbmlkID09PSBhY2NvdW50LmxvZ2luaWQpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlQ3VycmVudEFjY291bnREZXRhaWxzO1xuIiwiaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICdAZGVyaXYvc3RvcmVzJztcbmltcG9ydCB1c2VDdXJyZW5jeUNvbmZpZyBmcm9tICcuL3VzZUN1cnJlbmN5Q29uZmlnJztcblxuLyoqIEEgY3VzdG9tIGhvb2sgdG8gZ2V0IHRoZSBjdXJyZW5jeSBjb25maWcgaW5mb3JtYXRpb24gZm9yIHRoZSB1c2VyJ3MgY3VycmVudCBjdXJyZW5jeS4gKi9cbmNvbnN0IHVzZUN1cnJlbnRDdXJyZW5jeUNvbmZpZyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNsaWVudCB9ID0gdXNlU3RvcmUoKTtcbiAgICBjb25zdCB7IGN1cnJlbmN5IH0gPSBjbGllbnQ7XG4gICAgY29uc3QgeyBnZXRDb25maWcgfSA9IHVzZUN1cnJlbmN5Q29uZmlnKCk7XG4gICAgY29uc3QgY3VycmVuY3lfY29uZmlnID0gZ2V0Q29uZmlnKGN1cnJlbmN5KTtcblxuICAgIC8vIFNhZmUgdG8gZG8gbnVsbCBhc3NlcnRpb24gaGVyZSBiZWNhdXNlIHRoZSB1c2VyJ3MgY3VycmVuY3kgaXMgYWx3YXlzXG4gICAgLy8gYXZhaWxhYmxlIGluIHRoZSBjdXJyZW5jeSBjb25maWcgb2JqZWN0IHNvIGl0IGNhbid0IGJlIG51bGwuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICByZXR1cm4gY3VycmVuY3lfY29uZmlnITtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUN1cnJlbnRDdXJyZW5jeUNvbmZpZztcbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VSZXF1ZXN0IH0gZnJvbSAnQGRlcml2L2FwaSc7XG5cbmNvbnN0IHVzZURlcG9zaXRDcnlwdG9BZGRyZXNzID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgZGF0YSwgbXV0YXRlLCAuLi5yZXN0IH0gPSB1c2VSZXF1ZXN0KCdjYXNoaWVyJyk7XG4gICAgY29uc3QgZGVwb3NpdF9hZGRyZXNzID0gdHlwZW9mIGRhdGE/LmNhc2hpZXIgIT09ICdzdHJpbmcnID8gZGF0YT8uY2FzaGllcj8uZGVwb3NpdD8uYWRkcmVzcyA6IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0IHNlbmQgPSB1c2VDYWxsYmFjayhcbiAgICAgICAgKCkgPT4gbXV0YXRlKHsgcGF5bG9hZDogeyBjYXNoaWVyOiAnZGVwb3NpdCcsIHByb3ZpZGVyOiAnY3J5cHRvJywgdHlwZTogJ2FwaScgfSB9KSxcbiAgICAgICAgW211dGF0ZV1cbiAgICApO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2VuZCgpO1xuICAgIH0sIFtzZW5kXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5yZXN0LFxuICAgICAgICByZXNlbmQ6IHNlbmQsXG4gICAgICAgIGRhdGE6IGRlcG9zaXRfYWRkcmVzcyxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlRGVwb3NpdENyeXB0b0FkZHJlc3M7XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlUmVxdWVzdCB9IGZyb20gJ0BkZXJpdi9hcGknO1xuaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICdAZGVyaXYvc3RvcmVzJztcblxuY29uc3QgdXNlRGVwb3NpdEZpYXRBZGRyZXNzID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgdWkgfSA9IHVzZVN0b3JlKCk7XG4gICAgY29uc3QgeyBpc19kYXJrX21vZGVfb24gfSA9IHVpO1xuICAgIGNvbnN0IHsgZGF0YSwgbXV0YXRlLCAuLi5yZXN0IH0gPSB1c2VSZXF1ZXN0KCdjYXNoaWVyJyk7XG4gICAgY29uc3QgZGVwb3NpdF9pZnJhbWVfdXJsID1cbiAgICAgICAgdHlwZW9mIGRhdGE/LmNhc2hpZXIgPT09ICdzdHJpbmcnID8gYCR7ZGF0YT8uY2FzaGllcn0mRGFya01vZGU9JHtpc19kYXJrX21vZGVfb24gPyAnb24nIDogJ29mZid9YCA6IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0IHNlbmQgPSB1c2VDYWxsYmFjaygoKSA9PiBtdXRhdGUoeyBwYXlsb2FkOiB7IGNhc2hpZXI6ICdkZXBvc2l0JywgcHJvdmlkZXI6ICdkb3VnaGZsb3cnIH0gfSksIFttdXRhdGVdKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNlbmQoKTtcbiAgICB9LCBbc2VuZF0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgcmVzZW5kOiBzZW5kLFxuICAgICAgICBkYXRhOiBkZXBvc2l0X2lmcmFtZV91cmwsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZURlcG9zaXRGaWF0QWRkcmVzcztcbiIsImltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnQGRlcml2L3N0b3Jlcyc7XG5cbmNvbnN0IHVzZU5lZWRBdXRoZW50aWNhdGlvbiA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNsaWVudCwgdHJhZGVyc19odWIgfSA9IHVzZVN0b3JlKCk7XG4gICAgY29uc3QgeyBpc19hdXRoZW50aWNhdGlvbl9uZWVkZWQgfSA9IGNsaWVudDtcbiAgICBjb25zdCB7IGlzX2xvd19yaXNrX2NyX2V1X3JlYWwgfSA9IHRyYWRlcnNfaHViO1xuICAgIGNvbnN0IGlzX25lZWRfYXV0aGVudGljYXRpb24gPSBpc19hdXRoZW50aWNhdGlvbl9uZWVkZWQgJiYgaXNfbG93X3Jpc2tfY3JfZXVfcmVhbDtcblxuICAgIHJldHVybiBpc19uZWVkX2F1dGhlbnRpY2F0aW9uO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlTmVlZEF1dGhlbnRpY2F0aW9uO1xuIiwiaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICdAZGVyaXYvc3RvcmVzJztcblxuY29uc3QgdXNlTmVlZEZpbmFuY2lhbEFzc2Vzc21lbnQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjbGllbnQgfSA9IHVzZVN0b3JlKCk7XG4gICAgY29uc3QgeyBpc19maW5hbmNpYWxfYWNjb3VudCwgaXNfZmluYW5jaWFsX2luZm9ybWF0aW9uX2luY29tcGxldGUsIGlzX3RyYWRpbmdfZXhwZXJpZW5jZV9pbmNvbXBsZXRlIH0gPSBjbGllbnQ7XG4gICAgY29uc3QgaXNfbmVlZF9maW5hbmNpYWxfYXNzZXNzbWVudCA9XG4gICAgICAgIGlzX2ZpbmFuY2lhbF9hY2NvdW50ICYmIChpc19maW5hbmNpYWxfaW5mb3JtYXRpb25faW5jb21wbGV0ZSB8fCBpc190cmFkaW5nX2V4cGVyaWVuY2VfaW5jb21wbGV0ZSk7XG5cbiAgICByZXR1cm4gaXNfbmVlZF9maW5hbmNpYWxfYXNzZXNzbWVudDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZU5lZWRGaW5hbmNpYWxBc3Nlc3NtZW50O1xuIiwiaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICdAZGVyaXYvc3RvcmVzJztcblxuY29uc3QgdXNlUmVhbFNUUEFjY291bnQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjbGllbnQgfSA9IHVzZVN0b3JlKCk7XG4gICAgY29uc3QgeyBtdDVfbG9naW5fbGlzdCB9ID0gY2xpZW50O1xuICAgIGNvbnN0IGhhc19yZWFsX3N0cF9hY2NvdW50ID0gbXQ1X2xvZ2luX2xpc3Quc29tZShcbiAgICAgICAgaXRlbSA9PiBpdGVtLmFjY291bnRfdHlwZSA9PT0gJ3JlYWwnICYmIGl0ZW0uc3ViX2FjY291bnRfdHlwZSA9PT0gJ2ZpbmFuY2lhbF9zdHAnXG4gICAgKTtcblxuICAgIHJldHVybiBoYXNfcmVhbF9zdHBfYWNjb3VudDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZVJlYWxTVFBBY2NvdW50O1xuIiwiaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICdAZGVyaXYvc3RvcmVzJztcbmltcG9ydCB1c2VSZWFsU1RQQWNjb3VudCBmcm9tICcuL3VzZVJlYWxTVFBBY2NvdW50JztcblxuY29uc3QgdXNlTmVlZFROQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNsaWVudCB9ID0gdXNlU3RvcmUoKTtcbiAgICBjb25zdCB7IGlzX2V1LCBpc190bmNfbmVlZGVkIH0gPSBjbGllbnQ7XG4gICAgY29uc3QgaGFzX3JlYWxfc3RwX2FjY291bnQgPSB1c2VSZWFsU1RQQWNjb3VudCgpO1xuICAgIGNvbnN0IGlzX25lZWRfdG5jID0gKGlzX2V1IHx8IGhhc19yZWFsX3N0cF9hY2NvdW50KSAmJiBpc190bmNfbmVlZGVkO1xuXG4gICAgcmV0dXJuIGlzX25lZWRfdG5jO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlTmVlZFROQztcbiIsImltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnQGRlcml2L3N0b3Jlcyc7XG5pbXBvcnQgdXNlTmVlZEF1dGhlbnRpY2F0aW9uIGZyb20gJy4vdXNlTmVlZEF1dGhlbnRpY2F0aW9uJztcbmltcG9ydCB1c2VOZWVkRmluYW5jaWFsQXNzZXNzbWVudCBmcm9tICcuL3VzZU5lZWRGaW5hbmNpYWxBc3Nlc3NtZW50JztcbmltcG9ydCB1c2VOZWVkVE5DIGZyb20gJy4vdXNlTmVlZFROQyc7XG5cbmNvbnN0IHVzZURlcG9zaXRMb2NrZWQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjbGllbnQgfSA9IHVzZVN0b3JlKCk7XG4gICAgY29uc3QgeyBpc19kZXBvc2l0X2xvY2ssIGlzX3RyYWRpbmdfZXhwZXJpZW5jZV9pbmNvbXBsZXRlLCBsYW5kaW5nX2NvbXBhbnlfc2hvcnRjb2RlIH0gPSBjbGllbnQ7XG4gICAgY29uc3QgaXNfbmVlZF9hdXRoZW50aWNhdGlvbiA9IHVzZU5lZWRBdXRoZW50aWNhdGlvbigpO1xuICAgIGNvbnN0IGlzX25lZWRfdG5jID0gdXNlTmVlZFROQygpO1xuICAgIGNvbnN0IGlzX25lZWRfZmluYW5jaWFsX2Fzc2Vzc21lbnQgPSB1c2VOZWVkRmluYW5jaWFsQXNzZXNzbWVudCgpO1xuICAgIGNvbnN0IGlzX21hbHRhX2ludmVzdCA9IGxhbmRpbmdfY29tcGFueV9zaG9ydGNvZGUgPT09ICdtYWx0YWludmVzdCc7XG4gICAgY29uc3QgaXNfdHJhZGluZ19leHBlcmllbmNlX2luY29tcGxldGVfb3JfbmVlZF9maW5hbmNpYWxfYXNzZXNzbWVudCA9IGlzX21hbHRhX2ludmVzdFxuICAgICAgICA/IGlzX3RyYWRpbmdfZXhwZXJpZW5jZV9pbmNvbXBsZXRlXG4gICAgICAgIDogaXNfbmVlZF9maW5hbmNpYWxfYXNzZXNzbWVudDtcblxuICAgIGNvbnN0IGlzX2RlcG9zaXRfbG9ja2VkID1cbiAgICAgICAgaXNfZGVwb3NpdF9sb2NrIHx8XG4gICAgICAgIGlzX25lZWRfYXV0aGVudGljYXRpb24gfHxcbiAgICAgICAgaXNfbmVlZF90bmMgfHxcbiAgICAgICAgaXNfdHJhZGluZ19leHBlcmllbmNlX2luY29tcGxldGVfb3JfbmVlZF9maW5hbmNpYWxfYXNzZXNzbWVudDtcblxuICAgIHJldHVybiBpc19kZXBvc2l0X2xvY2tlZDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZURlcG9zaXRMb2NrZWQ7XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnQGRlcml2L3N0b3Jlcyc7XG5cbi8qKlxuICogd2UgY2FuIHVzZSB0aGlzIGhvb2sgdG8gZ2V0IHRoZSBleGNoYW5nZSByYXRlIGZvciB0aGUgZ2l2ZW4gY3VycmVuY3kuXG4gKiBleGNoYW5nZV9yYXRlcyBjb21lcyBmcm9tIHN0b3JlIGFuZCBpbmNsdWRlcyB0aGUgcmF0ZXMgZm9yIGFsbCBjdXJyZW5jaWVzIGJhc2VkIG9uIFVTRC5cbiAqL1xuY29uc3QgdXNlRXhjaGFuZ2VSYXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgZXhjaGFuZ2VfcmF0ZXMgfSA9IHVzZVN0b3JlKCk7XG4gICAgY29uc3QgZGF0YSA9IGV4Y2hhbmdlX3JhdGVzLmRhdGE7XG4gICAgY29uc3QgcmF0ZXMgPSBkYXRhPy5yYXRlcztcblxuICAgIGNvbnN0IGdldFJhdGUgPSB1c2VDYWxsYmFjaygoY3VycmVuY3k6IHN0cmluZykgPT4gcmF0ZXM/LltjdXJyZW5jeV0gfHwgMSwgW3JhdGVzXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBnZXRSYXRlLFxuICAgICAgICBsYXN0X3VwZGF0ZTogZGF0YT8uZGF0ZSxcbiAgICAgICAgYmFzZV9jdXJyZW5jeTogZGF0YT8uYmFzZV9jdXJyZW5jeSB8fCAnVVNEJyxcbiAgICB9O1xufTtcbmV4cG9ydCBkZWZhdWx0IHVzZUV4Y2hhbmdlUmF0ZTtcbiIsImltcG9ydCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VGZXRjaCB9IGZyb20gJ0BkZXJpdi9hcGknO1xuaW1wb3J0IHVzZUFjdGl2ZVdhbGxldCBmcm9tICcuL3VzZUFjdGl2ZVdhbGxldCc7XG5pbXBvcnQgeyB1c2VTdG9yZSB9IGZyb20gJ0BkZXJpdi9zdG9yZXMnO1xuXG50eXBlIFRBY2NvdW50ID0ge1xuICAgIGNmZF90eXBlPzogJ210NScgfCAnZGVyaXZleicgfCAnZHh0cmFkZSc7XG4gICAgbWFya2V0X3R5cGU/OiAnZmluYW5jaWFsJyB8ICdzeW50aGV0aWMnIHwgJ2FsbCc7XG59O1xuXG5jb25zdCBnZXRBY2NvdW50SWNvbiA9ICh7IGNmZF90eXBlLCBtYXJrZXRfdHlwZSB9OiBUQWNjb3VudCkgPT4ge1xuICAgIHN3aXRjaCAoY2ZkX3R5cGUpIHtcbiAgICAgICAgY2FzZSAnbXQ1Jzoge1xuICAgICAgICAgICAgc3dpdGNoIChtYXJrZXRfdHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbmFuY2lhbCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnSWNSZWJyYW5kaW5nTXQ1RmluYW5jaWFsRGFzaGJvYXJkJztcbiAgICAgICAgICAgICAgICBjYXNlICdzeW50aGV0aWMnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ0ljUmVicmFuZGluZ010NURlcml2ZWREYXNoYm9hcmQnO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FsbCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnSWNSZWJyYW5kaW5nTXQ1U3dhcEZyZWUnO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnSWNSZWJyYW5kaW5nRG10NURhc2hib2FyZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZGVyaXZleic6XG4gICAgICAgICAgICByZXR1cm4gJ0ljUmVicmFuZGluZ0Rlcml2RXonO1xuICAgICAgICBjYXNlICdkeHRyYWRlJzpcbiAgICAgICAgICAgIHJldHVybiAnSWNSZWJyYW5kaW5nRGVyaXZYJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICB9XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBUaGlzIGhvb2sgaXMgdXNlZCB0byBnZXQgdGhlIGNyZWF0ZWQgQ0ZEIGFjY291bnRzIG9mIHRoZSB1c2VyLlxuICovXG5jb25zdCB1c2VFeGlzdGluZ0NGREFjY291bnRzID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgdHJhZGVyc19odWIgfSA9IHVzZVN0b3JlKCk7XG4gICAgY29uc3QgeyBjb21iaW5lZF9jZmRfbXQ1X2FjY291bnRzIH0gPSB0cmFkZXJzX2h1YjtcbiAgICBjb25zdCB3YWxsZXQgPSB1c2VBY3RpdmVXYWxsZXQoKTtcbiAgICBjb25zdCB7IGRhdGE6IG10NSwgLi4ubXQ1X3Jlc3QgfSA9IHVzZUZldGNoKCdtdDVfbG9naW5fbGlzdCcpO1xuICAgIGNvbnN0IHsgZGF0YTogZGVyaXZleiwgLi4uZGVyaXZlel9yZXN0IH0gPSB1c2VGZXRjaCgndHJhZGluZ19wbGF0Zm9ybV9hY2NvdW50cycsIHtcbiAgICAgICAgcGF5bG9hZDogeyBwbGF0Zm9ybTogJ2Rlcml2ZXonIH0sXG4gICAgfSk7XG4gICAgY29uc3QgeyBkYXRhOiBkeHRyYWRlLCAuLi5keHRyYWRlX3Jlc3QgfSA9IHVzZUZldGNoKCd0cmFkaW5nX3BsYXRmb3JtX2FjY291bnRzJywge1xuICAgICAgICBwYXlsb2FkOiB7IHBsYXRmb3JtOiAnZHh0cmFkZScgfSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgdGhlIG1vZGlmaWVkIE1UNSBhY2NvdW50cyB0aGF0IHdpbGwgYmUgdXNlZCBpbiB0aGUgQ0ZEIGFjY291bnQgY3JlYXRpb24uXG4gICAgICovXG4gICAgY29uc3QgbW9kaWZpZWRfbXQ1X2FjY291bnRzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGdldEFjY291bnRJbmZvID0gKGxvZ2luPzogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBsYXRmb3JtOiB3YWxsZXQ/LmxpbmtlZF90bz8uZmluZChsaW5rZWQgPT4gbGlua2VkLmxvZ2luaWQgPT09IGxvZ2luKT8ucGxhdGZvcm0sXG4gICAgICAgICAgICAgICAgaWNvbjogY29tYmluZWRfY2ZkX210NV9hY2NvdW50cz8uZmluZChjZmQgPT4gY2ZkLmxvZ2luID09PSBsb2dpbik/Lmljb24sXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGNvbWJpbmVkX2NmZF9tdDVfYWNjb3VudHM/LmZpbmQoY2ZkID0+IGNmZC5sb2dpbiA9PT0gbG9naW4pPy5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBuYW1lOiBjb21iaW5lZF9jZmRfbXQ1X2FjY291bnRzPy5maW5kKGNmZCA9PiBjZmQubG9naW4gPT09IGxvZ2luKT8ubmFtZSxcbiAgICAgICAgICAgICAgICBzdWJfdGl0bGU6IGNvbWJpbmVkX2NmZF9tdDVfYWNjb3VudHM/LmZpbmQoY2ZkID0+IGNmZC5sb2dpbiA9PT0gbG9naW4pPy5zdWJfdGl0bGUsXG4gICAgICAgICAgICAgICAgYWN0aW9uX3R5cGU6ICdtdWx0aS1hY3Rpb24nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbXQ1Py5tdDVfbG9naW5fbGlzdD8ubWFwKGFjY291bnQgPT4gKHtcbiAgICAgICAgICAgIC4uLmFjY291bnQsXG4gICAgICAgICAgICAuLi5nZXRBY2NvdW50SW5mbyhhY2NvdW50LmxvZ2luKSxcbiAgICAgICAgICAgIGxvZ2luaWQ6IGFjY291bnQubG9naW4sXG4gICAgICAgICAgICB0cmFuc2Zlcl9pY29uOiBnZXRBY2NvdW50SWNvbih7IGNmZF90eXBlOiAnbXQ1JywgLi4uYWNjb3VudCB9KSxcbiAgICAgICAgfSkpO1xuICAgIH0sIFttdDU/Lm10NV9sb2dpbl9saXN0LCB3YWxsZXQ/LmxpbmtlZF90bywgY29tYmluZWRfY2ZkX210NV9hY2NvdW50c10pO1xuXG4gICAgY29uc3QgbW9kaWZpZWRfZGVyaXZlel9hY2NvdW50cyA9IHVzZU1lbW8oXG4gICAgICAgICgpID0+XG4gICAgICAgICAgICBkZXJpdmV6Py50cmFkaW5nX3BsYXRmb3JtX2FjY291bnRzPy5tYXAoYWNjb3VudCA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLmFjY291bnQsXG4gICAgICAgICAgICAgICAgbG9naW5pZDogYWNjb3VudC5sb2dpbixcbiAgICAgICAgICAgICAgICB0cmFuc2Zlcl9pY29uOiBnZXRBY2NvdW50SWNvbih7IGNmZF90eXBlOiAnZGVyaXZleicgfSksXG4gICAgICAgICAgICB9KSksXG4gICAgICAgIFtkZXJpdmV6Py50cmFkaW5nX3BsYXRmb3JtX2FjY291bnRzXVxuICAgICk7XG4gICAgY29uc3QgbW9kaWZpZWRfZHh0cmFkZV9hY2NvdW50cyA9IHVzZU1lbW8oXG4gICAgICAgICgpID0+XG4gICAgICAgICAgICBkeHRyYWRlPy50cmFkaW5nX3BsYXRmb3JtX2FjY291bnRzPy5tYXAoYWNjb3VudCA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLmFjY291bnQsXG4gICAgICAgICAgICAgICAgbG9naW5pZDogYWNjb3VudC5hY2NvdW50X2lkLFxuICAgICAgICAgICAgICAgIHRyYW5zZmVyX2ljb246IGdldEFjY291bnRJY29uKHsgY2ZkX3R5cGU6ICdkeHRyYWRlJyB9KSxcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgW2R4dHJhZGU/LnRyYWRpbmdfcGxhdGZvcm1fYWNjb3VudHNdXG4gICAgKTtcbiAgICBjb25zdCBkYXRhID0gdXNlTWVtbyhcbiAgICAgICAgKCkgPT4gKHtcbiAgICAgICAgICAgIG10NV9hY2NvdW50czogbW9kaWZpZWRfbXQ1X2FjY291bnRzIHx8IFtdLFxuICAgICAgICAgICAgZHh0cmFkZV9hY2NvdW50czogbW9kaWZpZWRfZHh0cmFkZV9hY2NvdW50cyB8fCBbXSxcbiAgICAgICAgICAgIGRlcml2ZXpfYWNjb3VudHM6IG1vZGlmaWVkX2Rlcml2ZXpfYWNjb3VudHMgfHwgW10sXG4gICAgICAgIH0pLFxuICAgICAgICBbbW9kaWZpZWRfbXQ1X2FjY291bnRzLCBtb2RpZmllZF9keHRyYWRlX2FjY291bnRzLCBtb2RpZmllZF9kZXJpdmV6X2FjY291bnRzXVxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBkYXRhLFxuICAgICAgICBpc1N1Y2Nlc3M6IFttdDVfcmVzdC5pc1N1Y2Nlc3MsIGR4dHJhZGVfcmVzdC5pc1N1Y2Nlc3MsIGRlcml2ZXpfcmVzdC5pc1N1Y2Nlc3NdLmV2ZXJ5KEJvb2xlYW4pLFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VFeGlzdGluZ0NGREFjY291bnRzO1xuIiwiaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnQGRlcml2L3N0b3Jlcyc7XG5cbmNvbnN0IHVzZUZlYXR1cmVGbGFncyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGZlYXR1cmVfZmxhZ3MgfSA9IHVzZVN0b3JlKCk7XG5cbiAgICBjb25zdCByZXN1bHQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgLy8gU2FmZSB0byBkbyBudWxsIGFzc2VydGlvbnMgaGVyZSBhcyB3ZSBhcmUgc2V0dGluZyBkZWZhdWx0IHZhbHVlcyBpbiB0aGUgc3RvcmUuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGNvbnN0IGZsYWdzID0gZmVhdHVyZV9mbGFncy5kYXRhITtcblxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoZmxhZ3MpLnJlZHVjZShcbiAgICAgICAgICAgIChwcmV2aW91cywgY3VycmVudCkgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi5wcmV2aW91cyxcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGN1cnJlbnQga2V5IGlzIGFsd2F5cyBwcmVzZW50IGluIHRoZSBvYmplY3QsIEhlbmNlIGNhbiBpZ25vcmUgdGhlIFRTIGVycm9yLlxuICAgICAgICAgICAgICAgIFtgaXNfJHtjdXJyZW50fV9lbmFibGVkYF06IEJvb2xlYW4oZmxhZ3NbY3VycmVudF0pLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB7fSBhcyBSZWNvcmQ8YGlzXyR7a2V5b2YgdHlwZW9mIGZsYWdzfV9lbmFibGVkYCwgYm9vbGVhbj5cbiAgICAgICAgKTtcbiAgICB9LCBbZmVhdHVyZV9mbGFncy5kYXRhXSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydCBkZWZhdWx0IHVzZUZlYXR1cmVGbGFncztcbiIsImltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnQGRlcml2L3N0b3Jlcyc7XG5cbmNvbnN0IHVzZUZpYXRBY2NvdW50TGlzdCA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNsaWVudCB9ID0gdXNlU3RvcmUoKTtcbiAgICBjb25zdCB7IGFjY291bnRfbGlzdCwgaXNfY3J5cHRvIH0gPSBjbGllbnQ7XG5cbiAgICBjb25zdCBmaWF0X2FjY291bnRfbGlzdCA9IGFjY291bnRfbGlzdC5maWx0ZXIoYWNjb3VudCA9PiAhYWNjb3VudC5pc192aXJ0dWFsICYmICFpc19jcnlwdG8oYWNjb3VudC50aXRsZSB8fCAnJykpO1xuXG4gICAgcmV0dXJuIGZpYXRfYWNjb3VudF9saXN0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlRmlhdEFjY291bnRMaXN0O1xuIiwiaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICdAZGVyaXYvc3RvcmVzJztcblxuY29uc3QgdXNlSGFzQWN0aXZlUmVhbEFjY291bnQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjbGllbnQgfSA9IHVzZVN0b3JlKCk7XG4gICAgY29uc3QgeyBhY3RpdmVfYWNjb3VudHMgfSA9IGNsaWVudDtcblxuICAgIGNvbnN0IGhhc19hY3RpdmVfcmVhbF9hY2NvdW50ID0gYWN0aXZlX2FjY291bnRzLnNvbWUoYWNjb3VudCA9PiBhY2NvdW50LmlzX3ZpcnR1YWwgPT09IDApO1xuXG4gICAgcmV0dXJuIGhhc19hY3RpdmVfcmVhbF9hY2NvdW50O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlSGFzQWN0aXZlUmVhbEFjY291bnQ7XG4iLCJpbXBvcnQgeyB1c2VTdG9yZSB9IGZyb20gJ0BkZXJpdi9zdG9yZXMnO1xuXG5jb25zdCB1c2VIYXNDcnlwdG9DdXJyZW5jeSA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNsaWVudCB9ID0gdXNlU3RvcmUoKTtcbiAgICBjb25zdCB7IGFjY291bnRfbGlzdCwgaXNfY3J5cHRvIH0gPSBjbGllbnQ7XG5cbiAgICBjb25zdCBoYXNfY3J5cHRvX2N1cnJlbmN5ID0gYWNjb3VudF9saXN0LnNvbWUoYWNjb3VudCA9PiBpc19jcnlwdG8oYWNjb3VudC50aXRsZSB8fCAnVVNEJykpO1xuXG4gICAgcmV0dXJuIGhhc19jcnlwdG9fY3VycmVuY3k7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VIYXNDcnlwdG9DdXJyZW5jeTtcbiIsImltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnQGRlcml2L3N0b3Jlcyc7XG5pbXBvcnQgdXNlQ3VycmVuY3lDb25maWcgZnJvbSAnLi91c2VDdXJyZW5jeUNvbmZpZyc7XG5cbmNvbnN0IHVzZUhhc0ZpYXRDdXJyZW5jeSA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNsaWVudCB9ID0gdXNlU3RvcmUoKTtcbiAgICBjb25zdCB7IGFjY291bnRfbGlzdCB9ID0gY2xpZW50O1xuICAgIGNvbnN0IHsgZ2V0Q29uZmlnIH0gPSB1c2VDdXJyZW5jeUNvbmZpZygpO1xuXG4gICAgY29uc3QgaGFzX2ZpYXRfY3VycmVuY3kgPSBhY2NvdW50X2xpc3Quc29tZShcbiAgICAgICAgYWNjb3VudCA9PiBhY2NvdW50LnRpdGxlICE9PSAnUmVhbCcgJiYgZ2V0Q29uZmlnKGFjY291bnQudGl0bGUgfHwgJycpPy5pc19maWF0XG4gICAgKTtcblxuICAgIHJldHVybiBoYXNfZmlhdF9jdXJyZW5jeTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUhhc0ZpYXRDdXJyZW5jeTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VGZXRjaCwgdXNlSW52YWxpZGF0ZVF1ZXJ5IH0gZnJvbSAnQGRlcml2L2FwaSc7XG5pbXBvcnQgeyB1c2VTdG9yZSB9IGZyb20gJ0BkZXJpdi9zdG9yZXMnO1xuXG4vKipcbiAqIEEgY3VzdG9tIGhvb2sgdG8gZ2V0IHRoZSBwMnBfY29uZmlnIGluZm9ybWF0aW9uIGZyb20gYHdlYnNpdGVfc3RhdHVzYCBlbmRwb2ludFxuICovXG5jb25zdCB1c2VQMlBDb25maWcgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjbGllbnQgfSA9IHVzZVN0b3JlKCk7XG4gICAgY29uc3QgeyBpc19hdXRob3JpemUsIGxvZ2luaWQgfSA9IGNsaWVudDtcbiAgICBjb25zdCB7IGRhdGEsIC4uLnJlc3QgfSA9IHVzZUZldGNoKCd3ZWJzaXRlX3N0YXR1cycsIHsgb3B0aW9uczogeyBlbmFibGVkOiBpc19hdXRob3JpemUgfSB9KTtcbiAgICBjb25zdCBpbnZhbGlkYXRlID0gdXNlSW52YWxpZGF0ZVF1ZXJ5KCk7XG5cbiAgICAvLyBBZGQgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0byB0aGUgcDJwIGNvbmZpZyBkYXRhLlxuICAgIGNvbnN0IG1vZGlmaWVkX3AycF9jb25maWcgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3QgcDJwX2NvbmZpZyA9IGRhdGE/LndlYnNpdGVfc3RhdHVzPy5wMnBfY29uZmlnO1xuXG4gICAgICAgIGlmICghcDJwX2NvbmZpZykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnAycF9jb25maWcsXG4gICAgICAgICAgICAvKiogSW5kaWNhdGVzIGlmIHRoZSBwYXltZW50IG1ldGhvZHMgZmVhdHVyZSBpcyBlbmFibGVkLiAqL1xuICAgICAgICAgICAgaXNfcGF5bWVudF9tZXRob2RzX2VuYWJsZWQ6IEJvb2xlYW4ocDJwX2NvbmZpZz8ucGF5bWVudF9tZXRob2RzX2VuYWJsZWQpLFxuICAgICAgICB9O1xuICAgIH0sIFtkYXRhPy53ZWJzaXRlX3N0YXR1cz8ucDJwX2NvbmZpZ10pO1xuXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaW52YWxpZGF0ZSgnd2Vic2l0ZV9zdGF0dXMnKTtcbiAgICB9LCBbaW52YWxpZGF0ZSwgbG9naW5pZF0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqIFRoZSBwMnAgY29uZmlnIHJlc3BvbnNlLiAqL1xuICAgICAgICBkYXRhOiBtb2RpZmllZF9wMnBfY29uZmlnLFxuICAgICAgICAuLi5yZXN0LFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VQMlBDb25maWc7XG4iLCJpbXBvcnQgeyB1c2VTdG9yZSB9IGZyb20gJ0BkZXJpdi9zdG9yZXMnO1xuaW1wb3J0IHVzZVAyUENvbmZpZyBmcm9tICcuL3VzZVAyUENvbmZpZyc7XG5cbmNvbnN0IHVzZUhhc1AyUFN1cHBvcnRlZEN1cnJlbmNpZXMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjbGllbnQgfSA9IHVzZVN0b3JlKCk7XG4gICAgY29uc3QgeyBhY3RpdmVfYWNjb3VudHMgfSA9IGNsaWVudDtcbiAgICBjb25zdCB7IGRhdGEsIC4uLnJlc3QgfSA9IHVzZVAyUENvbmZpZygpO1xuXG4gICAgY29uc3QgcmVhbF9hY2NvdW50X2N1cnJlbmNpZXNfbGlzdCA9IGFjdGl2ZV9hY2NvdW50c1xuICAgICAgICAuZmlsdGVyKGFjY291bnQgPT4gIWFjY291bnQuaXNfdmlydHVhbClcbiAgICAgICAgLm1hcChhY2NvdW50ID0+IGFjY291bnQuY3VycmVuY3k/LnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgY29uc3QgaGFzX3AycF9zdXBwb3J0ZWRfY3VycmVuY2llcyA9IEJvb2xlYW4oXG4gICAgICAgIGRhdGE/LnN1cHBvcnRlZF9jdXJyZW5jaWVzLnNvbWUoKGN1cnJlbmN5OiBzdHJpbmcpID0+IHJlYWxfYWNjb3VudF9jdXJyZW5jaWVzX2xpc3QuaW5jbHVkZXMoY3VycmVuY3kpKVxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5yZXN0LFxuICAgICAgICBkYXRhOiBoYXNfcDJwX3N1cHBvcnRlZF9jdXJyZW5jaWVzLFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VIYXNQMlBTdXBwb3J0ZWRDdXJyZW5jaWVzO1xuIiwiaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICdAZGVyaXYvc3RvcmVzJztcbmltcG9ydCB1c2VIYXNBY3RpdmVSZWFsQWNjb3VudCBmcm9tICcuL3VzZUhhc0FjdGl2ZVJlYWxBY2NvdW50JztcblxuY29uc3QgdXNlSGFzU2V0Q3VycmVuY3kgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjbGllbnQgfSA9IHVzZVN0b3JlKCk7XG4gICAgY29uc3QgeyBhY2NvdW50X2xpc3QgfSA9IGNsaWVudDtcbiAgICBjb25zdCBoYXNfYWN0aXZlX3JlYWxfYWNjb3VudCA9IHVzZUhhc0FjdGl2ZVJlYWxBY2NvdW50KCk7XG5cbiAgICBjb25zdCBoYXNfcmVhbF9hY2NvdW50ID0gYWNjb3VudF9saXN0XG4gICAgICAgIC5maWx0ZXIoYWNjb3VudCA9PiAhYWNjb3VudC5pc192aXJ0dWFsKVxuICAgICAgICAuc29tZShhY2NvdW50ID0+IGFjY291bnQudGl0bGUgIT09ICdSZWFsJyAmJiBhY2NvdW50LnRpdGxlICE9PSAnSW52ZXN0bWVudCcpO1xuXG4gICAgY29uc3QgaGFzX3NldF9jdXJyZW5jeSA9IGhhc19yZWFsX2FjY291bnQgfHwgIWhhc19hY3RpdmVfcmVhbF9hY2NvdW50O1xuXG4gICAgcmV0dXJuIGhhc19zZXRfY3VycmVuY3k7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VIYXNTZXRDdXJyZW5jeTtcbiIsImltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnQGRlcml2L3N0b3Jlcyc7XG5cbmNvbnN0IHVzZUhhc1N2Z0FjY291bnQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjbGllbnQgfSA9IHVzZVN0b3JlKCk7XG4gICAgY29uc3QgeyBhY3RpdmVfYWNjb3VudHMgfSA9IGNsaWVudDtcbiAgICBjb25zdCBoYXNfc3ZnX2FjY291bnQgPSBhY3RpdmVfYWNjb3VudHMuc29tZShhY2NvdW50ID0+IGFjY291bnQubGFuZGluZ19jb21wYW55X3Nob3J0Y29kZSA9PT0gJ3N2ZycpO1xuXG4gICAgcmV0dXJuIGhhc19zdmdfYWNjb3VudDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUhhc1N2Z0FjY291bnQ7XG4iLCJpbXBvcnQgeyB1c2VTdG9yZSB9IGZyb20gJ0BkZXJpdi9zdG9yZXMnO1xuXG4vKipcbiAqIFRoaXMgaG9vayBpcyB1c2VkIHRvIGNoZWNrIGlmIHRoZSBjbGllbnQgaGFzIGEgU3dhcC1GcmVlIGFjY291bnQuXG4gKiBJdCBjaGVja3MgZm9yIGF2YWlsYWJpbGl0eSBvZiBtYXJrZXRfdHlwZSAnYWxsJyBpbiB0cmFkaW5nX3BsYXRmb3JtX2F2YWlsYWJsZV9hY2NvdW50cyBBUEkgcmVzcG9uc2VcbiAqL1xuY29uc3QgdXNlSGFzU3dhcEZyZWVBY2NvdW50ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY2xpZW50IH0gPSB1c2VTdG9yZSgpO1xuICAgIGNvbnN0IHsgdHJhZGluZ19wbGF0Zm9ybV9hdmFpbGFibGVfYWNjb3VudHMgfSA9IGNsaWVudDtcbiAgICBjb25zdCBoYXNfc3dhcF9mcmVlX2FjY291bnQgPSB0cmFkaW5nX3BsYXRmb3JtX2F2YWlsYWJsZV9hY2NvdW50cy5zb21lKFxuICAgICAgICBhdmFpbGFibGVfYWNjb3VudCA9PiBhdmFpbGFibGVfYWNjb3VudC5tYXJrZXRfdHlwZSA9PT0gJ2FsbCdcbiAgICApO1xuXG4gICAgcmV0dXJuIGhhc19zd2FwX2ZyZWVfYWNjb3VudDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUhhc1N3YXBGcmVlQWNjb3VudDtcbiIsImltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnQGRlcml2L3N0b3Jlcyc7XG5cbmNvbnN0IHVzZUhhc1VTREN1cnJlbmN5ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY2xpZW50IH0gPSB1c2VTdG9yZSgpO1xuICAgIGNvbnN0IHsgYWNjb3VudF9saXN0IH0gPSBjbGllbnQ7XG5cbiAgICBjb25zdCBoYXNfdXNkX2N1cnJlbmN5ID0gYWNjb3VudF9saXN0LnNvbWUoYWNjb3VudCA9PiBhY2NvdW50LnRpdGxlID09PSAnVVNEJyk7XG5cbiAgICByZXR1cm4gaGFzX3VzZF9jdXJyZW5jeTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUhhc1VTREN1cnJlbmN5O1xuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbnR5cGUgVE9wdGlvbnMgPSB7XG4gICAgZnJhY3Rpb25fZGlnaXRzPzogbnVtYmVyO1xuICAgIHdpdGhfc2lnbj86IGJvb2xlYW47XG59O1xuXG5jb25zdCB1c2VJbnB1dERlY2ltYWxGb3JtYXR0ZXIgPSAoaW5pdGlhbD86IG51bWJlciwgb3B0aW9ucz86IFRPcHRpb25zKSA9PiB7XG4gICAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSB1c2VTdGF0ZSgnJyk7XG4gICAgY29uc3QgeyBmcmFjdGlvbl9kaWdpdHMgPSAyLCB3aXRoX3NpZ24gPSBmYWxzZSB9ID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGNvbnN0IG9uQ2hhbmdlID0gdXNlQ2FsbGJhY2soXG4gICAgICAgIChlOiBEZWVwUGFydGlhbDxSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50Pj4gfCBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgICAgICAgICAgc2V0VmFsdWUob2xkX3ZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdfdmFsdWUgPSBlPy50YXJnZXQ/LnZhbHVlIHx8ICcnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzRW1wdHkgPSBuZXdfdmFsdWUgPT09ICcnO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGZpZWxkIGhhcyBiZWVuIGNsZWFyZWQsIFNvIHdlIHJldHVybiB0aGUgbmV3IHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KSByZXR1cm4gbmV3X3ZhbHVlO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IHdpdGhfc2lnbiA/IG5ld192YWx1ZSA6IG5ld192YWx1ZS5yZXBsYWNlQWxsKC9bKy1dL2csICcnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dHMgPSB0ZXh0LnNwbGl0KCcuJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgZmllbGQgY29udGFpbnMgbW9yZSB0aGFuIG9uZSBkb3QsIFNvIHdlIHJldHVybiB0aGUgb2xkIHZhbHVlIGFzIG9ubHkgb25lIGRvdFxuICAgICAgICAgICAgICAgIC8vIGlzIGFsbG93ZWQuXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0cy5sZW5ndGggPiAyKSByZXR1cm4gb2xkX3ZhbHVlO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdCA9IGlucHV0c1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IGlucHV0cy5sZW5ndGggPiAxID8gaW5wdXRzWzFdIDogbnVsbDtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNfcmlnaHQgPSByaWdodCAhPT0gbnVsbCAmJiByaWdodCAhPT0gJyc7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgZmllbGQgdmFsdWUgaXMgcG9zaXRpdmUgb3IgbmVnYXRpdmUgc2lnbiwgU28gd2UgcmV0dXJuIHRoZSBuZXcgdmFsdWUgd2l0aG91dFxuICAgICAgICAgICAgICAgIC8vIGFueSBjYWxjdWxhdGlvbnMuXG4gICAgICAgICAgICAgICAgaWYgKChsZWZ0ID09PSAnLScgfHwgbGVmdCA9PT0gJysnKSAmJiAhaGFzX3JpZ2h0KSByZXR1cm4gbmV3X3ZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGZpZWxkIHZhbHVlIGlzIDAsIFNvIHdlIHJldHVybiB0aGUgbmV3IHZhbHVlIHdpdGhvdXQgYW55IGNhbGN1bGF0aW9ucy5cbiAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gJzAnICYmICFoYXNfcmlnaHQpIHJldHVybiBuZXdfdmFsdWU7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpc19udW1iZXIgPSAhaXNOYU4oTnVtYmVyKG5ld192YWx1ZSkpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGlucHV0IHZhbHVlIGlzIG5vdCBhIHZhbGlkIG51bWJlciwgU28gd2UgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKCFpc19udW1iZXIpIHJldHVybiBvbGRfdmFsdWU7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdfbGVmdCA9IGxlZnQucmVwbGFjZUFsbCgvWystXS9nLCAnJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzX2RlY2ltYWwgPSBuZXdfdmFsdWUuaW5jbHVkZXMoJy4nKTtcblxuICAgICAgICAgICAgICAgIC8vIFRoZSBmaWVsZCBzdGFydHMgd2l0aCAwIGJ1dCBkb2Vzbid0IGhhdmUgZGVjaW1hbCBwb2ludCwgU28gd2UgcmV0dXJuIHRoZSBvbGQgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyBhcyB0aGUgb25seSB2YWxpZCBpbnB1dCBhdCB0aGlzIHN0ZXAgaXMgZGVjaW1hbCBwb2ludC5cbiAgICAgICAgICAgICAgICBpZiAobmV3X2xlZnQuc3RhcnRzV2l0aCgnMCcpICYmIG5ld19sZWZ0Lmxlbmd0aCAhPT0gMSAmJiAhaGFzX2RlY2ltYWwpIHJldHVybiBvbGRfdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgZmllbGQgaGF2ZSBhIGRlY2ltYWwgcG9pbnQgYW5kIGRlY2ltYWwgcGxhY2VzIGFyZSBhbHJlYWR5IGFzIGFsbG93ZWQgZnJhY3Rpb25cbiAgICAgICAgICAgICAgICAvLyBkaWdpdHMsIFNvIHdlIHJlbW92ZSB0aGUgZXh0cmEgZGVjaW1hbCBkaWdpdHMgZnJvbSB0aGUgcmlnaHQgYW5kIHJldHVybiB0aGUgbmV3IHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChoYXNfcmlnaHQgJiYgcmlnaHQubGVuZ3RoID4gZnJhY3Rpb25fZGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld19yaWdodCA9IHJpZ2h0LnN1YnN0cmluZygwLCBmcmFjdGlvbl9kaWdpdHMpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHtsZWZ0fS4ke25ld19yaWdodH1gO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdfdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgW2ZyYWN0aW9uX2RpZ2l0cywgd2l0aF9zaWduXVxuICAgICk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoaW5pdGlhbCkgb25DaGFuZ2UoeyB0YXJnZXQ6IHsgdmFsdWU6IGAke2luaXRpYWx9YCB9IH0pO1xuICAgIH0sIFtpbml0aWFsLCBvbkNoYW5nZV0pO1xuXG4gICAgcmV0dXJuIHsgdmFsdWUsIG9uQ2hhbmdlIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VJbnB1dERlY2ltYWxGb3JtYXR0ZXI7XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1bkZvcm1hdExvY2FsZVN0cmluZyB9IGZyb20gJ0BkZXJpdi91dGlscyc7XG5pbXBvcnQgdXNlSW5wdXREZWNpbWFsRm9ybWF0dGVyIGZyb20gJy4vdXNlSW5wdXREZWNpbWFsRm9ybWF0dGVyJztcblxudHlwZSBUT3B0aW9ucyA9IHtcbiAgICBmcmFjdGlvbl9kaWdpdHM/OiBudW1iZXI7XG4gICAgbG9jYWxlPzogSW50bC5Mb2NhbGVzQXJndW1lbnQ7XG59O1xuXG5jb25zdCB1c2VJbnB1dEFUTUZvcm1hdHRlciA9IChpbml0aWFsPzogbnVtYmVyLCBvcHRpb25zPzogVE9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBpc19wYXN0aW5nID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCB7IHZhbHVlLCBvbkNoYW5nZTogb25DaGFuZ2VEZWNpbWFsIH0gPSB1c2VJbnB1dERlY2ltYWxGb3JtYXR0ZXIodW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICBjb25zdCB7IGxvY2FsZSwgZnJhY3Rpb25fZGlnaXRzID0gMiB9ID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGNvbnN0IGZvcm1hdHRlZF92YWx1ZSA9IHVzZU1lbW8oXG4gICAgICAgICgpID0+IGAke051bWJlcih2YWx1ZSkudG9Mb2NhbGVTdHJpbmcobG9jYWxlLCB7IG1pbmltdW1GcmFjdGlvbkRpZ2l0czogZnJhY3Rpb25fZGlnaXRzIH0pfWAsXG4gICAgICAgIFtmcmFjdGlvbl9kaWdpdHMsIGxvY2FsZSwgdmFsdWVdXG4gICAgKTtcblxuICAgIGNvbnN0IG9uQ2hhbmdlID0gdXNlQ2FsbGJhY2soXG4gICAgICAgIChlOiBEZWVwUGFydGlhbDxSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50Pj4gfCBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3X3ZhbHVlID0gZT8udGFyZ2V0Py52YWx1ZSB8fCAnJztcbiAgICAgICAgICAgIGNvbnN0IHVuZm9ybWF0dGVkID0gdW5Gb3JtYXRMb2NhbGVTdHJpbmcobmV3X3ZhbHVlLCBsb2NhbGUpO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBzaG91bGRuJ3QgY2FzdCB0byBudW1iZXIgYmVjYXVzZSB3ZSB3aWxsIGxvc2UgdGhlIHRyYWlsaW5nIHplcm9zLlxuICAgICAgICAgICAgY29uc3Qgc2hpZnRlZCA9IE1hdGguZnJvdW5kKHVuZm9ybWF0dGVkICogMTApLnRvRml4ZWQoZnJhY3Rpb25fZGlnaXRzKTtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igc2hvdWxkbid0IGNhc3QgdG8gbnVtYmVyIGJlY2F1c2Ugd2Ugd2lsbCBsb3NlIHRoZSB0cmFpbGluZyB6ZXJvcy5cbiAgICAgICAgICAgIGNvbnN0IHVuX3NoaWZ0ZWQgPSBNYXRoLmZyb3VuZCh1bmZvcm1hdHRlZCAvIDEwKS50b0ZpeGVkKGZyYWN0aW9uX2RpZ2l0cyk7XG4gICAgICAgICAgICBjb25zdCB1bmZvcm1hdHRlZF9mcmFjdGlvbiA9IHVuZm9ybWF0dGVkLnNwbGl0KCcuJyk/LlsxXT8ubGVuZ3RoIHx8IGZyYWN0aW9uX2RpZ2l0cztcblxuICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgaXMgcGFzdGluZywgd2UgZG9uJ3QgbmVlZCB0byBzaGlmdCB0aGUgZGVjaW1hbCBwb2ludCxcbiAgICAgICAgICAgIC8vIFdlIGp1c3QgbmVlZCB0byBmb3JtYXQgdGhlIHZhbHVlLlxuICAgICAgICAgICAgaWYgKGlzX3Bhc3RpbmcuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGlzX3Bhc3RpbmcuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBvbkNoYW5nZURlY2ltYWwoeyB0YXJnZXQ6IHsgdmFsdWU6IHVuZm9ybWF0dGVkIH0gfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZSBuZXcgdmFsdWUgaGFzIG9uZSBtb3JlIGRlY2ltYWwgcGxhY2VzIHRoYW4gdGhlIGZyYWN0aW9uX2RpZ2l0cyxcbiAgICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gc2hpZnQgdGhlIGRlY2ltYWwgcG9pbnQgdG8gdGhlIGxlZnQuXG4gICAgICAgICAgICBpZiAodW5mb3JtYXR0ZWRfZnJhY3Rpb24gLSAxID09PSBmcmFjdGlvbl9kaWdpdHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb25DaGFuZ2VEZWNpbWFsKHsgdGFyZ2V0OiB7IHZhbHVlOiBzaGlmdGVkIH0gfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZSBuZXcgdmFsdWUgaGFzIG9uZSBsZXNzIGRlY2ltYWwgcGxhY2VzIHRoYW4gdGhlIGZyYWN0aW9uX2RpZ2l0cyxcbiAgICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gc2hpZnQgdGhlIGRlY2ltYWwgcG9pbnQgdG8gdGhlIHJpZ2h0LlxuICAgICAgICAgICAgaWYgKHVuZm9ybWF0dGVkX2ZyYWN0aW9uICsgMSA9PT0gZnJhY3Rpb25fZGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9uQ2hhbmdlRGVjaW1hbCh7IHRhcmdldDogeyB2YWx1ZTogdW5fc2hpZnRlZCB9IH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGUgbmV3IHZhbHVlIGhhcyB0aGUgc2FtZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgYXMgdGhlIGZyYWN0aW9uX2RpZ2l0cyxcbiAgICAgICAgICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgdG8gc2hpZnQgdGhlIGRlY2ltYWwgcG9pbnQuXG4gICAgICAgICAgICBpZiAodW5mb3JtYXR0ZWRfZnJhY3Rpb24gPT09IGZyYWN0aW9uX2RpZ2l0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvbkNoYW5nZURlY2ltYWwoeyB0YXJnZXQ6IHsgdmFsdWU6IHVuZm9ybWF0dGVkIH0gfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZSBuZXcgdmFsdWUgaGFzIG1vcmUgZGVjaW1hbCBwbGFjZXMgdGhhbiB0aGUgZnJhY3Rpb25fZGlnaXRzLFxuICAgICAgICAgICAgLy8gc28gd2UgY2hvcCB0aGUgZXh0cmEgZGVjaW1hbCBwb2ludHMuXG4gICAgICAgICAgICBpZiAodW5mb3JtYXR0ZWRfZnJhY3Rpb24gLSAxID4gZnJhY3Rpb25fZGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9uQ2hhbmdlRGVjaW1hbCh7IHRhcmdldDogeyB2YWx1ZTogdW5mb3JtYXR0ZWQgfSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhlIG5ldyB2YWx1ZSBoYXMgbGVzcyBkZWNpbWFsIHBsYWNlcyB0aGFuIHRoZSBmcmFjdGlvbl9kaWdpdHMsXG4gICAgICAgICAgICAvLyBzbyB3ZSBhZGQgdGhlIG1pc3NpbmcgZXh0cmEgZGVjaW1hbCBwb2ludC5cbiAgICAgICAgICAgIGlmICh1bmZvcm1hdHRlZF9mcmFjdGlvbiArIDEgPCBmcmFjdGlvbl9kaWdpdHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb25DaGFuZ2VEZWNpbWFsKHsgdGFyZ2V0OiB7IHZhbHVlOiB1bmZvcm1hdHRlZCB9IH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb25DaGFuZ2VEZWNpbWFsKHsgdGFyZ2V0OiB7IHZhbHVlOiB1bmZvcm1hdHRlZCB9IH0pO1xuICAgICAgICB9LFxuICAgICAgICBbbG9jYWxlLCBmcmFjdGlvbl9kaWdpdHMsIG9uQ2hhbmdlRGVjaW1hbF1cbiAgICApO1xuXG4gICAgY29uc3Qgb25QYXN0ZTogUmVhY3QuQ2xpcGJvYXJkRXZlbnRIYW5kbGVyPEhUTUxJbnB1dEVsZW1lbnQ+ID0gdXNlQ2FsbGJhY2soXG4gICAgICAgIGUgPT4gKGlzX3Bhc3RpbmcuY3VycmVudCA9IGUudHlwZSA9PT0gJ3Bhc3RlJyksXG4gICAgICAgIFtdXG4gICAgKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChpbml0aWFsKSB7XG4gICAgICAgICAgICBpc19wYXN0aW5nLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYCR7TnVtYmVyKGluaXRpYWwpLnRvTG9jYWxlU3RyaW5nKGxvY2FsZSwgeyBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IGZyYWN0aW9uX2RpZ2l0cyB9KX1gLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtmcmFjdGlvbl9kaWdpdHMsIGluaXRpYWwsIGxvY2FsZSwgb25DaGFuZ2VdKTtcblxuICAgIHJldHVybiB7IHZhbHVlOiBmb3JtYXR0ZWRfdmFsdWUsIG9uQ2hhbmdlLCBvblBhc3RlIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VJbnB1dEFUTUZvcm1hdHRlcjtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VTdG9yZSB9IGZyb20gJ0BkZXJpdi9zdG9yZXMnO1xuXG5jb25zdCBBY2NvdW50U3RhdHVzTGlzdCA9IFtcbiAgICAnYWRkcmVzc192ZXJpZmllZCcsXG4gICAgJ2FnZV92ZXJpZmljYXRpb24nLFxuICAgICdhbGxvd19kb2N1bWVudF91cGxvYWQnLFxuICAgICdhbGxvd19wb2FfcmVzdWJtaXNzaW9uJyxcbiAgICAnYWxsb3dfcG9pX3Jlc3VibWlzc2lvbicsXG4gICAgJ2F1dGhlbnRpY2F0ZWQnLFxuICAgICdhdXRoZW50aWNhdGVkX3dpdGhfaWR2X3Bob3RvaWQnLFxuICAgICdjYXNoaWVyX2xvY2tlZCcsXG4gICAgJ2Nyc190aW5faW5mb3JtYXRpb24nLFxuICAgICdkZXBvc2l0X2F0dGVtcHQnLFxuICAgICdkZXBvc2l0X2xvY2tlZCcsXG4gICAgJ2RmX2RlcG9zaXRfcmVxdWlyZXNfcG9pJyxcbiAgICAnZGlzYWJsZWQnLFxuICAgICdkb2N1bWVudF9leHBpcmVkJyxcbiAgICAnZG9jdW1lbnRfZXhwaXJpbmdfc29vbicsXG4gICAgJ2RvY3VtZW50X3VuZGVyX3JldmlldycsXG4gICAgJ2R4dHJhZGVfcGFzc3dvcmRfbm90X3NldCcsXG4gICAgJ2ZpbmFuY2lhbF9hc3Nlc3NtZW50X25vdF9jb21wbGV0ZScsXG4gICAgJ2ZpbmFuY2lhbF9pbmZvcm1hdGlvbl9ub3RfY29tcGxldGUnLFxuICAgICdmaW5hbmNpYWxfcmlza19hcHByb3ZhbCcsXG4gICAgJ2lkdl9yZXZva2VkJyxcbiAgICAnbWF4X3R1cm5vdmVyX2xpbWl0X25vdF9zZXQnLFxuICAgICdtdDVfcGFzc3dvcmRfbm90X3NldCcsXG4gICAgJ210NV93aXRoZHJhd2FsX2xvY2tlZCcsXG4gICAgJ25lZWRzX2FmZmlsaWF0ZV9jb2NfYXBwcm92YWwnLFxuICAgICdub190cmFkaW5nJyxcbiAgICAnbm9fd2l0aGRyYXdhbF9vcl90cmFkaW5nJyxcbiAgICAncDJwX2Jsb2NrZWRfZm9yX3BhJyxcbiAgICAncGFfd2l0aGRyYXdhbF9leHBsaWNpdGx5X2FsbG93ZWQnLFxuICAgICdwYXNzd29yZF9yZXNldF9yZXF1aXJlZCcsXG4gICAgJ3BlcnNvbmFsX2RldGFpbHNfbG9ja2VkJyxcbiAgICAncG9pX25hbWVfbWlzbWF0Y2gnLFxuICAgICdwcm9mZXNzaW9uYWwnLFxuICAgICdwcm9mZXNzaW9uYWxfcmVxdWVzdGVkJyxcbiAgICAncHJvZmVzc2lvbmFsX3JlamVjdGVkJyxcbiAgICAnc2hhcmVkX3BheW1lbnRfbWV0aG9kJyxcbiAgICAnc29jaWFsX3NpZ251cCcsXG4gICAgJ3RyYW5zZmVyc19ibG9ja2VkJyxcbiAgICAndHJhZGluZ19leHBlcmllbmNlX25vdF9jb21wbGV0ZScsXG4gICAgJ3VrZ2NfZnVuZHNfcHJvdGVjdGlvbicsXG4gICAgJ3Vud2VsY29tZScsXG4gICAgJ3dpdGhkcmF3YWxfbG9ja2VkJyxcbl0gYXMgY29uc3Q7XG5cbnR5cGUgVEFjY291bnRTdGF0dXMgPSB0eXBlb2YgQWNjb3VudFN0YXR1c0xpc3RbbnVtYmVyXTtcblxuLyoqXG4gKiBDdXN0b20gaG9vayB0byBjaGVjayBpZiBhIHBhcnRpY3VsYXIgYWNjb3VudCBzdGF0dXMgaXMgcHJlc2VudC5cbiAqIEBuYW1lIHVzZUlzQWNjb3VudFN0YXR1c1ByZXNlbnRcbiAqIEBwYXJhbSBzdGF0dXMgb2YgdGhlIGFjY291bnQgdG8gY2hlY2tcbiAqIEByZXR1cm5zIGJvb2xlYW5cbiAqL1xuY29uc3QgdXNlSXNBY2NvdW50U3RhdHVzUHJlc2VudCA9IChzdGF0dXM6IFRBY2NvdW50U3RhdHVzKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgICBjbGllbnQ6IHsgYWNjb3VudF9zdGF0dXMgfSxcbiAgICB9ID0gdXNlU3RvcmUoKTtcblxuICAgIGNvbnN0IHN0YXR1c19saXN0ID0gYWNjb3VudF9zdGF0dXM/LnN0YXR1cztcblxuICAgIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHN0YXR1c19saXN0Py5pbmNsdWRlcyhzdGF0dXMpID8/IGZhbHNlLCBbc3RhdHVzX2xpc3QsIHN0YXR1c10pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlSXNBY2NvdW50U3RhdHVzUHJlc2VudDtcbiIsImltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnQGRlcml2L3N0b3Jlcyc7XG5pbXBvcnQgdXNlUDJQQ29uZmlnIGZyb20gJy4vdXNlUDJQQ29uZmlnJztcblxuY29uc3QgdXNlSXNQMlBFbmFibGVkID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY2xpZW50LCB0cmFkZXJzX2h1YiB9ID0gdXNlU3RvcmUoKTtcbiAgICAvLyBUb2RvOiB0byByZXBsYWNlIGl0IHdpdGggdXNlQXV0aG9yaXplIGhvb2tcbiAgICBjb25zdCB7IGN1cnJlbmN5LCBpc192aXJ0dWFsIH0gPSBjbGllbnQ7XG4gICAgY29uc3QgeyBpc19sb3dfcmlza19jcl9ldV9yZWFsIH0gPSB0cmFkZXJzX2h1YjtcbiAgICBjb25zdCB7IGRhdGEsIC4uLnJlc3QgfSA9IHVzZVAyUENvbmZpZygpO1xuXG4gICAgY29uc3QgaXNfcDJwX3N1cHBvcnRlZF9jdXJyZW5jeSA9IEJvb2xlYW4oZGF0YT8uc3VwcG9ydGVkX2N1cnJlbmNpZXMuaW5jbHVkZXMoY3VycmVuY3kudG9Mb2NhbGVMb3dlckNhc2UoKSkpO1xuICAgIGNvbnN0IGlzX3AycF9lbmFibGVkID0gaXNfcDJwX3N1cHBvcnRlZF9jdXJyZW5jeSAmJiAhaXNfdmlydHVhbCAmJiAhaXNfbG93X3Jpc2tfY3JfZXVfcmVhbDtcblxuICAgIC8vIFRvZG86IHNob3VsZCByZXBsYWNlIHdpdGggdGhlIG5leHQgbGluZSBpbnN0ZWFkIG9uY2UgQkUgaXMgZml4ZWQuXG4gICAgLy8gY29uc3QgaXNfcDJwX2VuYWJsZWQgPSBkYXRhPy5kaXNhYmxlZCA9PT0gMDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIGRhdGE6IGlzX3AycF9lbmFibGVkLFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VJc1AyUEVuYWJsZWQ7XG4iLCJpbXBvcnQgeyB1c2VTdG9yZSB9IGZyb20gJ0BkZXJpdi9zdG9yZXMnO1xuaW1wb3J0IHVzZUhhc01hbHRhSW52ZXN0QWNjb3VudCBmcm9tICcuL3VzZUhhc01hbHRhSW52ZXN0QWNjb3VudCc7XG5pbXBvcnQgdXNlSGFzU3ZnQWNjb3VudCBmcm9tICcuL3VzZUhhc1N2Z0FjY291bnQnO1xuXG5jb25zdCB1c2VJc1JlYWxBY2NvdW50TmVlZGVkRm9yQ2FzaGllciA9ICgpID0+IHtcbiAgICBjb25zdCB7IHRyYWRlcnNfaHViIH0gPSB1c2VTdG9yZSgpO1xuICAgIGNvbnN0IHsgaXNfZXVfdXNlciwgaXNfcmVhbCB9ID0gdHJhZGVyc19odWI7XG5cbiAgICBjb25zdCBoYXNfc3ZnX2FjY291bnQgPSB1c2VIYXNTdmdBY2NvdW50KCk7XG4gICAgY29uc3QgaGFzX21hbHRhaW52ZXN0X2FjY291bnQgPSB1c2VIYXNNYWx0YUludmVzdEFjY291bnQoKTtcblxuICAgIGNvbnN0IG5vX3JlYWxfbWZfYWNjb3VudCA9IGhhc19zdmdfYWNjb3VudCAmJiAhaGFzX21hbHRhaW52ZXN0X2FjY291bnQgJiYgaXNfZXVfdXNlcjtcblxuICAgIGNvbnN0IG5vX3JlYWxfY3JfYWNjb3VudCA9ICFoYXNfc3ZnX2FjY291bnQgJiYgaGFzX21hbHRhaW52ZXN0X2FjY291bnQgJiYgIWlzX2V1X3VzZXI7XG5cbiAgICBjb25zdCBpc19yZWFsX2FjY291bnRfbmVlZGVkID0gbm9fcmVhbF9tZl9hY2NvdW50IHx8IG5vX3JlYWxfY3JfYWNjb3VudDtcblxuICAgIGNvbnN0IGlzX3JlYWxfYWNjb3VudF9uZWVkZWRfZm9yX2Nhc2hpZXIgPSBpc19yZWFsX2FjY291bnRfbmVlZGVkICYmIGlzX3JlYWw7XG5cbiAgICByZXR1cm4gaXNfcmVhbF9hY2NvdW50X25lZWRlZF9mb3JfY2FzaGllcjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUlzUmVhbEFjY291bnROZWVkZWRGb3JDYXNoaWVyO1xuIiwiaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICdAZGVyaXYvc3RvcmVzJztcblxuY29uc3QgdXNlSXNTeXN0ZW1NYWludGVuYW5jZSA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNsaWVudCB9ID0gdXNlU3RvcmUoKTtcbiAgICBjb25zdCB7IGFjY291bnRfc3RhdHVzIH0gPSBjbGllbnQ7XG5cbiAgICBjb25zdCBpc19zeXN0ZW1fbWFpbnRlbmFuY2UgPVxuICAgICAgICBhY2NvdW50X3N0YXR1cy5jYXNoaWVyX3ZhbGlkYXRpb24/LnNvbWUodmFsaWRhdGlvbiA9PiB2YWxpZGF0aW9uID09PSAnc3lzdGVtX21haW50ZW5hbmNlJykgfHwgZmFsc2U7XG5cbiAgICByZXR1cm4gaXNfc3lzdGVtX21haW50ZW5hbmNlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlSXNTeXN0ZW1NYWludGVuYW5jZTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBnZXRMb2NhbFN0b3JhZ2UgfSBmcm9tICdAZGVyaXYvdXRpbHMnO1xuXG4vKipcbiAqIEhvb2sgdGhhdCBtYW5hZ2VzIGEgbG9jYWxTdG9yYWdlIHZhbHVlIGFzIGEgUmVhY3Qgc3RhdGUuXG4gKiBAdGVtcGxhdGUgVCAtIFRoZSBnZW5lcmljIHR5cGUgb2YgdGhlIGxvY2FsU3RvcmFnZSB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUgbG9jYWxTdG9yYWdlIGtleS5cbiAqIEBwYXJhbSB7VH0gW2ZhbGxiYWNrX3ZhbHVlXSAtIE9wdGlvbmFsIGZhbGxiYWNrIHZhbHVlIGlmIHRoZSBrZXkgZG9lcyBub3QgZXhpc3Qgb3IgaGFzIG5vIHZhbHVlLlxuICogQHJldHVybnMgLSBBbiBhcnJheSBjb250YWluaW5nIHRoZSBjdXJyZW50IHZhbHVlLCBhIGZ1bmN0aW9uIHRvIHVwZGF0ZSB0aGUgdmFsdWUsIGFuZCBhIGZ1bmN0aW9uIHRvIGNsZWFyIHRoZSB2YWx1ZS5cbiAqL1xuY29uc3QgdXNlTG9jYWxTdG9yYWdlRGF0YSA9IDxUPihcbiAgICBrZXk6IHN0cmluZyxcbiAgICBmYWxsYmFja192YWx1ZT86IFRcbik6IFtUIHwgbnVsbCwgUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248VCB8IG51bGw+PiwgVm9pZEZ1bmN0aW9uXSA9PiB7XG4gICAgY29uc3QgW2RhdGEsIHNldERhdGFdID0gUmVhY3QudXNlU3RhdGU8VCB8IG51bGw+KGdldExvY2FsU3RvcmFnZShrZXkpID8/IGZhbGxiYWNrX3ZhbHVlID8/IG51bGwpO1xuXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgfSwgW2tleSwgZGF0YV0pO1xuXG4gICAgY29uc3QgY2xlYXJEYXRhID0gKCkgPT4ge1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICBzZXREYXRhKGZhbGxiYWNrX3ZhbHVlID8/IG51bGwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gW2RhdGEsIHNldERhdGEsIGNsZWFyRGF0YV07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VMb2NhbFN0b3JhZ2VEYXRhO1xuIiwiaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICdAZGVyaXYvc3RvcmVzJztcblxuY29uc3QgdXNlTmVlZFBPSSA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNsaWVudCB9ID0gdXNlU3RvcmUoKTtcbiAgICBjb25zdCBhdXRoZW50aWNhdGlvbiA9IGNsaWVudC5hY2NvdW50X3N0YXR1cz8uYXV0aGVudGljYXRpb247XG5cbiAgICByZXR1cm4gYXV0aGVudGljYXRpb24/Lm5lZWRzX3ZlcmlmaWNhdGlvbi5pbmNsdWRlcygnaWRlbnRpdHknKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZU5lZWRQT0k7XG4iLCJpbXBvcnQgeyB1c2VTdG9yZSB9IGZyb20gJ0BkZXJpdi9zdG9yZXMnO1xuXG5jb25zdCB1c2VPbnJhbXBWaXNpYmxlID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY2xpZW50IH0gPSB1c2VTdG9yZSgpO1xuICAgIGNvbnN0IHsgaXNfdmlydHVhbCwgaXNfY3J5cHRvIH0gPSBjbGllbnQ7XG4gICAgY29uc3QgaXNfb25yYW1wX3Zpc2libGUgPSAhaXNfdmlydHVhbCAmJiBpc19jcnlwdG8oKTtcblxuICAgIHJldHVybiBpc19vbnJhbXBfdmlzaWJsZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZU9ucmFtcFZpc2libGU7XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUZldGNoLCB1c2VJbnZhbGlkYXRlUXVlcnksIHVzZVJlcXVlc3QgfSBmcm9tICdAZGVyaXYvYXBpJztcbmltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnQGRlcml2L3N0b3Jlcyc7XG5cbnR5cGUgVFBheWxvYWRzID0gTm9uTnVsbGFibGU8XG4gICAgTm9uTnVsbGFibGU8UGFyYW1ldGVyczxSZXR1cm5UeXBlPHR5cGVvZiB1c2VSZXF1ZXN0PCdwMnBfYWR2ZXJ0aXNlcl9wYXltZW50X21ldGhvZHMnPj5bJ211dGF0ZSddPlswXT5bJ3BheWxvYWQnXVxuPjtcbnR5cGUgVENyZWF0ZVBheWxvYWQgPSBOb25OdWxsYWJsZTxUUGF5bG9hZHNbJ2NyZWF0ZSddPlswXTtcbnR5cGUgVFVwZGF0ZVBheWxvYWQgPSBOb25OdWxsYWJsZTxUUGF5bG9hZHNbJ3VwZGF0ZSddPlswXTtcblxuY29uc3QgdHlwZV90b19pY29uX21hcHBlciA9IHtcbiAgICBiYW5rOiAnSWNDYXNoaWVyQmFua1RyYW5zZmVyJyxcbiAgICBvdGhlcjogJ0ljQ2FzaGllck90aGVyJyxcbiAgICBld2FsbGV0OiAnSWNDYXNoaWVyRXdhbGxldCcsXG59O1xuXG4vKiogQSBjdXN0b20gaG9vayB0byBmZXRjaCwgY3JlYXRlLCB1cGRhdGUsIGFuZCBkZWxldGUgcDJwIGFkdmVydGlzZXIgcGF5bWVudCBtZXRob2RzICovXG5jb25zdCB1c2VQMlBBZHZlcnRpc2VyUGF5bWVudE1ldGhvZHMgPSAoKSA9PiB7XG4gICAgY29uc3QgaW52YWxpZGF0ZSA9IHVzZUludmFsaWRhdGVRdWVyeSgpO1xuICAgIGNvbnN0IHsgY2xpZW50IH0gPSB1c2VTdG9yZSgpO1xuICAgIGNvbnN0IHsgaXNfYXV0aG9yaXplIH0gPSBjbGllbnQ7XG4gICAgY29uc3QgeyBtdXRhdGUsIC4uLm11dGF0ZV9yZXN0IH0gPSB1c2VSZXF1ZXN0KCdwMnBfYWR2ZXJ0aXNlcl9wYXltZW50X21ldGhvZHMnLCB7XG4gICAgICAgIG9uU3VjY2VzczogKCkgPT4gaW52YWxpZGF0ZSgncDJwX2FkdmVydGlzZXJfcGF5bWVudF9tZXRob2RzJyksXG4gICAgfSk7XG4gICAgY29uc3QgeyBkYXRhLCAuLi5yZXN0IH0gPSB1c2VGZXRjaCgncDJwX2FkdmVydGlzZXJfcGF5bWVudF9tZXRob2RzJywge1xuICAgICAgICBvcHRpb25zOiB7IGVuYWJsZWQ6IGlzX2F1dGhvcml6ZSB9LFxuICAgIH0pO1xuXG4gICAgLy8gTW9kaWZ5IHRoZSByZXNwb25zZSB0byBhZGQgYWRkaXRpb25hbCBpbmZvcm1hdGlvbnNcbiAgICBjb25zdCBtb2RpZmllZF9kYXRhID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHAycF9hZHZlcnRpc2VyX3BheW1lbnRfbWV0aG9kcyA9IGRhdGE/LnAycF9hZHZlcnRpc2VyX3BheW1lbnRfbWV0aG9kcztcblxuICAgICAgICBpZiAoIXAycF9hZHZlcnRpc2VyX3BheW1lbnRfbWV0aG9kcykgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocDJwX2FkdmVydGlzZXJfcGF5bWVudF9tZXRob2RzKS5tYXAoa2V5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFkdmVydGlzZXJfcGF5bWVudF9tZXRob2QgPSBwMnBfYWR2ZXJ0aXNlcl9wYXltZW50X21ldGhvZHNba2V5XTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5hZHZlcnRpc2VyX3BheW1lbnRfbWV0aG9kLFxuICAgICAgICAgICAgICAgIC8qKiBJY29uIGZvciBlYWNoIHBheW1lbnQgbWV0aG9kIGJhc2VkIG9uIHRoZSB0eXBlICovXG4gICAgICAgICAgICAgICAgaWNvbjogdHlwZV90b19pY29uX21hcHBlclthZHZlcnRpc2VyX3BheW1lbnRfbWV0aG9kLnR5cGVdLFxuICAgICAgICAgICAgICAgIC8qKiBUaGUgaWQgb2YgcGF5bWVudCBtZXRob2QgKi9cbiAgICAgICAgICAgICAgICBpZDoga2V5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSwgW2RhdGFdKTtcblxuICAgIGNvbnN0IGNyZWF0ZSA9IHVzZUNhbGxiYWNrKCh2YWx1ZXM6IFRDcmVhdGVQYXlsb2FkKSA9PiBtdXRhdGUoeyBwYXlsb2FkOiB7IGNyZWF0ZTogW3sgLi4udmFsdWVzIH1dIH0gfSksIFttdXRhdGVdKTtcblxuICAgIGNvbnN0IHVwZGF0ZSA9IHVzZUNhbGxiYWNrKFxuICAgICAgICAoaWQ6IHN0cmluZywgdmFsdWVzOiBUVXBkYXRlUGF5bG9hZCkgPT4gbXV0YXRlKHsgcGF5bG9hZDogeyB1cGRhdGU6IHsgW2lkXTogeyAuLi52YWx1ZXMgfSB9IH0gfSksXG4gICAgICAgIFttdXRhdGVdXG4gICAgKTtcblxuICAgIGNvbnN0IGRlbGV0ZV9wYXltZW50X21ldGhvZCA9IHVzZUNhbGxiYWNrKChpZDogbnVtYmVyKSA9PiBtdXRhdGUoeyBwYXlsb2FkOiB7IGRlbGV0ZTogW2lkXSB9IH0pLCBbbXV0YXRlXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKiogVGhlIGxpc3Qgb2YgcDJwIGFkdmVydGlzZXIgcGF5bWVudCBtZXRob2RzICovXG4gICAgICAgIGRhdGE6IG1vZGlmaWVkX2RhdGEsXG4gICAgICAgIC8qKiBTZW5kcyBhIHJlcXVlc3QgdG8gY3JlYXRlIG5ldyBwMnAgYWR2ZXJ0aXNlciBwYXltZW50IG1ldGhvZCAqL1xuICAgICAgICBjcmVhdGUsXG4gICAgICAgIC8qKiBTZW5kcyBhIHJlcXVlc3QgdG8gdXBkYXRlIGV4aXN0aW5nIHAycCBhZHZlcnRpc2VyIHBheW1lbnQgbWV0aG9kICovXG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgLyoqIFNlbmRzIGEgcmVxdWVzdCB0byBkZWxldGUgZXhpc3RpbmcgcDJwIGFkdmVydGlzZXIgcGF5bWVudCBtZXRob2QgKi9cbiAgICAgICAgZGVsZXRlOiBkZWxldGVfcGF5bWVudF9tZXRob2QsXG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIG11dGF0aW9uOiBtdXRhdGVfcmVzdCxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlUDJQQWR2ZXJ0aXNlclBheW1lbnRNZXRob2RzO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVBhZ2luYXRlZEZldGNoIH0gZnJvbSAnQGRlcml2L2FwaSc7XG5pbXBvcnQgdXNlRXhjaGFuZ2VSYXRlIGZyb20gJy4vdXNlRXhjaGFuZ2VSYXRlJztcblxuLyoqXG4gKiBUaGlzIGN1c3RvbSBob29rIHJldHVybnMgYXZhaWxhYmxlIGFkdmVydHMgZm9yIHVzZSB3aXRoICdwMnBfb3JkZXJfY3JlYXRlJyBieSBjYWxsaW5nICdwMnBfYWR2ZXJ0X2xpc3QnIGVuZHBvaW50XG4gKi9cbmNvbnN0IHVzZVAyUEFkdmVydExpc3QgPSAoXG4gICAgcGF5bG9hZD86IE5vbk51bGxhYmxlPFBhcmFtZXRlcnM8dHlwZW9mIHVzZVBhZ2luYXRlZEZldGNoPCdwMnBfYWR2ZXJ0X2xpc3QnPj5bMV0+WydwYXlsb2FkJ11cbikgPT4ge1xuICAgIGNvbnN0IHsgZ2V0UmF0ZSB9ID0gdXNlRXhjaGFuZ2VSYXRlKCk7XG4gICAgY29uc3QgeyBkYXRhLCAuLi5yZXN0IH0gPSB1c2VQYWdpbmF0ZWRGZXRjaCgncDJwX2FkdmVydF9saXN0JywgeyBwYXlsb2FkIH0pO1xuXG4gICAgLy8gQWRkIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gdGhlICdwMnBfYWR2ZXJ0X2xpc3QnIGRhdGFcbiAgICBjb25zdCBtb2RpZmllZF9kYXRhID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFkdmVydF9saXN0ID0gZGF0YT8ucDJwX2FkdmVydF9saXN0Py5saXN0O1xuXG4gICAgICAgIGlmICghYWR2ZXJ0X2xpc3QpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgICAgcmV0dXJuIGFkdmVydF9saXN0Lm1hcChhZHZlcnQgPT4gKHtcbiAgICAgICAgICAgIC4uLmFkdmVydCxcbiAgICAgICAgICAgIC8qKiBDb252ZXJzaW9uIHJhdGUgZnJvbSBhY2NvdW50IGN1cnJlbmN5IHRvIGxvY2FsIGN1cnJlbmN5LCB1c2luZyBjdXJyZW50IG1hcmtldCByYXRlIGlmIGFwcGxpY2FibGUuICovXG4gICAgICAgICAgICBlZmZlY3RpdmVfcmF0ZTogZ2V0UmF0ZShhZHZlcnQubG9jYWxfY3VycmVuY3kgfHwgJycpLFxuICAgICAgICAgICAgLyoqIERldGVybWluZSBpZiB0aGUgcmF0ZSBpcyBmbG9hdGluZyBvciBmaXhlZCAqL1xuICAgICAgICAgICAgaXNfZmxvYXRpbmc6IGFkdmVydC5yYXRlX3R5cGUgPT09ICdmbG9hdCcsXG4gICAgICAgICAgICAvKiogVGhlIGFkdmVydCBjcmVhdGlvbiB0aW1lIGluIGVwb2NoLiAqL1xuICAgICAgICAgICAgY3JlYXRlZF90aW1lOiBuZXcgRGF0ZShhZHZlcnQuY3JlYXRlZF90aW1lKSxcbiAgICAgICAgfSkpO1xuICAgIH0sIFtkYXRhPy5wMnBfYWR2ZXJ0X2xpc3Q/Lmxpc3QsIGdldFJhdGVdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKiBUaGUgJ3AycF9hZHZlcnRfbGlzdCcgcmVzcG9uc2UuICovXG4gICAgICAgIGRhdGE6IG1vZGlmaWVkX2RhdGEsXG4gICAgICAgIC4uLnJlc3QsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZVAyUEFkdmVydExpc3Q7XG4iLCJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICdAZGVyaXYvc3RvcmVzJztcblxudHlwZSBUTm90aWZpY2F0aW9uID0ge1xuICAgIG9yZGVyX2lkOiBzdHJpbmc7XG4gICAgaXNfc2VlbjogYm9vbGVhbjtcbiAgICBpc19hY3RpdmU6IGJvb2xlYW47XG59O1xuXG50eXBlIFRDbGllbnREYXRhID0ge1xuICAgIGlzX2NhY2hlZDogYm9vbGVhbjtcbiAgICBub3RpZmljYXRpb25zOiBUTm90aWZpY2F0aW9uW107XG59O1xuXG50eXBlIFRQMlBTZXR0aW5ncyA9IFJlY29yZDxzdHJpbmcsIFRDbGllbnREYXRhPjtcblxuY29uc3QgdXNlUDJQTm90aWZpY2F0aW9uQ291bnQgPSAoKSA9PiB7XG4gICAgY29uc3QgW3AycF9zZXR0aW5ncywgc2V0UDJQU2V0dGluZ3NdID0gdXNlU3RhdGU8VFAyUFNldHRpbmdzPihcbiAgICAgICAgSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgncDJwX3NldHRpbmdzJykgfHwgJ3t9JylcbiAgICApO1xuICAgIGNvbnN0IHsgY2xpZW50IH0gPSB1c2VTdG9yZSgpO1xuICAgIGNvbnN0IHsgbG9naW5pZCB9ID0gY2xpZW50O1xuICAgIGNvbnN0IG5vdGlmaWNhdGlvbnMgPSBsb2dpbmlkID8gcDJwX3NldHRpbmdzW2xvZ2luaWRdPy5ub3RpZmljYXRpb25zIDogbnVsbDtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG9uU3RvcmFnZUNoYW5nZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3AycF9zZXR0aW5ncycpO1xuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHNldFAyUFNldHRpbmdzKEpTT04ucGFyc2UoZGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgb25TdG9yYWdlQ2hhbmdlZCk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgb25TdG9yYWdlQ2hhbmdlZCk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgcDJwX25vdGlmaWNhdGlvbl9jb3VudCA9IG5vdGlmaWNhdGlvbnM/LmZpbHRlcihub3RpZmljYXRpb24gPT4gIW5vdGlmaWNhdGlvbi5pc19zZWVuKS5sZW5ndGggfHwgMDtcblxuICAgIHJldHVybiBwMnBfbm90aWZpY2F0aW9uX2NvdW50O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlUDJQTm90aWZpY2F0aW9uQ291bnQ7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlRmV0Y2ggfSBmcm9tICdAZGVyaXYvYXBpJztcbmltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnQGRlcml2L3N0b3Jlcyc7XG5cbmNvbnN0IHR5cGVfdG9faWNvbl9tYXBwZXIgPSB7XG4gICAgYmFuazogJ0ljQ2FzaGllckJhbmtUcmFuc2ZlcicsXG4gICAgb3RoZXI6ICdJY0Nhc2hpZXJPdGhlcicsXG4gICAgZXdhbGxldDogJ0ljQ2FzaGllckV3YWxsZXQnLFxufTtcblxuLyoqIEEgY3VzdG9tIGhvb2sgdGhhdCByZXR1cm4gdGhlIGxpc3Qgb2YgUDJQIGF2YWlsYWJsZSBwYXltZW50IG1ldGhvZHMgKi9cbmNvbnN0IHVzZVAyUFBheW1lbnRNZXRob2RzID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY2xpZW50IH0gPSB1c2VTdG9yZSgpO1xuICAgIGNvbnN0IHsgaXNfYXV0aG9yaXplIH0gPSBjbGllbnQ7XG5cbiAgICBjb25zdCB7IGRhdGEsIC4uLnJlc3QgfSA9IHVzZUZldGNoKCdwMnBfcGF5bWVudF9tZXRob2RzJywgeyBvcHRpb25zOiB7IGVuYWJsZWQ6IGlzX2F1dGhvcml6ZSB9IH0pO1xuXG4gICAgLy8gTW9kaWZ5IHRoZSBkYXRhIHRvIGFkZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLlxuICAgIGNvbnN0IG1vZGlmaWVkX2RhdGEgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3QgcDJwX3BheW1lbnRfbWV0aG9kcyA9IGRhdGE/LnAycF9wYXltZW50X21ldGhvZHM7XG5cbiAgICAgICAgaWYgKCFwMnBfcGF5bWVudF9tZXRob2RzKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhwMnBfcGF5bWVudF9tZXRob2RzKS5tYXAoa2V5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBheW1lbnRfbWV0aG9kID0gcDJwX3BheW1lbnRfbWV0aG9kc1trZXldO1xuICAgICAgICAgICAgY29uc3QgZmllbGRzID0gT2JqZWN0LmtleXMocGF5bWVudF9tZXRob2QuZmllbGRzKS5tYXAoZmllbGRfa2V5ID0+IHBheW1lbnRfbWV0aG9kLmZpZWxkc1tmaWVsZF9rZXldKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5wYXltZW50X21ldGhvZCxcbiAgICAgICAgICAgICAgICAvKiogUGF5bWVudCBtZXRob2QgZmllbGQgZGVmaW5pdGlvbnMuICovXG4gICAgICAgICAgICAgICAgZmllbGRzLFxuICAgICAgICAgICAgICAgIC8qKiBJY29uIGZvciBlYWNoIHBheW1lbnQgbWV0aG9kIGJhc2VkIG9uIHRoZSB0eXBlICovXG4gICAgICAgICAgICAgICAgaWNvbjogdHlwZV90b19pY29uX21hcHBlcltwYXltZW50X21ldGhvZC50eXBlXSxcbiAgICAgICAgICAgICAgICAvKiogUGF5bWVudCBtZXRob2QgaWQgKi9cbiAgICAgICAgICAgICAgICBpZDoga2V5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSwgW2RhdGFdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IG1vZGlmaWVkX2RhdGEsXG4gICAgICAgIC4uLnJlc3QsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZVAyUFBheW1lbnRNZXRob2RzO1xuIiwiaW1wb3J0IHsgdXNlRmV0Y2ggfSBmcm9tICdAZGVyaXYvYXBpJztcbmltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnQGRlcml2L3N0b3Jlcyc7XG5cbmNvbnN0IHVzZVBheW1lbnRBZ2VudExpc3QgPSAoY3VycmVuY3k/OiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCB7IGNsaWVudCB9ID0gdXNlU3RvcmUoKTtcbiAgICBjb25zdCB7IHJlc2lkZW5jZSB9ID0gY2xpZW50O1xuXG4gICAgY29uc3QgeyBkYXRhLCAuLi5yZXN0IH0gPSB1c2VGZXRjaCgncGF5bWVudGFnZW50X2xpc3QnLCB7XG4gICAgICAgIHBheWxvYWQ6IHsgcGF5bWVudGFnZW50X2xpc3Q6IHJlc2lkZW5jZSwgY3VycmVuY3kgfSxcbiAgICAgICAgb3B0aW9uczogeyBlbmFibGVkOiBCb29sZWFuKHJlc2lkZW5jZSkgfSxcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IGRhdGE/LnBheW1lbnRhZ2VudF9saXN0Py5saXN0LFxuICAgICAgICAuLi5yZXN0LFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VQYXltZW50QWdlbnRMaXN0O1xuIiwiaW1wb3J0IHsgdXNlRmV0Y2ggfSBmcm9tICdAZGVyaXYvYXBpJztcbmltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnQGRlcml2L3N0b3Jlcyc7XG5cbmNvbnN0IHVzZVBheW1lbnRBZ2VudFRyYW5zZmVyVmlzaWJsZSA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNsaWVudCB9ID0gdXNlU3RvcmUoKTtcbiAgICBjb25zdCB7IGlzX2F1dGhvcml6ZSB9ID0gY2xpZW50O1xuXG4gICAgY29uc3QgeyBkYXRhLCAuLi5yZXN0IH0gPSB1c2VGZXRjaCgnZ2V0X3NldHRpbmdzJywgeyBvcHRpb25zOiB7IGVuYWJsZWQ6IGlzX2F1dGhvcml6ZSB9IH0pO1xuXG4gICAgY29uc3QgaXNfcGF5bWVudF9hZ2VudF90cmFuc2Zlcl92aXNpYmxlID0gQm9vbGVhbihkYXRhPy5nZXRfc2V0dGluZ3M/LmlzX2F1dGhlbnRpY2F0ZWRfcGF5bWVudF9hZ2VudCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBpc19wYXltZW50X2FnZW50X3RyYW5zZmVyX3Zpc2libGUsXG4gICAgICAgIC4uLnJlc3QsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZVBheW1lbnRBZ2VudFRyYW5zZmVyVmlzaWJsZTtcbiIsImltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnQGRlcml2L3N0b3Jlcyc7XG5cbi8qKlxuICogd2UgY2FuIHVzZSB0aGlzIGhvb2sgdG8gZ2V0IHRoZSBwbGF0Zm9ybSBkZW1vIGFjY291bnQuXG4gKiBpdCBsb29wcyB0aHJvdWdoIHRoZSBhbGwgb2YgdXNlcidzIGFjY291bnRzLCBmaW5kcyBhbmQgcmV0dXJucyBkZW1vIGFjY291bnRcbiAqL1xuXG5jb25zdCB1c2VQbGF0Zm9ybURlbW9BY2NvdW50ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY2xpZW50IH0gPSB1c2VTdG9yZSgpO1xuICAgIGNvbnN0IHsgYWNjb3VudHMgfSA9IGNsaWVudDtcbiAgICBjb25zdCBhY2NvdW50X2xpc3QgPSBPYmplY3Qua2V5cyhhY2NvdW50cykubWFwKGxvZ2luaWQgPT4gKHtcbiAgICAgICAgLi4uYWNjb3VudHNbbG9naW5pZF0sXG4gICAgICAgIGxvZ2luaWQsXG4gICAgfSkpO1xuXG4gICAgY29uc3QgcGxhdGZvcm1fZGVtb19hY2NvdW50ID0gYWNjb3VudF9saXN0LmZpbmQoYWNjb3VudCA9PiBhY2NvdW50LmlzX3ZpcnR1YWwpO1xuXG4gICAgcmV0dXJuIHBsYXRmb3JtX2RlbW9fYWNjb3VudDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZVBsYXRmb3JtRGVtb0FjY291bnQ7XG4iLCJpbXBvcnQgeyB1c2VTdG9yZSB9IGZyb20gJ0BkZXJpdi9zdG9yZXMnO1xuXG4vKipcbiAqIHdlIGNhbiB1c2UgdGhpcyBob29rIHRvIGdldCBhbGwgcmVhbCBhY2NvdW50cyBmb3IgYm90aCBFdSBhbmQgTm9uLUV1IHJlZ2lvbnMuXG4gKiBpdCBsb29wcyB0aHJvdWdoIHRoZSBhY2NvdW50cyBsaXN0IGFuZCByZXR1cm5zIGFsbCByZWFsIGFjY291bnRzXG4gKi9cblxuY29uc3QgdXNlUGxhdGZvcm1SZWFsQWNjb3VudHMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjbGllbnQsIHRyYWRlcnNfaHViIH0gPSB1c2VTdG9yZSgpO1xuICAgIGNvbnN0IHsgYWNjb3VudHMgfSA9IGNsaWVudDtcbiAgICBjb25zdCB7IGlzX2V1X3VzZXIgfSA9IHRyYWRlcnNfaHViO1xuICAgIGNvbnN0IGFjY291bnRfbGlzdCA9IE9iamVjdC5rZXlzKGFjY291bnRzKS5tYXAobG9naW5pZCA9PiAoe1xuICAgICAgICAuLi5hY2NvdW50c1tsb2dpbmlkXSxcbiAgICAgICAgbG9naW5pZCxcbiAgICB9KSk7XG5cbiAgICBjb25zdCBwbGF0Zm9ybV9yZWFsX2FjY291bnRzID0gYWNjb3VudF9saXN0LmZpbHRlcihhY2NvdW50ID0+IHtcbiAgICAgICAgY29uc3QgaXNfbWFsdGFpbnZlc3QgPVxuICAgICAgICAgICAgJ2xhbmRpbmdfY29tcGFueV9zaG9ydGNvZGUnIGluIGFjY291bnQgJiYgYWNjb3VudC5sYW5kaW5nX2NvbXBhbnlfc2hvcnRjb2RlID09PSAnbWFsdGFpbnZlc3QnO1xuXG4gICAgICAgIGlmIChhY2NvdW50LmlzX3ZpcnR1YWwpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFpc19ldV91c2VyKSByZXR1cm4gIWlzX21hbHRhaW52ZXN0O1xuXG4gICAgICAgIHJldHVybiBpc19tYWx0YWludmVzdDtcbiAgICB9KTtcblxuICAgIHJldHVybiBwbGF0Zm9ybV9yZWFsX2FjY291bnRzO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlUGxhdGZvcm1SZWFsQWNjb3VudHM7XG4iLCJpbXBvcnQgdXNlUGxhdGZvcm1EZW1vQWNjb3VudCBmcm9tICcuL3VzZVBsYXRmb3JtRGVtb0FjY291bnQnO1xuaW1wb3J0IHVzZVBsYXRmb3JtUmVhbEFjY291bnRzIGZyb20gJy4vdXNlUGxhdGZvcm1SZWFsQWNjb3VudHMnO1xuXG4vKipcbiAqIHRoaXMgaXMgYSB3cmFwcGVyIGhvb2sgZm9yIHVzZVBsYXRmb3JtRGVtb0FjY291bnQgYW5kIHVzZVBsYXRmb3JtUmVhbEFjY291bnRzXG4gKiBhbmQgaXQgcmV0dXJucyBkaWZmZXJlbnQgcGxhdGZvcm0gYWNjb3VudHMgd2hpY2ggYXJlIGRlbW8sIGFuZCByZWFsXG4gKi9cbmNvbnN0IHVzZVBsYXRmb3JtQWNjb3VudHMgPSAoKSA9PiB7XG4gICAgY29uc3QgcGxhdGZvcm1fZGVtb19hY2NvdW50ID0gdXNlUGxhdGZvcm1EZW1vQWNjb3VudCgpO1xuICAgIGNvbnN0IHBsYXRmb3JtX3JlYWxfYWNjb3VudHMgPSB1c2VQbGF0Zm9ybVJlYWxBY2NvdW50cygpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVtbzogcGxhdGZvcm1fZGVtb19hY2NvdW50LFxuICAgICAgICByZWFsOiBwbGF0Zm9ybV9yZWFsX2FjY291bnRzLFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VQbGF0Zm9ybUFjY291bnRzO1xuIiwiaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICdAZGVyaXYvc3RvcmVzJztcbmltcG9ydCB1c2VQbGF0Zm9ybUFjY291bnRzIGZyb20gJy4vdXNlUGxhdGZvcm1BY2NvdW50cyc7XG5cbmNvbnN0IHVzZVJlYWxUb3RhbEFzc2V0Q3VycmVuY3kgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjbGllbnQsIHRyYWRlcnNfaHViIH0gPSB1c2VTdG9yZSgpO1xuICAgIGNvbnN0IHsgY3VycmVudF9maWF0X2N1cnJlbmN5LCBpc19jcnlwdG8sIGN1cnJlbmN5LCBkZWZhdWx0X2N1cnJlbmN5IH0gPSBjbGllbnQ7XG4gICAgY29uc3QgeyBpc19ldV91c2VyIH0gPSB0cmFkZXJzX2h1YjtcbiAgICBjb25zdCB7IHJlYWw6IHBsYXRmb3JtX3JlYWxfYWNjb3VudHMgfSA9IHVzZVBsYXRmb3JtQWNjb3VudHMoKTtcblxuICAgIGlmICghcGxhdGZvcm1fcmVhbF9hY2NvdW50cy5sZW5ndGgpIHJldHVybiBkZWZhdWx0X2N1cnJlbmN5O1xuXG4gICAgY29uc3Qgbm9uX2NyeXB0b19hY2NvdW50cyA9IHBsYXRmb3JtX3JlYWxfYWNjb3VudHMuZmluZChhY2NvdW50ID0+ICFpc19jcnlwdG8oYWNjb3VudC5jdXJyZW5jeSB8fCAnVVNEJykpO1xuXG4gICAgaWYgKG5vbl9jcnlwdG9fYWNjb3VudHMpIHJldHVybiBub25fY3J5cHRvX2FjY291bnRzPy5jdXJyZW5jeSB8fCAnJztcblxuICAgIGNvbnN0IGN1cnJlbmN5X2lmX2lzX2NyeXB0byA9IGlzX2V1X3VzZXJcbiAgICAgICAgPyBjdXJyZW50X2ZpYXRfY3VycmVuY3kgfHwgZGVmYXVsdF9jdXJyZW5jeVxuICAgICAgICA6IHBsYXRmb3JtX3JlYWxfYWNjb3VudHNbMF0uY3VycmVuY3k7XG5cbiAgICByZXR1cm4gaXNfY3J5cHRvKCkgPyBjdXJyZW5jeV9pZl9pc19jcnlwdG8gOiBjdXJyZW5jeTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZVJlYWxUb3RhbEFzc2V0Q3VycmVuY3k7XG4iLCJpbXBvcnQgdXNlUmVhbFRvdGFsQXNzZXRDdXJyZW5jeSBmcm9tICcuL3VzZVRvdGFsQXNzZXRDdXJyZW5jeSc7XG5pbXBvcnQgdXNlRXhjaGFuZ2VSYXRlIGZyb20gJy4vdXNlRXhjaGFuZ2VSYXRlJztcbi8qKlxuICogd2UgY2FuIHVzZSB0aGlzIGhvb2sgdG8gZ2V0IHRoZSB0b3RhbCBiYWxhbmNlIG9mIHRoZSBnaXZlbiBhY2NvdW50cyBsaXN0LlxuICogaXQgbG9vcHMgdGhyb3VnaCB0aGUgYWNjb3VudHMgbGlzdCBhbmQgYWRkcyB0aGUgYmFsYW5jZSBvZiBlYWNoIGFjY291bnRcbiAqIHRvIHRoZSB0b3RhbCBiYWxhbmNlLCBpdCBhbHNvIGNvbnZlcnRzIHRoZSBiYWxhbmNlIHRvIHRoZSBjdXJyZW5jeSBvZiB0aGVcbiAqIGZpcnN0IGFjY291bnQgaW4gdGhlIGxpc3RcbiAqL1xudHlwZSBUVXNlVG90YWxBY2NvdW50QmFsYW5jZSA9IHtcbiAgICBiYWxhbmNlPzogbnVtYmVyO1xuICAgIGN1cnJlbmN5Pzogc3RyaW5nO1xuICAgIGFjY291bnRfdHlwZT86IHN0cmluZztcbn07XG5cbmNvbnN0IHVzZVRvdGFsQWNjb3VudEJhbGFuY2UgPSAoYWNjb3VudHM6IFRVc2VUb3RhbEFjY291bnRCYWxhbmNlW10pID0+IHtcbiAgICBjb25zdCB0b3RhbF9hc3NldHNfcmVhbF9jdXJyZW5jeSA9IHVzZVJlYWxUb3RhbEFzc2V0Q3VycmVuY3koKTtcbiAgICBjb25zdCB7IGdldFJhdGUgfSA9IHVzZUV4Y2hhbmdlUmF0ZSgpO1xuXG4gICAgaWYgKCFhY2NvdW50cy5sZW5ndGgpIHJldHVybiB7IGJhbGFuY2U6IDAsIGN1cnJlbmN5OiB0b3RhbF9hc3NldHNfcmVhbF9jdXJyZW5jeSB9O1xuXG4gICAgY29uc3QgYmFsYW5jZSA9IGFjY291bnRzLnJlZHVjZSgodG90YWwsIGFjY291bnQpID0+IHtcbiAgICAgICAgY29uc3QgYmFzZV9yYXRlID0gYWNjb3VudD8uYWNjb3VudF90eXBlID09PSAnZGVtbycgPyAxIDogZ2V0UmF0ZSh0b3RhbF9hc3NldHNfcmVhbF9jdXJyZW5jeSB8fCAnJyk7XG4gICAgICAgIGNvbnN0IHJhdGUgPSBnZXRSYXRlKGFjY291bnQuY3VycmVuY3kgfHwgdG90YWxfYXNzZXRzX3JlYWxfY3VycmVuY3kgfHwgJycpO1xuICAgICAgICBjb25zdCBleGNoYW5nZV9yYXRlID0gYmFzZV9yYXRlIC8gcmF0ZTtcblxuICAgICAgICByZXR1cm4gdG90YWwgKyAoYWNjb3VudC5iYWxhbmNlIHx8IDApICogZXhjaGFuZ2VfcmF0ZTtcbiAgICB9LCAwKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGJhbGFuY2UsXG4gICAgICAgIGN1cnJlbmN5OiB0b3RhbF9hc3NldHNfcmVhbF9jdXJyZW5jeSxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlVG90YWxBY2NvdW50QmFsYW5jZTtcbiIsImltcG9ydCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VTdG9yZSB9IGZyb20gJ0BkZXJpdi9zdG9yZXMnO1xuaW1wb3J0IHsgdXNlRmV0Y2ggfSBmcm9tICdAZGVyaXYvYXBpJztcbmltcG9ydCB1c2VBY3RpdmVXYWxsZXQgZnJvbSAnLi91c2VBY3RpdmVXYWxsZXQnO1xuaW1wb3J0IHVzZUN1cnJlbmN5Q29uZmlnIGZyb20gJy4vdXNlQ3VycmVuY3lDb25maWcnO1xuaW1wb3J0IHVzZUV4aXN0aW5nQ0ZEQWNjb3VudHMgZnJvbSAnLi91c2VFeGlzdGluZ0NGREFjY291bnRzJztcbmltcG9ydCB1c2VXYWxsZXRzTGlzdCBmcm9tICcuL3VzZVdhbGxldHNMaXN0JztcblxuY29uc3QgdXNlVHJhbnNmZXJCZXR3ZWVuQWNjb3VudHMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyB1aSB9ID0gdXNlU3RvcmUoKTtcbiAgICBjb25zdCB7IGlzX2RhcmtfbW9kZV9vbiB9ID0gdWk7XG5cbiAgICBjb25zdCBhY3RpdmVfd2FsbGV0ID0gdXNlQWN0aXZlV2FsbGV0KCk7XG5cbiAgICBjb25zdCB7IGRhdGE6IHdhbGxldHMgfSA9IHVzZVdhbGxldHNMaXN0KCk7XG5cbiAgICBjb25zdCB7IGdldENvbmZpZyB9ID0gdXNlQ3VycmVuY3lDb25maWcoKTtcblxuICAgIGNvbnN0IHRyYWRpbmdfYXBwc19pY29uID0gaXNfZGFya19tb2RlX29uID8gJ0ljV2FsbGV0T3B0aW9uc0RhcmsnIDogJ0ljV2FsbGV0T3B0aW9uc0xpZ2h0JztcblxuICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YTogeyBkZXJpdmV6X2FjY291bnRzLCBkeHRyYWRlX2FjY291bnRzLCBtdDVfYWNjb3VudHMgfSxcbiAgICAgICAgaXNTdWNjZXNzOiBpc19jZmRfYWNjb3VudHNfbG9hZGVkLFxuICAgIH0gPSB1c2VFeGlzdGluZ0NGREFjY291bnRzKCk7XG5cbiAgICBjb25zdCB7IGRhdGEsIC4uLnJlc3QgfSA9IHVzZUZldGNoKCd0cmFuc2Zlcl9iZXR3ZWVuX2FjY291bnRzJywge1xuICAgICAgICBwYXlsb2FkOiB7IGFjY291bnRzOiAnYWxsJyB9LFxuICAgICAgICBvcHRpb25zOiB7IGVuYWJsZWQ6IGlzX2NmZF9hY2NvdW50c19sb2FkZWQgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IG1vZGlmaWVkX3RyYW5zZmVyX2FjY291bnRzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFsbF9saW5rZWRfY2ZkX2FjY291bnRzID0gWy4uLmRlcml2ZXpfYWNjb3VudHMsIC4uLmR4dHJhZGVfYWNjb3VudHMsIC4uLm10NV9hY2NvdW50c107XG5cbiAgICAgICAgY29uc3QgZ2V0QWNjb3VudFR5cGUgPSAoaXNfZGVtbz86IG51bWJlciwgY3VycmVuY3k/OiBzdHJpbmcpOiAnZmlhdCcgfCAnY3J5cHRvJyB8ICdkZW1vJyA9PiB7XG4gICAgICAgICAgICBpZiAoaXNfZGVtbykgcmV0dXJuICdkZW1vJztcbiAgICAgICAgICAgIHJldHVybiBnZXRDb25maWcoY3VycmVuY3kgfHwgJycpPy5pc19jcnlwdG8gPyAnY3J5cHRvJyA6ICdmaWF0JztcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBhY2NvdW50cyA9IGRhdGE/LmFjY291bnRzPy5tYXAoYWNjb3VudCA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmFjY291bnQsXG4gICAgICAgICAgICAgICAgYWN0aXZlX3dhbGxldF9pY29uOiBhY3RpdmVfd2FsbGV0Py5pY29uLFxuICAgICAgICAgICAgICAgIGJhbGFuY2U6IHBhcnNlRmxvYXQoXG4gICAgICAgICAgICAgICAgICAgIE51bWJlcihhY2NvdW50LmJhbGFuY2UpLnRvRml4ZWQoZ2V0Q29uZmlnKGFjY291bnQuY3VycmVuY3kgfHwgJycpPy5mcmFjdGlvbmFsX2RpZ2l0cylcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlfY3VycmVuY3lfY29kZTogZ2V0Q29uZmlnKGFjY291bnQuY3VycmVuY3kgfHwgJycpPy5kaXNwbGF5X2NvZGUsXG4gICAgICAgICAgICAgICAgaXNfZGVtbzogQm9vbGVhbihhY2NvdW50Py5kZW1vX2FjY291bnQpLFxuICAgICAgICAgICAgICAgIHNob3J0Y29kZTogYWN0aXZlX3dhbGxldD8ubGFuZGluZ19jb21wYW55X25hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogZ2V0QWNjb3VudFR5cGUoYWNjb3VudC5kZW1vX2FjY291bnQsIGFjY291bnQuY3VycmVuY3kpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyYWRpbmdfYWNjb3VudHM6XG4gICAgICAgICAgICAgICAgYWNjb3VudHM/LnJlZHVjZShcbiAgICAgICAgICAgICAgICAgICAgKHRyYWRpbmdfYWNjb3VudHMsIGFjY291bnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY2NvdW50LmFjY291bnRfdHlwZSA9PT0gJ3dhbGxldCcpIHJldHVybiB0cmFkaW5nX2FjY291bnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhY2NvdW50LmxvZ2luaWQpIHJldHVybiB0cmFkaW5nX2FjY291bnRzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZmRfaWNvbiA9IGFsbF9saW5rZWRfY2ZkX2FjY291bnRzLmZpbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2ZkX2FjY291bnQgPT4gYWNjb3VudC5sb2dpbmlkICYmIGNmZF9hY2NvdW50LmxvZ2luaWQ/LmluY2x1ZGVzKGFjY291bnQubG9naW5pZClcbiAgICAgICAgICAgICAgICAgICAgICAgICk/LnRyYW5zZmVyX2ljb247XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWRpbmdfYWNjb3VudHNbYWNjb3VudC5sb2dpbmlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5hY2NvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRpZW50X2NsYXNzOiBhY3RpdmVfd2FsbGV0Py5ncmFkaWVudF9jYXJkX2NsYXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb246IGFjY291bnQuYWNjb3VudF90eXBlID09PSAndHJhZGluZycgPyB0cmFkaW5nX2FwcHNfaWNvbiA6IGNmZF9pY29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLihhY2NvdW50LmFjY291bnRfdHlwZSA9PT0gJ210NScgJiYge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdDVfbWFya2V0X3R5cGU6IG10NV9hY2NvdW50cz8uZmluZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG10NV9hY2NvdW50ID0+IGFjY291bnQubG9naW5pZCAmJiBtdDVfYWNjb3VudC5sb2dpbmlkPy5pbmNsdWRlcyhhY2NvdW50LmxvZ2luaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk/Lm1hcmtldF90eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYWRpbmdfYWNjb3VudHM7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHt9IGFzIFJlY29yZDxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIE5vbk51bGxhYmxlPFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBhY2NvdW50c1tudW1iZXJdICYge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudF9jbGFzcz86IGB3YWxsZXQtY2FyZF9fJHtzdHJpbmd9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj86IHN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXQ1X21hcmtldF90eXBlPzogJ2FsbCcgfCAnZmluYW5jaWFsJyB8ICdzeW50aGV0aWMnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICkgfHwge30sXG4gICAgICAgICAgICB3YWxsZXRfYWNjb3VudHM6XG4gICAgICAgICAgICAgICAgYWNjb3VudHM/LnJlZHVjZShcbiAgICAgICAgICAgICAgICAgICAgKHdhbGxldF9hY2NvdW50cywgd2FsbGV0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2FsbGV0LmFjY291bnRfdHlwZSAhPT0gJ3dhbGxldCcpIHJldHVybiB3YWxsZXRfYWNjb3VudHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdhbGxldC5sb2dpbmlkKSByZXR1cm4gd2FsbGV0X2FjY291bnRzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhdmFpbGFibGVfd2FsbGV0ID0gd2FsbGV0cz8uZmluZChhY2MgPT4gYWNjLmxvZ2luaWQgPT09IHdhbGxldC5sb2dpbmlkKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgd2FsbGV0X2FjY291bnRzW3dhbGxldC5sb2dpbmlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi53YWxsZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogYXZhaWxhYmxlX3dhbGxldD8uaWNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudF9jbGFzczogYXZhaWxhYmxlX3dhbGxldD8uZ3JhZGllbnRfY2FyZF9jbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3YWxsZXRfYWNjb3VudHM7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHt9IGFzIFJlY29yZDxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIE5vbk51bGxhYmxlPFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBhY2NvdW50c1tudW1iZXJdICYge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudF9jbGFzcz86IGB3YWxsZXQtY2FyZF9fJHtzdHJpbmd9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj86IHN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICApIHx8IHt9LFxuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgYWN0aXZlX3dhbGxldD8uZ3JhZGllbnRfY2FyZF9jbGFzcyxcbiAgICAgICAgYWN0aXZlX3dhbGxldD8uaWNvbixcbiAgICAgICAgYWN0aXZlX3dhbGxldD8ubGFuZGluZ19jb21wYW55X25hbWUsXG4gICAgICAgIGRhdGE/LmFjY291bnRzLFxuICAgICAgICBkZXJpdmV6X2FjY291bnRzLFxuICAgICAgICBkeHRyYWRlX2FjY291bnRzLFxuICAgICAgICBnZXRDb25maWcsXG4gICAgICAgIG10NV9hY2NvdW50cyxcbiAgICAgICAgdHJhZGluZ19hcHBzX2ljb24sXG4gICAgICAgIHdhbGxldHMsXG4gICAgXSk7XG5cbiAgICBjb25zdCBtb2RpZmllZF9hY3RpdmVfd2FsbGV0ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBhY3RpdmVfd2FsbGV0Py5sb2dpbmlkXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgIC4uLm1vZGlmaWVkX3RyYW5zZmVyX2FjY291bnRzLndhbGxldF9hY2NvdW50c1thY3RpdmVfd2FsbGV0Py5sb2dpbmlkXSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfSwgW2FjdGl2ZV93YWxsZXQ/LmxvZ2luaWQsIG1vZGlmaWVkX3RyYW5zZmVyX2FjY291bnRzLndhbGxldF9hY2NvdW50c10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgYWN0aXZlX3dhbGxldDogbW9kaWZpZWRfYWN0aXZlX3dhbGxldCxcbiAgICAgICAgdHJhZGluZ19hY2NvdW50czogbW9kaWZpZWRfdHJhbnNmZXJfYWNjb3VudHMudHJhZGluZ19hY2NvdW50cyxcbiAgICAgICAgd2FsbGV0X2FjY291bnRzOiBtb2RpZmllZF90cmFuc2Zlcl9hY2NvdW50cy53YWxsZXRfYWNjb3VudHMsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZVRyYW5zZmVyQmV0d2VlbkFjY291bnRzO1xuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlUmVxdWVzdCB9IGZyb20gJ0BkZXJpdi9hcGknO1xuaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICdAZGVyaXYvc3RvcmVzJztcbmltcG9ydCB1c2VDb3VudGRvd24gZnJvbSAnLi91c2VDb3VudGRvd24nO1xuXG5jb25zdCBSRVNFTkRfQ09VTlRET1dOID0gNjA7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSB1c2VWZXJpZnlFbWFpbCBmcm9tIEBkZXJpdi9hcGkgaW5zdGVhZFxuICovXG5jb25zdCB1c2VWZXJpZnlFbWFpbCA9IChcbiAgICB0eXBlOiBQYXJhbWV0ZXJzPFJldHVyblR5cGU8dHlwZW9mIHVzZVJlcXVlc3Q8J3ZlcmlmeV9lbWFpbCc+PlsnbXV0YXRlJ10+WzBdWydwYXlsb2FkJ11bJ3R5cGUnXVxuKSA9PiB7XG4gICAgY29uc3QgV1MgPSB1c2VSZXF1ZXN0KCd2ZXJpZnlfZW1haWwnKTtcbiAgICBjb25zdCBjb3VudGVyID0gdXNlQ291bnRkb3duKHsgZnJvbTogUkVTRU5EX0NPVU5URE9XTiB9KTtcbiAgICBjb25zdCB7IGNsaWVudCB9ID0gdXNlU3RvcmUoKTtcbiAgICBjb25zdCBbc2VudF9jb3VudCwgc2V0U2VudENvdW50XSA9IHVzZVN0YXRlKDApO1xuXG4gICAgY29uc3Qgc2VuZCA9IHVzZUNhbGxiYWNrKFxuICAgICAgICAoZW1haWw/OiBQYXJhbWV0ZXJzPFJldHVyblR5cGU8dHlwZW9mIHVzZVJlcXVlc3Q8J3ZlcmlmeV9lbWFpbCc+PlsnbXV0YXRlJ10+WzBdWydwYXlsb2FkJ11bJ3ZlcmlmeV9lbWFpbCddKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0X2VtYWlsID0gZW1haWwgPz8gY2xpZW50LmVtYWlsO1xuICAgICAgICAgICAgaWYgKCFyZXF1ZXN0X2VtYWlsKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoY291bnRlci5pc19ydW5uaW5nKSByZXR1cm47XG5cbiAgICAgICAgICAgIGNvdW50ZXIucmVzZXQoKTtcbiAgICAgICAgICAgIGNvdW50ZXIuc3RhcnQoKTtcblxuICAgICAgICAgICAgc2V0U2VudENvdW50KGNvdW50ID0+IGNvdW50ICsgMSk7XG5cbiAgICAgICAgICAgIFdTLm11dGF0ZSh7IHBheWxvYWQ6IHsgdmVyaWZ5X2VtYWlsOiByZXF1ZXN0X2VtYWlsLCB0eXBlIH0gfSk7XG4gICAgICAgIH0sXG4gICAgICAgIFtXUywgY2xpZW50LmVtYWlsLCBjb3VudGVyLCB0eXBlXVxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBpc19sb2FkaW5nOiBXUy5pc0xvYWRpbmcsXG4gICAgICAgIGVycm9yOiBXUy5lcnJvcixcbiAgICAgICAgZGF0YTogV1MuZGF0YSxcbiAgICAgICAgY291bnRlcjogY291bnRlci5jb3VudCxcbiAgICAgICAgaXNfY291bnRlcl9ydW5uaW5nOiBjb3VudGVyLmlzX3J1bm5pbmcsXG4gICAgICAgIHNlbnRfY291bnQsXG4gICAgICAgIGhhc19iZWVuX3NlbnQ6IHNlbnRfY291bnQgIT09IDAsXG4gICAgICAgIHNlbmQsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZVZlcmlmeUVtYWlsO1xuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VBdXRob3JpemUsIHVzZUZldGNoLCB1c2VJbnZhbGlkYXRlUXVlcnksIHVzZVJlcXVlc3QgfSBmcm9tICdAZGVyaXYvYXBpJztcbmltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnQGRlcml2L3N0b3Jlcyc7XG5cbi8qKiBBIGN1c3RvbSBob29rIHRvIGdldCB0aGUgc3RhdHVzIG9mIHdhbGxldF9taWdyYXRpb24gQVBJIGFuZCB0byBzdGFydC9yZXNldCB0aGUgbWlncmF0aW9uIHByb2Nlc3NcbiAqIEBkZXByZWNhdGVkIFRoaXMgaG9vayBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRoZSBob29rIGZyb20gQGRlcml2L2FwaSBpbnN0ZWFkLlxuICovXG5jb25zdCB1c2VXYWxsZXRNaWdyYXRpb24gPSAoKSA9PiB7XG4gICAgLy8gVE9ETzogZGVsZXRlIGl0IGxhdGVyLCBpdCdzIGEgdGVtcG9yYXJ5IHNvbHV0aW9uXG4gICAgLy8gYmVjYXVzZSB3ZSBoYXZlIHRvIGNoZWNrIGZvciBhdXRob3JpemUgZnJvbSBjbGllbnQgc3RvcmUgYmVmb3JlIGRvaW5nIEFQSSBjYWxsXG4gICAgLy8gVGhpcyBob29rIHdpbGwgYmUgcmVmYWN0b3JlZCBsYXRlciBmb3Igc3Vic2NyaWJlIHdoZW4gQkUgaXMgcmVhZHlcbiAgICBjb25zdCB7IGNsaWVudCB9ID0gdXNlU3RvcmUoKTtcbiAgICBjb25zdCB7IGlzX2F1dGhvcml6ZSB9ID0gY2xpZW50O1xuXG4gICAgY29uc3QgaW52YWxpZGF0ZSA9IHVzZUludmFsaWRhdGVRdWVyeSgpO1xuXG4gICAgLyoqIE1ha2UgYSByZXF1ZXN0IHRvIHdhbGxldF9taWdyYXRpb24gQVBJIGFuZCBvblN1Y2Nlc3MgaXQgd2lsbCBpbnZhbGlkYXRlIHRoZSBjYWNoZWQgZGF0YSAgKi9cbiAgICBjb25zdCB7IG11dGF0ZSB9ID0gdXNlUmVxdWVzdCgnd2FsbGV0X21pZ3JhdGlvbicsIHsgb25TdWNjZXNzOiAoKSA9PiBpbnZhbGlkYXRlKCd3YWxsZXRfbWlncmF0aW9uJykgfSk7XG5cbiAgICBjb25zdCB7IGlzU3VjY2VzcyB9ID0gdXNlQXV0aG9yaXplKCk7XG5cbiAgICAvKiogRmV0Y2ggdGhlIHdhbGxldF9taWdyYXRpb24gQVBJIGFuZCByZWZldGNoIGl0IGV2ZXJ5IHNlY29uZCBpZiB0aGUgc3RhdHVzIGlzIGluX3Byb2dyZXNzICovXG4gICAgY29uc3QgeyBkYXRhIH0gPSB1c2VGZXRjaCgnd2FsbGV0X21pZ3JhdGlvbicsIHtcbiAgICAgICAgcGF5bG9hZDogeyB3YWxsZXRfbWlncmF0aW9uOiAnc3RhdGUnIH0sXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHJlZmV0Y2hJbnRlcnZhbDogcmVzcG9uc2UgPT4gKHJlc3BvbnNlPy53YWxsZXRfbWlncmF0aW9uPy5zdGF0ZSA9PT0gJ2luX3Byb2dyZXNzJyA/IDUwMCA6IGZhbHNlKSxcbiAgICAgICAgICAgIC8vIGRlbGV0ZSBpdCBsYXRlclxuICAgICAgICAgICAgZW5hYmxlZDogaXNfYXV0aG9yaXplICYmIGlzU3VjY2VzcyxcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHN0YXJ0X21pZ3JhdGlvbiA9IHVzZUNhbGxiYWNrKCgpID0+IG11dGF0ZSh7IHBheWxvYWQ6IHsgd2FsbGV0X21pZ3JhdGlvbjogJ3N0YXJ0JyB9IH0pLCBbbXV0YXRlXSk7XG5cbiAgICBjb25zdCByZXNldF9taWdyYXRpb24gPSB1c2VDYWxsYmFjaygoKSA9PiBtdXRhdGUoeyBwYXlsb2FkOiB7IHdhbGxldF9taWdyYXRpb246ICdyZXNldCcgfSB9KSwgW211dGF0ZV0pO1xuXG4gICAgY29uc3Qgc3RhdGUgPSBkYXRhPy53YWxsZXRfbWlncmF0aW9uPy5zdGF0ZTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKiBUaGUgc3RhdHVzIG9mIHRoZSB3YWxsZXRfbWlncmF0aW9uIEFQSSAqL1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgLyoqIEEgYm9vbGVhbiB0byBjaGVjayBpZiB0aGUgc3RhdHVzIGlzIG5vdF9lbGlnaWJsZSAqL1xuICAgICAgICBpc19pbmVsaWdpYmxlOiBzdGF0ZSA9PT0gJ2luZWxpZ2libGUnLFxuICAgICAgICAvKiogQSBib29sZWFuIHRvIGNoZWNrIGlmIHRoZSBzdGF0dXMgaXMgZWxpZ2libGUgKi9cbiAgICAgICAgaXNfZWxpZ2libGU6IHN0YXRlID09PSAnZWxpZ2libGUnLFxuICAgICAgICAvKiogQSBib29sZWFuIHRvIGNoZWNrIGlmIHRoZSBzdGF0dXMgaXMgaW5fcHJvZ3Jlc3MgKi9cbiAgICAgICAgaXNfaW5fcHJvZ3Jlc3M6IHN0YXRlID09PSAnaW5fcHJvZ3Jlc3MnLFxuICAgICAgICAvKiogQSBib29sZWFuIHRvIGNoZWNrIGlmIHRoZSBzdGF0dXMgaXMgY29tcGxldGVkICovXG4gICAgICAgIGlzX21pZ3JhdGVkOiBzdGF0ZSA9PT0gJ21pZ3JhdGVkJyxcbiAgICAgICAgLyoqIEEgYm9vbGVhbiB0byBjaGVjayBpZiB0aGUgc3RhdHVzIGlzIGZhaWxlZCAqL1xuICAgICAgICBpc19mYWlsZWQ6IHN0YXRlID09PSAnZmFpbGVkJyxcbiAgICAgICAgLyoqIFNlbmRzIGEgcmVxdWVzdCB0byB3YWxsZXRfbWlncmF0aW9uIEFQSSB0byBzdGFydCB0aGUgbWlncmF0aW9uIHByb2Nlc3MgKi9cbiAgICAgICAgc3RhcnRfbWlncmF0aW9uLFxuICAgICAgICAvKiogU2VuZHMgYSByZXF1ZXN0IHRvIHdhbGxldF9taWdyYXRpb24gQVBJIHRvIHJlc2V0IHRoZSBtaWdyYXRpb24gcHJvY2VzcyAqL1xuICAgICAgICByZXNldF9taWdyYXRpb24sXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZVdhbGxldE1pZ3JhdGlvbjtcbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICdAZGVyaXYvc3RvcmVzJztcbmltcG9ydCB7IGdldFdhbGxldEN1cnJlbmN5SWNvbiB9IGZyb20gJ0BkZXJpdi91dGlscyc7XG5pbXBvcnQgdXNlQWN0aXZlV2FsbGV0IGZyb20gJy4vdXNlQWN0aXZlV2FsbGV0JztcbmltcG9ydCB1c2VDdXJyZW5jeUNvbmZpZyBmcm9tICcuL3VzZUN1cnJlbmN5Q29uZmlnJztcbmltcG9ydCB1c2VQbGF0Zm9ybUFjY291bnRzIGZyb20gJy4vdXNlUGxhdGZvcm1BY2NvdW50cyc7XG5pbXBvcnQgdXNlV2FsbGV0c0xpc3QgZnJvbSAnLi91c2VXYWxsZXRzTGlzdCc7XG5cbmNvbnN0IHRyYWRpbmdfYWNjb3VudHNfZGlzcGxheV9wcmVmaXhlcyA9IHtcbiAgICBzdGFuZGFyZDogJ0Rlcml2IEFwcHMnLFxuICAgIG10NTogJ01UNScsXG4gICAgZHh0cmFkZTogJ0Rlcml2IFgnLFxuICAgIGJpbmFyeTogJ0JpbmFyeScsXG59IGFzIGNvbnN0O1xuXG5jb25zdCBsYW5kaW5nX2NvbXBhbnlfZGlzcGxheV9zaG9ydGNvZGVzID0ge1xuICAgIHN2ZzogJ1NWRycsXG4gICAgbWFsdGE6ICdNYWx0YScsXG59IGFzIGNvbnN0O1xuXG5jb25zdCB1c2VXYWxsZXRUcmFuc2FjdGlvbnMgPSAoXG4gICAgYWN0aW9uX3R5cGU6ICcnIHwgJ2RlcG9zaXQnIHwgJ3dpdGhkcmF3YWwnIHwgJ2luaXRpYWxfZnVuZCcgfCAncmVzZXRfYmFsYW5jZScgfCAndHJhbnNmZXInXG4pID0+IHtcbiAgICBjb25zdCB7XG4gICAgICAgIGNsaWVudDogeyBsb2dpbmlkLCBsYW5kaW5nX2NvbXBhbnlfc2hvcnRjb2RlOiBzaG9ydGNvZGUgfSxcbiAgICAgICAgdWk6IHsgaXNfZGFya19tb2RlX29uIH0sXG4gICAgfSA9IHVzZVN0b3JlKCk7XG4gICAgY29uc3QgeyBkYXRhOiB3YWxsZXRzIH0gPSB1c2VXYWxsZXRzTGlzdCgpO1xuICAgIGNvbnN0IGN1cnJlbnRfd2FsbGV0ID0gdXNlQWN0aXZlV2FsbGV0KCk7XG4gICAgbGV0IHsgZGVtbzogZGVtb19wbGF0Zm9ybV9hY2NvdW50IH0gPSB1c2VQbGF0Zm9ybUFjY291bnRzKCk7XG4gICAgY29uc3QgeyByZWFsOiByZWFsX3BsYXRmb3JtX2FjY291bnRzIH0gPSB1c2VQbGF0Zm9ybUFjY291bnRzKCk7XG5cbiAgICAvLyBUT0RPIHJlbW92ZSB0aGVzZSBtb2NrcyB3aGVuIHdlJ3JlIHRvIHN3aXRjaCB0byBBUEkgZGF0YVxuICAgIGRlbW9fcGxhdGZvcm1fYWNjb3VudCA9IHtcbiAgICAgICAgYWNjb3VudF9jYXRlZ29yeTogJ3RyYWRpbmcnLFxuICAgICAgICBhY2NvdW50X3R5cGU6ICdzdGFuZGFyZCcsXG4gICAgICAgIGN1cnJlbmN5OiAnVVNEJyxcbiAgICAgICAgbG9naW5pZDogJ1ZSVENNT0NLMDAwMScsXG4gICAgICAgIGlzX3ZpcnR1YWw6IDEsXG4gICAgICAgIGxhbmRpbmdfY29tcGFueV9zaG9ydGNvZGU6IHNob3J0Y29kZSBhcyAnc3ZnJyB8ICdtYWx0YScsXG4gICAgICAgIHRva2VuOiAnJyxcbiAgICB9O1xuICAgIHJlYWxfcGxhdGZvcm1fYWNjb3VudHMucHVzaCh7XG4gICAgICAgIGFjY291bnRfY2F0ZWdvcnk6ICd0cmFkaW5nJyxcbiAgICAgICAgYWNjb3VudF90eXBlOiAnc3RhbmRhcmQnLFxuICAgICAgICBjdXJyZW5jeTogJ1VTRCcsXG4gICAgICAgIGxvZ2luaWQ6ICdDUk1PQ0swMDAxJyxcbiAgICAgICAgaXNfdmlydHVhbDogMCxcbiAgICAgICAgbGFuZGluZ19jb21wYW55X3Nob3J0Y29kZTogc2hvcnRjb2RlIGFzICdzdmcnIHwgJ21hbHRhJyxcbiAgICAgICAgdG9rZW46ICcnLFxuICAgIH0pO1xuICAgIGlmICh3YWxsZXRzICYmIGN1cnJlbnRfd2FsbGV0KVxuICAgICAgICB3YWxsZXRzLnB1c2goe1xuICAgICAgICAgICAgYWNjb3VudF90eXBlOiAnY3J5cHRvJyxcbiAgICAgICAgICAgIGJhbGFuY2U6IDAsXG4gICAgICAgICAgICBjdXJyZW5jeTogJ0JUQycsXG4gICAgICAgICAgICBncmFkaWVudF9oZWFkZXJfY2xhc3M6ICd3YWxsZXQtaGVhZGVyX19idGMtYmcnLFxuICAgICAgICAgICAgZ3JhZGllbnRfY2FyZF9jbGFzczogYHdhbGxldC1jYXJkX19idGMtYmcke2lzX2RhcmtfbW9kZV9vbiA/ICctLWRhcmsnIDogJyd9YCxcbiAgICAgICAgICAgIGlzX2RlbW86ICEhY3VycmVudF93YWxsZXQuaXNfdmlydHVhbCxcbiAgICAgICAgICAgIGlzX2Rpc2FibGVkOiAwLFxuICAgICAgICAgICAgaXNfbWFsdGFfd2FsbGV0OiBmYWxzZSxcbiAgICAgICAgICAgIGlzX3NlbGVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzX3ZpcnR1YWw6IGN1cnJlbnRfd2FsbGV0LmlzX3ZpcnR1YWwsXG4gICAgICAgICAgICBsYW5kaW5nX2NvbXBhbnlfbmFtZTogJ3N2ZycsXG4gICAgICAgICAgICBsb2dpbmlkOiAnQ1JXTU9DSzAwMDQyJyxcbiAgICAgICAgICAgIGN1cnJlbmN5X2NvbmZpZzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaWNvbjogJ0ljV2FsbGV0Q3VycmVuY3lCdGMnLFxuICAgICAgICAgICAgd2FsbGV0X2N1cnJlbmN5X3R5cGU6ICdCVEMnLFxuICAgICAgICB9KTtcbiAgICBjb25zdCBhY2NvdW50cyA9IHVzZU1lbW8oXG4gICAgICAgICgpID0+IFtkZW1vX3BsYXRmb3JtX2FjY291bnQsIC4uLnJlYWxfcGxhdGZvcm1fYWNjb3VudHNdLFxuICAgICAgICBbZGVtb19wbGF0Zm9ybV9hY2NvdW50LCByZWFsX3BsYXRmb3JtX2FjY291bnRzXVxuICAgICk7XG4gICAgY29uc3QgeyBnZXRDb25maWcgfSA9IHVzZUN1cnJlbmN5Q29uZmlnKCk7XG5cbiAgICBjb25zdCBnZXRUcmFkaW5nQWNjb3VudE5hbWUgPSB1c2VDYWxsYmFjayhcbiAgICAgICAgKFxuICAgICAgICAgICAgYWNjb3VudF90eXBlOiAnc3RhbmRhcmQnIHwgJ210NScgfCAnZHh0cmFkZScgfCAnYmluYXJ5JyxcbiAgICAgICAgICAgIGlzX3ZpcnR1YWw6IGJvb2xlYW4sXG4gICAgICAgICAgICBsYW5kaW5nX2NvbXBhbnlfc2hvcnRjb2RlOiAnc3ZnJyB8ICdtYWx0YSdcbiAgICAgICAgKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dHJhZGluZ19hY2NvdW50c19kaXNwbGF5X3ByZWZpeGVzW2FjY291bnRfdHlwZV19ICR7XG4gICAgICAgICAgICAgICAgaXNfdmlydHVhbCA/ICdEZW1vJyA6IGAoJHtsYW5kaW5nX2NvbXBhbnlfZGlzcGxheV9zaG9ydGNvZGVzW2xhbmRpbmdfY29tcGFueV9zaG9ydGNvZGVdfSlgXG4gICAgICAgICAgICB9IGFjY291bnRgO1xuICAgICAgICB9LFxuICAgICAgICBbXVxuICAgICk7XG5cbiAgICAvLyBUT0RPIHJlbW92ZSB0aGlzIG1vY2sgd2hlbiB3ZSdyZSB0byBzd2l0Y2ggdG8gQVBJIGRhdGFcbiAgICBjb25zdCBtb2NrX3RyYW5zYWN0aW9ucyA9IGN1cnJlbnRfd2FsbGV0Py5pc192aXJ0dWFsXG4gICAgICAgID8gW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBhY3Rpb25fdHlwZTogJ3RyYW5zZmVyJyxcbiAgICAgICAgICAgICAgICAgIGFtb3VudDogNSxcbiAgICAgICAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgICAgICAgICBsb2dpbmlkLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgICAgICAgICAgbG9naW5pZDogJ1ZSVENNT0NLMDAwMScsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgYXBwX2lkOiB7fSxcbiAgICAgICAgICAgICAgICAgIGJhbGFuY2VfYWZ0ZXI6IDk5OTUsXG4gICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbl9pZDogMTc0OTQ0MTU0ODQsXG4gICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbl90aW1lOiAxNjg1OTQyMTM5LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBhY3Rpb25fdHlwZTogJ3Jlc2V0X2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgYW1vdW50OiAzNTAsXG4gICAgICAgICAgICAgICAgICBiYWxhbmNlX2FmdGVyOiAxMDAwMCxcbiAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uX2lkOiAxMzY5MzAwMzQyMSxcbiAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uX3RpbWU6IDE2ODU5NDIxMzgsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbl90eXBlOiAndHJhbnNmZXInLFxuICAgICAgICAgICAgICAgICAgYW1vdW50OiAyMDAsXG4gICAgICAgICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgICAgICAgICAgbG9naW5pZDogJ1ZSVENNT0NLMDAwMScsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgICAgICAgICBsb2dpbmlkLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGJhbGFuY2VfYWZ0ZXI6IDk2NTAsXG4gICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbl9pZDogMTc0OTQ0MTU0ODMsXG4gICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbl90aW1lOiAxNjg1ODU1NzQwLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBhY3Rpb25fdHlwZTogJ3RyYW5zZmVyJyxcbiAgICAgICAgICAgICAgICAgIGFtb3VudDogNTUwLFxuICAgICAgICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICAgICAgICAgIGxvZ2luaWQsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgICAgICAgICBsb2dpbmlkOiAnVlJUQ01PQ0swMDAxJyxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBhcHBfaWQ6IHt9LFxuICAgICAgICAgICAgICAgICAgYmFsYW5jZV9hZnRlcjogOTQ1MCxcbiAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uX2lkOiAxNzQ5NDQxNTQ4MixcbiAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uX3RpbWU6IDE2ODU4NTU3MzksXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbl90eXBlOiAnaW5pdGlhbF9mdW5kJyxcbiAgICAgICAgICAgICAgICAgIGFtb3VudDogMTAwMDAsXG4gICAgICAgICAgICAgICAgICBiYWxhbmNlX2FmdGVyOiAxMDAwMCxcbiAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uX2lkOiAxMzY5MzAxMTQwMSxcbiAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uX3RpbWU6IDE2ODU4NTU3MzgsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgXVxuICAgICAgICA6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgYWN0aW9uX3R5cGU6ICd0cmFuc2ZlcicsXG4gICAgICAgICAgICAgICAgICBhbW91bnQ6IDUsXG4gICAgICAgICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgICAgICAgICAgbG9naW5pZCxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICAgICAgICAgIGxvZ2luaWQ6ICdDUk1PQ0swMDAxJyxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBiYWxhbmNlX2FmdGVyOiAwLFxuICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25faWQ6IDE3NDk0MTE3NTQxLFxuICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25fdGltZTogMTY4NTk0MjEzOCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgYWN0aW9uX3R5cGU6ICd0cmFuc2ZlcicsXG4gICAgICAgICAgICAgICAgICBhbW91bnQ6IDIwLFxuICAgICAgICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICAgICAgICAgIGxvZ2luaWQsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgICAgICAgICBsb2dpbmlkOiAnQ1JXTU9DSzAwMDQyJyxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBiYWxhbmNlX2FmdGVyOiA1LFxuICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25faWQ6IDE3NDk0NDE1NDg5LFxuICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25fdGltZTogMTY4NTk0MjEzNyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgYWN0aW9uX3R5cGU6ICdkZXBvc2l0JyxcbiAgICAgICAgICAgICAgICAgIGFtb3VudDogMjUsXG4gICAgICAgICAgICAgICAgICBiYWxhbmNlX2FmdGVyOiAyNSxcbiAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uX2lkOiAxNzQ5NDQxNTQ4MSxcbiAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uX3RpbWU6IDE2ODU5NDIxMzYsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbl90eXBlOiAnd2l0aGRyYXdhbCcsXG4gICAgICAgICAgICAgICAgICBhbW91bnQ6IDc1MCxcbiAgICAgICAgICAgICAgICAgIGJhbGFuY2VfYWZ0ZXI6IDAsXG4gICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbl9pZDogMTc0OTQ0MTU0ODAsXG4gICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbl90aW1lOiAxNjg1OTQyMTM1LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBhY3Rpb25fdHlwZTogJ3RyYW5zZmVyJyxcbiAgICAgICAgICAgICAgICAgIGFtb3VudDogMTAwLFxuICAgICAgICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICAgICAgICAgIGxvZ2luaWQ6ICdDUk1PQ0swMDAxJyxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICAgICAgICAgIGxvZ2luaWQsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgYmFsYW5jZV9hZnRlcjogNzUwLFxuICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25faWQ6IDE3NDk0NDE1NDc5LFxuICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25fdGltZTogMTY4NTg1NTczOCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgYWN0aW9uX3R5cGU6ICd0cmFuc2ZlcicsXG4gICAgICAgICAgICAgICAgICBhbW91bnQ6IDIwMCxcbiAgICAgICAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgICAgICAgICBsb2dpbmlkOiAnQ1JXTU9DSzAwMDQyJyxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICAgICAgICAgIGxvZ2luaWQsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgYmFsYW5jZV9hZnRlcjogNjUwLFxuICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25faWQ6IDE3NDk0MTE3NTQxLFxuICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25fdGltZTogMTY4NTg1NTczNyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgYWN0aW9uX3R5cGU6ICd0cmFuc2ZlcicsXG4gICAgICAgICAgICAgICAgICBhbW91bnQ6IDU1MCxcbiAgICAgICAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgICAgICAgICBsb2dpbmlkLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgICAgICAgICAgbG9naW5pZDogJ0NSTU9DSzAwMDEnLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGJhbGFuY2VfYWZ0ZXI6IDQ1MCxcbiAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uX2lkOiAxNzQ5NDExNzU0MCxcbiAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uX3RpbWU6IDE2ODU4NTU3MzYsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbl90eXBlOiAnZGVwb3NpdCcsXG4gICAgICAgICAgICAgICAgICBhbW91bnQ6IDEwMDAsXG4gICAgICAgICAgICAgICAgICBiYWxhbmNlX2FmdGVyOiAxMDAwLFxuICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25faWQ6IDE3NDk0MTE3NTM5LFxuICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25fdGltZTogMTY4NTc2OTMzOCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBdO1xuXG4gICAgLy8gY29uc3QgeyBpc0xvYWRpbmcsIGlzU3VjY2VzcyB9ID0gdXNlRmV0Y2goJ3N0YXRlbWVudCcsIHtcbiAgICAvLyAgICAgb3B0aW9uczogeyBrZWVwUHJldmlvdXNEYXRhOiB0cnVlIH0sXG4gICAgLy8gICAgIHBheWxvYWQ6IHsgYWN0aW9uX3R5cGU6IH0sXG4gICAgLy8gfSk7XG5cbiAgICAvLyBUT0RPOiB1bi1jb21tZW50IHRoaXMgY29kZSB3aGVuIHdlJ3JlIHRvIHN3aXRjaCB0byBBUEkgZGF0YVxuICAgIC8vIGNvbnN0IHRyYW5zYWN0aW9ucyA9IGRhdGE/LnN0YXRlbWVudD8udHJhbnNhY3Rpb25zPy5maWx0ZXIoXG4gICAgLy8gICAgIGVsID0+XG4gICAgLy8gICAgICAgICAhIWVsLmFjdGlvbl90eXBlICYmXG4gICAgLy8gICAgICAgICBbJ2RlcG9zaXQnLCAnd2l0aGRyYXdhbCcsICdpbml0aWFsX2Z1bmQnLCAncmVzZXRfYmFsYW5jZScsICd0cmFuc2ZlciddLmluY2x1ZGVzKGVsLmFjdGlvbl90eXBlKVxuICAgIC8vICkgYXMgVFdhbGxldFRyYW5zYWN0aW9uW107XG5cbiAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSB1c2VNZW1vKFxuICAgICAgICAoKSA9PiBtb2NrX3RyYW5zYWN0aW9ucy5maWx0ZXIoZWwgPT4gIWFjdGlvbl90eXBlIHx8IGVsLmFjdGlvbl90eXBlID09PSBhY3Rpb25fdHlwZSksXG4gICAgICAgIFthY3Rpb25fdHlwZSwgbW9ja190cmFuc2FjdGlvbnNdXG4gICAgKTtcblxuICAgIGNvbnN0IGdldFRyYW5zZmVyQWNjb3VudE5hbWUgPSB1c2VDYWxsYmFjayhcbiAgICAgICAgKG90aGVyX2FjY291bnQ6IEV4Y2x1ZGU8dHlwZW9mIGFjY291bnRzW251bWJlcl0sIHVuZGVmaW5lZD4pID0+IHtcbiAgICAgICAgICAgIGlmIChvdGhlcl9hY2NvdW50LmFjY291bnRfY2F0ZWdvcnkgPT09ICd3YWxsZXQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2FsbGV0ID0gd2FsbGV0cz8uZmluZChlbCA9PiBlbC5sb2dpbmlkID09PSBvdGhlcl9hY2NvdW50LmxvZ2luaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt3YWxsZXQ/LmlzX3ZpcnR1YWwgPyAnRGVtbyAnIDogJyd9JHt3YWxsZXQ/LmN1cnJlbmN5fSAkeydXYWxsZXQnfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0VHJhZGluZ0FjY291bnROYW1lKFxuICAgICAgICAgICAgICAgIG90aGVyX2FjY291bnQuYWNjb3VudF90eXBlIGFzICdzdGFuZGFyZCcgfCAnbXQ1JyB8ICdkeHRyYWRlJyB8ICdiaW5hcnknLFxuICAgICAgICAgICAgICAgICEhb3RoZXJfYWNjb3VudC5pc192aXJ0dWFsLFxuICAgICAgICAgICAgICAgIG90aGVyX2FjY291bnQubGFuZGluZ19jb21wYW55X3Nob3J0Y29kZSBhcyAnc3ZnJyB8ICdtYWx0YSdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIFtnZXRUcmFkaW5nQWNjb3VudE5hbWUsIHdhbGxldHNdXG4gICAgKTtcblxuICAgIGNvbnN0IG1vZGlmaWVkX3RyYW5zYWN0aW9ucyA9IHVzZU1lbW8oXG4gICAgICAgICgpID0+XG4gICAgICAgICAgICB3YWxsZXRzICYmIGN1cnJlbnRfd2FsbGV0XG4gICAgICAgICAgICAgICAgPyB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAubWFwKHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uYW1vdW50ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmJhbGFuY2VfYWZ0ZXIgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uYWN0aW9uX3R5cGUgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWNjb3VudF9jYXRlZ29yeSA9ICd3YWxsZXQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWNjb3VudF90eXBlID0gY3VycmVudF93YWxsZXQuYWNjb3VudF90eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWNjb3VudF9uYW1lID0gYCR7Y3VycmVudF93YWxsZXQuaXNfdmlydHVhbCA/ICdEZW1vICcgOiAnJ30ke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF93YWxsZXQuY3VycmVuY3lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSAkeydXYWxsZXQnfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhY2NvdW50X2N1cnJlbmN5ID0gY3VycmVudF93YWxsZXQuY3VycmVuY3k7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBncmFkaWVudF9jbGFzcyA9IGN1cnJlbnRfd2FsbGV0LmdyYWRpZW50X2NhcmRfY2xhc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpY29uID0gZ2V0V2FsbGV0Q3VycmVuY3lJY29uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF93YWxsZXQuaXNfdmlydHVhbCA/ICdkZW1vJyA6IGN1cnJlbnRfd2FsbGV0LmN1cnJlbmN5IHx8ICdVU0QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNfZGFya19tb2RlX29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5hY3Rpb25fdHlwZSA9PT0gJ3RyYW5zZmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJfbG9naW5pZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24udG8/LmxvZ2luaWQgPT09IGxvZ2luaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0cmFuc2FjdGlvbi5mcm9tPy5sb2dpbmlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdHJhbnNhY3Rpb24udG8/LmxvZ2luaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW90aGVyX2xvZ2luaWQpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJfYWNjb3VudCA9IGFjY291bnRzLmZpbmQoZWwgPT4gZWw/LmxvZ2luaWQgPT09IG90aGVyX2xvZ2luaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvdGhlcl9hY2NvdW50Py5jdXJyZW5jeSB8fCAhb3RoZXJfYWNjb3VudD8uYWNjb3VudF90eXBlKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRfY2F0ZWdvcnkgPSBvdGhlcl9hY2NvdW50LmFjY291bnRfY2F0ZWdvcnkgfHwgJ3dhbGxldCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50X2N1cnJlbmN5ID0gb3RoZXJfYWNjb3VudC5jdXJyZW5jeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRfbmFtZSA9IGdldFRyYW5zZmVyQWNjb3VudE5hbWUob3RoZXJfYWNjb3VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50X3R5cGUgPSBvdGhlcl9hY2NvdW50LmFjY291bnRfdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRpZW50X2NsYXNzID0gYHdhbGxldC1jYXJkX18ke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyX2FjY291bnQuaXNfdmlydHVhbCA9PT0gMSA/ICdkZW1vJyA6IG90aGVyX2FjY291bnQ/LmN1cnJlbmN5Py50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LWJnJHtpc19kYXJrX21vZGVfb24gPyAnLS1kYXJrJyA6ICcnfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uID0gZ2V0V2FsbGV0Q3VycmVuY3lJY29uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyX2FjY291bnQuaXNfdmlydHVhbCA/ICdkZW1vJyA6IG90aGVyX2FjY291bnQuY3VycmVuY3kgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNfZGFya19tb2RlX29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbmN5X2NvbmZpZyA9IGdldENvbmZpZyhhY2NvdW50X2N1cnJlbmN5IHx8ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNfY3J5cHRvID0gY3VycmVuY3lfY29uZmlnPy5pc19jcnlwdG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGljb25fdHlwZSA9IGlzX2NyeXB0byB8fCBjdXJyZW50X3dhbGxldC5pc192aXJ0dWFsID8gJ2NyeXB0bycgOiAnZmlhdCc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudF9jYXRlZ29yeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRfY3VycmVuY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50X25hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50X3R5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudF9jbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKDxUPih2YWx1ZTogVCB8IG51bGwpOiB2YWx1ZSBpcyBUID0+IHZhbHVlICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIFthY2NvdW50cywgY3VycmVudF93YWxsZXQsIGdldENvbmZpZywgZ2V0VHJhbnNmZXJBY2NvdW50TmFtZSwgaXNfZGFya19tb2RlX29uLCBsb2dpbmlkLCB0cmFuc2FjdGlvbnMsIHdhbGxldHNdXG4gICAgKTtcblxuICAgIHJldHVybiB7IHRyYW5zYWN0aW9uczogbW9kaWZpZWRfdHJhbnNhY3Rpb25zLCBpc0xvYWRpbmc6IGZhbHNlLCBpc1N1Y2Nlc3M6IHRydWUgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZVdhbGxldFRyYW5zYWN0aW9ucztcbiIsImltcG9ydCB7IHVzZU1lbW8sIHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlVHJhbnNmZXJCZXR3ZWVuQWNjb3VudHMgZnJvbSAnLi91c2VUcmFuc2ZlckJldHdlZW5BY2NvdW50cyc7XG5cbmNvbnN0IHVzZVdhbGxldFRyYW5zZmVyID0gKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgICAgYWN0aXZlX3dhbGxldCxcbiAgICAgICAgdHJhZGluZ19hY2NvdW50cyxcbiAgICAgICAgd2FsbGV0X2FjY291bnRzLFxuICAgICAgICBpc0xvYWRpbmc6IGlzX2FjY291bnRzX2xvYWRpbmcsXG4gICAgfSA9IHVzZVRyYW5zZmVyQmV0d2VlbkFjY291bnRzKCk7XG5cbiAgICBjb25zdCBbZnJvbV9hY2NvdW50LCBzZXRGcm9tQWNjb3VudF0gPSB1c2VTdGF0ZTx0eXBlb2YgYWN0aXZlX3dhbGxldD4oKTtcbiAgICBjb25zdCBbdG9fYWNjb3VudCwgc2V0VG9BY2NvdW50XSA9IHVzZVN0YXRlPHR5cGVvZiBhY3RpdmVfd2FsbGV0PigpO1xuXG4gICAgY29uc3QgdG9fYWNjb3VudF9saXN0ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghZnJvbV9hY2NvdW50Py5sb2dpbmlkKSByZXR1cm4geyB0cmFkaW5nX2FjY291bnRzOiB7fSwgd2FsbGV0X2FjY291bnRzOiB7fSB9O1xuICAgICAgICBpZiAoIWFjdGl2ZV93YWxsZXQ/LmxvZ2luaWQpIHJldHVybiB7IHRyYWRpbmdfYWNjb3VudHM6IHt9LCB3YWxsZXRfYWNjb3VudHM6IHt9IH07XG5cbiAgICAgICAgaWYgKGZyb21fYWNjb3VudD8ubG9naW5pZCA9PT0gYWN0aXZlX3dhbGxldD8ubG9naW5pZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0cmFkaW5nX2FjY291bnRzLFxuICAgICAgICAgICAgICAgIHdhbGxldF9hY2NvdW50czogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyh3YWxsZXRfYWNjb3VudHMpLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIChba2V5XSkgPT4gYWN0aXZlX3dhbGxldD8ubG9naW5pZCAmJiAha2V5LmluY2x1ZGVzKGFjdGl2ZV93YWxsZXQ/LmxvZ2luaWQpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0cmFkaW5nX2FjY291bnRzOiB7fSwgd2FsbGV0X2FjY291bnRzOiB7IFthY3RpdmVfd2FsbGV0Py5sb2dpbmlkXTogYWN0aXZlX3dhbGxldCB9IH07XG4gICAgfSwgW2FjdGl2ZV93YWxsZXQsIGZyb21fYWNjb3VudD8ubG9naW5pZCwgdHJhZGluZ19hY2NvdW50cywgd2FsbGV0X2FjY291bnRzXSk7XG5cbiAgICAvL3RoaXMgdXNlRWZmZWN0IHBvcHVsYXRlcyBmcm9tL3RvIGFjY291bnRzIHdpdGggdXBkYXRlZCB2YWx1ZXMsIGlmIHRoZXkgd2VyZSB1cGRhdGVkIGluIHRoZSBiYWNrZ3JvdW5kXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2V0RnJvbUFjY291bnQoYWNjID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhY2M/LmxvZ2luaWQgPyB7IC4uLnRyYWRpbmdfYWNjb3VudHMsIC4uLndhbGxldF9hY2NvdW50cyB9W2FjYz8ubG9naW5pZF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBzZXRUb0FjY291bnQoYWNjID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhY2M/LmxvZ2luaWQgPyB7IC4uLnRyYWRpbmdfYWNjb3VudHMsIC4uLndhbGxldF9hY2NvdW50cyB9W2FjYz8ubG9naW5pZF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgIH0sIFtzZXRGcm9tQWNjb3VudCwgc2V0VG9BY2NvdW50LCB0cmFkaW5nX2FjY291bnRzLCB3YWxsZXRfYWNjb3VudHNdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGFjdGl2ZV93YWxsZXQsXG4gICAgICAgIGlzX2FjY291bnRzX2xvYWRpbmcsXG4gICAgICAgIGZyb21fYWNjb3VudCxcbiAgICAgICAgdG9fYWNjb3VudCxcbiAgICAgICAgdG9fYWNjb3VudF9saXN0LFxuICAgICAgICB0cmFuc2Zlcl9hY2NvdW50czogeyB0cmFkaW5nX2FjY291bnRzLCB3YWxsZXRfYWNjb3VudHMgfSxcbiAgICAgICAgc2V0RnJvbUFjY291bnQsXG4gICAgICAgIHNldFRvQWNjb3VudCxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlV2FsbGV0VHJhbnNmZXI7XG4iLCJpbXBvcnQgeyB1c2VGZXRjaCB9IGZyb20gJ0BkZXJpdi9hcGknO1xuLyoqXG4gKiBDdXN0b20gaG9vayB0byBnZXQgc3RhdGVzIGxpc3QgZm9yIGEgcGFydGljdWxhciBjb3VudHJ5LlxuICogQHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIHN0YXRlcyBsaXN0IGFuZCB0aGUgb3B0aW9ucyB0byBtYW5hZ2UgQVBJIHJlc3BvbnNlLlxuICovXG5jb25zdCB1c2VTdGF0ZXNMaXN0ID0gKGNvdW50cnk6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHsgZGF0YSwgLi4ucmVzdCB9ID0gdXNlRmV0Y2goJ3N0YXRlc19saXN0Jywge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRoZSBgc3RhdGVzX2xpc3RgIHR5cGUgZnJvbSBgQGRlcml2L2FwaS10eXBlc2AgaXMgbm90IGNvcnJlY3QuXG4gICAgICAgIC8vIFRoZSB0eXBlIHNob3VsZCBiZSBgc3RyaW5nYCwgYnV0IGl0J3MgYW4gYWxpYXMgdG8gc3RyaW5nIHR5cGUuXG4gICAgICAgIHBheWxvYWQ6IHsgc3RhdGVzX2xpc3Q6IGNvdW50cnkgfSxcbiAgICB9KTtcblxuICAgIHJldHVybiB7IC4uLnJlc3QsIGRhdGE6IGRhdGE/LnN0YXRlc19saXN0ID8/IFtdIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VTdGF0ZXNMaXN0O1xuIiwiaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICdAZGVyaXYvc3RvcmVzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBjbGllbnQgaXMgY29uc2lkZXJlZCBoaWdoIHJpc2sgZm9yIE1UNSB0cmFkaW5nIGJhc2VkIG9uIHRoZWlyIGF2YWlsYWJsZSB0cmFkaW5nIGFjY291bnRzLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBjbGllbnQgaXMgaGlnaCByaXNrIGZvciBNVDUgdHJhZGluZywgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmNvbnN0IHVzZUlzQ2xpZW50SGlnaFJpc2tGb3JNVDUgPSAoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgICBjbGllbnQ6IHsgdHJhZGluZ19wbGF0Zm9ybV9hdmFpbGFibGVfYWNjb3VudHMgfSxcbiAgICB9ID0gdXNlU3RvcmUoKTtcbiAgICBjb25zdCBmaW5hbmNpYWxfYXZhaWxhYmxlX2FjY291bnRzID0gdHJhZGluZ19wbGF0Zm9ybV9hdmFpbGFibGVfYWNjb3VudHMuZmlsdGVyKFxuICAgICAgICBhdmFpbGFibGVfYWNjb3VudCA9PiBhdmFpbGFibGVfYWNjb3VudC5tYXJrZXRfdHlwZSA9PT0gJ2ZpbmFuY2lhbCdcbiAgICApO1xuXG4gICAgY29uc3Qgc3ludGhldGljX2F2YWlsYWJsZV9hY2NvdW50cyA9IHRyYWRpbmdfcGxhdGZvcm1fYXZhaWxhYmxlX2FjY291bnRzLmZpbHRlcihcbiAgICAgICAgYXZhaWxhYmxlX2FjY291bnQgPT4gYXZhaWxhYmxlX2FjY291bnQubWFya2V0X3R5cGUgPT09ICdnYW1pbmcnXG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIGZpbmFuY2lhbF9hdmFpbGFibGVfYWNjb3VudHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgIGZpbmFuY2lhbF9hdmFpbGFibGVfYWNjb3VudHMuZXZlcnkoYWNjID0+IGFjYy5zaG9ydGNvZGUgPT09ICdzdmcnKSAmJlxuICAgICAgICBzeW50aGV0aWNfYXZhaWxhYmxlX2FjY291bnRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBzeW50aGV0aWNfYXZhaWxhYmxlX2FjY291bnRzLmV2ZXJ5KGFjYyA9PiBhY2Muc2hvcnRjb2RlID09PSAnc3ZnJylcbiAgICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlSXNDbGllbnRIaWdoUmlza0Zvck1UNTtcbiIsImltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnQGRlcml2L3N0b3Jlcyc7XG5pbXBvcnQgeyBDRkRfUExBVEZPUk1TIH0gZnJvbSAnQGRlcml2L3NoYXJlZCc7XG5pbXBvcnQgdXNlSXNDbGllbnRIaWdoUmlza0Zvck1UNSBmcm9tICcuL3VzZUlzQ2xpZW50SGlnaFJpc2tGb3JNVDUnO1xuXG5jb25zdCBBQ0NPVU5UX1RZUEVTID0gWydzeW50aGV0aWMnLCAnZmluYW5jaWFsJywgJ2FsbCddIGFzIGNvbnN0O1xuXG4vKipcbiAqIEN1c3RvbSBob29rIHRvIGRldGVybWluZSB3aGV0aGVyIGEgY2xpZW50IGlzIGVsaWdpYmxlIHRvIGdldCBtb3JlIE1UNSBDRkQgYWNjb3VudHMuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNsaWVudCBpcyBlbGlnaWJsZSB0byBnZXQgbW9yZSBNVDUgQ0ZEIGFjY291bnRzLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmNvbnN0IHVzZUNGRENhbkdldE1vcmVNVDVBY2NvdW50cyA9ICgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICAgIGNsaWVudDogeyBpc0VsaWdpYmxlRm9yTW9yZVJlYWxNdDUgfSxcbiAgICAgICAgdHJhZGVyc19odWI6IHsgaXNfZXVfdXNlciwgaXNfcmVhbCB9LFxuICAgICAgICBtb2R1bGVzOiB7IGNmZCB9LFxuICAgIH0gPSB1c2VTdG9yZSgpO1xuICAgIGNvbnN0IGlzX2hpZ2hfcmlza19jbGllbnRfZm9yX210NSA9IHVzZUlzQ2xpZW50SGlnaFJpc2tGb3JNVDUoKTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBjbGllbnQgaGFzIGEgc3BlY2lmaWMgdHlwZSBvZiBNVDUgQ0ZEIGFjY291bnQuXG4gICAgICovXG4gICAgY29uc3QgaGFzQ0ZEQWNjb3VudCA9ICh0eXBlOiB0eXBlb2YgQUNDT1VOVF9UWVBFU1tudW1iZXJdKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRfbGlzdF9rZXlzID0gT2JqZWN0LmtleXMoY2ZkLmN1cnJlbnRfbGlzdCk7XG4gICAgICAgIHJldHVybiBjdXJyZW50X2xpc3Rfa2V5cy5zb21lKGtleSA9PiBrZXkuc3RhcnRzV2l0aChgJHtDRkRfUExBVEZPUk1TLk1UNX0ucmVhbC4ke3R5cGV9YCkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gKFxuICAgICAgICBpc19yZWFsICYmXG4gICAgICAgICFpc19ldV91c2VyICYmXG4gICAgICAgIEFDQ09VTlRfVFlQRVMuc29tZSh0eXBlID0+IGhhc0NGREFjY291bnQodHlwZSkpICYmXG4gICAgICAgIEFDQ09VTlRfVFlQRVMuc29tZSh0eXBlID0+IGlzRWxpZ2libGVGb3JNb3JlUmVhbE10NSh0eXBlKSkgJiZcbiAgICAgICAgIWlzX2hpZ2hfcmlza19jbGllbnRfZm9yX210NVxuICAgICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VDRkRDYW5HZXRNb3JlTVQ1QWNjb3VudHM7XG4iLCJpbXBvcnQgRG9jdW1lbnRVcGxvYWRlciBmcm9tICdAYmluYXJ5LWNvbS9iaW5hcnktZG9jdW1lbnQtdXBsb2FkZXInO1xuaW1wb3J0IHsgdXNlTXV0YXRpb24gfSBmcm9tICdAZGVyaXYvYXBpJztcbmltcG9ydCB7IFdTLCBjb21wcmVzc0ltYWdlRmlsZXMsIHJlYWRGaWxlcyB9IGZyb20gJ0BkZXJpdi9zaGFyZWQnO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZU1lbW8sIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG50eXBlIFRTZXR0aW5nc1BheWxvYWQgPSBQYXJhbWV0ZXJzPFJldHVyblR5cGU8dHlwZW9mIHVzZU11dGF0aW9uPCdkb2N1bWVudF91cGxvYWQnPj5bJ211dGF0ZSddPlswXVsncGF5bG9hZCddO1xuXG50eXBlIFRGaWxlID1cbiAgICB8IFBhcnRpYWw8XG4gICAgICAgICAgVFNldHRpbmdzUGF5bG9hZCAmIHtcbiAgICAgICAgICAgICAgZmlsZW5hbWU6IEZpbGVbJ25hbWUnXTtcbiAgICAgICAgICAgICAgYnVmZmVyOiBGaWxlUmVhZGVyWydyZXN1bHQnXTtcbiAgICAgICAgICAgICAgZG9jdW1lbnRGb3JtYXQ6IHN0cmluZztcbiAgICAgICAgICAgICAgZmlsZV9zaXplOiBGaWxlWydzaXplJ107XG4gICAgICAgICAgfVxuICAgICAgPlxuICAgIHwge1xuICAgICAgICAgIG1lc3NhZ2U6IHN0cmluZztcbiAgICAgIH07XG5cbnR5cGUgVFVwbG9hZGVyUmVzcG9uc2UgPSB7XG4gICAgW2tleTogc3RyaW5nXTogdW5rbm93bjtcbiAgICBtZXNzYWdlPzogc3RyaW5nO1xuICAgIHdhcm5pbmc/OiBzdHJpbmc7XG59O1xuY29uc3QgZmlsZVJlYWRFcnJvck1lc3NhZ2UgPSAoZmlsZW5hbWU6IHN0cmluZykgPT4ge1xuICAgIHJldHVybiBgVW5hYmxlIHRvIHJlYWQgZmlsZSAke2ZpbGVuYW1lfWA7XG59O1xuXG4vKipcbiAqIEN1c3RvbSBob29rIHRvIGhhbmRsZSBmaWxlIHVwbG9hZGluZyB3aXRoIHRoZSBiaW5hcnktZG9jdW1lbnQtdXBsb2FkZXIgcGFja2FnZVxuICovXG5jb25zdCB1c2VGaWxlVXBsb2FkZXIgPSAoKSA9PiB7XG4gICAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTx1bmtub3duPihudWxsKTtcbiAgICBjb25zdCB1cGxvYWRlcl9pbnN0YW5jZSA9IHVzZU1lbW8oKCkgPT4gbmV3IERvY3VtZW50VXBsb2FkZXIoeyBjb25uZWN0aW9uOiBXUy5nZXRTb2NrZXQoKSB9KSwgW10pO1xuXG4gICAgY29uc3QgdXBsb2FkID0gdXNlQ2FsbGJhY2soXG4gICAgICAgIGFzeW5jIChmaWxlczogRmlsZVtdLCBzZXR0aW5ncz86IFRTZXR0aW5nc1BheWxvYWQsIG9uRXJyb3I/OiAoKSA9PiB2b2lkKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWZpbGVzPy5sZW5ndGgpIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ05vIGZpbGVzIHNlbGVjdGVkJykpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8e1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U/OiBzdHJpbmc7XG4gICAgICAgICAgICAgICAgd2FybmluZz86IHN0cmluZztcbiAgICAgICAgICAgICAgICBba2V5OiBzdHJpbmddOiB1bmtub3duO1xuICAgICAgICAgICAgfT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBpc19hbnlfZmlsZV9lcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBmaWxlX2Vycm9yOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wcmVzc2VkX2ZpbGVzOiBCbG9iW10gPSBhd2FpdCBjb21wcmVzc0ltYWdlRmlsZXMoZmlsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkX2ZpbGVzOiBURmlsZVtdID0gYXdhaXQgcmVhZEZpbGVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXByZXNzZWRfZmlsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVJlYWRFcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MgPz8ge31cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWRfZmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZSAmJiAnbWVzc2FnZScgaW4gZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc19hbnlfZmlsZV9lcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVfZXJyb3IgPSBmaWxlLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChmaWxlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzX2FueV9maWxlX2Vycm9yIHx8ICFwcm9jZXNzZWRfZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcj8uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoZmlsZV9lcnJvciA/PyAnU29tZXRoaW5nIHdlbnQgd3JvbmchJykpOyAvLyBkb24ndCBzdGFydCBzdWJtaXR0aW5nIGZpbGVzIHVudGlsIGFsbCBmcm9udC1lbmQgdmFsaWRhdGlvbiBjaGVja3MgcGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZW5kIGZpbGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZTogVFVwbG9hZGVyUmVzcG9uc2UgPSBhd2FpdCB1cGxvYWRlcl9pbnN0YW5jZS51cGxvYWQocHJvY2Vzc2VkX2ZpbGVzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgW3VwbG9hZGVyX2luc3RhbmNlXVxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogRXJyb3IgbWVzc2FnZSBmcm9tIHRoZSBmaWxlIHVwbG9hZGVyXG4gICAgICAgICAqL1xuICAgICAgICBlcnJvcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwbG9hZHMgYSBmaWxlIHRvIHRoZSBzZXJ2ZXIgd2l0aCB0aGUgYmluYXJ5LWRvY3VtZW50LXVwbG9hZGVyIHBhY2thZ2UgYWZ0ZXIgY29tcHJlc3NpbmcgYW5kIHJlYWRpbmcgdGhlIGZpbGUgd2l0aCBtZXRhIGRhdGFcbiAgICAgICAgICovXG4gICAgICAgIHVwbG9hZCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc3RhbmNlIG9mIHRoZSBiaW5hcnktZG9jdW1lbnQtdXBsb2FkZXJcbiAgICAgICAgICovXG4gICAgICAgIHVwbG9hZGVyX2luc3RhbmNlLFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VGaWxlVXBsb2FkZXI7XG4iLCJleHBvcnQgeyBkZWZhdWx0IGFzIHVzZUFjY291bnRUcmFuc2ZlclZpc2libGUgfSBmcm9tICcuL3VzZUFjY291bnRUcmFuc2ZlclZpc2libGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VBY3RpdmVXYWxsZXQgfSBmcm9tICcuL3VzZUFjdGl2ZVdhbGxldCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZUF1dGhvcml6ZSB9IGZyb20gJy4vdXNlQXV0aG9yaXplJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlQXZhaWxhYmxlV2FsbGV0cyB9IGZyb20gJy4vdXNlQXZhaWxhYmxlV2FsbGV0cyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZUNGREFjY291bnRzIH0gZnJvbSAnLi91c2VDRkRBY2NvdW50cyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZUNGREFsbEFjY291bnRzIH0gZnJvbSAnLi91c2VDRkRBbGxBY2NvdW50cyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZUNGRERlbW9BY2NvdW50cyB9IGZyb20gJy4vdXNlQ0ZERGVtb0FjY291bnRzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlQ0ZEUmVhbEFjY291bnRzIH0gZnJvbSAnLi91c2VDRkRSZWFsQWNjb3VudHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VDYXNoaWVyTG9ja2VkIH0gZnJvbSAnLi91c2VDYXNoaWVyTG9ja2VkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlQ29udGVudEZsYWcgfSBmcm9tICcuL3VzZUNvbnRlbnRGbGFnJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlQ291bnRkb3duIH0gZnJvbSAnLi91c2VDb3VudGRvd24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VDcnlwdG9UcmFuc2FjdGlvbnMgfSBmcm9tICcuL3VzZUNyeXB0b1RyYW5zYWN0aW9ucyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZUN1cnJlbmN5Q29uZmlnIH0gZnJvbSAnLi91c2VDdXJyZW5jeUNvbmZpZyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZUN1cnJlbnRBY2NvdW50RGV0YWlscyB9IGZyb20gJy4vdXNlQ3VycmVudEFjY291bnREZXRhaWxzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlQ3VycmVudEN1cnJlbmN5Q29uZmlnIH0gZnJvbSAnLi91c2VDdXJyZW50Q3VycmVuY3lDb25maWcnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VEZXBvc2l0Q3J5cHRvQWRkcmVzcyB9IGZyb20gJy4vdXNlRGVwb3NpdENyeXB0b0FkZHJlc3MnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VEZXBvc2l0RmlhdEFkZHJlc3MgfSBmcm9tICcuL3VzZURlcG9zaXRGaWF0QWRkcmVzcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZURlcG9zaXRMb2NrZWQgfSBmcm9tICcuL3VzZURlcG9zaXRMb2NrZWQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VFeGNoYW5nZVJhdGUgfSBmcm9tICcuL3VzZUV4Y2hhbmdlUmF0ZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZUV4aXN0aW5nQ0ZEQWNjb3VudHMgfSBmcm9tICcuL3VzZUV4aXN0aW5nQ0ZEQWNjb3VudHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VGZWF0dXJlRmxhZ3MgfSBmcm9tICcuL3VzZUZlYXR1cmVGbGFncyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZUZpYXRBY2NvdW50TGlzdCB9IGZyb20gJy4vdXNlRmlhdEFjY291bnRMaXN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlSGFzQWN0aXZlUmVhbEFjY291bnQgfSBmcm9tICcuL3VzZUhhc0FjdGl2ZVJlYWxBY2NvdW50JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlSGFzQ3J5cHRvQ3VycmVuY3kgfSBmcm9tICcuL3VzZUhhc0NyeXB0b0N1cnJlbmN5JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlSGFzRmlhdEN1cnJlbmN5IH0gZnJvbSAnLi91c2VIYXNGaWF0Q3VycmVuY3knO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VIYXNNYWx0YUludmVzdEFjY291bnQgfSBmcm9tICcuL3VzZUhhc01hbHRhSW52ZXN0QWNjb3VudCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZUhhc1AyUFN1cHBvcnRlZEN1cnJlbmNpZXMgfSBmcm9tICcuL3VzZUhhc1AyUFN1cHBvcnRlZEN1cnJlbmNpZXMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VIYXNTZXRDdXJyZW5jeSB9IGZyb20gJy4vdXNlSGFzU2V0Q3VycmVuY3knO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VIYXNTdmdBY2NvdW50IH0gZnJvbSAnLi91c2VIYXNTdmdBY2NvdW50JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlSGFzU3dhcEZyZWVBY2NvdW50IH0gZnJvbSAnLi91c2VIYXNTd2FwRnJlZUFjY291bnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VIYXNVU0RDdXJyZW5jeSB9IGZyb20gJy4vdXNlSGFzVVNEQ3VycmVuY3knO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VJbnB1dEFUTUZvcm1hdHRlciB9IGZyb20gJy4vdXNlSW5wdXRBVE1Gb3JtYXR0ZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VJbnB1dERlY2ltYWxGb3JtYXR0ZXIgfSBmcm9tICcuL3VzZUlucHV0RGVjaW1hbEZvcm1hdHRlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZUlzQWNjb3VudFN0YXR1c1ByZXNlbnQgfSBmcm9tICcuL3VzZUlzQWNjb3VudFN0YXR1c1ByZXNlbnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VJc1AyUEVuYWJsZWQgfSBmcm9tICcuL3VzZUlzUDJQRW5hYmxlZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZUlzUmVhbEFjY291bnROZWVkZWRGb3JDYXNoaWVyIH0gZnJvbSAnLi91c2VJc1JlYWxBY2NvdW50TmVlZGVkRm9yQ2FzaGllcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZUlzU3lzdGVtTWFpbnRlbmFuY2UgfSBmcm9tICcuL3VzZUlzU3lzdGVtTWFpbnRlbmFuY2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VMb2NhbFN0b3JhZ2VEYXRhIH0gZnJvbSAnLi91c2VMb2NhbFN0b3JhZ2VEYXRhJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlTmVlZEF1dGhlbnRpY2F0aW9uIH0gZnJvbSAnLi91c2VOZWVkQXV0aGVudGljYXRpb24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VOZWVkRmluYW5jaWFsQXNzZXNzbWVudCB9IGZyb20gJy4vdXNlTmVlZEZpbmFuY2lhbEFzc2Vzc21lbnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VOZWVkUE9JIH0gZnJvbSAnLi91c2VOZWVkUE9JJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlTmVlZFROQyB9IGZyb20gJy4vdXNlTmVlZFROQyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZU9ucmFtcFZpc2libGUgfSBmcm9tICcuL3VzZU9ucmFtcFZpc2libGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VQMlBBZHZlcnRpc2VyUGF5bWVudE1ldGhvZHMgfSBmcm9tICcuL3VzZVAyUEFkdmVydGlzZXJQYXltZW50TWV0aG9kcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZVAyUEFkdmVydExpc3QgfSBmcm9tICcuL3VzZVAyUEFkdmVydExpc3QnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VQMlBOb3RpZmljYXRpb25Db3VudCB9IGZyb20gJy4vdXNlUDJQTm90aWZpY2F0aW9uQ291bnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VQMlBQYXltZW50TWV0aG9kcyB9IGZyb20gJy4vdXNlUDJQUGF5bWVudE1ldGhvZHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VQYXltZW50QWdlbnRMaXN0IH0gZnJvbSAnLi91c2VQYXltZW50QWdlbnRMaXN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlUGF5bWVudEFnZW50VHJhbnNmZXJWaXNpYmxlIH0gZnJvbSAnLi91c2VQYXltZW50QWdlbnRUcmFuc2ZlclZpc2libGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VQbGF0Zm9ybUFjY291bnRzIH0gZnJvbSAnLi91c2VQbGF0Zm9ybUFjY291bnRzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlUGxhdGZvcm1EZW1vQWNjb3VudCB9IGZyb20gJy4vdXNlUGxhdGZvcm1EZW1vQWNjb3VudCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZVBsYXRmb3JtUmVhbEFjY291bnRzIH0gZnJvbSAnLi91c2VQbGF0Zm9ybVJlYWxBY2NvdW50cyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZVJlYWxTVFBBY2NvdW50IH0gZnJvbSAnLi91c2VSZWFsU1RQQWNjb3VudCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZVRvdGFsQWNjb3VudEJhbGFuY2UgfSBmcm9tICcuL3VzZVRvdGFsQWNjb3VudEJhbGFuY2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VUcmFuc2ZlckJldHdlZW5BY2NvdW50cyB9IGZyb20gJy4vdXNlVHJhbnNmZXJCZXR3ZWVuQWNjb3VudHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VWZXJpZnlFbWFpbCB9IGZyb20gJy4vdXNlVmVyaWZ5RW1haWwnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1c2VXYWxsZXRNaWdyYXRpb24gfSBmcm9tICcuL3VzZVdhbGxldE1pZ3JhdGlvbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZVdhbGxldFRyYW5zYWN0aW9ucyB9IGZyb20gJy4vdXNlV2FsbGV0VHJhbnNhY3Rpb25zJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlV2FsbGV0VHJhbnNmZXIgfSBmcm9tICcuL3VzZVdhbGxldFRyYW5zZmVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlV2FsbGV0c0xpc3QgfSBmcm9tICcuL3VzZVdhbGxldHNMaXN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlU3RhdGVzTGlzdCB9IGZyb20gJy4vdXNlU3RhdGVzTGlzdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZVAyUENvbmZpZyB9IGZyb20gJy4vdXNlUDJQQ29uZmlnJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlSXNDbGllbnRIaWdoUmlza0Zvck1UNSB9IGZyb20gJy4vdXNlSXNDbGllbnRIaWdoUmlza0Zvck1UNSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZUNGRENhbkdldE1vcmVNVDVBY2NvdW50cyB9IGZyb20gJy4vdXNlQ0ZEQ2FuR2V0TW9yZU1UNUFjY291bnRzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlRmlsZVVwbG9hZGVyIH0gZnJvbSAnLi91c2VGaWxlVXBsb2FkZXInO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEZpZWxkSW5wdXRQcm9wcywgRm9ybWlrSGVscGVycywgRm9ybWlrU3RhdGUsIEZpZWxkIH0gZnJvbSAnZm9ybWlrJztcbmltcG9ydCB7IElucHV0IH0gZnJvbSAnQGRlcml2L2NvbXBvbmVudHMnO1xuXG50eXBlIEZvcm1JbnB1dEZpZWxkUHJvcHMgPSB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIG9wdGlvbmFsPzogYm9vbGVhbjtcbiAgICB3YXJuPzogc3RyaW5nO1xufSAmIFJlYWN0LkNvbXBvbmVudFByb3BzPHR5cGVvZiBJbnB1dD47XG5cbnR5cGUgVEZvcm1JbnB1dEZpZWxkSGVscGVyczxUPiA9IHtcbiAgICBmaWVsZDogRmllbGRJbnB1dFByb3BzPHN0cmluZz47XG4gICAgZm9ybTogRm9ybWlrSGVscGVyczxUPiAmIEZvcm1pa1N0YXRlPFQ+O1xufTtcblxuLyoqXG4gKiBGb3JtSW5wdXRGaWVsZCBpcyBhIHdyYXBwZXIgYXJvdW5kIElucHV0IHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBGb3JtaWsuXG4gKiBAbmFtZSBGb3JtSW5wdXRGaWVsZFxuICogQHBhcmFtIG5hbWUgLSBOYW1lIG9mIHRoZSBmaWVsZFxuICogQHBhcmFtIFtvcHRpb25hbF0gLSBXaGV0aGVyIHRoZSBmaWVsZCBpcyBvcHRpb25hbFxuICogQHBhcmFtIFt3YXJuXSAtIERpc3BsYXkgYSB3YXJuaW5nIG1lc3NhZ2VcbiAqIEBwYXJhbSBbcHJvcHNdIC0gT3RoZXIgcHJvcHMgdG8gcGFzcyB0byBJbnB1dFxuICogQHJldHVybnMgUmVhY3ROb2RlXG4gKi9cbmNvbnN0IEZvcm1JbnB1dEZpZWxkID0gKHsgbmFtZSwgd2FybiwgLi4ucmVzdCB9OiBGb3JtSW5wdXRGaWVsZFByb3BzKSA9PiAoXG4gICAgPEZpZWxkIG5hbWU9e25hbWV9PlxuICAgICAgICB7KHsgZmllbGQsIGZvcm06IHsgZXJyb3JzLCB0b3VjaGVkIH0gfTogVEZvcm1JbnB1dEZpZWxkSGVscGVyczxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+PikgPT4gKFxuICAgICAgICAgICAgPElucHV0XG4gICAgICAgICAgICAgICAgey4uLmZpZWxkfVxuICAgICAgICAgICAgICAgIHsuLi5yZXN0fVxuICAgICAgICAgICAgICAgIHR5cGU9J3RleHQnXG4gICAgICAgICAgICAgICAgYXV0b0NvbXBsZXRlPSdvZmYnXG4gICAgICAgICAgICAgICAgZXJyb3I9e3RvdWNoZWRbZmllbGQubmFtZV0gJiYgZXJyb3JzW2ZpZWxkLm5hbWVdID8gZXJyb3JzW2ZpZWxkLm5hbWVdIDogdW5kZWZpbmVkfVxuICAgICAgICAgICAgICAgIHdhcm49e3dhcm59XG4gICAgICAgICAgICAvPlxuICAgICAgICApfVxuICAgIDwvRmllbGQ+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBGb3JtSW5wdXRGaWVsZDtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBGaWVsZCwgRmllbGRQcm9wcyB9IGZyb20gJ2Zvcm1payc7XG5pbXBvcnQgeyBEYXRlT2ZCaXJ0aFBpY2tlciB9IGZyb20gJ0BkZXJpdi9jb21wb25lbnRzJztcbmltcG9ydCB7IHRvTW9tZW50IH0gZnJvbSAnQGRlcml2L3NoYXJlZCc7XG5cbnR5cGUgVERhdGVPZkJpcnRoRmllbGRQcm9wcyA9IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgcG9ydGFsX2lkOiBzdHJpbmc7XG59ICYgT21pdDxSZWFjdC5Db21wb25lbnRQcm9wczx0eXBlb2YgRGF0ZU9mQmlydGhQaWNrZXI+LCAnb25CbHVyJyB8ICdvbkNoYW5nZScgfCAnZXJyb3InPjtcblxuLyoqXG4gKiBEYXRlT2ZCaXJ0aEZpZWxkIGlzIGEgd3JhcHBlciBhcm91bmQgRGF0ZU9mQmlydGhQaWNrZXIgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIEZvcm1pay5cbiAqIEBuYW1lIERhdGVPZkJpcnRoRmllbGRcbiAqIEBwYXJhbSBuYW1lIC0gTmFtZSBvZiB0aGUgZmllbGRcbiAqIEBwYXJhbSBwb3J0YWxfaWQgLSBQb3J0YWwgSURcbiAqIEBwYXJhbSBbcHJvcHNdIC0gT3RoZXIgcHJvcHMgdG8gcGFzcyB0byBEYXRlT2ZCaXJ0aFBpY2tlclxuICogQHJldHVybnMge1JlYWN0LlJlYWN0Tm9kZX1cbiAqL1xuY29uc3QgRGF0ZU9mQmlydGhGaWVsZCA9ICh7IG5hbWUsIHBvcnRhbF9pZCwgLi4ucmVzdCB9OiBURGF0ZU9mQmlydGhGaWVsZFByb3BzKSA9PiAoXG4gICAgPEZpZWxkIG5hbWU9e25hbWV9PlxuICAgICAgICB7KHsgZmllbGQsIGZvcm06IHsgc2V0RmllbGRWYWx1ZSB9LCBtZXRhOiB7IGVycm9yLCB0b3VjaGVkIH0gfTogRmllbGRQcm9wczxzdHJpbmcgfCBtb21lbnQuTW9tZW50PikgPT4gKFxuICAgICAgICAgICAgPERhdGVPZkJpcnRoUGlja2VyXG4gICAgICAgICAgICAgICAgey4uLnJlc3R9XG4gICAgICAgICAgICAgICAgey4uLmZpZWxkfVxuICAgICAgICAgICAgICAgIGVycm9yPXt0b3VjaGVkID8gZXJyb3IgOiB1bmRlZmluZWR9XG4gICAgICAgICAgICAgICAgbmFtZT17bmFtZX1cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17KHsgdGFyZ2V0IH06IGFueSkgPT5cbiAgICAgICAgICAgICAgICAgICAgc2V0RmllbGRWYWx1ZShuYW1lLCB0YXJnZXQ/LnZhbHVlID8gdG9Nb21lbnQodGFyZ2V0LnZhbHVlKS5mb3JtYXQoJ1lZWVktTU0tREQnKSA6ICcnLCB0cnVlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3J0YWxfaWQ9e3BvcnRhbF9pZH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICl9XG4gICAgPC9GaWVsZD5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IERhdGVPZkJpcnRoRmllbGQ7XG4iLCJpbXBvcnQgRm9ybUlucHV0RmllbGQgZnJvbSAnLi9mb3JtLWlucHV0LWZpZWxkJztcbmltcG9ydCBEYXRlT2ZCaXJ0aEZpZWxkIGZyb20gJy4vZGF0ZS1vZi1iaXJ0aC1maWVsZCc7XG5cbmV4cG9ydCB7IEZvcm1JbnB1dEZpZWxkLCBEYXRlT2ZCaXJ0aEZpZWxkIH07XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlRm9ybWlrQ29udGV4dCB9IGZyb20gJ2Zvcm1payc7XG5cbnR5cGUgVFNjcm9sbFRvRmllbGRXaXRoRXJyb3IgPSB7XG4gICAgZmllbGRzX3RvX3Njcm9sbF90b3A/OiBzdHJpbmdbXTtcbiAgICBmaWVsZHNfdG9fc2Nyb2xsX2JvdHRvbT86IHN0cmluZ1tdO1xuICAgIHNob3VsZF9yZWNvbGxlY3RfaW5wdXRzX25hbWVzPzogYm9vbGVhbjtcbn07XG5cbmNvbnN0IFNjcm9sbFRvRmllbGRXaXRoRXJyb3IgPSAoe1xuICAgIGZpZWxkc190b19zY3JvbGxfdG9wLFxuICAgIGZpZWxkc190b19zY3JvbGxfYm90dG9tLFxuICAgIHNob3VsZF9yZWNvbGxlY3RfaW5wdXRzX25hbWVzID0gZmFsc2UsXG59OiBUU2Nyb2xsVG9GaWVsZFdpdGhFcnJvcikgPT4ge1xuICAgIGNvbnN0IFthbGxfcGFnZV9pbnB1dHNfbmFtZXMsIHNldEFsbFBhZ2VJbnB1dHNOYW1lc10gPSBSZWFjdC51c2VTdGF0ZTxzdHJpbmdbXT4oW10pO1xuICAgIGNvbnN0IHsgZXJyb3JzLCBpc1N1Ym1pdHRpbmcgfSA9IHVzZUZvcm1pa0NvbnRleHQoKTtcbiAgICBjb25zdCBzY3JvbGxUb0VsZW1lbnQgPSAoZWxlbWVudF9uYW1lOiBzdHJpbmcsIGJsb2NrOiBTY3JvbGxMb2dpY2FsUG9zaXRpb24gPSAnY2VudGVyJykgPT4ge1xuICAgICAgICBpZiAoIWVsZW1lbnRfbmFtZSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtuYW1lPVwiJHtlbGVtZW50X25hbWV9XCJdYCkgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICAgICAgKGVsPy5wYXJlbnRFbGVtZW50ID8/IGVsKT8uc2Nyb2xsSW50b1ZpZXcoeyBiZWhhdmlvcjogJ3Ntb290aCcsIGJsb2NrIH0pO1xuICAgICAgICBpZiAoZWw/LnR5cGUgIT09ICdyYWRpbycpIGVsPy5mb2N1cygpO1xuICAgIH07XG5cbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQsIHNlbGVjdCcpXSBhcyBIVE1MSW5wdXRFbGVtZW50W107XG4gICAgICAgIHNldEFsbFBhZ2VJbnB1dHNOYW1lcyhpbnB1dHMubWFwKGlucHV0ID0+IGlucHV0Lm5hbWUpKTtcbiAgICB9LCBbc2hvdWxkX3JlY29sbGVjdF9pbnB1dHNfbmFtZXNdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50X2Vycm9yX2ZpZWxkX25hbWUgPVxuICAgICAgICAgICAgYWxsX3BhZ2VfaW5wdXRzX25hbWVzLmZpbmQoaW5wdXRfbmFtZSA9PiBPYmplY3QuaGFzT3duKGVycm9ycywgaW5wdXRfbmFtZSkpIHx8ICcnO1xuXG4gICAgICAgIGlmIChmaWVsZHNfdG9fc2Nyb2xsX3RvcD8uaW5jbHVkZXMoY3VycmVudF9lcnJvcl9maWVsZF9uYW1lKSkge1xuICAgICAgICAgICAgc2Nyb2xsVG9FbGVtZW50KGN1cnJlbnRfZXJyb3JfZmllbGRfbmFtZSwgJ3N0YXJ0Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGRzX3RvX3Njcm9sbF9ib3R0b20/LmluY2x1ZGVzKGN1cnJlbnRfZXJyb3JfZmllbGRfbmFtZSkpIHtcbiAgICAgICAgICAgIHNjcm9sbFRvRWxlbWVudChjdXJyZW50X2Vycm9yX2ZpZWxkX25hbWUsICdlbmQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjcm9sbFRvRWxlbWVudChjdXJyZW50X2Vycm9yX2ZpZWxkX25hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbaXNTdWJtaXR0aW5nXSk7XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNjcm9sbFRvRmllbGRXaXRoRXJyb3I7XG4iLCJpbXBvcnQgeyBGb3JtaWtFcnJvcnMsIEZvcm1pa1ZhbHVlcyB9IGZyb20gJ2Zvcm1payc7XG5cbi8qKlxuICogVGFrZXMgdmFsaWRhdGlvbiByZXN1bHQgb2YgYSBmb3JtLCBzZXRzIHdhcm5pbmdzIG9uIGNvbXBvbmVudCdzIHN0YXRlIGFuZCBwYXNzIGVycm9ycyBkb3duIHRvIHRoZSBmb3JtXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyAtIG9iamVjdCBjb250YWluaW5nIGZvcm0gZmllbGQgdmFsdWVzIGFuZCB2YWxpZGF0aW9uc1xuICogQHJldHVybiB7b2JqZWN0fSBvYmplY3QgY29udGFpbmluZyBlcnJvcnMgYW5kIHdhcm5pbmdzXG4gKi9cbmZ1bmN0aW9uIHNwbGl0VmFsaWRhdGlvblJlc3VsdFR5cGVzKHZhbHVlczogRm9ybWlrVmFsdWVzKSB7XG4gICAgY29uc3Qgd2FybmluZ3M6IEZvcm1pa0Vycm9yczxGb3JtaWtWYWx1ZXM+ID0ge307XG4gICAgY29uc3QgZXJyb3JzOiBGb3JtaWtFcnJvcnM8Rm9ybWlrVmFsdWVzPiA9IHt9O1xuICAgIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaCgoZmllbGQ6IHN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVzW2ZpZWxkXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgIGlmIChpdGVtWzBdID09PSAnd2FybicpIHtcbiAgICAgICAgICAgICAgICB3YXJuaW5nc1tmaWVsZF0gPSBpdGVtWzFdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtWzBdID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzW2ZpZWxkXSA9IGl0ZW1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4geyB3YXJuaW5ncywgZXJyb3JzIH07XG59XG5cbmV4cG9ydCB7IHNwbGl0VmFsaWRhdGlvblJlc3VsdFR5cGVzIH07XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBGb3JtaWssIEZpZWxkLCBGb3JtaWtWYWx1ZXMsIEZvcm1pa0hlbHBlcnMsIEZvcm1pa0hhbmRsZXJzLCBGb3JtaWtTdGF0ZSB9IGZyb20gJ2Zvcm1payc7XG5pbXBvcnQgeyBTdGF0ZXNMaXN0IH0gZnJvbSAnQGRlcml2L2FwaS10eXBlcyc7XG5pbXBvcnQge1xuICAgIEF1dG9jb21wbGV0ZSxcbiAgICBBdXRvSGVpZ2h0V3JhcHBlcixcbiAgICBEZXNrdG9wV3JhcHBlcixcbiAgICBEaXYxMDB2aENvbnRhaW5lcixcbiAgICBGb3JtU3VibWl0QnV0dG9uLFxuICAgIExvYWRpbmcsXG4gICAgTW9iaWxlV3JhcHBlcixcbiAgICBNb2RhbCxcbiAgICBTZWxlY3ROYXRpdmUsXG4gICAgVGV4dCxcbiAgICBUaGVtZWRTY3JvbGxiYXJzLFxufSBmcm9tICdAZGVyaXYvY29tcG9uZW50cyc7XG5pbXBvcnQgeyB1c2VTdGF0ZXNMaXN0IH0gZnJvbSAnQGRlcml2L2hvb2tzJztcbmltcG9ydCB7IGdldExvY2F0aW9uIH0gZnJvbSAnQGRlcml2L3NoYXJlZCc7XG5pbXBvcnQgeyBvYnNlcnZlciwgdXNlU3RvcmUgfSBmcm9tICdAZGVyaXYvc3RvcmVzJztcbmltcG9ydCB7IGxvY2FsaXplLCBMb2NhbGl6ZSB9IGZyb20gJ0BkZXJpdi90cmFuc2xhdGlvbnMnO1xuaW1wb3J0IHsgRm9ybUlucHV0RmllbGQgfSBmcm9tICcuLi9mb3Jtcy9mb3JtLWZpZWxkcyc7XG5pbXBvcnQgU2Nyb2xsVG9GaWVsZFdpdGhFcnJvciBmcm9tICcuLi9mb3Jtcy9zY3JvbGwtdG8tZmllbGQtd2l0aC1lcnJvcic7XG5pbXBvcnQgeyBzcGxpdFZhbGlkYXRpb25SZXN1bHRUeXBlcyB9IGZyb20gJy4uL3JlYWwtYWNjb3VudC1zaWdudXAvaGVscGVycy91dGlscyc7XG5cbmV4cG9ydCB0eXBlIFRBZGRyZXNzRGV0YWlsRm9ybVByb3BzID0ge1xuICAgIGFkZHJlc3NfbGluZV8xOiBzdHJpbmc7XG4gICAgYWRkcmVzc19saW5lXzI/OiBzdHJpbmc7XG4gICAgYWRkcmVzc19jaXR5OiBzdHJpbmc7XG4gICAgYWRkcmVzc19zdGF0ZT86IHN0cmluZztcbiAgICBhZGRyZXNzX3Bvc3Rjb2RlPzogc3RyaW5nO1xufTtcblxudHlwZSBUQWRkcmVzc0RldGFpbHMgPSB7XG4gICAgZGlzYWJsZWRfaXRlbXM6IHN0cmluZ1tdO1xuICAgIHN0YXRlc19saXN0OiBTdGF0ZXNMaXN0O1xuICAgIGdldEN1cnJlbnRTdGVwPzogKCkgPT4gbnVtYmVyO1xuICAgIG9uU2F2ZTogKGN1cnJlbnRfc3RlcDogbnVtYmVyLCB2YWx1ZXM6IFRBZGRyZXNzRGV0YWlsRm9ybVByb3BzKSA9PiB2b2lkO1xuICAgIG9uQ2FuY2VsOiAoY3VycmVudF9zdGVwOiBudW1iZXIsIGdvVG9QcmV2aW91c1N0ZXA6ICgpID0+IHZvaWQpID0+IHZvaWQ7XG4gICAgZ29Ub05leHRTdGVwOiAoKSA9PiB2b2lkO1xuICAgIGdvVG9QcmV2aW91c1N0ZXA6ICgpID0+IHZvaWQ7XG4gICAgdmFsaWRhdGU6ICh2YWx1ZXM6IFRBZGRyZXNzRGV0YWlsRm9ybVByb3BzKSA9PiBUQWRkcmVzc0RldGFpbEZvcm1Qcm9wcztcbiAgICBvblN1Ym1pdDogKFxuICAgICAgICBjdXJyZW50X3N0ZXA6IG51bWJlciB8IG51bGwsXG4gICAgICAgIHZhbHVlczogVEFkZHJlc3NEZXRhaWxGb3JtUHJvcHMsXG4gICAgICAgIGFjdGlvbjogKGlzU3VibWl0dGluZzogYm9vbGVhbikgPT4gdm9pZCxcbiAgICAgICAgbmV4dF9zdGVwOiAoKSA9PiB2b2lkXG4gICAgKSA9PiB2b2lkO1xuICAgIGlzX2diX3Jlc2lkZW5jZTogYm9vbGVhbiB8IHN0cmluZztcbiAgICB2YWx1ZTogVEFkZHJlc3NEZXRhaWxGb3JtUHJvcHM7XG4gICAgaGFzX3JlYWxfYWNjb3VudDogYm9vbGVhbjtcbn07XG5cbnR5cGUgVEF1dG9Db21wbGV0ZSA9IHtcbiAgICB2YWx1ZTogYm9vbGVhbjtcbiAgICB0ZXh0OiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIENvbXBvbmVudCB0byBkaXNwbGF5IGFkZHJlc3MgZGV0YWlscyBmb3JtXG4gKiBAbmFtZSBBZGRyZXNzRGV0YWlsc1xuICogQHBhcmFtIGdldEN1cnJlbnRTdGVwIC0gZnVuY3Rpb24gdG8gZ2V0IGN1cnJlbnQgc3RlcFxuICogQHBhcmFtIHN0YXRlc19saXN0IC0gYXJyYXkgb2Ygc3RhdGVzIGZvciB0aGUgc2VsZWN0ZWQgcmVzaWRlbmNlIGNvdW50cnlcbiAqIEBwYXJhbSBvblNhdmUgLSBmdW5jdGlvbiB0byBzYXZlIGZvcm0gdmFsdWVzXG4gKiBAcGFyYW0gb25DYW5jZWwgLSBmdW5jdGlvbiB0byBjYW5jZWwgZm9ybSB2YWx1ZXNcbiAqIEBwYXJhbSBnb1RvTmV4dFN0ZXAgLSBmdW5jdGlvbiB0byBnbyB0byBuZXh0IHN0ZXBcbiAqIEBwYXJhbSBnb1RvUHJldmlvdXNTdGVwIC0gZnVuY3Rpb24gdG8gZ28gdG8gcHJldmlvdXMgc3RlcFxuICogQHBhcmFtIHZhbGlkYXRlIC0gZnVuY3Rpb24gdG8gdmFsaWRhdGUgZm9ybSB2YWx1ZXNcbiAqIEBwYXJhbSBvblN1Ym1pdCAtIGZ1bmN0aW9uIHRvIHN1Ym1pdCBmb3JtIHZhbHVlc1xuICogQHBhcmFtIGlzX2diX3Jlc2lkZW5jZSAtIGlzIHJlc2lkZW5jZSBHcmVhdCBCcml0YW5cbiAqIEBwYXJhbSB2YWx1ZSAtIGZvcm0gdmFsdWVzXG4gKiBAcGFyYW0gZGlzYWJsZWRfaXRlbXMgLSBhcnJheSBvZiBkaXNhYmxlZCBmaWVsZHNcbiAqIEBwYXJhbSBoYXNfcmVhbF9hY2NvdW50IC0gaGFzIHJlYWwgYWNjb3VudFxuICogQHJldHVybnMgcmVhY3Qgbm9kZVxuICovXG5jb25zdCBBZGRyZXNzRGV0YWlscyA9IG9ic2VydmVyKFxuICAgICh7XG4gICAgICAgIGdldEN1cnJlbnRTdGVwLFxuICAgICAgICBvblNhdmUsXG4gICAgICAgIG9uQ2FuY2VsLFxuICAgICAgICBnb1RvTmV4dFN0ZXAsXG4gICAgICAgIGdvVG9QcmV2aW91c1N0ZXAsXG4gICAgICAgIHZhbGlkYXRlLFxuICAgICAgICBvblN1Ym1pdCxcbiAgICAgICAgaXNfZ2JfcmVzaWRlbmNlLFxuICAgICAgICBkaXNhYmxlZF9pdGVtcyxcbiAgICAgICAgaGFzX3JlYWxfYWNjb3VudCxcbiAgICAgICAgLi4ucHJvcHNcbiAgICB9OiBUQWRkcmVzc0RldGFpbHMpID0+IHtcbiAgICAgICAgY29uc3QgW2FkZHJlc3Nfc3RhdGVfdG9fZGlzcGxheSwgc2V0QWRkcmVzc1N0YXRlVG9EaXNwbGF5XSA9IFJlYWN0LnVzZVN0YXRlKCcnKTtcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB1aSxcbiAgICAgICAgICAgIGNsaWVudDogeyByZXNpZGVuY2UgfSxcbiAgICAgICAgfSA9IHVzZVN0b3JlKCk7XG5cbiAgICAgICAgY29uc3QgeyBpc19kZXNrdG9wLCBpc19tb2JpbGUgfSA9IHVpO1xuICAgICAgICBjb25zdCB7IGRhdGE6IHN0YXRlc19saXN0LCBpc0ZldGNoZWQgfSA9IHVzZVN0YXRlc0xpc3QocmVzaWRlbmNlKTtcblxuICAgICAgICBjb25zdCBoYW5kbGVDYW5jZWwgPSAodmFsdWVzOiBUQWRkcmVzc0RldGFpbEZvcm1Qcm9wcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudF9zdGVwID0gKGdldEN1cnJlbnRTdGVwPy4oKSB8fCAxKSAtIDE7XG4gICAgICAgICAgICBvblNhdmUoY3VycmVudF9zdGVwLCB2YWx1ZXMpO1xuICAgICAgICAgICAgb25DYW5jZWwoY3VycmVudF9zdGVwLCBnb1RvUHJldmlvdXNTdGVwKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBoYW5kbGVWYWxpZGF0ZSA9ICh2YWx1ZXM6IFRBZGRyZXNzRGV0YWlsRm9ybVByb3BzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGVycm9ycyB9ID0gc3BsaXRWYWxpZGF0aW9uUmVzdWx0VHlwZXModmFsaWRhdGUodmFsdWVzKSk7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGhhbmRsZVN1Ym1pdERhdGEgPSAodmFsdWVzOiBUQWRkcmVzc0RldGFpbEZvcm1Qcm9wcywgYWN0aW9uczogRm9ybWlrSGVscGVyczxUQWRkcmVzc0RldGFpbEZvcm1Qcm9wcz4pID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMuYWRkcmVzc19zdGF0ZSAmJiBzdGF0ZXNfbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMuYWRkcmVzc19zdGF0ZSA9IGFkZHJlc3Nfc3RhdGVfdG9fZGlzcGxheVxuICAgICAgICAgICAgICAgICAgICA/IGdldExvY2F0aW9uKHN0YXRlc19saXN0LCBhZGRyZXNzX3N0YXRlX3RvX2Rpc3BsYXksICd2YWx1ZScpXG4gICAgICAgICAgICAgICAgICAgIDogZ2V0TG9jYXRpb24oc3RhdGVzX2xpc3QsIHZhbHVlcy5hZGRyZXNzX3N0YXRlLCAndmFsdWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uU3VibWl0KChnZXRDdXJyZW50U3RlcD8uKCkgfHwgMSkgLSAxLCB2YWx1ZXMsIGFjdGlvbnMuc2V0U3VibWl0dGluZywgZ29Ub05leHRTdGVwKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPEZvcm1payBpbml0aWFsVmFsdWVzPXtwcm9wcy52YWx1ZX0gdmFsaWRhdGU9e2hhbmRsZVZhbGlkYXRlfSB2YWxpZGF0ZU9uTW91bnQgb25TdWJtaXQ9e2hhbmRsZVN1Ym1pdERhdGF9PlxuICAgICAgICAgICAgICAgIHsoe1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVTdWJtaXQsXG4gICAgICAgICAgICAgICAgICAgIGlzU3VibWl0dGluZyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLFxuICAgICAgICAgICAgICAgICAgICBzZXRGaWVsZFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVDaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIHNldEZpZWxkVG91Y2hlZCxcbiAgICAgICAgICAgICAgICB9OiBGb3JtaWtIYW5kbGVycyAmIEZvcm1pa0hlbHBlcnM8VEFkZHJlc3NEZXRhaWxGb3JtUHJvcHM+ICYgRm9ybWlrU3RhdGU8VEFkZHJlc3NEZXRhaWxGb3JtUHJvcHM+KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgIDxBdXRvSGVpZ2h0V3JhcHBlciBkZWZhdWx0X2hlaWdodD17MzUwfSBoZWlnaHRfb2Zmc2V0PXtpc19kZXNrdG9wID8gODAgOiBudWxsfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0UmVmOiAoaW5zdGFuY2U6IEhUTUxGb3JtRWxlbWVudCkgPT4gdm9pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG51bWJlciB8IHN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pID0+IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL25vVmFsaWRhdGUgaGVyZSBpcyBmb3Igc2tpcHBpbmcgZGVmYXVsdCBicm93c2VyIHZhbGlkYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Zm9ybSByZWY9e3NldFJlZn0gb25TdWJtaXQ9e2hhbmRsZVN1Ym1pdH0gbm9WYWxpZGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPERpdjEwMHZoQ29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9J2RldGFpbHMtZm9ybSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodF9vZmZzZXQ9JzkwcHgnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc19kaXNhYmxlZD17aXNfZGVza3RvcH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPFNjcm9sbFRvRmllbGRXaXRoRXJyb3IgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxUZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXM9J3AnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ249J2xlZnQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZT0neHhzJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVfaGVpZ2h0PSdsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT0nZGV0YWlscy1mb3JtX19kZXNjcmlwdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Ryb25nPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8TG9jYWxpemUgaTE4bl9kZWZhdWx0X3RleHQ9J09ubHkgdXNlIGFuIGFkZHJlc3MgZm9yIHdoaWNoIHlvdSBoYXZlIHByb29mIG9mIHJlc2lkZW5jZSAtICcgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3N0cm9uZz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8TG9jYWxpemUgaTE4bl9kZWZhdWx0X3RleHQ9J2EgcmVjZW50IHV0aWxpdHkgYmlsbCAoZS5nLiBlbGVjdHJpY2l0eSwgd2F0ZXIsIGdhcywgbGFuZGxpbmUsIG9yIGludGVybmV0KSwgYmFuayBzdGF0ZW1lbnQsIG9yIGdvdmVybm1lbnQtaXNzdWVkIGxldHRlciB3aXRoIHlvdXIgbmFtZSBhbmQgdGhpcyBhZGRyZXNzLicgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvVGV4dD5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPFRoZW1lZFNjcm9sbGJhcnMgaGVpZ2h0PXtoZWlnaHR9IGNsYXNzTmFtZT0nZGV0YWlscy1mb3JtX19zY3JvbGxiYXInPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWVzKCdkZXRhaWxzLWZvcm1fX2VsZW1lbnRzJywgJ2FkZHJlc3MtZGV0YWlscy1mb3JtICcpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPEZvcm1JbnB1dEZpZWxkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPSdhZGRyZXNzX2xpbmVfMSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD17bG9jYWxpemUoJ0ZpcnN0IGxpbmUgb2YgYWRkcmVzcyonKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heExlbmd0aD17MjU1fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9e2xvY2FsaXplKCdGaXJzdCBsaW5lIG9mIGFkZHJlc3MnKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZF9pdGVtcy5pbmNsdWRlcygnYWRkcmVzc19saW5lXzEnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICghIXByb3BzLnZhbHVlPy5hZGRyZXNzX2xpbmVfMSAmJiBoYXNfcmVhbF9hY2NvdW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Rm9ybUlucHV0RmllbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9J2FkZHJlc3NfbGluZV8yJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9e2xvY2FsaXplKCdTZWNvbmQgbGluZSBvZiBhZGRyZXNzJyl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhMZW5ndGg9ezI1NX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPXtsb2NhbGl6ZSgnU2Vjb25kIGxpbmUgb2YgYWRkcmVzcycpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkX2l0ZW1zLmluY2x1ZGVzKCdhZGRyZXNzX2xpbmVfMicpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCEhcHJvcHMudmFsdWU/LmFkZHJlc3NfbGluZV8yICYmIGhhc19yZWFsX2FjY291bnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxGb3JtSW5wdXRGaWVsZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT0nYWRkcmVzc19jaXR5J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPXtsb2NhbGl6ZSgnVG93bi9DaXR5KicpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9e2xvY2FsaXplKCdUb3duL0NpdHknKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZF9pdGVtcy5pbmNsdWRlcygnYWRkcmVzc19jaXR5JykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoISFwcm9wcy52YWx1ZT8uYWRkcmVzc19jaXR5ICYmIGhhc19yZWFsX2FjY291bnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHshaXNGZXRjaGVkICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdkZXRhaWxzLWZvcm1fX2xvYWRlcic+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPExvYWRpbmcgaXNfZnVsbHNjcmVlbj17ZmFsc2V9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0YXRlc19saXN0Py5sZW5ndGggPiAwID8gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPEZpZWxkIG5hbWU9J2FkZHJlc3Nfc3RhdGUnPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsoeyBmaWVsZCB9OiBGb3JtaWtWYWx1ZXMpID0+IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPFJlYWN0LkZyYWdtZW50PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPERlc2t0b3BXcmFwcGVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxBdXRvY29tcGxldGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgey4uLmZpZWxkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Li4uKGFkZHJlc3Nfc3RhdGVfdG9fZGlzcGxheSAmJiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYWRkcmVzc19zdGF0ZV90b19kaXNwbGF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1scGlnbm9yZT0ndHJ1ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b0NvbXBsZXRlPSduZXctcGFzc3dvcmQnIC8vIHByZXZlbnQgY2hyb21lIGF1dG9jb21wbGV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPSd0ZXh0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD17bG9jYWxpemUoJ1N0YXRlL1Byb3ZpbmNlJyl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RfaXRlbXM9e3N0YXRlc19saXN0fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkl0ZW1TZWxlY3Rpb249eyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH06IFRBdXRvQ29tcGxldGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEZpZWxkVmFsdWUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZHJlc3Nfc3RhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID8gdGV4dCA6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBZGRyZXNzU3RhdGVUb0Rpc3BsYXkoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0X3BvcnRhbF9pZD0nbW9kYWxfcm9vdCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWRfaXRlbXMuaW5jbHVkZXMoJ2FkZHJlc3Nfc3RhdGUnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHByb3BzLnZhbHVlPy5hZGRyZXNzX3N0YXRlICYmIGhhc19yZWFsX2FjY291bnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9EZXNrdG9wV3JhcHBlcj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxNb2JpbGVXcmFwcGVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxTZWxlY3ROYXRpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9e2xvY2FsaXplKCdQbGVhc2Ugc2VsZWN0Jyl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPXtsb2NhbGl6ZSgnU3RhdGUvUHJvdmluY2UnKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc19zdGF0ZV90b19kaXNwbGF5IHx8IHZhbHVlcy5hZGRyZXNzX3N0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdF9pdGVtcz17c3RhdGVzX2xpc3R9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZV90ZXh0PXt0cnVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGU6IHsgdGFyZ2V0OiB7IHZhbHVlOiBzdHJpbmcgfSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRGaWVsZFZhbHVlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRyZXNzX3N0YXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnRhcmdldC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QWRkcmVzc1N0YXRlVG9EaXNwbGF5KCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWRfaXRlbXMuaW5jbHVkZXMoJ2FkZHJlc3Nfc3RhdGUnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCEhcHJvcHMudmFsdWU/LmFkZHJlc3Nfc3RhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNfcmVhbF9hY2NvdW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvTW9iaWxlV3JhcHBlcj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9SZWFjdC5GcmFnbWVudD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9GaWVsZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGlucHV0IGZpZWxkIHdoZW4gc3RhdGVzIGxpc3QgaXMgZW1wdHkgLyB1bmF2YWlsYWJsZSBmb3IgY291bnRyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPEZvcm1JbnB1dEZpZWxkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT0nYWRkcmVzc19zdGF0ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD17bG9jYWxpemUoJ1N0YXRlL1Byb3ZpbmNlJyl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9e2xvY2FsaXplKCdTdGF0ZS9Qcm92aW5jZScpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWRfaXRlbXMuaW5jbHVkZXMoJ2FkZHJlc3Nfc3RhdGUnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoISFwcm9wcy52YWx1ZT8uYWRkcmVzc19zdGF0ZSAmJiBoYXNfcmVhbF9hY2NvdW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxGb3JtSW5wdXRGaWVsZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT0nYWRkcmVzc19wb3N0Y29kZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkPXshIWlzX2diX3Jlc2lkZW5jZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPXtsb2NhbGl6ZSgnUG9zdGFsL1pJUCBDb2RlJyl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj17bG9jYWxpemUoJ1Bvc3RhbC9aSVAgQ29kZScpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEZpZWxkVG91Y2hlZCgnYWRkcmVzc19wb3N0Y29kZScsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUNoYW5nZShlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWRfaXRlbXMuaW5jbHVkZXMoJ2FkZHJlc3NfcG9zdGNvZGUnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICghIXByb3BzLnZhbHVlPy5hZGRyZXNzX3Bvc3Rjb2RlICYmIGhhc19yZWFsX2FjY291bnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L1RoZW1lZFNjcm9sbGJhcnM+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvRGl2MTAwdmhDb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxNb2RhbC5Gb290ZXIgaGFzX3NlcGFyYXRvciBpc19ieXBhc3NlZD17aXNfbW9iaWxlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxGb3JtU3VibWl0QnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNfZGlzYWJsZWQ9e2lzU3VibWl0dGluZ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD17bG9jYWxpemUoJ05leHQnKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc19hYnNvbHV0ZT17aXNfbW9iaWxlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc19jYW5jZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxfbGFiZWw9e2xvY2FsaXplKCdQcmV2aW91cycpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2FuY2VsPXsoKSA9PiBoYW5kbGVDYW5jZWwodmFsdWVzKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvTW9kYWwuRm9vdGVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZm9ybT5cbiAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIDwvQXV0b0hlaWdodFdyYXBwZXI+XG4gICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDwvRm9ybWlrPlxuICAgICAgICApO1xuICAgIH1cbik7XG5cbmV4cG9ydCBkZWZhdWx0IEFkZHJlc3NEZXRhaWxzO1xuIiwiaW1wb3J0IEFkZHJlc3NEZXRhaWxzIGZyb20gJy4vYWRkcmVzcy1kZXRhaWxzJztcblxuZXhwb3J0IGRlZmF1bHQgQWRkcmVzc0RldGFpbHM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./Components/address-details/index.js\n");

/***/ }),

/***/ "../../../node_modules/classnames/index.js":
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\tCopyright (c) 2018 Jed Watson.\n\tLicensed under the MIT License (MIT), see\n\thttp://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\tvar nativeCodeString = '[native code]';\n\n\tfunction classNames() {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tif (arg.length) {\n\t\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\t\tif (inner) {\n\t\t\t\t\t\tclasses.push(inner);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tif (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {\n\t\t\t\t\tclasses.push(arg.toString());\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif ( true && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (true) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn classNames;\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzPzNkY2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG5cdENvcHlyaWdodCAoYykgMjAxOCBKZWQgV2F0c29uLlxuXHRMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuXHRodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXHR2YXIgbmF0aXZlQ29kZVN0cmluZyA9ICdbbmF0aXZlIGNvZGVdJztcblxuXHRmdW5jdGlvbiBjbGFzc05hbWVzKCkge1xuXHRcdHZhciBjbGFzc2VzID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmICghYXJnKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuXG5cdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgfHwgYXJnVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGFyZyk7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHRpZiAoYXJnLmxlbmd0aCkge1xuXHRcdFx0XHRcdHZhciBpbm5lciA9IGNsYXNzTmFtZXMuYXBwbHkobnVsbCwgYXJnKTtcblx0XHRcdFx0XHRpZiAoaW5uZXIpIHtcblx0XHRcdFx0XHRcdGNsYXNzZXMucHVzaChpbm5lcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGlmIChhcmcudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgJiYgIWFyZy50b1N0cmluZy50b1N0cmluZygpLmluY2x1ZGVzKCdbbmF0aXZlIGNvZGVdJykpIHtcblx0XHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnLnRvU3RyaW5nKCkpO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGFyZykge1xuXHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdGNsYXNzZXMucHVzaChrZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjbGFzc2VzLmpvaW4oJyAnKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdGNsYXNzTmFtZXMuZGVmYXVsdCA9IGNsYXNzTmFtZXM7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0fVxufSgpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/classnames/index.js\n");

/***/ }),

/***/ "../../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar reactIs = __webpack_require__(\"../../../node_modules/react-is/index.js\");\n\n/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n};\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\nvar FORWARD_REF_STATICS = {\n  '$$typeof': true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true\n};\nvar MEMO_STATICS = {\n  '$$typeof': true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true\n};\nvar TYPE_STATICS = {};\nTYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;\nTYPE_STATICS[reactIs.Memo] = MEMO_STATICS;\n\nfunction getStatics(component) {\n  // React v16.11 and below\n  if (reactIs.isMemo(component)) {\n    return MEMO_STATICS;\n  } // React v16.12 and above\n\n\n  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;\n}\n\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n  if (typeof sourceComponent !== 'string') {\n    // don't hoist over string (html) components\n    if (objectPrototype) {\n      var inheritedComponent = getPrototypeOf(sourceComponent);\n\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n      }\n    }\n\n    var keys = getOwnPropertyNames(sourceComponent);\n\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n    }\n\n    var targetStatics = getStatics(targetComponent);\n    var sourceStatics = getStatics(sourceComponent);\n\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i];\n\n      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n\n        try {\n          // Avoid failures from read-only properties\n          defineProperty(targetComponent, key, descriptor);\n        } catch (e) {}\n      }\n    }\n  }\n\n  return targetComponent;\n}\n\nmodule.exports = hoistNonReactStatics;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2Rpc3QvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MuY2pzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2Rpc3QvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MuY2pzLmpzPzkwY2YiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICBjaGlsZENvbnRleHRUeXBlczogdHJ1ZSxcbiAgY29udGV4dFR5cGU6IHRydWUsXG4gIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I6IHRydWUsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczogdHJ1ZSxcbiAgbWl4aW5zOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWUsXG4gIHR5cGU6IHRydWVcbn07XG52YXIgS05PV05fU1RBVElDUyA9IHtcbiAgbmFtZTogdHJ1ZSxcbiAgbGVuZ3RoOiB0cnVlLFxuICBwcm90b3R5cGU6IHRydWUsXG4gIGNhbGxlcjogdHJ1ZSxcbiAgY2FsbGVlOiB0cnVlLFxuICBhcmd1bWVudHM6IHRydWUsXG4gIGFyaXR5OiB0cnVlXG59O1xudmFyIEZPUldBUkRfUkVGX1NUQVRJQ1MgPSB7XG4gICckJHR5cGVvZic6IHRydWUsXG4gIHJlbmRlcjogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlXG59O1xudmFyIE1FTU9fU1RBVElDUyA9IHtcbiAgJyQkdHlwZW9mJzogdHJ1ZSxcbiAgY29tcGFyZTogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlLFxuICB0eXBlOiB0cnVlXG59O1xudmFyIFRZUEVfU1RBVElDUyA9IHt9O1xuVFlQRV9TVEFUSUNTW3JlYWN0SXMuRm9yd2FyZFJlZl0gPSBGT1JXQVJEX1JFRl9TVEFUSUNTO1xuVFlQRV9TVEFUSUNTW3JlYWN0SXMuTWVtb10gPSBNRU1PX1NUQVRJQ1M7XG5cbmZ1bmN0aW9uIGdldFN0YXRpY3MoY29tcG9uZW50KSB7XG4gIC8vIFJlYWN0IHYxNi4xMSBhbmQgYmVsb3dcbiAgaWYgKHJlYWN0SXMuaXNNZW1vKGNvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gTUVNT19TVEFUSUNTO1xuICB9IC8vIFJlYWN0IHYxNi4xMiBhbmQgYWJvdmVcblxuXG4gIHJldHVybiBUWVBFX1NUQVRJQ1NbY29tcG9uZW50WyckJHR5cGVvZiddXSB8fCBSRUFDVF9TVEFUSUNTO1xufVxuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQsIGJsYWNrbGlzdCkge1xuICBpZiAodHlwZW9mIHNvdXJjZUNvbXBvbmVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBkb24ndCBob2lzdCBvdmVyIHN0cmluZyAoaHRtbCkgY29tcG9uZW50c1xuICAgIGlmIChvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgIHZhciBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgICBpZiAoaW5oZXJpdGVkQ29tcG9uZW50ICYmIGluaGVyaXRlZENvbXBvbmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgaW5oZXJpdGVkQ29tcG9uZW50LCBibGFja2xpc3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAga2V5cyA9IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0U3RhdGljcyA9IGdldFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50KTtcbiAgICB2YXIgc291cmNlU3RhdGljcyA9IGdldFN0YXRpY3Moc291cmNlQ29tcG9uZW50KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmICghS05PV05fU1RBVElDU1trZXldICYmICEoYmxhY2tsaXN0ICYmIGJsYWNrbGlzdFtrZXldKSAmJiAhKHNvdXJjZVN0YXRpY3MgJiYgc291cmNlU3RhdGljc1trZXldKSAmJiAhKHRhcmdldFN0YXRpY3MgJiYgdGFyZ2V0U3RhdGljc1trZXldKSkge1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VDb21wb25lbnQsIGtleSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBBdm9pZCBmYWlsdXJlcyBmcm9tIHJlYWQtb25seSBwcm9wZXJ0aWVzXG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0Q29tcG9uZW50LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaG9pc3ROb25SZWFjdFN0YXRpY3M7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\n");

/***/ }),

/***/ "../../../node_modules/lodash.groupby/index.js":
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for comparison styles. */\nvar UNORDERED_COMPARE_FLAG = 1,\n    PARTIAL_COMPARE_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `baseAggregator` for arrays.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction arrayAggregator(array, setter, iteratee, accumulator) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    var value = array[index];\n    setter(accumulator, value, iteratee(value), array);\n  }\n  return accumulator;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values ? values.length : 0;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * Aggregates elements of `collection` on `accumulator` with keys transformed\n * by `iteratee` and values set by `setter`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction baseAggregator(collection, setter, iteratee, accumulator) {\n  baseEach(collection, function(value, key, collection) {\n    setter(accumulator, value, iteratee(value), collection);\n  });\n  return accumulator;\n}\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {boolean} [bitmask] The bitmask of comparison flags.\n *  The bitmask may be composed of the following flags:\n *     1 - Unordered comparison\n *     2 - Partial comparison\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, customizer, bitmask, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = arrayTag,\n      othTag = arrayTag;\n\n  if (!objIsArr) {\n    objTag = getTag(object);\n    objTag = objTag == argsTag ? objectTag : objTag;\n  }\n  if (!othIsArr) {\n    othTag = getTag(other);\n    othTag = othTag == argsTag ? objectTag : othTag;\n  }\n  var objIsObj = objTag == objectTag && !isHostObject(object),\n      othIsObj = othTag == objectTag && !isHostObject(other),\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)\n      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);\n  }\n  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);\n}\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];\n}\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);\n  };\n}\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Creates a function like `_.groupBy`.\n *\n * @private\n * @param {Function} setter The function to set accumulator values.\n * @param {Function} [initializer] The accumulator object initializer.\n * @returns {Function} Returns the new aggregator function.\n */\nfunction createAggregator(setter, initializer) {\n  return function(collection, iteratee) {\n    var func = isArray(collection) ? arrayAggregator : baseAggregator,\n        accumulator = initializer ? initializer() : {};\n\n    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);\n  };\n}\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, equalFunc, customizer, bitmask, stack) {\n  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!seen.has(othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {\n              return seen.add(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, customizer, bitmask, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= UNORDERED_COMPARE_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, equalFunc, customizer, bitmask, stack) {\n  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n      objProps = keys(object),\n      objLength = objProps.length,\n      othProps = keys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var result,\n      index = -1,\n      length = path.length;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result) {\n    return result;\n  }\n  var length = object ? object.length : 0;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates an object composed of keys generated from the results of running\n * each element of `collection` thru `iteratee`. The order of grouped values\n * is determined by the order they occur in `collection`. The corresponding\n * value of each key is an array of elements responsible for generating the\n * key. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity]\n *  The iteratee to transform keys.\n * @returns {Object} Returns the composed aggregate object.\n * @example\n *\n * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n * // => { '4': [4.2], '6': [6.1, 6.3] }\n *\n * // The `_.property` iteratee shorthand.\n * _.groupBy(['one', 'two', 'three'], 'length');\n * // => { '3': ['one', 'two'], '5': ['three'] }\n */\nvar groupBy = createAggregator(function(result, value, key) {\n  if (hasOwnProperty.call(result, key)) {\n    result[key].push(value);\n  } else {\n    result[key] = [value];\n  }\n});\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = groupBy;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC5ncm91cGJ5L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC5ncm91cGJ5L2luZGV4LmpzPzBiNmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNvbXBhcmlzb24gc3R5bGVzLiAqL1xudmFyIFVOT1JERVJFRF9DT01QQVJFX0ZMQUcgPSAxLFxuICAgIFBBUlRJQUxfQ09NUEFSRV9GTEFHID0gMjtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICByZUxlYWRpbmdEb3QgPSAvXlxcLi8sXG4gICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlQWdncmVnYXRvcmAgZm9yIGFycmF5cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlBZ2dyZWdhdG9yKGFycmF5LCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSksIGFycmF5KTtcbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XG4gIC8vIE1hbnkgaG9zdCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIHRoYXQgY2FuIGNvZXJjZSB0byBzdHJpbmdzXG4gIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2wsXG4gICAgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheSxcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKSxcbiAgICBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxuICAgIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKSxcbiAgICBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpLFxuICAgIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHJldHVybiB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gZGF0YVtrZXldICE9PSB1bmRlZmluZWQgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICBnZXRNYXBEYXRhKHRoaXMsIGtleSkuc2V0KGtleSwgdmFsdWUpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID8gdmFsdWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX19bJ2RlbGV0ZSddKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgY2FjaGUgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoY2FjaGUgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBjYWNoZS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY2FjaGUgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBjYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIC8vIFNhZmFyaSA5IG1ha2VzIGBhcmd1bWVudHMubGVuZ3RoYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICB2YXIgcmVzdWx0ID0gKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSlcbiAgICA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZylcbiAgICA6IFtdO1xuXG4gIHZhciBsZW5ndGggPSByZXN1bHQubGVuZ3RoLFxuICAgICAgc2tpcEluZGV4ZXMgPSAhIWxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChrZXkgPT0gJ2xlbmd0aCcgfHwgaXNJbmRleChrZXksIGxlbmd0aCkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBBZ2dyZWdhdGVzIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBvbiBgYWNjdW11bGF0b3JgIHdpdGgga2V5cyB0cmFuc2Zvcm1lZFxuICogYnkgYGl0ZXJhdGVlYCBhbmQgdmFsdWVzIHNldCBieSBgc2V0dGVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFnZ3JlZ2F0b3IoY29sbGVjdGlvbiwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKi9cbnZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBpc0tleShwYXRoLCBvYmplY3QpID8gW3BhdGhdIDogY2FzdFBhdGgocGF0aCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtib29sZWFufSBbYml0bWFza10gVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy5cbiAqICBUaGUgYml0bWFzayBtYXkgYmUgY29tcG9zZWQgb2YgdGhlIGZvbGxvd2luZyBmbGFnczpcbiAqICAgICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAgICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdCh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJhc2VJc0VxdWFsLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjayk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gW2JpdG1hc2tdIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgXG4gKiAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gYXJyYXlUYWcsXG4gICAgICBvdGhUYWcgPSBhcnJheVRhZztcblxuICBpZiAoIW9iaklzQXJyKSB7XG4gICAgb2JqVGFnID0gZ2V0VGFnKG9iamVjdCk7XG4gICAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIH1cbiAgaWYgKCFvdGhJc0Fycikge1xuICAgIG90aFRhZyA9IGdldFRhZyhvdGhlcik7XG4gICAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG4gIH1cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyAmJiAhaXNIb3N0T2JqZWN0KG9iamVjdCksXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcgJiYgIWlzSG9zdE9iamVjdChvdGhlciksXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIFBBUlRJQUxfQ09NUEFSRV9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjayk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiAhbGVuZ3RoO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIGN1c3RvbWl6ZXIsIFVOT1JERVJFRF9DT01QQVJFX0ZMQUcgfCBQQVJUSUFMX0NPTVBBUkVfRkxBRywgc3RhY2spXG4gICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gKGlzRnVuY3Rpb24odmFsdWUpIHx8IGlzSG9zdE9iamVjdCh2YWx1ZSkpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW29iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpXTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgdW5kZWZpbmVkLCBVTk9SREVSRURfQ09NUEFSRV9GTEFHIHwgUEFSVElBTF9DT01QQVJFX0ZMQUcpO1xuICB9O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlKSB7XG4gIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogc3RyaW5nVG9QYXRoKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5ncm91cEJ5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYWNjdW11bGF0b3IgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2luaXRpYWxpemVyXSBUaGUgYWNjdW11bGF0b3Igb2JqZWN0IGluaXRpYWxpemVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWdncmVnYXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRvcihzZXR0ZXIsIGluaXRpYWxpemVyKSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5QWdncmVnYXRvciA6IGJhc2VBZ2dyZWdhdG9yLFxuICAgICAgICBhY2N1bXVsYXRvciA9IGluaXRpYWxpemVyID8gaW5pdGlhbGl6ZXIoKSA6IHt9O1xuXG4gICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgc2V0dGVyLCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBhY2N1bXVsYXRvcik7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgXG4gKiAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIFBBUlRJQUxfQ09NUEFSRV9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBVTk9SREVSRURfQ09NUEFSRV9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIXNlZW4uaGFzKG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5hZGQob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBjb21wYXJpc29uIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYFxuICogIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgUEFSVElBTF9DT01QQVJFX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBVTk9SREVSRURfQ09NUEFSRV9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgXG4gKiAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBQQVJUSUFMX0NPTVBBUkVfRkxBRyxcbiAgICAgIG9ialByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBrZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEsXG4vLyBmb3IgZGF0YSB2aWV3cyBpbiBFZGdlIDwgMTQsIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzLlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBpc0tleShwYXRoLCBvYmplY3QpID8gW3BhdGhdIDogY2FzdFBhdGgocGF0aCk7XG5cbiAgdmFyIHJlc3VsdCxcbiAgICAgIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IG9iamVjdCA/IG9iamVjdC5sZW5ndGggOiAwO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgJiZcbiAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemUoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAocmVMZWFkaW5nRG90LnRlc3Qoc3RyaW5nKSkge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBvcmRlciBvZiBncm91cGVkIHZhbHVlc1xuICogaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiBgY29sbGVjdGlvbmAuIFRoZSBjb3JyZXNwb25kaW5nXG4gKiB2YWx1ZSBvZiBlYWNoIGtleSBpcyBhbiBhcnJheSBvZiBlbGVtZW50cyByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGVcbiAqIGtleS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XVxuICogIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZ3JvdXBCeShbNi4xLCA0LjIsIDYuM10sIE1hdGguZmxvb3IpO1xuICogLy8gPT4geyAnNCc6IFs0LjJdLCAnNic6IFs2LjEsIDYuM10gfVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5ncm91cEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gKiAvLyA9PiB7ICczJzogWydvbmUnLCAndHdvJ10sICc1JzogWyd0aHJlZSddIH1cbiAqL1xudmFyIGdyb3VwQnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHRba2V5XSA9IFt2YWx1ZV07XG4gIH1cbn0pO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEFzc2lnbiBjYWNoZSB0byBgXy5tZW1vaXplYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgfHwgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc1RhZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDgtOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gaXNPYmplY3QodmFsdWUpID8gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdyb3VwQnk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/lodash.groupby/index.js\n");

/***/ }),

/***/ "../../../node_modules/lodash.merge/index.js":
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeMax = Math.max,\n    nativeNow = Date.now;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * This function is like `assignValue` except that it doesn't assign\n * `undefined` values.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignMergeValue(object, key, value) {\n  if ((value !== undefined && !eq(object[key], value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.merge` without support for multiple sources.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMerge(object, source, srcIndex, customizer, stack) {\n  if (object === source) {\n    return;\n  }\n  baseFor(source, function(srcValue, key) {\n    stack || (stack = new Stack);\n    if (isObject(srcValue)) {\n      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n    }\n    else {\n      var newValue = customizer\n        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      if (newValue === undefined) {\n        newValue = srcValue;\n      }\n      assignMergeValue(object, key, newValue);\n    }\n  }, keysIn);\n}\n\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n  var objValue = safeGet(object, key),\n      srcValue = safeGet(source, key),\n      stacked = stack.get(srcValue);\n\n  if (stacked) {\n    assignMergeValue(object, key, stacked);\n    return;\n  }\n  var newValue = customizer\n    ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n    : undefined;\n\n  var isCommon = newValue === undefined;\n\n  if (isCommon) {\n    var isArr = isArray(srcValue),\n        isBuff = !isArr && isBuffer(srcValue),\n        isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n    newValue = srcValue;\n    if (isArr || isBuff || isTyped) {\n      if (isArray(objValue)) {\n        newValue = objValue;\n      }\n      else if (isArrayLikeObject(objValue)) {\n        newValue = copyArray(objValue);\n      }\n      else if (isBuff) {\n        isCommon = false;\n        newValue = cloneBuffer(srcValue, true);\n      }\n      else if (isTyped) {\n        isCommon = false;\n        newValue = cloneTypedArray(srcValue, true);\n      }\n      else {\n        newValue = [];\n      }\n    }\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n      newValue = objValue;\n      if (isArguments(objValue)) {\n        newValue = toPlainObject(objValue);\n      }\n      else if (!isObject(objValue) || isFunction(objValue)) {\n        newValue = initCloneObject(srcValue);\n      }\n    }\n    else {\n      isCommon = false;\n    }\n  }\n  if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    stack.set(srcValue, newValue);\n    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n    stack['delete'](srcValue);\n  }\n  assignMergeValue(object, key, newValue);\n}\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\n/**\n * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction safeGet(object, key) {\n  if (key === 'constructor' && typeof object[key] === 'function') {\n    return;\n  }\n\n  if (key == '__proto__') {\n    return;\n  }\n\n  return object[key];\n}\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a plain object flattening inherited enumerable string\n * keyed properties of `value` to own properties of the plain object.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {Object} Returns the converted plain object.\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.assign({ 'a': 1 }, new Foo);\n * // => { 'a': 1, 'b': 2 }\n *\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n * // => { 'a': 1, 'b': 2, 'c': 3 }\n */\nfunction toPlainObject(value) {\n  return copyObject(value, keysIn(value));\n}\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\n/**\n * This method is like `_.assign` except that it recursively merges own and\n * inherited enumerable string keyed properties of source objects into the\n * destination object. Source properties that resolve to `undefined` are\n * skipped if a destination value exists. Array and plain object properties\n * are merged recursively. Other objects and value types are overridden by\n * assignment. Source objects are applied from left to right. Subsequent\n * sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = {\n *   'a': [{ 'b': 2 }, { 'd': 4 }]\n * };\n *\n * var other = {\n *   'a': [{ 'c': 3 }, { 'e': 5 }]\n * };\n *\n * _.merge(object, other);\n * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n */\nvar merge = createAssigner(function(object, source, srcIndex) {\n  baseMerge(object, source, srcIndex);\n});\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = merge;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC5tZXJnZS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGRlcml2L2FjY291bnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC5tZXJnZS9pbmRleC5qcz9mMGEzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgT3BlbkpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9vcGVuanNmLm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxuICAgIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXksXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQsXG4gICAgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCksXG4gICAgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSxcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLFxuICAgIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAqIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIoc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfSwga2V5c0luKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIHZhciBvYmpWYWx1ZSA9IHNhZmVHZXQob2JqZWN0LCBrZXkpLFxuICAgICAgc3JjVmFsdWUgPSBzYWZlR2V0KHNvdXJjZSwga2V5KSxcbiAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gIGlmIChzdGFja2VkKSB7XG4gICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICBpZiAoaXNDb21tb24pIHtcbiAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHNyY1ZhbHVlKSxcbiAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmIGlzQnVmZmVyKHNyY1ZhbHVlKSxcbiAgICAgICAgaXNUeXBlZCA9ICFpc0FyciAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheShzcmNWYWx1ZSk7XG5cbiAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgIGlmIChpc0FyciB8fCBpc0J1ZmYgfHwgaXNUeXBlZCkge1xuICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IHRvUGxhaW5PYmplY3Qob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCBpc0Z1bmN0aW9uKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGluaXRDbG9uZU9iamVjdChzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICB9XG4gIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIiBvciBcImNvbnN0cnVjdG9yXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Rba2V5XTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBtZXJnZXMgb3duIGFuZFxuICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICogc2tpcHBlZCBpZiBhIGRlc3RpbmF0aW9uIHZhbHVlIGV4aXN0cy4gQXJyYXkgYW5kIHBsYWluIG9iamVjdCBwcm9wZXJ0aWVzXG4gKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gKiBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC41LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHtcbiAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAqIH07XG4gKlxuICogdmFyIG90aGVyID0ge1xuICogICAnYSc6IFt7ICdjJzogMyB9LCB7ICdlJzogNSB9XVxuICogfTtcbiAqXG4gKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICovXG52YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcbiAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG59KTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/lodash.merge/index.js\n");

/***/ }),

/***/ "../../../node_modules/lodash.pickby/index.js":
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for comparison styles. */\nvar UNORDERED_COMPARE_FLAG = 1,\n    PARTIAL_COMPARE_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values ? values.length : 0;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {boolean} [bitmask] The bitmask of comparison flags.\n *  The bitmask may be composed of the following flags:\n *     1 - Unordered comparison\n *     2 - Partial comparison\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, customizer, bitmask, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = arrayTag,\n      othTag = arrayTag;\n\n  if (!objIsArr) {\n    objTag = getTag(object);\n    objTag = objTag == argsTag ? objectTag : objTag;\n  }\n  if (!othIsArr) {\n    othTag = getTag(other);\n    othTag = othTag == argsTag ? objectTag : othTag;\n  }\n  var objIsObj = objTag == objectTag && !isHostObject(object),\n      othIsObj = othTag == objectTag && !isHostObject(other),\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)\n      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);\n  }\n  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);\n}\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];\n}\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);\n  };\n}\n\n/**\n * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The source object.\n * @param {string[]} props The property identifiers to pick from.\n * @param {Function} predicate The function invoked per property.\n * @returns {Object} Returns the new object.\n */\nfunction basePickBy(object, props, predicate) {\n  var index = -1,\n      length = props.length,\n      result = {};\n\n  while (++index < length) {\n    var key = props[index],\n        value = object[key];\n\n    if (predicate(value, key)) {\n      result[key] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, equalFunc, customizer, bitmask, stack) {\n  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!seen.has(othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {\n              return seen.add(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, customizer, bitmask, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= UNORDERED_COMPARE_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, equalFunc, customizer, bitmask, stack) {\n  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n      objProps = keys(object),\n      objLength = objProps.length,\n      othProps = keys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n  return baseGetAllKeys(object, keysIn, getSymbolsIn);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Creates an array of the own enumerable symbol properties of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;\n\n/**\n * Creates an array of the own and inherited enumerable symbol properties\n * of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n  var result = [];\n  while (object) {\n    arrayPush(result, getSymbols(object));\n    object = getPrototype(object);\n  }\n  return result;\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var result,\n      index = -1,\n      length = path.length;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result) {\n    return result;\n  }\n  var length = object ? object.length : 0;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\n/**\n * Creates an object composed of the `object` properties `predicate` returns\n * truthy for. The predicate is invoked with two arguments: (value, key).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The source object.\n * @param {Function} [predicate=_.identity] The function invoked per property.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.pickBy(object, _.isNumber);\n * // => { 'a': 1, 'c': 3 }\n */\nfunction pickBy(object, predicate) {\n  return object == null ? {} : basePickBy(object, getAllKeysIn(object), baseIteratee(predicate));\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = pickBy;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC5waWNrYnkvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLnBpY2tieS9pbmRleC5qcz9jM2EyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjb21wYXJpc29uIHN0eWxlcy4gKi9cbnZhciBVTk9SREVSRURfQ09NUEFSRV9GTEFHID0gMSxcbiAgICBQQVJUSUFMX0NPTVBBUkVfRkxBRyA9IDI7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC8sXG4gICAgcmVMZWFkaW5nRG90ID0gL15cXC4vLFxuICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XG4gIC8vIE1hbnkgaG9zdCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIHRoYXQgY2FuIGNvZXJjZSB0byBzdHJpbmdzXG4gIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2wsXG4gICAgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheSxcbiAgICBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KSxcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKSxcbiAgICBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxuICAgIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKSxcbiAgICBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpLFxuICAgIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHJldHVybiB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gZGF0YVtrZXldICE9PSB1bmRlZmluZWQgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICBnZXRNYXBEYXRhKHRoaXMsIGtleSkuc2V0KGtleSwgdmFsdWUpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID8gdmFsdWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX19bJ2RlbGV0ZSddKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgY2FjaGUgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoY2FjaGUgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBjYWNoZS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY2FjaGUgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBjYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIC8vIFNhZmFyaSA5IG1ha2VzIGBhcmd1bWVudHMubGVuZ3RoYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICB2YXIgcmVzdWx0ID0gKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSlcbiAgICA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZylcbiAgICA6IFtdO1xuXG4gIHZhciBsZW5ndGggPSByZXN1bHQubGVuZ3RoLFxuICAgICAgc2tpcEluZGV4ZXMgPSAhIWxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChrZXkgPT0gJ2xlbmd0aCcgfHwgaXNJbmRleChrZXksIGxlbmd0aCkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBpc0tleShwYXRoLCBvYmplY3QpID8gW3BhdGhdIDogY2FzdFBhdGgocGF0aCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtiaXRtYXNrXSBUaGUgYml0bWFzayBvZiBjb21wYXJpc29uIGZsYWdzLlxuICogIFRoZSBiaXRtYXNrIG1heSBiZSBjb21wb3NlZCBvZiB0aGUgZm9sbG93aW5nIGZsYWdzOlxuICogICAgIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogICAgIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0KHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYmFzZUlzRXF1YWwsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYml0bWFza10gVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGBcbiAqICBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBhcnJheVRhZyxcbiAgICAgIG90aFRhZyA9IGFycmF5VGFnO1xuXG4gIGlmICghb2JqSXNBcnIpIHtcbiAgICBvYmpUYWcgPSBnZXRUYWcob2JqZWN0KTtcbiAgICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgfVxuICBpZiAoIW90aElzQXJyKSB7XG4gICAgb3RoVGFnID0gZ2V0VGFnKG90aGVyKTtcbiAgICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcbiAgfVxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnICYmICFpc0hvc3RPYmplY3Qob2JqZWN0KSxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyAmJiAhaXNIb3N0T2JqZWN0KG90aGVyKSxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgUEFSVElBTF9DT01QQVJFX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgY3VzdG9taXplciwgVU5PUkRFUkVEX0NPTVBBUkVfRkxBRyB8IFBBUlRJQUxfQ09NUEFSRV9GTEFHLCBzdGFjaylcbiAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgaXNIb3N0T2JqZWN0KHZhbHVlKSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSldO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICovXG5mdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcbiAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCB1bmRlZmluZWQsIFVOT1JERVJFRF9DT01QQVJFX0ZMQUcgfCBQQVJUSUFMX0NPTVBBUkVfRkxBRyk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIHBpY2sgZnJvbS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGlja0J5KG9iamVjdCwgcHJvcHMsIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGtleSkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBzdHJpbmdUb1BhdGgodmFsdWUpO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgXG4gKiAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIFBBUlRJQUxfQ09NUEFSRV9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBVTk9SREVSRURfQ09NUEFSRV9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIXNlZW4uaGFzKG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5hZGQob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBjb21wYXJpc29uIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYFxuICogIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgUEFSVElBTF9DT01QQVJFX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBVTk9SREVSRURfQ09NUEFSRV9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgXG4gKiAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBQQVJUSUFMX0NPTVBBUkVfRkxBRyxcbiAgICAgIG9ialByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBrZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbCBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gbmF0aXZlR2V0U3ltYm9scyA/IG92ZXJBcmcobmF0aXZlR2V0U3ltYm9scywgT2JqZWN0KSA6IHN0dWJBcnJheTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbCBwcm9wZXJ0aWVzXG4gKiBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAob2JqZWN0KSB7XG4gICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExLFxuLy8gZm9yIGRhdGEgdmlld3MgaW4gRWRnZSA8IDE0LCBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcy5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICBwYXRoID0gaXNLZXkocGF0aCwgb2JqZWN0KSA/IFtwYXRoXSA6IGNhc3RQYXRoKHBhdGgpO1xuXG4gIHZhciByZXN1bHQsXG4gICAgICBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHZhciBsZW5ndGggPSBvYmplY3QgPyBvYmplY3QubGVuZ3RoIDogMDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmXG4gICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZShmdW5jdGlvbihzdHJpbmcpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChyZUxlYWRpbmdEb3QudGVzdChzdHJpbmcpKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gQXNzaWduIGNhY2hlIHRvIGBfLm1lbW9pemVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAoIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKSB8fCBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOC05IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgYG9iamVjdGAgcHJvcGVydGllcyBgcHJlZGljYXRlYCByZXR1cm5zXG4gKiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAodmFsdWUsIGtleSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5waWNrQnkob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICovXG5mdW5jdGlvbiBwaWNrQnkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8ge30gOiBiYXNlUGlja0J5KG9iamVjdCwgZ2V0QWxsS2V5c0luKG9iamVjdCksIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUpKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBpY2tCeTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/lodash.pickby/index.js\n");

/***/ }),

/***/ "../../../node_modules/moment/moment.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n//! moment.js\n//! version : 2.29.4\n//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\n//! license : MIT\n//! momentjs.com\n\n;(function (global, factory) {\n     true ? module.exports = factory() :\n    0\n}(this, (function () { 'use strict';\n\n    var hookCallback;\n\n    function hooks() {\n        return hookCallback.apply(null, arguments);\n    }\n\n    // This is done to register the method called with moment()\n    // without creating circular dependencies.\n    function setHookCallback(callback) {\n        hookCallback = callback;\n    }\n\n    function isArray(input) {\n        return (\n            input instanceof Array ||\n            Object.prototype.toString.call(input) === '[object Array]'\n        );\n    }\n\n    function isObject(input) {\n        // IE8 will treat undefined and null as object if it wasn't for\n        // input != null\n        return (\n            input != null &&\n            Object.prototype.toString.call(input) === '[object Object]'\n        );\n    }\n\n    function hasOwnProp(a, b) {\n        return Object.prototype.hasOwnProperty.call(a, b);\n    }\n\n    function isObjectEmpty(obj) {\n        if (Object.getOwnPropertyNames) {\n            return Object.getOwnPropertyNames(obj).length === 0;\n        } else {\n            var k;\n            for (k in obj) {\n                if (hasOwnProp(obj, k)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    function isUndefined(input) {\n        return input === void 0;\n    }\n\n    function isNumber(input) {\n        return (\n            typeof input === 'number' ||\n            Object.prototype.toString.call(input) === '[object Number]'\n        );\n    }\n\n    function isDate(input) {\n        return (\n            input instanceof Date ||\n            Object.prototype.toString.call(input) === '[object Date]'\n        );\n    }\n\n    function map(arr, fn) {\n        var res = [],\n            i,\n            arrLen = arr.length;\n        for (i = 0; i < arrLen; ++i) {\n            res.push(fn(arr[i], i));\n        }\n        return res;\n    }\n\n    function extend(a, b) {\n        for (var i in b) {\n            if (hasOwnProp(b, i)) {\n                a[i] = b[i];\n            }\n        }\n\n        if (hasOwnProp(b, 'toString')) {\n            a.toString = b.toString;\n        }\n\n        if (hasOwnProp(b, 'valueOf')) {\n            a.valueOf = b.valueOf;\n        }\n\n        return a;\n    }\n\n    function createUTC(input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, true).utc();\n    }\n\n    function defaultParsingFlags() {\n        // We need to deep clone this object.\n        return {\n            empty: false,\n            unusedTokens: [],\n            unusedInput: [],\n            overflow: -2,\n            charsLeftOver: 0,\n            nullInput: false,\n            invalidEra: null,\n            invalidMonth: null,\n            invalidFormat: false,\n            userInvalidated: false,\n            iso: false,\n            parsedDateParts: [],\n            era: null,\n            meridiem: null,\n            rfc2822: false,\n            weekdayMismatch: false,\n        };\n    }\n\n    function getParsingFlags(m) {\n        if (m._pf == null) {\n            m._pf = defaultParsingFlags();\n        }\n        return m._pf;\n    }\n\n    var some;\n    if (Array.prototype.some) {\n        some = Array.prototype.some;\n    } else {\n        some = function (fun) {\n            var t = Object(this),\n                len = t.length >>> 0,\n                i;\n\n            for (i = 0; i < len; i++) {\n                if (i in t && fun.call(this, t[i], i, t)) {\n                    return true;\n                }\n            }\n\n            return false;\n        };\n    }\n\n    function isValid(m) {\n        if (m._isValid == null) {\n            var flags = getParsingFlags(m),\n                parsedParts = some.call(flags.parsedDateParts, function (i) {\n                    return i != null;\n                }),\n                isNowValid =\n                    !isNaN(m._d.getTime()) &&\n                    flags.overflow < 0 &&\n                    !flags.empty &&\n                    !flags.invalidEra &&\n                    !flags.invalidMonth &&\n                    !flags.invalidWeekday &&\n                    !flags.weekdayMismatch &&\n                    !flags.nullInput &&\n                    !flags.invalidFormat &&\n                    !flags.userInvalidated &&\n                    (!flags.meridiem || (flags.meridiem && parsedParts));\n\n            if (m._strict) {\n                isNowValid =\n                    isNowValid &&\n                    flags.charsLeftOver === 0 &&\n                    flags.unusedTokens.length === 0 &&\n                    flags.bigHour === undefined;\n            }\n\n            if (Object.isFrozen == null || !Object.isFrozen(m)) {\n                m._isValid = isNowValid;\n            } else {\n                return isNowValid;\n            }\n        }\n        return m._isValid;\n    }\n\n    function createInvalid(flags) {\n        var m = createUTC(NaN);\n        if (flags != null) {\n            extend(getParsingFlags(m), flags);\n        } else {\n            getParsingFlags(m).userInvalidated = true;\n        }\n\n        return m;\n    }\n\n    // Plugins that add properties should also add the key here (null value),\n    // so we can properly clone ourselves.\n    var momentProperties = (hooks.momentProperties = []),\n        updateInProgress = false;\n\n    function copyConfig(to, from) {\n        var i,\n            prop,\n            val,\n            momentPropertiesLen = momentProperties.length;\n\n        if (!isUndefined(from._isAMomentObject)) {\n            to._isAMomentObject = from._isAMomentObject;\n        }\n        if (!isUndefined(from._i)) {\n            to._i = from._i;\n        }\n        if (!isUndefined(from._f)) {\n            to._f = from._f;\n        }\n        if (!isUndefined(from._l)) {\n            to._l = from._l;\n        }\n        if (!isUndefined(from._strict)) {\n            to._strict = from._strict;\n        }\n        if (!isUndefined(from._tzm)) {\n            to._tzm = from._tzm;\n        }\n        if (!isUndefined(from._isUTC)) {\n            to._isUTC = from._isUTC;\n        }\n        if (!isUndefined(from._offset)) {\n            to._offset = from._offset;\n        }\n        if (!isUndefined(from._pf)) {\n            to._pf = getParsingFlags(from);\n        }\n        if (!isUndefined(from._locale)) {\n            to._locale = from._locale;\n        }\n\n        if (momentPropertiesLen > 0) {\n            for (i = 0; i < momentPropertiesLen; i++) {\n                prop = momentProperties[i];\n                val = from[prop];\n                if (!isUndefined(val)) {\n                    to[prop] = val;\n                }\n            }\n        }\n\n        return to;\n    }\n\n    // Moment prototype object\n    function Moment(config) {\n        copyConfig(this, config);\n        this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n        if (!this.isValid()) {\n            this._d = new Date(NaN);\n        }\n        // Prevent infinite loop in case updateOffset creates new moment\n        // objects.\n        if (updateInProgress === false) {\n            updateInProgress = true;\n            hooks.updateOffset(this);\n            updateInProgress = false;\n        }\n    }\n\n    function isMoment(obj) {\n        return (\n            obj instanceof Moment || (obj != null && obj._isAMomentObject != null)\n        );\n    }\n\n    function warn(msg) {\n        if (\n            hooks.suppressDeprecationWarnings === false &&\n            typeof console !== 'undefined' &&\n            console.warn\n        ) {\n            console.warn('Deprecation warning: ' + msg);\n        }\n    }\n\n    function deprecate(msg, fn) {\n        var firstTime = true;\n\n        return extend(function () {\n            if (hooks.deprecationHandler != null) {\n                hooks.deprecationHandler(null, msg);\n            }\n            if (firstTime) {\n                var args = [],\n                    arg,\n                    i,\n                    key,\n                    argLen = arguments.length;\n                for (i = 0; i < argLen; i++) {\n                    arg = '';\n                    if (typeof arguments[i] === 'object') {\n                        arg += '\\n[' + i + '] ';\n                        for (key in arguments[0]) {\n                            if (hasOwnProp(arguments[0], key)) {\n                                arg += key + ': ' + arguments[0][key] + ', ';\n                            }\n                        }\n                        arg = arg.slice(0, -2); // Remove trailing comma and space\n                    } else {\n                        arg = arguments[i];\n                    }\n                    args.push(arg);\n                }\n                warn(\n                    msg +\n                        '\\nArguments: ' +\n                        Array.prototype.slice.call(args).join('') +\n                        '\\n' +\n                        new Error().stack\n                );\n                firstTime = false;\n            }\n            return fn.apply(this, arguments);\n        }, fn);\n    }\n\n    var deprecations = {};\n\n    function deprecateSimple(name, msg) {\n        if (hooks.deprecationHandler != null) {\n            hooks.deprecationHandler(name, msg);\n        }\n        if (!deprecations[name]) {\n            warn(msg);\n            deprecations[name] = true;\n        }\n    }\n\n    hooks.suppressDeprecationWarnings = false;\n    hooks.deprecationHandler = null;\n\n    function isFunction(input) {\n        return (\n            (typeof Function !== 'undefined' && input instanceof Function) ||\n            Object.prototype.toString.call(input) === '[object Function]'\n        );\n    }\n\n    function set(config) {\n        var prop, i;\n        for (i in config) {\n            if (hasOwnProp(config, i)) {\n                prop = config[i];\n                if (isFunction(prop)) {\n                    this[i] = prop;\n                } else {\n                    this['_' + i] = prop;\n                }\n            }\n        }\n        this._config = config;\n        // Lenient ordinal parsing accepts just a number in addition to\n        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        this._dayOfMonthOrdinalParseLenient = new RegExp(\n            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +\n                '|' +\n                /\\d{1,2}/.source\n        );\n    }\n\n    function mergeConfigs(parentConfig, childConfig) {\n        var res = extend({}, parentConfig),\n            prop;\n        for (prop in childConfig) {\n            if (hasOwnProp(childConfig, prop)) {\n                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\n                    res[prop] = {};\n                    extend(res[prop], parentConfig[prop]);\n                    extend(res[prop], childConfig[prop]);\n                } else if (childConfig[prop] != null) {\n                    res[prop] = childConfig[prop];\n                } else {\n                    delete res[prop];\n                }\n            }\n        }\n        for (prop in parentConfig) {\n            if (\n                hasOwnProp(parentConfig, prop) &&\n                !hasOwnProp(childConfig, prop) &&\n                isObject(parentConfig[prop])\n            ) {\n                // make sure changes to properties don't modify parent config\n                res[prop] = extend({}, res[prop]);\n            }\n        }\n        return res;\n    }\n\n    function Locale(config) {\n        if (config != null) {\n            this.set(config);\n        }\n    }\n\n    var keys;\n\n    if (Object.keys) {\n        keys = Object.keys;\n    } else {\n        keys = function (obj) {\n            var i,\n                res = [];\n            for (i in obj) {\n                if (hasOwnProp(obj, i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        };\n    }\n\n    var defaultCalendar = {\n        sameDay: '[Today at] LT',\n        nextDay: '[Tomorrow at] LT',\n        nextWeek: 'dddd [at] LT',\n        lastDay: '[Yesterday at] LT',\n        lastWeek: '[Last] dddd [at] LT',\n        sameElse: 'L',\n    };\n\n    function calendar(key, mom, now) {\n        var output = this._calendar[key] || this._calendar['sameElse'];\n        return isFunction(output) ? output.call(mom, now) : output;\n    }\n\n    function zeroFill(number, targetLength, forceSign) {\n        var absNumber = '' + Math.abs(number),\n            zerosToFill = targetLength - absNumber.length,\n            sign = number >= 0;\n        return (\n            (sign ? (forceSign ? '+' : '') : '-') +\n            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +\n            absNumber\n        );\n    }\n\n    var formattingTokens =\n            /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,\n        localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g,\n        formatFunctions = {},\n        formatTokenFunctions = {};\n\n    // token:    'M'\n    // padded:   ['MM', 2]\n    // ordinal:  'Mo'\n    // callback: function () { this.month() + 1 }\n    function addFormatToken(token, padded, ordinal, callback) {\n        var func = callback;\n        if (typeof callback === 'string') {\n            func = function () {\n                return this[callback]();\n            };\n        }\n        if (token) {\n            formatTokenFunctions[token] = func;\n        }\n        if (padded) {\n            formatTokenFunctions[padded[0]] = function () {\n                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n            };\n        }\n        if (ordinal) {\n            formatTokenFunctions[ordinal] = function () {\n                return this.localeData().ordinal(\n                    func.apply(this, arguments),\n                    token\n                );\n            };\n        }\n    }\n\n    function removeFormattingTokens(input) {\n        if (input.match(/\\[[\\s\\S]/)) {\n            return input.replace(/^\\[|\\]$/g, '');\n        }\n        return input.replace(/\\\\/g, '');\n    }\n\n    function makeFormatFunction(format) {\n        var array = format.match(formattingTokens),\n            i,\n            length;\n\n        for (i = 0, length = array.length; i < length; i++) {\n            if (formatTokenFunctions[array[i]]) {\n                array[i] = formatTokenFunctions[array[i]];\n            } else {\n                array[i] = removeFormattingTokens(array[i]);\n            }\n        }\n\n        return function (mom) {\n            var output = '',\n                i;\n            for (i = 0; i < length; i++) {\n                output += isFunction(array[i])\n                    ? array[i].call(mom, format)\n                    : array[i];\n            }\n            return output;\n        };\n    }\n\n    // format date using native date object\n    function formatMoment(m, format) {\n        if (!m.isValid()) {\n            return m.localeData().invalidDate();\n        }\n\n        format = expandFormat(format, m.localeData());\n        formatFunctions[format] =\n            formatFunctions[format] || makeFormatFunction(format);\n\n        return formatFunctions[format](m);\n    }\n\n    function expandFormat(format, locale) {\n        var i = 5;\n\n        function replaceLongDateFormatTokens(input) {\n            return locale.longDateFormat(input) || input;\n        }\n\n        localFormattingTokens.lastIndex = 0;\n        while (i >= 0 && localFormattingTokens.test(format)) {\n            format = format.replace(\n                localFormattingTokens,\n                replaceLongDateFormatTokens\n            );\n            localFormattingTokens.lastIndex = 0;\n            i -= 1;\n        }\n\n        return format;\n    }\n\n    var defaultLongDateFormat = {\n        LTS: 'h:mm:ss A',\n        LT: 'h:mm A',\n        L: 'MM/DD/YYYY',\n        LL: 'MMMM D, YYYY',\n        LLL: 'MMMM D, YYYY h:mm A',\n        LLLL: 'dddd, MMMM D, YYYY h:mm A',\n    };\n\n    function longDateFormat(key) {\n        var format = this._longDateFormat[key],\n            formatUpper = this._longDateFormat[key.toUpperCase()];\n\n        if (format || !formatUpper) {\n            return format;\n        }\n\n        this._longDateFormat[key] = formatUpper\n            .match(formattingTokens)\n            .map(function (tok) {\n                if (\n                    tok === 'MMMM' ||\n                    tok === 'MM' ||\n                    tok === 'DD' ||\n                    tok === 'dddd'\n                ) {\n                    return tok.slice(1);\n                }\n                return tok;\n            })\n            .join('');\n\n        return this._longDateFormat[key];\n    }\n\n    var defaultInvalidDate = 'Invalid date';\n\n    function invalidDate() {\n        return this._invalidDate;\n    }\n\n    var defaultOrdinal = '%d',\n        defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\n\n    function ordinal(number) {\n        return this._ordinal.replace('%d', number);\n    }\n\n    var defaultRelativeTime = {\n        future: 'in %s',\n        past: '%s ago',\n        s: 'a few seconds',\n        ss: '%d seconds',\n        m: 'a minute',\n        mm: '%d minutes',\n        h: 'an hour',\n        hh: '%d hours',\n        d: 'a day',\n        dd: '%d days',\n        w: 'a week',\n        ww: '%d weeks',\n        M: 'a month',\n        MM: '%d months',\n        y: 'a year',\n        yy: '%d years',\n    };\n\n    function relativeTime(number, withoutSuffix, string, isFuture) {\n        var output = this._relativeTime[string];\n        return isFunction(output)\n            ? output(number, withoutSuffix, string, isFuture)\n            : output.replace(/%d/i, number);\n    }\n\n    function pastFuture(diff, output) {\n        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\n        return isFunction(format) ? format(output) : format.replace(/%s/i, output);\n    }\n\n    var aliases = {};\n\n    function addUnitAlias(unit, shorthand) {\n        var lowerCase = unit.toLowerCase();\n        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\n    }\n\n    function normalizeUnits(units) {\n        return typeof units === 'string'\n            ? aliases[units] || aliases[units.toLowerCase()]\n            : undefined;\n    }\n\n    function normalizeObjectUnits(inputObject) {\n        var normalizedInput = {},\n            normalizedProp,\n            prop;\n\n        for (prop in inputObject) {\n            if (hasOwnProp(inputObject, prop)) {\n                normalizedProp = normalizeUnits(prop);\n                if (normalizedProp) {\n                    normalizedInput[normalizedProp] = inputObject[prop];\n                }\n            }\n        }\n\n        return normalizedInput;\n    }\n\n    var priorities = {};\n\n    function addUnitPriority(unit, priority) {\n        priorities[unit] = priority;\n    }\n\n    function getPrioritizedUnits(unitsObj) {\n        var units = [],\n            u;\n        for (u in unitsObj) {\n            if (hasOwnProp(unitsObj, u)) {\n                units.push({ unit: u, priority: priorities[u] });\n            }\n        }\n        units.sort(function (a, b) {\n            return a.priority - b.priority;\n        });\n        return units;\n    }\n\n    function isLeapYear(year) {\n        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n    }\n\n    function absFloor(number) {\n        if (number < 0) {\n            // -0 -> 0\n            return Math.ceil(number) || 0;\n        } else {\n            return Math.floor(number);\n        }\n    }\n\n    function toInt(argumentForCoercion) {\n        var coercedNumber = +argumentForCoercion,\n            value = 0;\n\n        if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n            value = absFloor(coercedNumber);\n        }\n\n        return value;\n    }\n\n    function makeGetSet(unit, keepTime) {\n        return function (value) {\n            if (value != null) {\n                set$1(this, unit, value);\n                hooks.updateOffset(this, keepTime);\n                return this;\n            } else {\n                return get(this, unit);\n            }\n        };\n    }\n\n    function get(mom, unit) {\n        return mom.isValid()\n            ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()\n            : NaN;\n    }\n\n    function set$1(mom, unit, value) {\n        if (mom.isValid() && !isNaN(value)) {\n            if (\n                unit === 'FullYear' &&\n                isLeapYear(mom.year()) &&\n                mom.month() === 1 &&\n                mom.date() === 29\n            ) {\n                value = toInt(value);\n                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](\n                    value,\n                    mom.month(),\n                    daysInMonth(value, mom.month())\n                );\n            } else {\n                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function stringGet(units) {\n        units = normalizeUnits(units);\n        if (isFunction(this[units])) {\n            return this[units]();\n        }\n        return this;\n    }\n\n    function stringSet(units, value) {\n        if (typeof units === 'object') {\n            units = normalizeObjectUnits(units);\n            var prioritized = getPrioritizedUnits(units),\n                i,\n                prioritizedLen = prioritized.length;\n            for (i = 0; i < prioritizedLen; i++) {\n                this[prioritized[i].unit](units[prioritized[i].unit]);\n            }\n        } else {\n            units = normalizeUnits(units);\n            if (isFunction(this[units])) {\n                return this[units](value);\n            }\n        }\n        return this;\n    }\n\n    var match1 = /\\d/, //       0 - 9\n        match2 = /\\d\\d/, //      00 - 99\n        match3 = /\\d{3}/, //     000 - 999\n        match4 = /\\d{4}/, //    0000 - 9999\n        match6 = /[+-]?\\d{6}/, // -999999 - 999999\n        match1to2 = /\\d\\d?/, //       0 - 99\n        match3to4 = /\\d\\d\\d\\d?/, //     999 - 9999\n        match5to6 = /\\d\\d\\d\\d\\d\\d?/, //   99999 - 999999\n        match1to3 = /\\d{1,3}/, //       0 - 999\n        match1to4 = /\\d{1,4}/, //       0 - 9999\n        match1to6 = /[+-]?\\d{1,6}/, // -999999 - 999999\n        matchUnsigned = /\\d+/, //       0 - inf\n        matchSigned = /[+-]?\\d+/, //    -inf - inf\n        matchOffset = /Z|[+-]\\d\\d:?\\d\\d/gi, // +00:00 -00:00 +0000 -0000 or Z\n        matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z\n        matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/, // 123456789 123456789.123\n        // any word (or two) characters or numbers including two/three word month in arabic.\n        // includes scottish gaelic two word and hyphenated months\n        matchWord =\n            /[0-9]{0,256}['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFF07\\uFF10-\\uFFEF]{1,256}|[\\u0600-\\u06FF\\/]{1,256}(\\s*?[\\u0600-\\u06FF]{1,256}){1,2}/i,\n        regexes;\n\n    regexes = {};\n\n    function addRegexToken(token, regex, strictRegex) {\n        regexes[token] = isFunction(regex)\n            ? regex\n            : function (isStrict, localeData) {\n                  return isStrict && strictRegex ? strictRegex : regex;\n              };\n    }\n\n    function getParseRegexForToken(token, config) {\n        if (!hasOwnProp(regexes, token)) {\n            return new RegExp(unescapeFormat(token));\n        }\n\n        return regexes[token](config._strict, config._locale);\n    }\n\n    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n    function unescapeFormat(s) {\n        return regexEscape(\n            s\n                .replace('\\\\', '')\n                .replace(\n                    /\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g,\n                    function (matched, p1, p2, p3, p4) {\n                        return p1 || p2 || p3 || p4;\n                    }\n                )\n        );\n    }\n\n    function regexEscape(s) {\n        return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    }\n\n    var tokens = {};\n\n    function addParseToken(token, callback) {\n        var i,\n            func = callback,\n            tokenLen;\n        if (typeof token === 'string') {\n            token = [token];\n        }\n        if (isNumber(callback)) {\n            func = function (input, array) {\n                array[callback] = toInt(input);\n            };\n        }\n        tokenLen = token.length;\n        for (i = 0; i < tokenLen; i++) {\n            tokens[token[i]] = func;\n        }\n    }\n\n    function addWeekParseToken(token, callback) {\n        addParseToken(token, function (input, array, config, token) {\n            config._w = config._w || {};\n            callback(input, config._w, config, token);\n        });\n    }\n\n    function addTimeToArrayFromToken(token, input, config) {\n        if (input != null && hasOwnProp(tokens, token)) {\n            tokens[token](input, config._a, config, token);\n        }\n    }\n\n    var YEAR = 0,\n        MONTH = 1,\n        DATE = 2,\n        HOUR = 3,\n        MINUTE = 4,\n        SECOND = 5,\n        MILLISECOND = 6,\n        WEEK = 7,\n        WEEKDAY = 8;\n\n    function mod(n, x) {\n        return ((n % x) + x) % x;\n    }\n\n    var indexOf;\n\n    if (Array.prototype.indexOf) {\n        indexOf = Array.prototype.indexOf;\n    } else {\n        indexOf = function (o) {\n            // I know\n            var i;\n            for (i = 0; i < this.length; ++i) {\n                if (this[i] === o) {\n                    return i;\n                }\n            }\n            return -1;\n        };\n    }\n\n    function daysInMonth(year, month) {\n        if (isNaN(year) || isNaN(month)) {\n            return NaN;\n        }\n        var modMonth = mod(month, 12);\n        year += (month - modMonth) / 12;\n        return modMonth === 1\n            ? isLeapYear(year)\n                ? 29\n                : 28\n            : 31 - ((modMonth % 7) % 2);\n    }\n\n    // FORMATTING\n\n    addFormatToken('M', ['MM', 2], 'Mo', function () {\n        return this.month() + 1;\n    });\n\n    addFormatToken('MMM', 0, 0, function (format) {\n        return this.localeData().monthsShort(this, format);\n    });\n\n    addFormatToken('MMMM', 0, 0, function (format) {\n        return this.localeData().months(this, format);\n    });\n\n    // ALIASES\n\n    addUnitAlias('month', 'M');\n\n    // PRIORITY\n\n    addUnitPriority('month', 8);\n\n    // PARSING\n\n    addRegexToken('M', match1to2);\n    addRegexToken('MM', match1to2, match2);\n    addRegexToken('MMM', function (isStrict, locale) {\n        return locale.monthsShortRegex(isStrict);\n    });\n    addRegexToken('MMMM', function (isStrict, locale) {\n        return locale.monthsRegex(isStrict);\n    });\n\n    addParseToken(['M', 'MM'], function (input, array) {\n        array[MONTH] = toInt(input) - 1;\n    });\n\n    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\n        var month = config._locale.monthsParse(input, token, config._strict);\n        // if we didn't find a month name, mark the date as invalid.\n        if (month != null) {\n            array[MONTH] = month;\n        } else {\n            getParsingFlags(config).invalidMonth = input;\n        }\n    });\n\n    // LOCALES\n\n    var defaultLocaleMonths =\n            'January_February_March_April_May_June_July_August_September_October_November_December'.split(\n                '_'\n            ),\n        defaultLocaleMonthsShort =\n            'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n        MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/,\n        defaultMonthsShortRegex = matchWord,\n        defaultMonthsRegex = matchWord;\n\n    function localeMonths(m, format) {\n        if (!m) {\n            return isArray(this._months)\n                ? this._months\n                : this._months['standalone'];\n        }\n        return isArray(this._months)\n            ? this._months[m.month()]\n            : this._months[\n                  (this._months.isFormat || MONTHS_IN_FORMAT).test(format)\n                      ? 'format'\n                      : 'standalone'\n              ][m.month()];\n    }\n\n    function localeMonthsShort(m, format) {\n        if (!m) {\n            return isArray(this._monthsShort)\n                ? this._monthsShort\n                : this._monthsShort['standalone'];\n        }\n        return isArray(this._monthsShort)\n            ? this._monthsShort[m.month()]\n            : this._monthsShort[\n                  MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'\n              ][m.month()];\n    }\n\n    function handleStrictParse(monthName, format, strict) {\n        var i,\n            ii,\n            mom,\n            llc = monthName.toLocaleLowerCase();\n        if (!this._monthsParse) {\n            // this is not used\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n            for (i = 0; i < 12; ++i) {\n                mom = createUTC([2000, i]);\n                this._shortMonthsParse[i] = this.monthsShort(\n                    mom,\n                    ''\n                ).toLocaleLowerCase();\n                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();\n            }\n        }\n\n        if (strict) {\n            if (format === 'MMM') {\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === 'MMM') {\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n\n    function localeMonthsParse(monthName, format, strict) {\n        var i, mom, regex;\n\n        if (this._monthsParseExact) {\n            return handleStrictParse.call(this, monthName, format, strict);\n        }\n\n        if (!this._monthsParse) {\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n        }\n\n        // TODO: add sorting\n        // Sorting makes sure if one month (or abbr) is a prefix of another\n        // see sorting in computeMonthsParse\n        for (i = 0; i < 12; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, i]);\n            if (strict && !this._longMonthsParse[i]) {\n                this._longMonthsParse[i] = new RegExp(\n                    '^' + this.months(mom, '').replace('.', '') + '$',\n                    'i'\n                );\n                this._shortMonthsParse[i] = new RegExp(\n                    '^' + this.monthsShort(mom, '').replace('.', '') + '$',\n                    'i'\n                );\n            }\n            if (!strict && !this._monthsParse[i]) {\n                regex =\n                    '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (\n                strict &&\n                format === 'MMMM' &&\n                this._longMonthsParse[i].test(monthName)\n            ) {\n                return i;\n            } else if (\n                strict &&\n                format === 'MMM' &&\n                this._shortMonthsParse[i].test(monthName)\n            ) {\n                return i;\n            } else if (!strict && this._monthsParse[i].test(monthName)) {\n                return i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function setMonth(mom, value) {\n        var dayOfMonth;\n\n        if (!mom.isValid()) {\n            // No op\n            return mom;\n        }\n\n        if (typeof value === 'string') {\n            if (/^\\d+$/.test(value)) {\n                value = toInt(value);\n            } else {\n                value = mom.localeData().monthsParse(value);\n                // TODO: Another silent failure?\n                if (!isNumber(value)) {\n                    return mom;\n                }\n            }\n        }\n\n        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\n        return mom;\n    }\n\n    function getSetMonth(value) {\n        if (value != null) {\n            setMonth(this, value);\n            hooks.updateOffset(this, true);\n            return this;\n        } else {\n            return get(this, 'Month');\n        }\n    }\n\n    function getDaysInMonth() {\n        return daysInMonth(this.year(), this.month());\n    }\n\n    function monthsShortRegex(isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsShortStrictRegex;\n            } else {\n                return this._monthsShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_monthsShortRegex')) {\n                this._monthsShortRegex = defaultMonthsShortRegex;\n            }\n            return this._monthsShortStrictRegex && isStrict\n                ? this._monthsShortStrictRegex\n                : this._monthsShortRegex;\n        }\n    }\n\n    function monthsRegex(isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsStrictRegex;\n            } else {\n                return this._monthsRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                this._monthsRegex = defaultMonthsRegex;\n            }\n            return this._monthsStrictRegex && isStrict\n                ? this._monthsStrictRegex\n                : this._monthsRegex;\n        }\n    }\n\n    function computeMonthsParse() {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n\n        var shortPieces = [],\n            longPieces = [],\n            mixedPieces = [],\n            i,\n            mom;\n        for (i = 0; i < 12; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, i]);\n            shortPieces.push(this.monthsShort(mom, ''));\n            longPieces.push(this.months(mom, ''));\n            mixedPieces.push(this.months(mom, ''));\n            mixedPieces.push(this.monthsShort(mom, ''));\n        }\n        // Sorting makes sure if one month (or abbr) is a prefix of another it\n        // will match the longer piece.\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n        for (i = 0; i < 12; i++) {\n            shortPieces[i] = regexEscape(shortPieces[i]);\n            longPieces[i] = regexEscape(longPieces[i]);\n        }\n        for (i = 0; i < 24; i++) {\n            mixedPieces[i] = regexEscape(mixedPieces[i]);\n        }\n\n        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n        this._monthsShortRegex = this._monthsRegex;\n        this._monthsStrictRegex = new RegExp(\n            '^(' + longPieces.join('|') + ')',\n            'i'\n        );\n        this._monthsShortStrictRegex = new RegExp(\n            '^(' + shortPieces.join('|') + ')',\n            'i'\n        );\n    }\n\n    // FORMATTING\n\n    addFormatToken('Y', 0, 0, function () {\n        var y = this.year();\n        return y <= 9999 ? zeroFill(y, 4) : '+' + y;\n    });\n\n    addFormatToken(0, ['YY', 2], 0, function () {\n        return this.year() % 100;\n    });\n\n    addFormatToken(0, ['YYYY', 4], 0, 'year');\n    addFormatToken(0, ['YYYYY', 5], 0, 'year');\n    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\n\n    // ALIASES\n\n    addUnitAlias('year', 'y');\n\n    // PRIORITIES\n\n    addUnitPriority('year', 1);\n\n    // PARSING\n\n    addRegexToken('Y', matchSigned);\n    addRegexToken('YY', match1to2, match2);\n    addRegexToken('YYYY', match1to4, match4);\n    addRegexToken('YYYYY', match1to6, match6);\n    addRegexToken('YYYYYY', match1to6, match6);\n\n    addParseToken(['YYYYY', 'YYYYYY'], YEAR);\n    addParseToken('YYYY', function (input, array) {\n        array[YEAR] =\n            input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\n    });\n    addParseToken('YY', function (input, array) {\n        array[YEAR] = hooks.parseTwoDigitYear(input);\n    });\n    addParseToken('Y', function (input, array) {\n        array[YEAR] = parseInt(input, 10);\n    });\n\n    // HELPERS\n\n    function daysInYear(year) {\n        return isLeapYear(year) ? 366 : 365;\n    }\n\n    // HOOKS\n\n    hooks.parseTwoDigitYear = function (input) {\n        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n    };\n\n    // MOMENTS\n\n    var getSetYear = makeGetSet('FullYear', true);\n\n    function getIsLeapYear() {\n        return isLeapYear(this.year());\n    }\n\n    function createDate(y, m, d, h, M, s, ms) {\n        // can't just apply() to create a date:\n        // https://stackoverflow.com/q/181348\n        var date;\n        // the date constructor remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            // preserve leap years using a full 400 year cycle, then reset\n            date = new Date(y + 400, m, d, h, M, s, ms);\n            if (isFinite(date.getFullYear())) {\n                date.setFullYear(y);\n            }\n        } else {\n            date = new Date(y, m, d, h, M, s, ms);\n        }\n\n        return date;\n    }\n\n    function createUTCDate(y) {\n        var date, args;\n        // the Date.UTC function remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            args = Array.prototype.slice.call(arguments);\n            // preserve leap years using a full 400 year cycle, then reset\n            args[0] = y + 400;\n            date = new Date(Date.UTC.apply(null, args));\n            if (isFinite(date.getUTCFullYear())) {\n                date.setUTCFullYear(y);\n            }\n        } else {\n            date = new Date(Date.UTC.apply(null, arguments));\n        }\n\n        return date;\n    }\n\n    // start-of-first-week - start-of-year\n    function firstWeekOffset(year, dow, doy) {\n        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n            fwd = 7 + dow - doy,\n            // first-week day local weekday -- which local weekday is fwd\n            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\n\n        return -fwdlw + fwd - 1;\n    }\n\n    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {\n        var localWeekday = (7 + weekday - dow) % 7,\n            weekOffset = firstWeekOffset(year, dow, doy),\n            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\n            resYear,\n            resDayOfYear;\n\n        if (dayOfYear <= 0) {\n            resYear = year - 1;\n            resDayOfYear = daysInYear(resYear) + dayOfYear;\n        } else if (dayOfYear > daysInYear(year)) {\n            resYear = year + 1;\n            resDayOfYear = dayOfYear - daysInYear(year);\n        } else {\n            resYear = year;\n            resDayOfYear = dayOfYear;\n        }\n\n        return {\n            year: resYear,\n            dayOfYear: resDayOfYear,\n        };\n    }\n\n    function weekOfYear(mom, dow, doy) {\n        var weekOffset = firstWeekOffset(mom.year(), dow, doy),\n            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,\n            resWeek,\n            resYear;\n\n        if (week < 1) {\n            resYear = mom.year() - 1;\n            resWeek = week + weeksInYear(resYear, dow, doy);\n        } else if (week > weeksInYear(mom.year(), dow, doy)) {\n            resWeek = week - weeksInYear(mom.year(), dow, doy);\n            resYear = mom.year() + 1;\n        } else {\n            resYear = mom.year();\n            resWeek = week;\n        }\n\n        return {\n            week: resWeek,\n            year: resYear,\n        };\n    }\n\n    function weeksInYear(year, dow, doy) {\n        var weekOffset = firstWeekOffset(year, dow, doy),\n            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\n        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\n    }\n\n    // FORMATTING\n\n    addFormatToken('w', ['ww', 2], 'wo', 'week');\n    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\n\n    // ALIASES\n\n    addUnitAlias('week', 'w');\n    addUnitAlias('isoWeek', 'W');\n\n    // PRIORITIES\n\n    addUnitPriority('week', 5);\n    addUnitPriority('isoWeek', 5);\n\n    // PARSING\n\n    addRegexToken('w', match1to2);\n    addRegexToken('ww', match1to2, match2);\n    addRegexToken('W', match1to2);\n    addRegexToken('WW', match1to2, match2);\n\n    addWeekParseToken(\n        ['w', 'ww', 'W', 'WW'],\n        function (input, week, config, token) {\n            week[token.substr(0, 1)] = toInt(input);\n        }\n    );\n\n    // HELPERS\n\n    // LOCALES\n\n    function localeWeek(mom) {\n        return weekOfYear(mom, this._week.dow, this._week.doy).week;\n    }\n\n    var defaultLocaleWeek = {\n        dow: 0, // Sunday is the first day of the week.\n        doy: 6, // The week that contains Jan 6th is the first week of the year.\n    };\n\n    function localeFirstDayOfWeek() {\n        return this._week.dow;\n    }\n\n    function localeFirstDayOfYear() {\n        return this._week.doy;\n    }\n\n    // MOMENTS\n\n    function getSetWeek(input) {\n        var week = this.localeData().week(this);\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    function getSetISOWeek(input) {\n        var week = weekOfYear(this, 1, 4).week;\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    // FORMATTING\n\n    addFormatToken('d', 0, 'do', 'day');\n\n    addFormatToken('dd', 0, 0, function (format) {\n        return this.localeData().weekdaysMin(this, format);\n    });\n\n    addFormatToken('ddd', 0, 0, function (format) {\n        return this.localeData().weekdaysShort(this, format);\n    });\n\n    addFormatToken('dddd', 0, 0, function (format) {\n        return this.localeData().weekdays(this, format);\n    });\n\n    addFormatToken('e', 0, 0, 'weekday');\n    addFormatToken('E', 0, 0, 'isoWeekday');\n\n    // ALIASES\n\n    addUnitAlias('day', 'd');\n    addUnitAlias('weekday', 'e');\n    addUnitAlias('isoWeekday', 'E');\n\n    // PRIORITY\n    addUnitPriority('day', 11);\n    addUnitPriority('weekday', 11);\n    addUnitPriority('isoWeekday', 11);\n\n    // PARSING\n\n    addRegexToken('d', match1to2);\n    addRegexToken('e', match1to2);\n    addRegexToken('E', match1to2);\n    addRegexToken('dd', function (isStrict, locale) {\n        return locale.weekdaysMinRegex(isStrict);\n    });\n    addRegexToken('ddd', function (isStrict, locale) {\n        return locale.weekdaysShortRegex(isStrict);\n    });\n    addRegexToken('dddd', function (isStrict, locale) {\n        return locale.weekdaysRegex(isStrict);\n    });\n\n    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {\n        var weekday = config._locale.weekdaysParse(input, token, config._strict);\n        // if we didn't get a weekday name, mark the date as invalid\n        if (weekday != null) {\n            week.d = weekday;\n        } else {\n            getParsingFlags(config).invalidWeekday = input;\n        }\n    });\n\n    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\n        week[token] = toInt(input);\n    });\n\n    // HELPERS\n\n    function parseWeekday(input, locale) {\n        if (typeof input !== 'string') {\n            return input;\n        }\n\n        if (!isNaN(input)) {\n            return parseInt(input, 10);\n        }\n\n        input = locale.weekdaysParse(input);\n        if (typeof input === 'number') {\n            return input;\n        }\n\n        return null;\n    }\n\n    function parseIsoWeekday(input, locale) {\n        if (typeof input === 'string') {\n            return locale.weekdaysParse(input) % 7 || 7;\n        }\n        return isNaN(input) ? null : input;\n    }\n\n    // LOCALES\n    function shiftWeekdays(ws, n) {\n        return ws.slice(n, 7).concat(ws.slice(0, n));\n    }\n\n    var defaultLocaleWeekdays =\n            'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n        defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n        defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n        defaultWeekdaysRegex = matchWord,\n        defaultWeekdaysShortRegex = matchWord,\n        defaultWeekdaysMinRegex = matchWord;\n\n    function localeWeekdays(m, format) {\n        var weekdays = isArray(this._weekdays)\n            ? this._weekdays\n            : this._weekdays[\n                  m && m !== true && this._weekdays.isFormat.test(format)\n                      ? 'format'\n                      : 'standalone'\n              ];\n        return m === true\n            ? shiftWeekdays(weekdays, this._week.dow)\n            : m\n            ? weekdays[m.day()]\n            : weekdays;\n    }\n\n    function localeWeekdaysShort(m) {\n        return m === true\n            ? shiftWeekdays(this._weekdaysShort, this._week.dow)\n            : m\n            ? this._weekdaysShort[m.day()]\n            : this._weekdaysShort;\n    }\n\n    function localeWeekdaysMin(m) {\n        return m === true\n            ? shiftWeekdays(this._weekdaysMin, this._week.dow)\n            : m\n            ? this._weekdaysMin[m.day()]\n            : this._weekdaysMin;\n    }\n\n    function handleStrictParse$1(weekdayName, format, strict) {\n        var i,\n            ii,\n            mom,\n            llc = weekdayName.toLocaleLowerCase();\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._minWeekdaysParse = [];\n\n            for (i = 0; i < 7; ++i) {\n                mom = createUTC([2000, 1]).day(i);\n                this._minWeekdaysParse[i] = this.weekdaysMin(\n                    mom,\n                    ''\n                ).toLocaleLowerCase();\n                this._shortWeekdaysParse[i] = this.weekdaysShort(\n                    mom,\n                    ''\n                ).toLocaleLowerCase();\n                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();\n            }\n        }\n\n        if (strict) {\n            if (format === 'dddd') {\n                ii = indexOf.call(this._weekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === 'ddd') {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === 'dddd') {\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === 'ddd') {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n\n    function localeWeekdaysParse(weekdayName, format, strict) {\n        var i, mom, regex;\n\n        if (this._weekdaysParseExact) {\n            return handleStrictParse$1.call(this, weekdayName, format, strict);\n        }\n\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._minWeekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._fullWeekdaysParse = [];\n        }\n\n        for (i = 0; i < 7; i++) {\n            // make the regex if we don't have it already\n\n            mom = createUTC([2000, 1]).day(i);\n            if (strict && !this._fullWeekdaysParse[i]) {\n                this._fullWeekdaysParse[i] = new RegExp(\n                    '^' + this.weekdays(mom, '').replace('.', '\\\\.?') + '$',\n                    'i'\n                );\n                this._shortWeekdaysParse[i] = new RegExp(\n                    '^' + this.weekdaysShort(mom, '').replace('.', '\\\\.?') + '$',\n                    'i'\n                );\n                this._minWeekdaysParse[i] = new RegExp(\n                    '^' + this.weekdaysMin(mom, '').replace('.', '\\\\.?') + '$',\n                    'i'\n                );\n            }\n            if (!this._weekdaysParse[i]) {\n                regex =\n                    '^' +\n                    this.weekdays(mom, '') +\n                    '|^' +\n                    this.weekdaysShort(mom, '') +\n                    '|^' +\n                    this.weekdaysMin(mom, '');\n                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (\n                strict &&\n                format === 'dddd' &&\n                this._fullWeekdaysParse[i].test(weekdayName)\n            ) {\n                return i;\n            } else if (\n                strict &&\n                format === 'ddd' &&\n                this._shortWeekdaysParse[i].test(weekdayName)\n            ) {\n                return i;\n            } else if (\n                strict &&\n                format === 'dd' &&\n                this._minWeekdaysParse[i].test(weekdayName)\n            ) {\n                return i;\n            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\n                return i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function getSetDayOfWeek(input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n        if (input != null) {\n            input = parseWeekday(input, this.localeData());\n            return this.add(input - day, 'd');\n        } else {\n            return day;\n        }\n    }\n\n    function getSetLocaleDayOfWeek(input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n        return input == null ? weekday : this.add(input - weekday, 'd');\n    }\n\n    function getSetISODayOfWeek(input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n\n        // behaves the same as moment#day except\n        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n        // as a setter, sunday should belong to the previous week.\n\n        if (input != null) {\n            var weekday = parseIsoWeekday(input, this.localeData());\n            return this.day(this.day() % 7 ? weekday : weekday - 7);\n        } else {\n            return this.day() || 7;\n        }\n    }\n\n    function weekdaysRegex(isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysStrictRegex;\n            } else {\n                return this._weekdaysRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                this._weekdaysRegex = defaultWeekdaysRegex;\n            }\n            return this._weekdaysStrictRegex && isStrict\n                ? this._weekdaysStrictRegex\n                : this._weekdaysRegex;\n        }\n    }\n\n    function weekdaysShortRegex(isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysShortStrictRegex;\n            } else {\n                return this._weekdaysShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysShortRegex')) {\n                this._weekdaysShortRegex = defaultWeekdaysShortRegex;\n            }\n            return this._weekdaysShortStrictRegex && isStrict\n                ? this._weekdaysShortStrictRegex\n                : this._weekdaysShortRegex;\n        }\n    }\n\n    function weekdaysMinRegex(isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysMinStrictRegex;\n            } else {\n                return this._weekdaysMinRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysMinRegex')) {\n                this._weekdaysMinRegex = defaultWeekdaysMinRegex;\n            }\n            return this._weekdaysMinStrictRegex && isStrict\n                ? this._weekdaysMinStrictRegex\n                : this._weekdaysMinRegex;\n        }\n    }\n\n    function computeWeekdaysParse() {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n\n        var minPieces = [],\n            shortPieces = [],\n            longPieces = [],\n            mixedPieces = [],\n            i,\n            mom,\n            minp,\n            shortp,\n            longp;\n        for (i = 0; i < 7; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, 1]).day(i);\n            minp = regexEscape(this.weekdaysMin(mom, ''));\n            shortp = regexEscape(this.weekdaysShort(mom, ''));\n            longp = regexEscape(this.weekdays(mom, ''));\n            minPieces.push(minp);\n            shortPieces.push(shortp);\n            longPieces.push(longp);\n            mixedPieces.push(minp);\n            mixedPieces.push(shortp);\n            mixedPieces.push(longp);\n        }\n        // Sorting makes sure if one weekday (or abbr) is a prefix of another it\n        // will match the longer piece.\n        minPieces.sort(cmpLenRev);\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n\n        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n        this._weekdaysShortRegex = this._weekdaysRegex;\n        this._weekdaysMinRegex = this._weekdaysRegex;\n\n        this._weekdaysStrictRegex = new RegExp(\n            '^(' + longPieces.join('|') + ')',\n            'i'\n        );\n        this._weekdaysShortStrictRegex = new RegExp(\n            '^(' + shortPieces.join('|') + ')',\n            'i'\n        );\n        this._weekdaysMinStrictRegex = new RegExp(\n            '^(' + minPieces.join('|') + ')',\n            'i'\n        );\n    }\n\n    // FORMATTING\n\n    function hFormat() {\n        return this.hours() % 12 || 12;\n    }\n\n    function kFormat() {\n        return this.hours() || 24;\n    }\n\n    addFormatToken('H', ['HH', 2], 0, 'hour');\n    addFormatToken('h', ['hh', 2], 0, hFormat);\n    addFormatToken('k', ['kk', 2], 0, kFormat);\n\n    addFormatToken('hmm', 0, 0, function () {\n        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);\n    });\n\n    addFormatToken('hmmss', 0, 0, function () {\n        return (\n            '' +\n            hFormat.apply(this) +\n            zeroFill(this.minutes(), 2) +\n            zeroFill(this.seconds(), 2)\n        );\n    });\n\n    addFormatToken('Hmm', 0, 0, function () {\n        return '' + this.hours() + zeroFill(this.minutes(), 2);\n    });\n\n    addFormatToken('Hmmss', 0, 0, function () {\n        return (\n            '' +\n            this.hours() +\n            zeroFill(this.minutes(), 2) +\n            zeroFill(this.seconds(), 2)\n        );\n    });\n\n    function meridiem(token, lowercase) {\n        addFormatToken(token, 0, 0, function () {\n            return this.localeData().meridiem(\n                this.hours(),\n                this.minutes(),\n                lowercase\n            );\n        });\n    }\n\n    meridiem('a', true);\n    meridiem('A', false);\n\n    // ALIASES\n\n    addUnitAlias('hour', 'h');\n\n    // PRIORITY\n    addUnitPriority('hour', 13);\n\n    // PARSING\n\n    function matchMeridiem(isStrict, locale) {\n        return locale._meridiemParse;\n    }\n\n    addRegexToken('a', matchMeridiem);\n    addRegexToken('A', matchMeridiem);\n    addRegexToken('H', match1to2);\n    addRegexToken('h', match1to2);\n    addRegexToken('k', match1to2);\n    addRegexToken('HH', match1to2, match2);\n    addRegexToken('hh', match1to2, match2);\n    addRegexToken('kk', match1to2, match2);\n\n    addRegexToken('hmm', match3to4);\n    addRegexToken('hmmss', match5to6);\n    addRegexToken('Hmm', match3to4);\n    addRegexToken('Hmmss', match5to6);\n\n    addParseToken(['H', 'HH'], HOUR);\n    addParseToken(['k', 'kk'], function (input, array, config) {\n        var kInput = toInt(input);\n        array[HOUR] = kInput === 24 ? 0 : kInput;\n    });\n    addParseToken(['a', 'A'], function (input, array, config) {\n        config._isPm = config._locale.isPM(input);\n        config._meridiem = input;\n    });\n    addParseToken(['h', 'hh'], function (input, array, config) {\n        array[HOUR] = toInt(input);\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('hmm', function (input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('hmmss', function (input, array, config) {\n        var pos1 = input.length - 4,\n            pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('Hmm', function (input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n    });\n    addParseToken('Hmmss', function (input, array, config) {\n        var pos1 = input.length - 4,\n            pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n    });\n\n    // LOCALES\n\n    function localeIsPM(input) {\n        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n        // Using charAt should be more compatible.\n        return (input + '').toLowerCase().charAt(0) === 'p';\n    }\n\n    var defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i,\n        // Setting the hour should keep the time, because the user explicitly\n        // specified which hour they want. So trying to maintain the same hour (in\n        // a new timezone) makes sense. Adding/subtracting hours does not follow\n        // this rule.\n        getSetHour = makeGetSet('Hours', true);\n\n    function localeMeridiem(hours, minutes, isLower) {\n        if (hours > 11) {\n            return isLower ? 'pm' : 'PM';\n        } else {\n            return isLower ? 'am' : 'AM';\n        }\n    }\n\n    var baseConfig = {\n        calendar: defaultCalendar,\n        longDateFormat: defaultLongDateFormat,\n        invalidDate: defaultInvalidDate,\n        ordinal: defaultOrdinal,\n        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\n        relativeTime: defaultRelativeTime,\n\n        months: defaultLocaleMonths,\n        monthsShort: defaultLocaleMonthsShort,\n\n        week: defaultLocaleWeek,\n\n        weekdays: defaultLocaleWeekdays,\n        weekdaysMin: defaultLocaleWeekdaysMin,\n        weekdaysShort: defaultLocaleWeekdaysShort,\n\n        meridiemParse: defaultLocaleMeridiemParse,\n    };\n\n    // internal storage for locale config files\n    var locales = {},\n        localeFamilies = {},\n        globalLocale;\n\n    function commonPrefix(arr1, arr2) {\n        var i,\n            minl = Math.min(arr1.length, arr2.length);\n        for (i = 0; i < minl; i += 1) {\n            if (arr1[i] !== arr2[i]) {\n                return i;\n            }\n        }\n        return minl;\n    }\n\n    function normalizeLocale(key) {\n        return key ? key.toLowerCase().replace('_', '-') : key;\n    }\n\n    // pick the locale from the array\n    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\n    function chooseLocale(names) {\n        var i = 0,\n            j,\n            next,\n            locale,\n            split;\n\n        while (i < names.length) {\n            split = normalizeLocale(names[i]).split('-');\n            j = split.length;\n            next = normalizeLocale(names[i + 1]);\n            next = next ? next.split('-') : null;\n            while (j > 0) {\n                locale = loadLocale(split.slice(0, j).join('-'));\n                if (locale) {\n                    return locale;\n                }\n                if (\n                    next &&\n                    next.length >= j &&\n                    commonPrefix(split, next) >= j - 1\n                ) {\n                    //the next array item is better than a shallower substring of this one\n                    break;\n                }\n                j--;\n            }\n            i++;\n        }\n        return globalLocale;\n    }\n\n    function isLocaleNameSane(name) {\n        // Prevent names that look like filesystem paths, i.e contain '/' or '\\'\n        return name.match('^[^/\\\\\\\\]*$') != null;\n    }\n\n    function loadLocale(name) {\n        var oldLocale = null,\n            aliasedRequire;\n        // TODO: Find a better way to register and load all the locales in Node\n        if (\n            locales[name] === undefined &&\n            \"object\" !== 'undefined' &&\n            module &&\n            module.exports &&\n            isLocaleNameSane(name)\n        ) {\n            try {\n                oldLocale = globalLocale._abbr;\n                aliasedRequire = undefined;\n                Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'undefined'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n                getSetGlobalLocale(oldLocale);\n            } catch (e) {\n                // mark as not found to avoid repeating expensive file require call causing high CPU\n                // when trying to find en-US, en_US, en-us for every format call\n                locales[name] = null; // null means not found\n            }\n        }\n        return locales[name];\n    }\n\n    // This function will load locale and then set the global locale.  If\n    // no arguments are passed in, it will simply return the current global\n    // locale key.\n    function getSetGlobalLocale(key, values) {\n        var data;\n        if (key) {\n            if (isUndefined(values)) {\n                data = getLocale(key);\n            } else {\n                data = defineLocale(key, values);\n            }\n\n            if (data) {\n                // moment.duration._locale = moment._locale = data;\n                globalLocale = data;\n            } else {\n                if (typeof console !== 'undefined' && console.warn) {\n                    //warn user if arguments are passed but the locale could not be set\n                    console.warn(\n                        'Locale ' + key + ' not found. Did you forget to load it?'\n                    );\n                }\n            }\n        }\n\n        return globalLocale._abbr;\n    }\n\n    function defineLocale(name, config) {\n        if (config !== null) {\n            var locale,\n                parentConfig = baseConfig;\n            config.abbr = name;\n            if (locales[name] != null) {\n                deprecateSimple(\n                    'defineLocaleOverride',\n                    'use moment.updateLocale(localeName, config) to change ' +\n                        'an existing locale. moment.defineLocale(localeName, ' +\n                        'config) should only be used for creating a new locale ' +\n                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'\n                );\n                parentConfig = locales[name]._config;\n            } else if (config.parentLocale != null) {\n                if (locales[config.parentLocale] != null) {\n                    parentConfig = locales[config.parentLocale]._config;\n                } else {\n                    locale = loadLocale(config.parentLocale);\n                    if (locale != null) {\n                        parentConfig = locale._config;\n                    } else {\n                        if (!localeFamilies[config.parentLocale]) {\n                            localeFamilies[config.parentLocale] = [];\n                        }\n                        localeFamilies[config.parentLocale].push({\n                            name: name,\n                            config: config,\n                        });\n                        return null;\n                    }\n                }\n            }\n            locales[name] = new Locale(mergeConfigs(parentConfig, config));\n\n            if (localeFamilies[name]) {\n                localeFamilies[name].forEach(function (x) {\n                    defineLocale(x.name, x.config);\n                });\n            }\n\n            // backwards compat for now: also set the locale\n            // make sure we set the locale AFTER all child locales have been\n            // created, so we won't end up with the child locale set.\n            getSetGlobalLocale(name);\n\n            return locales[name];\n        } else {\n            // useful for testing\n            delete locales[name];\n            return null;\n        }\n    }\n\n    function updateLocale(name, config) {\n        if (config != null) {\n            var locale,\n                tmpLocale,\n                parentConfig = baseConfig;\n\n            if (locales[name] != null && locales[name].parentLocale != null) {\n                // Update existing child locale in-place to avoid memory-leaks\n                locales[name].set(mergeConfigs(locales[name]._config, config));\n            } else {\n                // MERGE\n                tmpLocale = loadLocale(name);\n                if (tmpLocale != null) {\n                    parentConfig = tmpLocale._config;\n                }\n                config = mergeConfigs(parentConfig, config);\n                if (tmpLocale == null) {\n                    // updateLocale is called for creating a new locale\n                    // Set abbr so it will have a name (getters return\n                    // undefined otherwise).\n                    config.abbr = name;\n                }\n                locale = new Locale(config);\n                locale.parentLocale = locales[name];\n                locales[name] = locale;\n            }\n\n            // backwards compat for now: also set the locale\n            getSetGlobalLocale(name);\n        } else {\n            // pass null for config to unupdate, useful for tests\n            if (locales[name] != null) {\n                if (locales[name].parentLocale != null) {\n                    locales[name] = locales[name].parentLocale;\n                    if (name === getSetGlobalLocale()) {\n                        getSetGlobalLocale(name);\n                    }\n                } else if (locales[name] != null) {\n                    delete locales[name];\n                }\n            }\n        }\n        return locales[name];\n    }\n\n    // returns locale data\n    function getLocale(key) {\n        var locale;\n\n        if (key && key._locale && key._locale._abbr) {\n            key = key._locale._abbr;\n        }\n\n        if (!key) {\n            return globalLocale;\n        }\n\n        if (!isArray(key)) {\n            //short-circuit everything else\n            locale = loadLocale(key);\n            if (locale) {\n                return locale;\n            }\n            key = [key];\n        }\n\n        return chooseLocale(key);\n    }\n\n    function listLocales() {\n        return keys(locales);\n    }\n\n    function checkOverflow(m) {\n        var overflow,\n            a = m._a;\n\n        if (a && getParsingFlags(m).overflow === -2) {\n            overflow =\n                a[MONTH] < 0 || a[MONTH] > 11\n                    ? MONTH\n                    : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])\n                    ? DATE\n                    : a[HOUR] < 0 ||\n                      a[HOUR] > 24 ||\n                      (a[HOUR] === 24 &&\n                          (a[MINUTE] !== 0 ||\n                              a[SECOND] !== 0 ||\n                              a[MILLISECOND] !== 0))\n                    ? HOUR\n                    : a[MINUTE] < 0 || a[MINUTE] > 59\n                    ? MINUTE\n                    : a[SECOND] < 0 || a[SECOND] > 59\n                    ? SECOND\n                    : a[MILLISECOND] < 0 || a[MILLISECOND] > 999\n                    ? MILLISECOND\n                    : -1;\n\n            if (\n                getParsingFlags(m)._overflowDayOfYear &&\n                (overflow < YEAR || overflow > DATE)\n            ) {\n                overflow = DATE;\n            }\n            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\n                overflow = WEEK;\n            }\n            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\n                overflow = WEEKDAY;\n            }\n\n            getParsingFlags(m).overflow = overflow;\n        }\n\n        return m;\n    }\n\n    // iso 8601 regex\n    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\n    var extendedIsoRegex =\n            /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([+-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/,\n        basicIsoRegex =\n            /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d|))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([+-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/,\n        tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/,\n        isoDates = [\n            ['YYYYYY-MM-DD', /[+-]\\d{6}-\\d\\d-\\d\\d/],\n            ['YYYY-MM-DD', /\\d{4}-\\d\\d-\\d\\d/],\n            ['GGGG-[W]WW-E', /\\d{4}-W\\d\\d-\\d/],\n            ['GGGG-[W]WW', /\\d{4}-W\\d\\d/, false],\n            ['YYYY-DDD', /\\d{4}-\\d{3}/],\n            ['YYYY-MM', /\\d{4}-\\d\\d/, false],\n            ['YYYYYYMMDD', /[+-]\\d{10}/],\n            ['YYYYMMDD', /\\d{8}/],\n            ['GGGG[W]WWE', /\\d{4}W\\d{3}/],\n            ['GGGG[W]WW', /\\d{4}W\\d{2}/, false],\n            ['YYYYDDD', /\\d{7}/],\n            ['YYYYMM', /\\d{6}/, false],\n            ['YYYY', /\\d{4}/, false],\n        ],\n        // iso time formats and regexes\n        isoTimes = [\n            ['HH:mm:ss.SSSS', /\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\n            ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/],\n            ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/],\n            ['HH:mm', /\\d\\d:\\d\\d/],\n            ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/],\n            ['HHmmss,SSSS', /\\d\\d\\d\\d\\d\\d,\\d+/],\n            ['HHmmss', /\\d\\d\\d\\d\\d\\d/],\n            ['HHmm', /\\d\\d\\d\\d/],\n            ['HH', /\\d\\d/],\n        ],\n        aspNetJsonRegex = /^\\/?Date\\((-?\\d+)/i,\n        // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\n        rfc2822 =\n            /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/,\n        obsOffsets = {\n            UT: 0,\n            GMT: 0,\n            EDT: -4 * 60,\n            EST: -5 * 60,\n            CDT: -5 * 60,\n            CST: -6 * 60,\n            MDT: -6 * 60,\n            MST: -7 * 60,\n            PDT: -7 * 60,\n            PST: -8 * 60,\n        };\n\n    // date from iso format\n    function configFromISO(config) {\n        var i,\n            l,\n            string = config._i,\n            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\n            allowTime,\n            dateFormat,\n            timeFormat,\n            tzFormat,\n            isoDatesLen = isoDates.length,\n            isoTimesLen = isoTimes.length;\n\n        if (match) {\n            getParsingFlags(config).iso = true;\n            for (i = 0, l = isoDatesLen; i < l; i++) {\n                if (isoDates[i][1].exec(match[1])) {\n                    dateFormat = isoDates[i][0];\n                    allowTime = isoDates[i][2] !== false;\n                    break;\n                }\n            }\n            if (dateFormat == null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[3]) {\n                for (i = 0, l = isoTimesLen; i < l; i++) {\n                    if (isoTimes[i][1].exec(match[3])) {\n                        // match[2] should be 'T' or space\n                        timeFormat = (match[2] || ' ') + isoTimes[i][0];\n                        break;\n                    }\n                }\n                if (timeFormat == null) {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            if (!allowTime && timeFormat != null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[4]) {\n                if (tzRegex.exec(match[4])) {\n                    tzFormat = 'Z';\n                } else {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\n            configFromStringAndFormat(config);\n        } else {\n            config._isValid = false;\n        }\n    }\n\n    function extractFromRFC2822Strings(\n        yearStr,\n        monthStr,\n        dayStr,\n        hourStr,\n        minuteStr,\n        secondStr\n    ) {\n        var result = [\n            untruncateYear(yearStr),\n            defaultLocaleMonthsShort.indexOf(monthStr),\n            parseInt(dayStr, 10),\n            parseInt(hourStr, 10),\n            parseInt(minuteStr, 10),\n        ];\n\n        if (secondStr) {\n            result.push(parseInt(secondStr, 10));\n        }\n\n        return result;\n    }\n\n    function untruncateYear(yearStr) {\n        var year = parseInt(yearStr, 10);\n        if (year <= 49) {\n            return 2000 + year;\n        } else if (year <= 999) {\n            return 1900 + year;\n        }\n        return year;\n    }\n\n    function preprocessRFC2822(s) {\n        // Remove comments and folding whitespace and replace multiple-spaces with a single space\n        return s\n            .replace(/\\([^()]*\\)|[\\n\\t]/g, ' ')\n            .replace(/(\\s\\s+)/g, ' ')\n            .replace(/^\\s\\s*/, '')\n            .replace(/\\s\\s*$/, '');\n    }\n\n    function checkWeekday(weekdayStr, parsedInput, config) {\n        if (weekdayStr) {\n            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.\n            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),\n                weekdayActual = new Date(\n                    parsedInput[0],\n                    parsedInput[1],\n                    parsedInput[2]\n                ).getDay();\n            if (weekdayProvided !== weekdayActual) {\n                getParsingFlags(config).weekdayMismatch = true;\n                config._isValid = false;\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function calculateOffset(obsOffset, militaryOffset, numOffset) {\n        if (obsOffset) {\n            return obsOffsets[obsOffset];\n        } else if (militaryOffset) {\n            // the only allowed military tz is Z\n            return 0;\n        } else {\n            var hm = parseInt(numOffset, 10),\n                m = hm % 100,\n                h = (hm - m) / 100;\n            return h * 60 + m;\n        }\n    }\n\n    // date and time from ref 2822 format\n    function configFromRFC2822(config) {\n        var match = rfc2822.exec(preprocessRFC2822(config._i)),\n            parsedArray;\n        if (match) {\n            parsedArray = extractFromRFC2822Strings(\n                match[4],\n                match[3],\n                match[2],\n                match[5],\n                match[6],\n                match[7]\n            );\n            if (!checkWeekday(match[1], parsedArray, config)) {\n                return;\n            }\n\n            config._a = parsedArray;\n            config._tzm = calculateOffset(match[8], match[9], match[10]);\n\n            config._d = createUTCDate.apply(null, config._a);\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n\n            getParsingFlags(config).rfc2822 = true;\n        } else {\n            config._isValid = false;\n        }\n    }\n\n    // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict\n    function configFromString(config) {\n        var matched = aspNetJsonRegex.exec(config._i);\n        if (matched !== null) {\n            config._d = new Date(+matched[1]);\n            return;\n        }\n\n        configFromISO(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n\n        configFromRFC2822(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n\n        if (config._strict) {\n            config._isValid = false;\n        } else {\n            // Final attempt, use Input Fallback\n            hooks.createFromInputFallback(config);\n        }\n    }\n\n    hooks.createFromInputFallback = deprecate(\n        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +\n            'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +\n            'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',\n        function (config) {\n            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\n        }\n    );\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function currentDateArray(config) {\n        // hooks is actually the exported moment object\n        var nowValue = new Date(hooks.now());\n        if (config._useUTC) {\n            return [\n                nowValue.getUTCFullYear(),\n                nowValue.getUTCMonth(),\n                nowValue.getUTCDate(),\n            ];\n        }\n        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\n    }\n\n    // convert an array to a date.\n    // the array should mirror the parameters below\n    // note: all values past the year are optional and will default to the lowest possible value.\n    // [year, month, day , hour, minute, second, millisecond]\n    function configFromArray(config) {\n        var i,\n            date,\n            input = [],\n            currentDate,\n            expectedWeekday,\n            yearToUse;\n\n        if (config._d) {\n            return;\n        }\n\n        currentDate = currentDateArray(config);\n\n        //compute day of the year from weeks and weekdays\n        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n            dayOfYearFromWeekInfo(config);\n        }\n\n        //if the day of the year is set, figure out what it is\n        if (config._dayOfYear != null) {\n            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n\n            if (\n                config._dayOfYear > daysInYear(yearToUse) ||\n                config._dayOfYear === 0\n            ) {\n                getParsingFlags(config)._overflowDayOfYear = true;\n            }\n\n            date = createUTCDate(yearToUse, 0, config._dayOfYear);\n            config._a[MONTH] = date.getUTCMonth();\n            config._a[DATE] = date.getUTCDate();\n        }\n\n        // Default to current date.\n        // * if no year, month, day of month are given, default to today\n        // * if day of month is given, default month and year\n        // * if month is given, default only year\n        // * if year is given, don't default anything\n        for (i = 0; i < 3 && config._a[i] == null; ++i) {\n            config._a[i] = input[i] = currentDate[i];\n        }\n\n        // Zero out whatever was not defaulted, including time\n        for (; i < 7; i++) {\n            config._a[i] = input[i] =\n                config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];\n        }\n\n        // Check for 24:00:00.000\n        if (\n            config._a[HOUR] === 24 &&\n            config._a[MINUTE] === 0 &&\n            config._a[SECOND] === 0 &&\n            config._a[MILLISECOND] === 0\n        ) {\n            config._nextDay = true;\n            config._a[HOUR] = 0;\n        }\n\n        config._d = (config._useUTC ? createUTCDate : createDate).apply(\n            null,\n            input\n        );\n        expectedWeekday = config._useUTC\n            ? config._d.getUTCDay()\n            : config._d.getDay();\n\n        // Apply timezone offset from input. The actual utcOffset can be changed\n        // with parseZone.\n        if (config._tzm != null) {\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n        }\n\n        if (config._nextDay) {\n            config._a[HOUR] = 24;\n        }\n\n        // check for mismatching day of week\n        if (\n            config._w &&\n            typeof config._w.d !== 'undefined' &&\n            config._w.d !== expectedWeekday\n        ) {\n            getParsingFlags(config).weekdayMismatch = true;\n        }\n    }\n\n    function dayOfYearFromWeekInfo(config) {\n        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;\n\n        w = config._w;\n        if (w.GG != null || w.W != null || w.E != null) {\n            dow = 1;\n            doy = 4;\n\n            // TODO: We need to take the current isoWeekYear, but that depends on\n            // how we interpret now (local, utc, fixed offset). So create\n            // a now version of current config (take local/utc/offset flags, and\n            // create now).\n            weekYear = defaults(\n                w.GG,\n                config._a[YEAR],\n                weekOfYear(createLocal(), 1, 4).year\n            );\n            week = defaults(w.W, 1);\n            weekday = defaults(w.E, 1);\n            if (weekday < 1 || weekday > 7) {\n                weekdayOverflow = true;\n            }\n        } else {\n            dow = config._locale._week.dow;\n            doy = config._locale._week.doy;\n\n            curWeek = weekOfYear(createLocal(), dow, doy);\n\n            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);\n\n            // Default to current week.\n            week = defaults(w.w, curWeek.week);\n\n            if (w.d != null) {\n                // weekday -- low day numbers are considered next week\n                weekday = w.d;\n                if (weekday < 0 || weekday > 6) {\n                    weekdayOverflow = true;\n                }\n            } else if (w.e != null) {\n                // local weekday -- counting starts from beginning of week\n                weekday = w.e + dow;\n                if (w.e < 0 || w.e > 6) {\n                    weekdayOverflow = true;\n                }\n            } else {\n                // default to beginning of week\n                weekday = dow;\n            }\n        }\n        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\n            getParsingFlags(config)._overflowWeeks = true;\n        } else if (weekdayOverflow != null) {\n            getParsingFlags(config)._overflowWeekday = true;\n        } else {\n            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\n            config._a[YEAR] = temp.year;\n            config._dayOfYear = temp.dayOfYear;\n        }\n    }\n\n    // constant that refers to the ISO standard\n    hooks.ISO_8601 = function () {};\n\n    // constant that refers to the RFC 2822 form\n    hooks.RFC_2822 = function () {};\n\n    // date from string and format string\n    function configFromStringAndFormat(config) {\n        // TODO: Move this to another part of the creation flow to prevent circular deps\n        if (config._f === hooks.ISO_8601) {\n            configFromISO(config);\n            return;\n        }\n        if (config._f === hooks.RFC_2822) {\n            configFromRFC2822(config);\n            return;\n        }\n        config._a = [];\n        getParsingFlags(config).empty = true;\n\n        // This array is used to make a Date, either with `new Date` or `Date.UTC`\n        var string = '' + config._i,\n            i,\n            parsedInput,\n            tokens,\n            token,\n            skipped,\n            stringLength = string.length,\n            totalParsedInputLength = 0,\n            era,\n            tokenLen;\n\n        tokens =\n            expandFormat(config._f, config._locale).match(formattingTokens) || [];\n        tokenLen = tokens.length;\n        for (i = 0; i < tokenLen; i++) {\n            token = tokens[i];\n            parsedInput = (string.match(getParseRegexForToken(token, config)) ||\n                [])[0];\n            if (parsedInput) {\n                skipped = string.substr(0, string.indexOf(parsedInput));\n                if (skipped.length > 0) {\n                    getParsingFlags(config).unusedInput.push(skipped);\n                }\n                string = string.slice(\n                    string.indexOf(parsedInput) + parsedInput.length\n                );\n                totalParsedInputLength += parsedInput.length;\n            }\n            // don't parse if it's not a known token\n            if (formatTokenFunctions[token]) {\n                if (parsedInput) {\n                    getParsingFlags(config).empty = false;\n                } else {\n                    getParsingFlags(config).unusedTokens.push(token);\n                }\n                addTimeToArrayFromToken(token, parsedInput, config);\n            } else if (config._strict && !parsedInput) {\n                getParsingFlags(config).unusedTokens.push(token);\n            }\n        }\n\n        // add remaining unparsed input length to the string\n        getParsingFlags(config).charsLeftOver =\n            stringLength - totalParsedInputLength;\n        if (string.length > 0) {\n            getParsingFlags(config).unusedInput.push(string);\n        }\n\n        // clear _12h flag if hour is <= 12\n        if (\n            config._a[HOUR] <= 12 &&\n            getParsingFlags(config).bigHour === true &&\n            config._a[HOUR] > 0\n        ) {\n            getParsingFlags(config).bigHour = undefined;\n        }\n\n        getParsingFlags(config).parsedDateParts = config._a.slice(0);\n        getParsingFlags(config).meridiem = config._meridiem;\n        // handle meridiem\n        config._a[HOUR] = meridiemFixWrap(\n            config._locale,\n            config._a[HOUR],\n            config._meridiem\n        );\n\n        // handle era\n        era = getParsingFlags(config).era;\n        if (era !== null) {\n            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);\n        }\n\n        configFromArray(config);\n        checkOverflow(config);\n    }\n\n    function meridiemFixWrap(locale, hour, meridiem) {\n        var isPm;\n\n        if (meridiem == null) {\n            // nothing to do\n            return hour;\n        }\n        if (locale.meridiemHour != null) {\n            return locale.meridiemHour(hour, meridiem);\n        } else if (locale.isPM != null) {\n            // Fallback\n            isPm = locale.isPM(meridiem);\n            if (isPm && hour < 12) {\n                hour += 12;\n            }\n            if (!isPm && hour === 12) {\n                hour = 0;\n            }\n            return hour;\n        } else {\n            // this is not supposed to happen\n            return hour;\n        }\n    }\n\n    // date from string and array of format strings\n    function configFromStringAndArray(config) {\n        var tempConfig,\n            bestMoment,\n            scoreToBeat,\n            i,\n            currentScore,\n            validFormatFound,\n            bestFormatIsValid = false,\n            configfLen = config._f.length;\n\n        if (configfLen === 0) {\n            getParsingFlags(config).invalidFormat = true;\n            config._d = new Date(NaN);\n            return;\n        }\n\n        for (i = 0; i < configfLen; i++) {\n            currentScore = 0;\n            validFormatFound = false;\n            tempConfig = copyConfig({}, config);\n            if (config._useUTC != null) {\n                tempConfig._useUTC = config._useUTC;\n            }\n            tempConfig._f = config._f[i];\n            configFromStringAndFormat(tempConfig);\n\n            if (isValid(tempConfig)) {\n                validFormatFound = true;\n            }\n\n            // if there is any input that was not parsed add a penalty for that format\n            currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\n            //or tokens\n            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n\n            getParsingFlags(tempConfig).score = currentScore;\n\n            if (!bestFormatIsValid) {\n                if (\n                    scoreToBeat == null ||\n                    currentScore < scoreToBeat ||\n                    validFormatFound\n                ) {\n                    scoreToBeat = currentScore;\n                    bestMoment = tempConfig;\n                    if (validFormatFound) {\n                        bestFormatIsValid = true;\n                    }\n                }\n            } else {\n                if (currentScore < scoreToBeat) {\n                    scoreToBeat = currentScore;\n                    bestMoment = tempConfig;\n                }\n            }\n        }\n\n        extend(config, bestMoment || tempConfig);\n    }\n\n    function configFromObject(config) {\n        if (config._d) {\n            return;\n        }\n\n        var i = normalizeObjectUnits(config._i),\n            dayOrDate = i.day === undefined ? i.date : i.day;\n        config._a = map(\n            [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],\n            function (obj) {\n                return obj && parseInt(obj, 10);\n            }\n        );\n\n        configFromArray(config);\n    }\n\n    function createFromConfig(config) {\n        var res = new Moment(checkOverflow(prepareConfig(config)));\n        if (res._nextDay) {\n            // Adding is smart enough around DST\n            res.add(1, 'd');\n            res._nextDay = undefined;\n        }\n\n        return res;\n    }\n\n    function prepareConfig(config) {\n        var input = config._i,\n            format = config._f;\n\n        config._locale = config._locale || getLocale(config._l);\n\n        if (input === null || (format === undefined && input === '')) {\n            return createInvalid({ nullInput: true });\n        }\n\n        if (typeof input === 'string') {\n            config._i = input = config._locale.preparse(input);\n        }\n\n        if (isMoment(input)) {\n            return new Moment(checkOverflow(input));\n        } else if (isDate(input)) {\n            config._d = input;\n        } else if (isArray(format)) {\n            configFromStringAndArray(config);\n        } else if (format) {\n            configFromStringAndFormat(config);\n        } else {\n            configFromInput(config);\n        }\n\n        if (!isValid(config)) {\n            config._d = null;\n        }\n\n        return config;\n    }\n\n    function configFromInput(config) {\n        var input = config._i;\n        if (isUndefined(input)) {\n            config._d = new Date(hooks.now());\n        } else if (isDate(input)) {\n            config._d = new Date(input.valueOf());\n        } else if (typeof input === 'string') {\n            configFromString(config);\n        } else if (isArray(input)) {\n            config._a = map(input.slice(0), function (obj) {\n                return parseInt(obj, 10);\n            });\n            configFromArray(config);\n        } else if (isObject(input)) {\n            configFromObject(config);\n        } else if (isNumber(input)) {\n            // from milliseconds\n            config._d = new Date(input);\n        } else {\n            hooks.createFromInputFallback(config);\n        }\n    }\n\n    function createLocalOrUTC(input, format, locale, strict, isUTC) {\n        var c = {};\n\n        if (format === true || format === false) {\n            strict = format;\n            format = undefined;\n        }\n\n        if (locale === true || locale === false) {\n            strict = locale;\n            locale = undefined;\n        }\n\n        if (\n            (isObject(input) && isObjectEmpty(input)) ||\n            (isArray(input) && input.length === 0)\n        ) {\n            input = undefined;\n        }\n        // object construction must be done this way.\n        // https://github.com/moment/moment/issues/1423\n        c._isAMomentObject = true;\n        c._useUTC = c._isUTC = isUTC;\n        c._l = locale;\n        c._i = input;\n        c._f = format;\n        c._strict = strict;\n\n        return createFromConfig(c);\n    }\n\n    function createLocal(input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, false);\n    }\n\n    var prototypeMin = deprecate(\n            'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',\n            function () {\n                var other = createLocal.apply(null, arguments);\n                if (this.isValid() && other.isValid()) {\n                    return other < this ? this : other;\n                } else {\n                    return createInvalid();\n                }\n            }\n        ),\n        prototypeMax = deprecate(\n            'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',\n            function () {\n                var other = createLocal.apply(null, arguments);\n                if (this.isValid() && other.isValid()) {\n                    return other > this ? this : other;\n                } else {\n                    return createInvalid();\n                }\n            }\n        );\n\n    // Pick a moment m from moments so that m[fn](other) is true for all\n    // other. This relies on the function fn to be transitive.\n    //\n    // moments should either be an array of moment objects or an array, whose\n    // first element is an array of moment objects.\n    function pickBy(fn, moments) {\n        var res, i;\n        if (moments.length === 1 && isArray(moments[0])) {\n            moments = moments[0];\n        }\n        if (!moments.length) {\n            return createLocal();\n        }\n        res = moments[0];\n        for (i = 1; i < moments.length; ++i) {\n            if (!moments[i].isValid() || moments[i][fn](res)) {\n                res = moments[i];\n            }\n        }\n        return res;\n    }\n\n    // TODO: Use [].sort instead?\n    function min() {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isBefore', args);\n    }\n\n    function max() {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isAfter', args);\n    }\n\n    var now = function () {\n        return Date.now ? Date.now() : +new Date();\n    };\n\n    var ordering = [\n        'year',\n        'quarter',\n        'month',\n        'week',\n        'day',\n        'hour',\n        'minute',\n        'second',\n        'millisecond',\n    ];\n\n    function isDurationValid(m) {\n        var key,\n            unitHasDecimal = false,\n            i,\n            orderLen = ordering.length;\n        for (key in m) {\n            if (\n                hasOwnProp(m, key) &&\n                !(\n                    indexOf.call(ordering, key) !== -1 &&\n                    (m[key] == null || !isNaN(m[key]))\n                )\n            ) {\n                return false;\n            }\n        }\n\n        for (i = 0; i < orderLen; ++i) {\n            if (m[ordering[i]]) {\n                if (unitHasDecimal) {\n                    return false; // only allow non-integers for smallest unit\n                }\n                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\n                    unitHasDecimal = true;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    function isValid$1() {\n        return this._isValid;\n    }\n\n    function createInvalid$1() {\n        return createDuration(NaN);\n    }\n\n    function Duration(duration) {\n        var normalizedInput = normalizeObjectUnits(duration),\n            years = normalizedInput.year || 0,\n            quarters = normalizedInput.quarter || 0,\n            months = normalizedInput.month || 0,\n            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,\n            days = normalizedInput.day || 0,\n            hours = normalizedInput.hour || 0,\n            minutes = normalizedInput.minute || 0,\n            seconds = normalizedInput.second || 0,\n            milliseconds = normalizedInput.millisecond || 0;\n\n        this._isValid = isDurationValid(normalizedInput);\n\n        // representation for dateAddRemove\n        this._milliseconds =\n            +milliseconds +\n            seconds * 1e3 + // 1000\n            minutes * 6e4 + // 1000 * 60\n            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\n        // Because of dateAddRemove treats 24 hours as different from a\n        // day when working around DST, we need to store them separately\n        this._days = +days + weeks * 7;\n        // It is impossible to translate months into days without knowing\n        // which months you are are talking about, so we have to store\n        // it separately.\n        this._months = +months + quarters * 3 + years * 12;\n\n        this._data = {};\n\n        this._locale = getLocale();\n\n        this._bubble();\n    }\n\n    function isDuration(obj) {\n        return obj instanceof Duration;\n    }\n\n    function absRound(number) {\n        if (number < 0) {\n            return Math.round(-1 * number) * -1;\n        } else {\n            return Math.round(number);\n        }\n    }\n\n    // compare two arrays, return the number of differences\n    function compareArrays(array1, array2, dontConvert) {\n        var len = Math.min(array1.length, array2.length),\n            lengthDiff = Math.abs(array1.length - array2.length),\n            diffs = 0,\n            i;\n        for (i = 0; i < len; i++) {\n            if (\n                (dontConvert && array1[i] !== array2[i]) ||\n                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))\n            ) {\n                diffs++;\n            }\n        }\n        return diffs + lengthDiff;\n    }\n\n    // FORMATTING\n\n    function offset(token, separator) {\n        addFormatToken(token, 0, 0, function () {\n            var offset = this.utcOffset(),\n                sign = '+';\n            if (offset < 0) {\n                offset = -offset;\n                sign = '-';\n            }\n            return (\n                sign +\n                zeroFill(~~(offset / 60), 2) +\n                separator +\n                zeroFill(~~offset % 60, 2)\n            );\n        });\n    }\n\n    offset('Z', ':');\n    offset('ZZ', '');\n\n    // PARSING\n\n    addRegexToken('Z', matchShortOffset);\n    addRegexToken('ZZ', matchShortOffset);\n    addParseToken(['Z', 'ZZ'], function (input, array, config) {\n        config._useUTC = true;\n        config._tzm = offsetFromString(matchShortOffset, input);\n    });\n\n    // HELPERS\n\n    // timezone chunker\n    // '+10:00' > ['10',  '00']\n    // '-1530'  > ['-15', '30']\n    var chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n\n    function offsetFromString(matcher, string) {\n        var matches = (string || '').match(matcher),\n            chunk,\n            parts,\n            minutes;\n\n        if (matches === null) {\n            return null;\n        }\n\n        chunk = matches[matches.length - 1] || [];\n        parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n        minutes = +(parts[1] * 60) + toInt(parts[2]);\n\n        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;\n    }\n\n    // Return a moment from input, that is local/utc/zone equivalent to model.\n    function cloneWithOffset(input, model) {\n        var res, diff;\n        if (model._isUTC) {\n            res = model.clone();\n            diff =\n                (isMoment(input) || isDate(input)\n                    ? input.valueOf()\n                    : createLocal(input).valueOf()) - res.valueOf();\n            // Use low-level api, because this fn is low-level api.\n            res._d.setTime(res._d.valueOf() + diff);\n            hooks.updateOffset(res, false);\n            return res;\n        } else {\n            return createLocal(input).local();\n        }\n    }\n\n    function getDateOffset(m) {\n        // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n        // https://github.com/moment/moment/pull/1871\n        return -Math.round(m._d.getTimezoneOffset());\n    }\n\n    // HOOKS\n\n    // This function will be called whenever a moment is mutated.\n    // It is intended to keep the offset in sync with the timezone.\n    hooks.updateOffset = function () {};\n\n    // MOMENTS\n\n    // keepLocalTime = true means only change the timezone, without\n    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n    // +0200, so we adjust the time as needed, to be valid.\n    //\n    // Keeping the time actually adds/subtracts (one hour)\n    // from the actual represented time. That is why we call updateOffset\n    // a second time. In case it wants us to change the offset again\n    // _changeInProgress == true case, then we have to adjust, because\n    // there is no such time in the given timezone.\n    function getSetOffset(input, keepLocalTime, keepMinutes) {\n        var offset = this._offset || 0,\n            localAdjust;\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        if (input != null) {\n            if (typeof input === 'string') {\n                input = offsetFromString(matchShortOffset, input);\n                if (input === null) {\n                    return this;\n                }\n            } else if (Math.abs(input) < 16 && !keepMinutes) {\n                input = input * 60;\n            }\n            if (!this._isUTC && keepLocalTime) {\n                localAdjust = getDateOffset(this);\n            }\n            this._offset = input;\n            this._isUTC = true;\n            if (localAdjust != null) {\n                this.add(localAdjust, 'm');\n            }\n            if (offset !== input) {\n                if (!keepLocalTime || this._changeInProgress) {\n                    addSubtract(\n                        this,\n                        createDuration(input - offset, 'm'),\n                        1,\n                        false\n                    );\n                } else if (!this._changeInProgress) {\n                    this._changeInProgress = true;\n                    hooks.updateOffset(this, true);\n                    this._changeInProgress = null;\n                }\n            }\n            return this;\n        } else {\n            return this._isUTC ? offset : getDateOffset(this);\n        }\n    }\n\n    function getSetZone(input, keepLocalTime) {\n        if (input != null) {\n            if (typeof input !== 'string') {\n                input = -input;\n            }\n\n            this.utcOffset(input, keepLocalTime);\n\n            return this;\n        } else {\n            return -this.utcOffset();\n        }\n    }\n\n    function setOffsetToUTC(keepLocalTime) {\n        return this.utcOffset(0, keepLocalTime);\n    }\n\n    function setOffsetToLocal(keepLocalTime) {\n        if (this._isUTC) {\n            this.utcOffset(0, keepLocalTime);\n            this._isUTC = false;\n\n            if (keepLocalTime) {\n                this.subtract(getDateOffset(this), 'm');\n            }\n        }\n        return this;\n    }\n\n    function setOffsetToParsedOffset() {\n        if (this._tzm != null) {\n            this.utcOffset(this._tzm, false, true);\n        } else if (typeof this._i === 'string') {\n            var tZone = offsetFromString(matchOffset, this._i);\n            if (tZone != null) {\n                this.utcOffset(tZone);\n            } else {\n                this.utcOffset(0, true);\n            }\n        }\n        return this;\n    }\n\n    function hasAlignedHourOffset(input) {\n        if (!this.isValid()) {\n            return false;\n        }\n        input = input ? createLocal(input).utcOffset() : 0;\n\n        return (this.utcOffset() - input) % 60 === 0;\n    }\n\n    function isDaylightSavingTime() {\n        return (\n            this.utcOffset() > this.clone().month(0).utcOffset() ||\n            this.utcOffset() > this.clone().month(5).utcOffset()\n        );\n    }\n\n    function isDaylightSavingTimeShifted() {\n        if (!isUndefined(this._isDSTShifted)) {\n            return this._isDSTShifted;\n        }\n\n        var c = {},\n            other;\n\n        copyConfig(c, this);\n        c = prepareConfig(c);\n\n        if (c._a) {\n            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\n            this._isDSTShifted =\n                this.isValid() && compareArrays(c._a, other.toArray()) > 0;\n        } else {\n            this._isDSTShifted = false;\n        }\n\n        return this._isDSTShifted;\n    }\n\n    function isLocal() {\n        return this.isValid() ? !this._isUTC : false;\n    }\n\n    function isUtcOffset() {\n        return this.isValid() ? this._isUTC : false;\n    }\n\n    function isUtc() {\n        return this.isValid() ? this._isUTC && this._offset === 0 : false;\n    }\n\n    // ASP.NET json date format regex\n    var aspNetRegex = /^(-|\\+)?(?:(\\d*)[. ])?(\\d+):(\\d+)(?::(\\d+)(\\.\\d*)?)?$/,\n        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n        // and further modified to allow for strings containing both week and day\n        isoRegex =\n            /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n\n    function createDuration(input, key) {\n        var duration = input,\n            // matching against regexp is expensive, do it on demand\n            match = null,\n            sign,\n            ret,\n            diffRes;\n\n        if (isDuration(input)) {\n            duration = {\n                ms: input._milliseconds,\n                d: input._days,\n                M: input._months,\n            };\n        } else if (isNumber(input) || !isNaN(+input)) {\n            duration = {};\n            if (key) {\n                duration[key] = +input;\n            } else {\n                duration.milliseconds = +input;\n            }\n        } else if ((match = aspNetRegex.exec(input))) {\n            sign = match[1] === '-' ? -1 : 1;\n            duration = {\n                y: 0,\n                d: toInt(match[DATE]) * sign,\n                h: toInt(match[HOUR]) * sign,\n                m: toInt(match[MINUTE]) * sign,\n                s: toInt(match[SECOND]) * sign,\n                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match\n            };\n        } else if ((match = isoRegex.exec(input))) {\n            sign = match[1] === '-' ? -1 : 1;\n            duration = {\n                y: parseIso(match[2], sign),\n                M: parseIso(match[3], sign),\n                w: parseIso(match[4], sign),\n                d: parseIso(match[5], sign),\n                h: parseIso(match[6], sign),\n                m: parseIso(match[7], sign),\n                s: parseIso(match[8], sign),\n            };\n        } else if (duration == null) {\n            // checks for null or undefined\n            duration = {};\n        } else if (\n            typeof duration === 'object' &&\n            ('from' in duration || 'to' in duration)\n        ) {\n            diffRes = momentsDifference(\n                createLocal(duration.from),\n                createLocal(duration.to)\n            );\n\n            duration = {};\n            duration.ms = diffRes.milliseconds;\n            duration.M = diffRes.months;\n        }\n\n        ret = new Duration(duration);\n\n        if (isDuration(input) && hasOwnProp(input, '_locale')) {\n            ret._locale = input._locale;\n        }\n\n        if (isDuration(input) && hasOwnProp(input, '_isValid')) {\n            ret._isValid = input._isValid;\n        }\n\n        return ret;\n    }\n\n    createDuration.fn = Duration.prototype;\n    createDuration.invalid = createInvalid$1;\n\n    function parseIso(inp, sign) {\n        // We'd normally use ~~inp for this, but unfortunately it also\n        // converts floats to ints.\n        // inp may be undefined, so careful calling replace on it.\n        var res = inp && parseFloat(inp.replace(',', '.'));\n        // apply sign while we're at it\n        return (isNaN(res) ? 0 : res) * sign;\n    }\n\n    function positiveMomentsDifference(base, other) {\n        var res = {};\n\n        res.months =\n            other.month() - base.month() + (other.year() - base.year()) * 12;\n        if (base.clone().add(res.months, 'M').isAfter(other)) {\n            --res.months;\n        }\n\n        res.milliseconds = +other - +base.clone().add(res.months, 'M');\n\n        return res;\n    }\n\n    function momentsDifference(base, other) {\n        var res;\n        if (!(base.isValid() && other.isValid())) {\n            return { milliseconds: 0, months: 0 };\n        }\n\n        other = cloneWithOffset(other, base);\n        if (base.isBefore(other)) {\n            res = positiveMomentsDifference(base, other);\n        } else {\n            res = positiveMomentsDifference(other, base);\n            res.milliseconds = -res.milliseconds;\n            res.months = -res.months;\n        }\n\n        return res;\n    }\n\n    // TODO: remove 'name' arg after deprecation is removed\n    function createAdder(direction, name) {\n        return function (val, period) {\n            var dur, tmp;\n            //invert the arguments, but complain about it\n            if (period !== null && !isNaN(+period)) {\n                deprecateSimple(\n                    name,\n                    'moment().' +\n                        name +\n                        '(period, number) is deprecated. Please use moment().' +\n                        name +\n                        '(number, period). ' +\n                        'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'\n                );\n                tmp = val;\n                val = period;\n                period = tmp;\n            }\n\n            dur = createDuration(val, period);\n            addSubtract(this, dur, direction);\n            return this;\n        };\n    }\n\n    function addSubtract(mom, duration, isAdding, updateOffset) {\n        var milliseconds = duration._milliseconds,\n            days = absRound(duration._days),\n            months = absRound(duration._months);\n\n        if (!mom.isValid()) {\n            // No op\n            return;\n        }\n\n        updateOffset = updateOffset == null ? true : updateOffset;\n\n        if (months) {\n            setMonth(mom, get(mom, 'Month') + months * isAdding);\n        }\n        if (days) {\n            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);\n        }\n        if (milliseconds) {\n            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\n        }\n        if (updateOffset) {\n            hooks.updateOffset(mom, days || months);\n        }\n    }\n\n    var add = createAdder(1, 'add'),\n        subtract = createAdder(-1, 'subtract');\n\n    function isString(input) {\n        return typeof input === 'string' || input instanceof String;\n    }\n\n    // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined\n    function isMomentInput(input) {\n        return (\n            isMoment(input) ||\n            isDate(input) ||\n            isString(input) ||\n            isNumber(input) ||\n            isNumberOrStringArray(input) ||\n            isMomentInputObject(input) ||\n            input === null ||\n            input === undefined\n        );\n    }\n\n    function isMomentInputObject(input) {\n        var objectTest = isObject(input) && !isObjectEmpty(input),\n            propertyTest = false,\n            properties = [\n                'years',\n                'year',\n                'y',\n                'months',\n                'month',\n                'M',\n                'days',\n                'day',\n                'd',\n                'dates',\n                'date',\n                'D',\n                'hours',\n                'hour',\n                'h',\n                'minutes',\n                'minute',\n                'm',\n                'seconds',\n                'second',\n                's',\n                'milliseconds',\n                'millisecond',\n                'ms',\n            ],\n            i,\n            property,\n            propertyLen = properties.length;\n\n        for (i = 0; i < propertyLen; i += 1) {\n            property = properties[i];\n            propertyTest = propertyTest || hasOwnProp(input, property);\n        }\n\n        return objectTest && propertyTest;\n    }\n\n    function isNumberOrStringArray(input) {\n        var arrayTest = isArray(input),\n            dataTypeTest = false;\n        if (arrayTest) {\n            dataTypeTest =\n                input.filter(function (item) {\n                    return !isNumber(item) && isString(input);\n                }).length === 0;\n        }\n        return arrayTest && dataTypeTest;\n    }\n\n    function isCalendarSpec(input) {\n        var objectTest = isObject(input) && !isObjectEmpty(input),\n            propertyTest = false,\n            properties = [\n                'sameDay',\n                'nextDay',\n                'lastDay',\n                'nextWeek',\n                'lastWeek',\n                'sameElse',\n            ],\n            i,\n            property;\n\n        for (i = 0; i < properties.length; i += 1) {\n            property = properties[i];\n            propertyTest = propertyTest || hasOwnProp(input, property);\n        }\n\n        return objectTest && propertyTest;\n    }\n\n    function getCalendarFormat(myMoment, now) {\n        var diff = myMoment.diff(now, 'days', true);\n        return diff < -6\n            ? 'sameElse'\n            : diff < -1\n            ? 'lastWeek'\n            : diff < 0\n            ? 'lastDay'\n            : diff < 1\n            ? 'sameDay'\n            : diff < 2\n            ? 'nextDay'\n            : diff < 7\n            ? 'nextWeek'\n            : 'sameElse';\n    }\n\n    function calendar$1(time, formats) {\n        // Support for single parameter, formats only overload to the calendar function\n        if (arguments.length === 1) {\n            if (!arguments[0]) {\n                time = undefined;\n                formats = undefined;\n            } else if (isMomentInput(arguments[0])) {\n                time = arguments[0];\n                formats = undefined;\n            } else if (isCalendarSpec(arguments[0])) {\n                formats = arguments[0];\n                time = undefined;\n            }\n        }\n        // We want to compare the start of today, vs this.\n        // Getting start-of-today depends on whether we're local/utc/offset or not.\n        var now = time || createLocal(),\n            sod = cloneWithOffset(now, this).startOf('day'),\n            format = hooks.calendarFormat(this, sod) || 'sameElse',\n            output =\n                formats &&\n                (isFunction(formats[format])\n                    ? formats[format].call(this, now)\n                    : formats[format]);\n\n        return this.format(\n            output || this.localeData().calendar(format, this, createLocal(now))\n        );\n    }\n\n    function clone() {\n        return new Moment(this);\n    }\n\n    function isAfter(input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units) || 'millisecond';\n        if (units === 'millisecond') {\n            return this.valueOf() > localInput.valueOf();\n        } else {\n            return localInput.valueOf() < this.clone().startOf(units).valueOf();\n        }\n    }\n\n    function isBefore(input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units) || 'millisecond';\n        if (units === 'millisecond') {\n            return this.valueOf() < localInput.valueOf();\n        } else {\n            return this.clone().endOf(units).valueOf() < localInput.valueOf();\n        }\n    }\n\n    function isBetween(from, to, units, inclusivity) {\n        var localFrom = isMoment(from) ? from : createLocal(from),\n            localTo = isMoment(to) ? to : createLocal(to);\n        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {\n            return false;\n        }\n        inclusivity = inclusivity || '()';\n        return (\n            (inclusivity[0] === '('\n                ? this.isAfter(localFrom, units)\n                : !this.isBefore(localFrom, units)) &&\n            (inclusivity[1] === ')'\n                ? this.isBefore(localTo, units)\n                : !this.isAfter(localTo, units))\n        );\n    }\n\n    function isSame(input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input),\n            inputMs;\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units) || 'millisecond';\n        if (units === 'millisecond') {\n            return this.valueOf() === localInput.valueOf();\n        } else {\n            inputMs = localInput.valueOf();\n            return (\n                this.clone().startOf(units).valueOf() <= inputMs &&\n                inputMs <= this.clone().endOf(units).valueOf()\n            );\n        }\n    }\n\n    function isSameOrAfter(input, units) {\n        return this.isSame(input, units) || this.isAfter(input, units);\n    }\n\n    function isSameOrBefore(input, units) {\n        return this.isSame(input, units) || this.isBefore(input, units);\n    }\n\n    function diff(input, units, asFloat) {\n        var that, zoneDelta, output;\n\n        if (!this.isValid()) {\n            return NaN;\n        }\n\n        that = cloneWithOffset(input, this);\n\n        if (!that.isValid()) {\n            return NaN;\n        }\n\n        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\n\n        units = normalizeUnits(units);\n\n        switch (units) {\n            case 'year':\n                output = monthDiff(this, that) / 12;\n                break;\n            case 'month':\n                output = monthDiff(this, that);\n                break;\n            case 'quarter':\n                output = monthDiff(this, that) / 3;\n                break;\n            case 'second':\n                output = (this - that) / 1e3;\n                break; // 1000\n            case 'minute':\n                output = (this - that) / 6e4;\n                break; // 1000 * 60\n            case 'hour':\n                output = (this - that) / 36e5;\n                break; // 1000 * 60 * 60\n            case 'day':\n                output = (this - that - zoneDelta) / 864e5;\n                break; // 1000 * 60 * 60 * 24, negate dst\n            case 'week':\n                output = (this - that - zoneDelta) / 6048e5;\n                break; // 1000 * 60 * 60 * 24 * 7, negate dst\n            default:\n                output = this - that;\n        }\n\n        return asFloat ? output : absFloor(output);\n    }\n\n    function monthDiff(a, b) {\n        if (a.date() < b.date()) {\n            // end-of-month calculations work correct when the start month has more\n            // days than the end month.\n            return -monthDiff(b, a);\n        }\n        // difference in months\n        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),\n            // b is in (anchor - 1 month, anchor + 1 month)\n            anchor = a.clone().add(wholeMonthDiff, 'months'),\n            anchor2,\n            adjust;\n\n        if (b - anchor < 0) {\n            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor - anchor2);\n        } else {\n            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor2 - anchor);\n        }\n\n        //check for negative zero, return zero if negative zero\n        return -(wholeMonthDiff + adjust) || 0;\n    }\n\n    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\n    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';\n\n    function toString() {\n        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\n    }\n\n    function toISOString(keepOffset) {\n        if (!this.isValid()) {\n            return null;\n        }\n        var utc = keepOffset !== true,\n            m = utc ? this.clone().utc() : this;\n        if (m.year() < 0 || m.year() > 9999) {\n            return formatMoment(\n                m,\n                utc\n                    ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'\n                    : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'\n            );\n        }\n        if (isFunction(Date.prototype.toISOString)) {\n            // native implementation is ~50x faster, use it when we can\n            if (utc) {\n                return this.toDate().toISOString();\n            } else {\n                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)\n                    .toISOString()\n                    .replace('Z', formatMoment(m, 'Z'));\n            }\n        }\n        return formatMoment(\n            m,\n            utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'\n        );\n    }\n\n    /**\n     * Return a human readable representation of a moment that can\n     * also be evaluated to get a new moment which is the same\n     *\n     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\n     */\n    function inspect() {\n        if (!this.isValid()) {\n            return 'moment.invalid(/* ' + this._i + ' */)';\n        }\n        var func = 'moment',\n            zone = '',\n            prefix,\n            year,\n            datetime,\n            suffix;\n        if (!this.isLocal()) {\n            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';\n            zone = 'Z';\n        }\n        prefix = '[' + func + '(\"]';\n        year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';\n        datetime = '-MM-DD[T]HH:mm:ss.SSS';\n        suffix = zone + '[\")]';\n\n        return this.format(prefix + year + datetime + suffix);\n    }\n\n    function format(inputString) {\n        if (!inputString) {\n            inputString = this.isUtc()\n                ? hooks.defaultFormatUtc\n                : hooks.defaultFormat;\n        }\n        var output = formatMoment(this, inputString);\n        return this.localeData().postformat(output);\n    }\n\n    function from(time, withoutSuffix) {\n        if (\n            this.isValid() &&\n            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())\n        ) {\n            return createDuration({ to: this, from: time })\n                .locale(this.locale())\n                .humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n\n    function fromNow(withoutSuffix) {\n        return this.from(createLocal(), withoutSuffix);\n    }\n\n    function to(time, withoutSuffix) {\n        if (\n            this.isValid() &&\n            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())\n        ) {\n            return createDuration({ from: this, to: time })\n                .locale(this.locale())\n                .humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n\n    function toNow(withoutSuffix) {\n        return this.to(createLocal(), withoutSuffix);\n    }\n\n    // If passed a locale key, it will set the locale for this\n    // instance.  Otherwise, it will return the locale configuration\n    // variables for this instance.\n    function locale(key) {\n        var newLocaleData;\n\n        if (key === undefined) {\n            return this._locale._abbr;\n        } else {\n            newLocaleData = getLocale(key);\n            if (newLocaleData != null) {\n                this._locale = newLocaleData;\n            }\n            return this;\n        }\n    }\n\n    var lang = deprecate(\n        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',\n        function (key) {\n            if (key === undefined) {\n                return this.localeData();\n            } else {\n                return this.locale(key);\n            }\n        }\n    );\n\n    function localeData() {\n        return this._locale;\n    }\n\n    var MS_PER_SECOND = 1000,\n        MS_PER_MINUTE = 60 * MS_PER_SECOND,\n        MS_PER_HOUR = 60 * MS_PER_MINUTE,\n        MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;\n\n    // actual modulo - handles negative numbers (for dates before 1970):\n    function mod$1(dividend, divisor) {\n        return ((dividend % divisor) + divisor) % divisor;\n    }\n\n    function localStartOfDate(y, m, d) {\n        // the date constructor remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            // preserve leap years using a full 400 year cycle, then reset\n            return new Date(y + 400, m, d) - MS_PER_400_YEARS;\n        } else {\n            return new Date(y, m, d).valueOf();\n        }\n    }\n\n    function utcStartOfDate(y, m, d) {\n        // Date.UTC remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            // preserve leap years using a full 400 year cycle, then reset\n            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;\n        } else {\n            return Date.UTC(y, m, d);\n        }\n    }\n\n    function startOf(units) {\n        var time, startOfDate;\n        units = normalizeUnits(units);\n        if (units === undefined || units === 'millisecond' || !this.isValid()) {\n            return this;\n        }\n\n        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\n\n        switch (units) {\n            case 'year':\n                time = startOfDate(this.year(), 0, 1);\n                break;\n            case 'quarter':\n                time = startOfDate(\n                    this.year(),\n                    this.month() - (this.month() % 3),\n                    1\n                );\n                break;\n            case 'month':\n                time = startOfDate(this.year(), this.month(), 1);\n                break;\n            case 'week':\n                time = startOfDate(\n                    this.year(),\n                    this.month(),\n                    this.date() - this.weekday()\n                );\n                break;\n            case 'isoWeek':\n                time = startOfDate(\n                    this.year(),\n                    this.month(),\n                    this.date() - (this.isoWeekday() - 1)\n                );\n                break;\n            case 'day':\n            case 'date':\n                time = startOfDate(this.year(), this.month(), this.date());\n                break;\n            case 'hour':\n                time = this._d.valueOf();\n                time -= mod$1(\n                    time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),\n                    MS_PER_HOUR\n                );\n                break;\n            case 'minute':\n                time = this._d.valueOf();\n                time -= mod$1(time, MS_PER_MINUTE);\n                break;\n            case 'second':\n                time = this._d.valueOf();\n                time -= mod$1(time, MS_PER_SECOND);\n                break;\n        }\n\n        this._d.setTime(time);\n        hooks.updateOffset(this, true);\n        return this;\n    }\n\n    function endOf(units) {\n        var time, startOfDate;\n        units = normalizeUnits(units);\n        if (units === undefined || units === 'millisecond' || !this.isValid()) {\n            return this;\n        }\n\n        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\n\n        switch (units) {\n            case 'year':\n                time = startOfDate(this.year() + 1, 0, 1) - 1;\n                break;\n            case 'quarter':\n                time =\n                    startOfDate(\n                        this.year(),\n                        this.month() - (this.month() % 3) + 3,\n                        1\n                    ) - 1;\n                break;\n            case 'month':\n                time = startOfDate(this.year(), this.month() + 1, 1) - 1;\n                break;\n            case 'week':\n                time =\n                    startOfDate(\n                        this.year(),\n                        this.month(),\n                        this.date() - this.weekday() + 7\n                    ) - 1;\n                break;\n            case 'isoWeek':\n                time =\n                    startOfDate(\n                        this.year(),\n                        this.month(),\n                        this.date() - (this.isoWeekday() - 1) + 7\n                    ) - 1;\n                break;\n            case 'day':\n            case 'date':\n                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;\n                break;\n            case 'hour':\n                time = this._d.valueOf();\n                time +=\n                    MS_PER_HOUR -\n                    mod$1(\n                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),\n                        MS_PER_HOUR\n                    ) -\n                    1;\n                break;\n            case 'minute':\n                time = this._d.valueOf();\n                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;\n                break;\n            case 'second':\n                time = this._d.valueOf();\n                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;\n                break;\n        }\n\n        this._d.setTime(time);\n        hooks.updateOffset(this, true);\n        return this;\n    }\n\n    function valueOf() {\n        return this._d.valueOf() - (this._offset || 0) * 60000;\n    }\n\n    function unix() {\n        return Math.floor(this.valueOf() / 1000);\n    }\n\n    function toDate() {\n        return new Date(this.valueOf());\n    }\n\n    function toArray() {\n        var m = this;\n        return [\n            m.year(),\n            m.month(),\n            m.date(),\n            m.hour(),\n            m.minute(),\n            m.second(),\n            m.millisecond(),\n        ];\n    }\n\n    function toObject() {\n        var m = this;\n        return {\n            years: m.year(),\n            months: m.month(),\n            date: m.date(),\n            hours: m.hours(),\n            minutes: m.minutes(),\n            seconds: m.seconds(),\n            milliseconds: m.milliseconds(),\n        };\n    }\n\n    function toJSON() {\n        // new Date(NaN).toJSON() === null\n        return this.isValid() ? this.toISOString() : null;\n    }\n\n    function isValid$2() {\n        return isValid(this);\n    }\n\n    function parsingFlags() {\n        return extend({}, getParsingFlags(this));\n    }\n\n    function invalidAt() {\n        return getParsingFlags(this).overflow;\n    }\n\n    function creationData() {\n        return {\n            input: this._i,\n            format: this._f,\n            locale: this._locale,\n            isUTC: this._isUTC,\n            strict: this._strict,\n        };\n    }\n\n    addFormatToken('N', 0, 0, 'eraAbbr');\n    addFormatToken('NN', 0, 0, 'eraAbbr');\n    addFormatToken('NNN', 0, 0, 'eraAbbr');\n    addFormatToken('NNNN', 0, 0, 'eraName');\n    addFormatToken('NNNNN', 0, 0, 'eraNarrow');\n\n    addFormatToken('y', ['y', 1], 'yo', 'eraYear');\n    addFormatToken('y', ['yy', 2], 0, 'eraYear');\n    addFormatToken('y', ['yyy', 3], 0, 'eraYear');\n    addFormatToken('y', ['yyyy', 4], 0, 'eraYear');\n\n    addRegexToken('N', matchEraAbbr);\n    addRegexToken('NN', matchEraAbbr);\n    addRegexToken('NNN', matchEraAbbr);\n    addRegexToken('NNNN', matchEraName);\n    addRegexToken('NNNNN', matchEraNarrow);\n\n    addParseToken(\n        ['N', 'NN', 'NNN', 'NNNN', 'NNNNN'],\n        function (input, array, config, token) {\n            var era = config._locale.erasParse(input, token, config._strict);\n            if (era) {\n                getParsingFlags(config).era = era;\n            } else {\n                getParsingFlags(config).invalidEra = input;\n            }\n        }\n    );\n\n    addRegexToken('y', matchUnsigned);\n    addRegexToken('yy', matchUnsigned);\n    addRegexToken('yyy', matchUnsigned);\n    addRegexToken('yyyy', matchUnsigned);\n    addRegexToken('yo', matchEraYearOrdinal);\n\n    addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);\n    addParseToken(['yo'], function (input, array, config, token) {\n        var match;\n        if (config._locale._eraYearOrdinalRegex) {\n            match = input.match(config._locale._eraYearOrdinalRegex);\n        }\n\n        if (config._locale.eraYearOrdinalParse) {\n            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);\n        } else {\n            array[YEAR] = parseInt(input, 10);\n        }\n    });\n\n    function localeEras(m, format) {\n        var i,\n            l,\n            date,\n            eras = this._eras || getLocale('en')._eras;\n        for (i = 0, l = eras.length; i < l; ++i) {\n            switch (typeof eras[i].since) {\n                case 'string':\n                    // truncate time\n                    date = hooks(eras[i].since).startOf('day');\n                    eras[i].since = date.valueOf();\n                    break;\n            }\n\n            switch (typeof eras[i].until) {\n                case 'undefined':\n                    eras[i].until = +Infinity;\n                    break;\n                case 'string':\n                    // truncate time\n                    date = hooks(eras[i].until).startOf('day').valueOf();\n                    eras[i].until = date.valueOf();\n                    break;\n            }\n        }\n        return eras;\n    }\n\n    function localeErasParse(eraName, format, strict) {\n        var i,\n            l,\n            eras = this.eras(),\n            name,\n            abbr,\n            narrow;\n        eraName = eraName.toUpperCase();\n\n        for (i = 0, l = eras.length; i < l; ++i) {\n            name = eras[i].name.toUpperCase();\n            abbr = eras[i].abbr.toUpperCase();\n            narrow = eras[i].narrow.toUpperCase();\n\n            if (strict) {\n                switch (format) {\n                    case 'N':\n                    case 'NN':\n                    case 'NNN':\n                        if (abbr === eraName) {\n                            return eras[i];\n                        }\n                        break;\n\n                    case 'NNNN':\n                        if (name === eraName) {\n                            return eras[i];\n                        }\n                        break;\n\n                    case 'NNNNN':\n                        if (narrow === eraName) {\n                            return eras[i];\n                        }\n                        break;\n                }\n            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {\n                return eras[i];\n            }\n        }\n    }\n\n    function localeErasConvertYear(era, year) {\n        var dir = era.since <= era.until ? +1 : -1;\n        if (year === undefined) {\n            return hooks(era.since).year();\n        } else {\n            return hooks(era.since).year() + (year - era.offset) * dir;\n        }\n    }\n\n    function getEraName() {\n        var i,\n            l,\n            val,\n            eras = this.localeData().eras();\n        for (i = 0, l = eras.length; i < l; ++i) {\n            // truncate time\n            val = this.clone().startOf('day').valueOf();\n\n            if (eras[i].since <= val && val <= eras[i].until) {\n                return eras[i].name;\n            }\n            if (eras[i].until <= val && val <= eras[i].since) {\n                return eras[i].name;\n            }\n        }\n\n        return '';\n    }\n\n    function getEraNarrow() {\n        var i,\n            l,\n            val,\n            eras = this.localeData().eras();\n        for (i = 0, l = eras.length; i < l; ++i) {\n            // truncate time\n            val = this.clone().startOf('day').valueOf();\n\n            if (eras[i].since <= val && val <= eras[i].until) {\n                return eras[i].narrow;\n            }\n            if (eras[i].until <= val && val <= eras[i].since) {\n                return eras[i].narrow;\n            }\n        }\n\n        return '';\n    }\n\n    function getEraAbbr() {\n        var i,\n            l,\n            val,\n            eras = this.localeData().eras();\n        for (i = 0, l = eras.length; i < l; ++i) {\n            // truncate time\n            val = this.clone().startOf('day').valueOf();\n\n            if (eras[i].since <= val && val <= eras[i].until) {\n                return eras[i].abbr;\n            }\n            if (eras[i].until <= val && val <= eras[i].since) {\n                return eras[i].abbr;\n            }\n        }\n\n        return '';\n    }\n\n    function getEraYear() {\n        var i,\n            l,\n            dir,\n            val,\n            eras = this.localeData().eras();\n        for (i = 0, l = eras.length; i < l; ++i) {\n            dir = eras[i].since <= eras[i].until ? +1 : -1;\n\n            // truncate time\n            val = this.clone().startOf('day').valueOf();\n\n            if (\n                (eras[i].since <= val && val <= eras[i].until) ||\n                (eras[i].until <= val && val <= eras[i].since)\n            ) {\n                return (\n                    (this.year() - hooks(eras[i].since).year()) * dir +\n                    eras[i].offset\n                );\n            }\n        }\n\n        return this.year();\n    }\n\n    function erasNameRegex(isStrict) {\n        if (!hasOwnProp(this, '_erasNameRegex')) {\n            computeErasParse.call(this);\n        }\n        return isStrict ? this._erasNameRegex : this._erasRegex;\n    }\n\n    function erasAbbrRegex(isStrict) {\n        if (!hasOwnProp(this, '_erasAbbrRegex')) {\n            computeErasParse.call(this);\n        }\n        return isStrict ? this._erasAbbrRegex : this._erasRegex;\n    }\n\n    function erasNarrowRegex(isStrict) {\n        if (!hasOwnProp(this, '_erasNarrowRegex')) {\n            computeErasParse.call(this);\n        }\n        return isStrict ? this._erasNarrowRegex : this._erasRegex;\n    }\n\n    function matchEraAbbr(isStrict, locale) {\n        return locale.erasAbbrRegex(isStrict);\n    }\n\n    function matchEraName(isStrict, locale) {\n        return locale.erasNameRegex(isStrict);\n    }\n\n    function matchEraNarrow(isStrict, locale) {\n        return locale.erasNarrowRegex(isStrict);\n    }\n\n    function matchEraYearOrdinal(isStrict, locale) {\n        return locale._eraYearOrdinalRegex || matchUnsigned;\n    }\n\n    function computeErasParse() {\n        var abbrPieces = [],\n            namePieces = [],\n            narrowPieces = [],\n            mixedPieces = [],\n            i,\n            l,\n            eras = this.eras();\n\n        for (i = 0, l = eras.length; i < l; ++i) {\n            namePieces.push(regexEscape(eras[i].name));\n            abbrPieces.push(regexEscape(eras[i].abbr));\n            narrowPieces.push(regexEscape(eras[i].narrow));\n\n            mixedPieces.push(regexEscape(eras[i].name));\n            mixedPieces.push(regexEscape(eras[i].abbr));\n            mixedPieces.push(regexEscape(eras[i].narrow));\n        }\n\n        this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n        this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');\n        this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');\n        this._erasNarrowRegex = new RegExp(\n            '^(' + narrowPieces.join('|') + ')',\n            'i'\n        );\n    }\n\n    // FORMATTING\n\n    addFormatToken(0, ['gg', 2], 0, function () {\n        return this.weekYear() % 100;\n    });\n\n    addFormatToken(0, ['GG', 2], 0, function () {\n        return this.isoWeekYear() % 100;\n    });\n\n    function addWeekYearFormatToken(token, getter) {\n        addFormatToken(0, [token, token.length], 0, getter);\n    }\n\n    addWeekYearFormatToken('gggg', 'weekYear');\n    addWeekYearFormatToken('ggggg', 'weekYear');\n    addWeekYearFormatToken('GGGG', 'isoWeekYear');\n    addWeekYearFormatToken('GGGGG', 'isoWeekYear');\n\n    // ALIASES\n\n    addUnitAlias('weekYear', 'gg');\n    addUnitAlias('isoWeekYear', 'GG');\n\n    // PRIORITY\n\n    addUnitPriority('weekYear', 1);\n    addUnitPriority('isoWeekYear', 1);\n\n    // PARSING\n\n    addRegexToken('G', matchSigned);\n    addRegexToken('g', matchSigned);\n    addRegexToken('GG', match1to2, match2);\n    addRegexToken('gg', match1to2, match2);\n    addRegexToken('GGGG', match1to4, match4);\n    addRegexToken('gggg', match1to4, match4);\n    addRegexToken('GGGGG', match1to6, match6);\n    addRegexToken('ggggg', match1to6, match6);\n\n    addWeekParseToken(\n        ['gggg', 'ggggg', 'GGGG', 'GGGGG'],\n        function (input, week, config, token) {\n            week[token.substr(0, 2)] = toInt(input);\n        }\n    );\n\n    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\n        week[token] = hooks.parseTwoDigitYear(input);\n    });\n\n    // MOMENTS\n\n    function getSetWeekYear(input) {\n        return getSetWeekYearHelper.call(\n            this,\n            input,\n            this.week(),\n            this.weekday(),\n            this.localeData()._week.dow,\n            this.localeData()._week.doy\n        );\n    }\n\n    function getSetISOWeekYear(input) {\n        return getSetWeekYearHelper.call(\n            this,\n            input,\n            this.isoWeek(),\n            this.isoWeekday(),\n            1,\n            4\n        );\n    }\n\n    function getISOWeeksInYear() {\n        return weeksInYear(this.year(), 1, 4);\n    }\n\n    function getISOWeeksInISOWeekYear() {\n        return weeksInYear(this.isoWeekYear(), 1, 4);\n    }\n\n    function getWeeksInYear() {\n        var weekInfo = this.localeData()._week;\n        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n    }\n\n    function getWeeksInWeekYear() {\n        var weekInfo = this.localeData()._week;\n        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);\n    }\n\n    function getSetWeekYearHelper(input, week, weekday, dow, doy) {\n        var weeksTarget;\n        if (input == null) {\n            return weekOfYear(this, dow, doy).year;\n        } else {\n            weeksTarget = weeksInYear(input, dow, doy);\n            if (week > weeksTarget) {\n                week = weeksTarget;\n            }\n            return setWeekAll.call(this, input, week, weekday, dow, doy);\n        }\n    }\n\n    function setWeekAll(weekYear, week, weekday, dow, doy) {\n        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),\n            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\n\n        this.year(date.getUTCFullYear());\n        this.month(date.getUTCMonth());\n        this.date(date.getUTCDate());\n        return this;\n    }\n\n    // FORMATTING\n\n    addFormatToken('Q', 0, 'Qo', 'quarter');\n\n    // ALIASES\n\n    addUnitAlias('quarter', 'Q');\n\n    // PRIORITY\n\n    addUnitPriority('quarter', 7);\n\n    // PARSING\n\n    addRegexToken('Q', match1);\n    addParseToken('Q', function (input, array) {\n        array[MONTH] = (toInt(input) - 1) * 3;\n    });\n\n    // MOMENTS\n\n    function getSetQuarter(input) {\n        return input == null\n            ? Math.ceil((this.month() + 1) / 3)\n            : this.month((input - 1) * 3 + (this.month() % 3));\n    }\n\n    // FORMATTING\n\n    addFormatToken('D', ['DD', 2], 'Do', 'date');\n\n    // ALIASES\n\n    addUnitAlias('date', 'D');\n\n    // PRIORITY\n    addUnitPriority('date', 9);\n\n    // PARSING\n\n    addRegexToken('D', match1to2);\n    addRegexToken('DD', match1to2, match2);\n    addRegexToken('Do', function (isStrict, locale) {\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        return isStrict\n            ? locale._dayOfMonthOrdinalParse || locale._ordinalParse\n            : locale._dayOfMonthOrdinalParseLenient;\n    });\n\n    addParseToken(['D', 'DD'], DATE);\n    addParseToken('Do', function (input, array) {\n        array[DATE] = toInt(input.match(match1to2)[0]);\n    });\n\n    // MOMENTS\n\n    var getSetDayOfMonth = makeGetSet('Date', true);\n\n    // FORMATTING\n\n    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\n\n    // ALIASES\n\n    addUnitAlias('dayOfYear', 'DDD');\n\n    // PRIORITY\n    addUnitPriority('dayOfYear', 4);\n\n    // PARSING\n\n    addRegexToken('DDD', match1to3);\n    addRegexToken('DDDD', match3);\n    addParseToken(['DDD', 'DDDD'], function (input, array, config) {\n        config._dayOfYear = toInt(input);\n    });\n\n    // HELPERS\n\n    // MOMENTS\n\n    function getSetDayOfYear(input) {\n        var dayOfYear =\n            Math.round(\n                (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5\n            ) + 1;\n        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');\n    }\n\n    // FORMATTING\n\n    addFormatToken('m', ['mm', 2], 0, 'minute');\n\n    // ALIASES\n\n    addUnitAlias('minute', 'm');\n\n    // PRIORITY\n\n    addUnitPriority('minute', 14);\n\n    // PARSING\n\n    addRegexToken('m', match1to2);\n    addRegexToken('mm', match1to2, match2);\n    addParseToken(['m', 'mm'], MINUTE);\n\n    // MOMENTS\n\n    var getSetMinute = makeGetSet('Minutes', false);\n\n    // FORMATTING\n\n    addFormatToken('s', ['ss', 2], 0, 'second');\n\n    // ALIASES\n\n    addUnitAlias('second', 's');\n\n    // PRIORITY\n\n    addUnitPriority('second', 15);\n\n    // PARSING\n\n    addRegexToken('s', match1to2);\n    addRegexToken('ss', match1to2, match2);\n    addParseToken(['s', 'ss'], SECOND);\n\n    // MOMENTS\n\n    var getSetSecond = makeGetSet('Seconds', false);\n\n    // FORMATTING\n\n    addFormatToken('S', 0, 0, function () {\n        return ~~(this.millisecond() / 100);\n    });\n\n    addFormatToken(0, ['SS', 2], 0, function () {\n        return ~~(this.millisecond() / 10);\n    });\n\n    addFormatToken(0, ['SSS', 3], 0, 'millisecond');\n    addFormatToken(0, ['SSSS', 4], 0, function () {\n        return this.millisecond() * 10;\n    });\n    addFormatToken(0, ['SSSSS', 5], 0, function () {\n        return this.millisecond() * 100;\n    });\n    addFormatToken(0, ['SSSSSS', 6], 0, function () {\n        return this.millisecond() * 1000;\n    });\n    addFormatToken(0, ['SSSSSSS', 7], 0, function () {\n        return this.millisecond() * 10000;\n    });\n    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {\n        return this.millisecond() * 100000;\n    });\n    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\n        return this.millisecond() * 1000000;\n    });\n\n    // ALIASES\n\n    addUnitAlias('millisecond', 'ms');\n\n    // PRIORITY\n\n    addUnitPriority('millisecond', 16);\n\n    // PARSING\n\n    addRegexToken('S', match1to3, match1);\n    addRegexToken('SS', match1to3, match2);\n    addRegexToken('SSS', match1to3, match3);\n\n    var token, getSetMillisecond;\n    for (token = 'SSSS'; token.length <= 9; token += 'S') {\n        addRegexToken(token, matchUnsigned);\n    }\n\n    function parseMs(input, array) {\n        array[MILLISECOND] = toInt(('0.' + input) * 1000);\n    }\n\n    for (token = 'S'; token.length <= 9; token += 'S') {\n        addParseToken(token, parseMs);\n    }\n\n    getSetMillisecond = makeGetSet('Milliseconds', false);\n\n    // FORMATTING\n\n    addFormatToken('z', 0, 0, 'zoneAbbr');\n    addFormatToken('zz', 0, 0, 'zoneName');\n\n    // MOMENTS\n\n    function getZoneAbbr() {\n        return this._isUTC ? 'UTC' : '';\n    }\n\n    function getZoneName() {\n        return this._isUTC ? 'Coordinated Universal Time' : '';\n    }\n\n    var proto = Moment.prototype;\n\n    proto.add = add;\n    proto.calendar = calendar$1;\n    proto.clone = clone;\n    proto.diff = diff;\n    proto.endOf = endOf;\n    proto.format = format;\n    proto.from = from;\n    proto.fromNow = fromNow;\n    proto.to = to;\n    proto.toNow = toNow;\n    proto.get = stringGet;\n    proto.invalidAt = invalidAt;\n    proto.isAfter = isAfter;\n    proto.isBefore = isBefore;\n    proto.isBetween = isBetween;\n    proto.isSame = isSame;\n    proto.isSameOrAfter = isSameOrAfter;\n    proto.isSameOrBefore = isSameOrBefore;\n    proto.isValid = isValid$2;\n    proto.lang = lang;\n    proto.locale = locale;\n    proto.localeData = localeData;\n    proto.max = prototypeMax;\n    proto.min = prototypeMin;\n    proto.parsingFlags = parsingFlags;\n    proto.set = stringSet;\n    proto.startOf = startOf;\n    proto.subtract = subtract;\n    proto.toArray = toArray;\n    proto.toObject = toObject;\n    proto.toDate = toDate;\n    proto.toISOString = toISOString;\n    proto.inspect = inspect;\n    if (typeof Symbol !== 'undefined' && Symbol.for != null) {\n        proto[Symbol.for('nodejs.util.inspect.custom')] = function () {\n            return 'Moment<' + this.format() + '>';\n        };\n    }\n    proto.toJSON = toJSON;\n    proto.toString = toString;\n    proto.unix = unix;\n    proto.valueOf = valueOf;\n    proto.creationData = creationData;\n    proto.eraName = getEraName;\n    proto.eraNarrow = getEraNarrow;\n    proto.eraAbbr = getEraAbbr;\n    proto.eraYear = getEraYear;\n    proto.year = getSetYear;\n    proto.isLeapYear = getIsLeapYear;\n    proto.weekYear = getSetWeekYear;\n    proto.isoWeekYear = getSetISOWeekYear;\n    proto.quarter = proto.quarters = getSetQuarter;\n    proto.month = getSetMonth;\n    proto.daysInMonth = getDaysInMonth;\n    proto.week = proto.weeks = getSetWeek;\n    proto.isoWeek = proto.isoWeeks = getSetISOWeek;\n    proto.weeksInYear = getWeeksInYear;\n    proto.weeksInWeekYear = getWeeksInWeekYear;\n    proto.isoWeeksInYear = getISOWeeksInYear;\n    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;\n    proto.date = getSetDayOfMonth;\n    proto.day = proto.days = getSetDayOfWeek;\n    proto.weekday = getSetLocaleDayOfWeek;\n    proto.isoWeekday = getSetISODayOfWeek;\n    proto.dayOfYear = getSetDayOfYear;\n    proto.hour = proto.hours = getSetHour;\n    proto.minute = proto.minutes = getSetMinute;\n    proto.second = proto.seconds = getSetSecond;\n    proto.millisecond = proto.milliseconds = getSetMillisecond;\n    proto.utcOffset = getSetOffset;\n    proto.utc = setOffsetToUTC;\n    proto.local = setOffsetToLocal;\n    proto.parseZone = setOffsetToParsedOffset;\n    proto.hasAlignedHourOffset = hasAlignedHourOffset;\n    proto.isDST = isDaylightSavingTime;\n    proto.isLocal = isLocal;\n    proto.isUtcOffset = isUtcOffset;\n    proto.isUtc = isUtc;\n    proto.isUTC = isUtc;\n    proto.zoneAbbr = getZoneAbbr;\n    proto.zoneName = getZoneName;\n    proto.dates = deprecate(\n        'dates accessor is deprecated. Use date instead.',\n        getSetDayOfMonth\n    );\n    proto.months = deprecate(\n        'months accessor is deprecated. Use month instead',\n        getSetMonth\n    );\n    proto.years = deprecate(\n        'years accessor is deprecated. Use year instead',\n        getSetYear\n    );\n    proto.zone = deprecate(\n        'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',\n        getSetZone\n    );\n    proto.isDSTShifted = deprecate(\n        'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',\n        isDaylightSavingTimeShifted\n    );\n\n    function createUnix(input) {\n        return createLocal(input * 1000);\n    }\n\n    function createInZone() {\n        return createLocal.apply(null, arguments).parseZone();\n    }\n\n    function preParsePostFormat(string) {\n        return string;\n    }\n\n    var proto$1 = Locale.prototype;\n\n    proto$1.calendar = calendar;\n    proto$1.longDateFormat = longDateFormat;\n    proto$1.invalidDate = invalidDate;\n    proto$1.ordinal = ordinal;\n    proto$1.preparse = preParsePostFormat;\n    proto$1.postformat = preParsePostFormat;\n    proto$1.relativeTime = relativeTime;\n    proto$1.pastFuture = pastFuture;\n    proto$1.set = set;\n    proto$1.eras = localeEras;\n    proto$1.erasParse = localeErasParse;\n    proto$1.erasConvertYear = localeErasConvertYear;\n    proto$1.erasAbbrRegex = erasAbbrRegex;\n    proto$1.erasNameRegex = erasNameRegex;\n    proto$1.erasNarrowRegex = erasNarrowRegex;\n\n    proto$1.months = localeMonths;\n    proto$1.monthsShort = localeMonthsShort;\n    proto$1.monthsParse = localeMonthsParse;\n    proto$1.monthsRegex = monthsRegex;\n    proto$1.monthsShortRegex = monthsShortRegex;\n    proto$1.week = localeWeek;\n    proto$1.firstDayOfYear = localeFirstDayOfYear;\n    proto$1.firstDayOfWeek = localeFirstDayOfWeek;\n\n    proto$1.weekdays = localeWeekdays;\n    proto$1.weekdaysMin = localeWeekdaysMin;\n    proto$1.weekdaysShort = localeWeekdaysShort;\n    proto$1.weekdaysParse = localeWeekdaysParse;\n\n    proto$1.weekdaysRegex = weekdaysRegex;\n    proto$1.weekdaysShortRegex = weekdaysShortRegex;\n    proto$1.weekdaysMinRegex = weekdaysMinRegex;\n\n    proto$1.isPM = localeIsPM;\n    proto$1.meridiem = localeMeridiem;\n\n    function get$1(format, index, field, setter) {\n        var locale = getLocale(),\n            utc = createUTC().set(setter, index);\n        return locale[field](utc, format);\n    }\n\n    function listMonthsImpl(format, index, field) {\n        if (isNumber(format)) {\n            index = format;\n            format = undefined;\n        }\n\n        format = format || '';\n\n        if (index != null) {\n            return get$1(format, index, field, 'month');\n        }\n\n        var i,\n            out = [];\n        for (i = 0; i < 12; i++) {\n            out[i] = get$1(format, i, field, 'month');\n        }\n        return out;\n    }\n\n    // ()\n    // (5)\n    // (fmt, 5)\n    // (fmt)\n    // (true)\n    // (true, 5)\n    // (true, fmt, 5)\n    // (true, fmt)\n    function listWeekdaysImpl(localeSorted, format, index, field) {\n        if (typeof localeSorted === 'boolean') {\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n\n            format = format || '';\n        } else {\n            format = localeSorted;\n            index = format;\n            localeSorted = false;\n\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n\n            format = format || '';\n        }\n\n        var locale = getLocale(),\n            shift = localeSorted ? locale._week.dow : 0,\n            i,\n            out = [];\n\n        if (index != null) {\n            return get$1(format, (index + shift) % 7, field, 'day');\n        }\n\n        for (i = 0; i < 7; i++) {\n            out[i] = get$1(format, (i + shift) % 7, field, 'day');\n        }\n        return out;\n    }\n\n    function listMonths(format, index) {\n        return listMonthsImpl(format, index, 'months');\n    }\n\n    function listMonthsShort(format, index) {\n        return listMonthsImpl(format, index, 'monthsShort');\n    }\n\n    function listWeekdays(localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');\n    }\n\n    function listWeekdaysShort(localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');\n    }\n\n    function listWeekdaysMin(localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');\n    }\n\n    getSetGlobalLocale('en', {\n        eras: [\n            {\n                since: '0001-01-01',\n                until: +Infinity,\n                offset: 1,\n                name: 'Anno Domini',\n                narrow: 'AD',\n                abbr: 'AD',\n            },\n            {\n                since: '0000-12-31',\n                until: -Infinity,\n                offset: 1,\n                name: 'Before Christ',\n                narrow: 'BC',\n                abbr: 'BC',\n            },\n        ],\n        dayOfMonthOrdinalParse: /\\d{1,2}(th|st|nd|rd)/,\n        ordinal: function (number) {\n            var b = number % 10,\n                output =\n                    toInt((number % 100) / 10) === 1\n                        ? 'th'\n                        : b === 1\n                        ? 'st'\n                        : b === 2\n                        ? 'nd'\n                        : b === 3\n                        ? 'rd'\n                        : 'th';\n            return number + output;\n        },\n    });\n\n    // Side effect imports\n\n    hooks.lang = deprecate(\n        'moment.lang is deprecated. Use moment.locale instead.',\n        getSetGlobalLocale\n    );\n    hooks.langData = deprecate(\n        'moment.langData is deprecated. Use moment.localeData instead.',\n        getLocale\n    );\n\n    var mathAbs = Math.abs;\n\n    function abs() {\n        var data = this._data;\n\n        this._milliseconds = mathAbs(this._milliseconds);\n        this._days = mathAbs(this._days);\n        this._months = mathAbs(this._months);\n\n        data.milliseconds = mathAbs(data.milliseconds);\n        data.seconds = mathAbs(data.seconds);\n        data.minutes = mathAbs(data.minutes);\n        data.hours = mathAbs(data.hours);\n        data.months = mathAbs(data.months);\n        data.years = mathAbs(data.years);\n\n        return this;\n    }\n\n    function addSubtract$1(duration, input, value, direction) {\n        var other = createDuration(input, value);\n\n        duration._milliseconds += direction * other._milliseconds;\n        duration._days += direction * other._days;\n        duration._months += direction * other._months;\n\n        return duration._bubble();\n    }\n\n    // supports only 2.0-style add(1, 's') or add(duration)\n    function add$1(input, value) {\n        return addSubtract$1(this, input, value, 1);\n    }\n\n    // supports only 2.0-style subtract(1, 's') or subtract(duration)\n    function subtract$1(input, value) {\n        return addSubtract$1(this, input, value, -1);\n    }\n\n    function absCeil(number) {\n        if (number < 0) {\n            return Math.floor(number);\n        } else {\n            return Math.ceil(number);\n        }\n    }\n\n    function bubble() {\n        var milliseconds = this._milliseconds,\n            days = this._days,\n            months = this._months,\n            data = this._data,\n            seconds,\n            minutes,\n            hours,\n            years,\n            monthsFromDays;\n\n        // if we have a mix of positive and negative values, bubble down first\n        // check: https://github.com/moment/moment/issues/2166\n        if (\n            !(\n                (milliseconds >= 0 && days >= 0 && months >= 0) ||\n                (milliseconds <= 0 && days <= 0 && months <= 0)\n            )\n        ) {\n            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n            days = 0;\n            months = 0;\n        }\n\n        // The following code bubbles up values, see the tests for\n        // examples of what that means.\n        data.milliseconds = milliseconds % 1000;\n\n        seconds = absFloor(milliseconds / 1000);\n        data.seconds = seconds % 60;\n\n        minutes = absFloor(seconds / 60);\n        data.minutes = minutes % 60;\n\n        hours = absFloor(minutes / 60);\n        data.hours = hours % 24;\n\n        days += absFloor(hours / 24);\n\n        // convert days to months\n        monthsFromDays = absFloor(daysToMonths(days));\n        months += monthsFromDays;\n        days -= absCeil(monthsToDays(monthsFromDays));\n\n        // 12 months -> 1 year\n        years = absFloor(months / 12);\n        months %= 12;\n\n        data.days = days;\n        data.months = months;\n        data.years = years;\n\n        return this;\n    }\n\n    function daysToMonths(days) {\n        // 400 years have 146097 days (taking into account leap year rules)\n        // 400 years have 12 months === 4800\n        return (days * 4800) / 146097;\n    }\n\n    function monthsToDays(months) {\n        // the reverse of daysToMonths\n        return (months * 146097) / 4800;\n    }\n\n    function as(units) {\n        if (!this.isValid()) {\n            return NaN;\n        }\n        var days,\n            months,\n            milliseconds = this._milliseconds;\n\n        units = normalizeUnits(units);\n\n        if (units === 'month' || units === 'quarter' || units === 'year') {\n            days = this._days + milliseconds / 864e5;\n            months = this._months + daysToMonths(days);\n            switch (units) {\n                case 'month':\n                    return months;\n                case 'quarter':\n                    return months / 3;\n                case 'year':\n                    return months / 12;\n            }\n        } else {\n            // handle milliseconds separately because of floating point math errors (issue #1867)\n            days = this._days + Math.round(monthsToDays(this._months));\n            switch (units) {\n                case 'week':\n                    return days / 7 + milliseconds / 6048e5;\n                case 'day':\n                    return days + milliseconds / 864e5;\n                case 'hour':\n                    return days * 24 + milliseconds / 36e5;\n                case 'minute':\n                    return days * 1440 + milliseconds / 6e4;\n                case 'second':\n                    return days * 86400 + milliseconds / 1000;\n                // Math.floor prevents floating point math errors here\n                case 'millisecond':\n                    return Math.floor(days * 864e5) + milliseconds;\n                default:\n                    throw new Error('Unknown unit ' + units);\n            }\n        }\n    }\n\n    // TODO: Use this.as('ms')?\n    function valueOf$1() {\n        if (!this.isValid()) {\n            return NaN;\n        }\n        return (\n            this._milliseconds +\n            this._days * 864e5 +\n            (this._months % 12) * 2592e6 +\n            toInt(this._months / 12) * 31536e6\n        );\n    }\n\n    function makeAs(alias) {\n        return function () {\n            return this.as(alias);\n        };\n    }\n\n    var asMilliseconds = makeAs('ms'),\n        asSeconds = makeAs('s'),\n        asMinutes = makeAs('m'),\n        asHours = makeAs('h'),\n        asDays = makeAs('d'),\n        asWeeks = makeAs('w'),\n        asMonths = makeAs('M'),\n        asQuarters = makeAs('Q'),\n        asYears = makeAs('y');\n\n    function clone$1() {\n        return createDuration(this);\n    }\n\n    function get$2(units) {\n        units = normalizeUnits(units);\n        return this.isValid() ? this[units + 's']() : NaN;\n    }\n\n    function makeGetter(name) {\n        return function () {\n            return this.isValid() ? this._data[name] : NaN;\n        };\n    }\n\n    var milliseconds = makeGetter('milliseconds'),\n        seconds = makeGetter('seconds'),\n        minutes = makeGetter('minutes'),\n        hours = makeGetter('hours'),\n        days = makeGetter('days'),\n        months = makeGetter('months'),\n        years = makeGetter('years');\n\n    function weeks() {\n        return absFloor(this.days() / 7);\n    }\n\n    var round = Math.round,\n        thresholds = {\n            ss: 44, // a few seconds to seconds\n            s: 45, // seconds to minute\n            m: 45, // minutes to hour\n            h: 22, // hours to day\n            d: 26, // days to month/week\n            w: null, // weeks to month\n            M: 11, // months to year\n        };\n\n    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n    }\n\n    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {\n        var duration = createDuration(posNegDuration).abs(),\n            seconds = round(duration.as('s')),\n            minutes = round(duration.as('m')),\n            hours = round(duration.as('h')),\n            days = round(duration.as('d')),\n            months = round(duration.as('M')),\n            weeks = round(duration.as('w')),\n            years = round(duration.as('y')),\n            a =\n                (seconds <= thresholds.ss && ['s', seconds]) ||\n                (seconds < thresholds.s && ['ss', seconds]) ||\n                (minutes <= 1 && ['m']) ||\n                (minutes < thresholds.m && ['mm', minutes]) ||\n                (hours <= 1 && ['h']) ||\n                (hours < thresholds.h && ['hh', hours]) ||\n                (days <= 1 && ['d']) ||\n                (days < thresholds.d && ['dd', days]);\n\n        if (thresholds.w != null) {\n            a =\n                a ||\n                (weeks <= 1 && ['w']) ||\n                (weeks < thresholds.w && ['ww', weeks]);\n        }\n        a = a ||\n            (months <= 1 && ['M']) ||\n            (months < thresholds.M && ['MM', months]) ||\n            (years <= 1 && ['y']) || ['yy', years];\n\n        a[2] = withoutSuffix;\n        a[3] = +posNegDuration > 0;\n        a[4] = locale;\n        return substituteTimeAgo.apply(null, a);\n    }\n\n    // This function allows you to set the rounding function for relative time strings\n    function getSetRelativeTimeRounding(roundingFunction) {\n        if (roundingFunction === undefined) {\n            return round;\n        }\n        if (typeof roundingFunction === 'function') {\n            round = roundingFunction;\n            return true;\n        }\n        return false;\n    }\n\n    // This function allows you to set a threshold for relative time strings\n    function getSetRelativeTimeThreshold(threshold, limit) {\n        if (thresholds[threshold] === undefined) {\n            return false;\n        }\n        if (limit === undefined) {\n            return thresholds[threshold];\n        }\n        thresholds[threshold] = limit;\n        if (threshold === 's') {\n            thresholds.ss = limit - 1;\n        }\n        return true;\n    }\n\n    function humanize(argWithSuffix, argThresholds) {\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n\n        var withSuffix = false,\n            th = thresholds,\n            locale,\n            output;\n\n        if (typeof argWithSuffix === 'object') {\n            argThresholds = argWithSuffix;\n            argWithSuffix = false;\n        }\n        if (typeof argWithSuffix === 'boolean') {\n            withSuffix = argWithSuffix;\n        }\n        if (typeof argThresholds === 'object') {\n            th = Object.assign({}, thresholds, argThresholds);\n            if (argThresholds.s != null && argThresholds.ss == null) {\n                th.ss = argThresholds.s - 1;\n            }\n        }\n\n        locale = this.localeData();\n        output = relativeTime$1(this, !withSuffix, th, locale);\n\n        if (withSuffix) {\n            output = locale.pastFuture(+this, output);\n        }\n\n        return locale.postformat(output);\n    }\n\n    var abs$1 = Math.abs;\n\n    function sign(x) {\n        return (x > 0) - (x < 0) || +x;\n    }\n\n    function toISOString$1() {\n        // for ISO strings we do not use the normal bubbling rules:\n        //  * milliseconds bubble up until they become hours\n        //  * days do not bubble at all\n        //  * months bubble up until they become years\n        // This is because there is no context-free conversion between hours and days\n        // (think of clock changes)\n        // and also not between days and months (28-31 days per month)\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n\n        var seconds = abs$1(this._milliseconds) / 1000,\n            days = abs$1(this._days),\n            months = abs$1(this._months),\n            minutes,\n            hours,\n            years,\n            s,\n            total = this.asSeconds(),\n            totalSign,\n            ymSign,\n            daysSign,\n            hmsSign;\n\n        if (!total) {\n            // this is the same as C#'s (Noda) and python (isodate)...\n            // but not other JS (goog.date)\n            return 'P0D';\n        }\n\n        // 3600 seconds -> 60 minutes -> 1 hour\n        minutes = absFloor(seconds / 60);\n        hours = absFloor(minutes / 60);\n        seconds %= 60;\n        minutes %= 60;\n\n        // 12 months -> 1 year\n        years = absFloor(months / 12);\n        months %= 12;\n\n        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n        s = seconds ? seconds.toFixed(3).replace(/\\.?0+$/, '') : '';\n\n        totalSign = total < 0 ? '-' : '';\n        ymSign = sign(this._months) !== sign(total) ? '-' : '';\n        daysSign = sign(this._days) !== sign(total) ? '-' : '';\n        hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';\n\n        return (\n            totalSign +\n            'P' +\n            (years ? ymSign + years + 'Y' : '') +\n            (months ? ymSign + months + 'M' : '') +\n            (days ? daysSign + days + 'D' : '') +\n            (hours || minutes || seconds ? 'T' : '') +\n            (hours ? hmsSign + hours + 'H' : '') +\n            (minutes ? hmsSign + minutes + 'M' : '') +\n            (seconds ? hmsSign + s + 'S' : '')\n        );\n    }\n\n    var proto$2 = Duration.prototype;\n\n    proto$2.isValid = isValid$1;\n    proto$2.abs = abs;\n    proto$2.add = add$1;\n    proto$2.subtract = subtract$1;\n    proto$2.as = as;\n    proto$2.asMilliseconds = asMilliseconds;\n    proto$2.asSeconds = asSeconds;\n    proto$2.asMinutes = asMinutes;\n    proto$2.asHours = asHours;\n    proto$2.asDays = asDays;\n    proto$2.asWeeks = asWeeks;\n    proto$2.asMonths = asMonths;\n    proto$2.asQuarters = asQuarters;\n    proto$2.asYears = asYears;\n    proto$2.valueOf = valueOf$1;\n    proto$2._bubble = bubble;\n    proto$2.clone = clone$1;\n    proto$2.get = get$2;\n    proto$2.milliseconds = milliseconds;\n    proto$2.seconds = seconds;\n    proto$2.minutes = minutes;\n    proto$2.hours = hours;\n    proto$2.days = days;\n    proto$2.weeks = weeks;\n    proto$2.months = months;\n    proto$2.years = years;\n    proto$2.humanize = humanize;\n    proto$2.toISOString = toISOString$1;\n    proto$2.toString = toISOString$1;\n    proto$2.toJSON = toISOString$1;\n    proto$2.locale = locale;\n    proto$2.localeData = localeData;\n\n    proto$2.toIsoString = deprecate(\n        'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',\n        toISOString$1\n    );\n    proto$2.lang = lang;\n\n    // FORMATTING\n\n    addFormatToken('X', 0, 0, 'unix');\n    addFormatToken('x', 0, 0, 'valueOf');\n\n    // PARSING\n\n    addRegexToken('x', matchSigned);\n    addRegexToken('X', matchTimestamp);\n    addParseToken('X', function (input, array, config) {\n        config._d = new Date(parseFloat(input) * 1000);\n    });\n    addParseToken('x', function (input, array, config) {\n        config._d = new Date(toInt(input));\n    });\n\n    //! moment.js\n\n    hooks.version = '2.29.4';\n\n    setHookCallback(createLocal);\n\n    hooks.fn = proto;\n    hooks.min = min;\n    hooks.max = max;\n    hooks.now = now;\n    hooks.utc = createUTC;\n    hooks.unix = createUnix;\n    hooks.months = listMonths;\n    hooks.isDate = isDate;\n    hooks.locale = getSetGlobalLocale;\n    hooks.invalid = createInvalid;\n    hooks.duration = createDuration;\n    hooks.isMoment = isMoment;\n    hooks.weekdays = listWeekdays;\n    hooks.parseZone = createInZone;\n    hooks.localeData = getLocale;\n    hooks.isDuration = isDuration;\n    hooks.monthsShort = listMonthsShort;\n    hooks.weekdaysMin = listWeekdaysMin;\n    hooks.defineLocale = defineLocale;\n    hooks.updateLocale = updateLocale;\n    hooks.locales = listLocales;\n    hooks.weekdaysShort = listWeekdaysShort;\n    hooks.normalizeUnits = normalizeUnits;\n    hooks.relativeTimeRounding = getSetRelativeTimeRounding;\n    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\n    hooks.calendarFormat = getCalendarFormat;\n    hooks.prototype = proto;\n\n    // currently HTML5 input type only supports 24-hour formats\n    hooks.HTML5_FMT = {\n        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type=\"datetime-local\" />\n        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type=\"datetime-local\" step=\"1\" />\n        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type=\"datetime-local\" step=\"0.001\" />\n        DATE: 'YYYY-MM-DD', // <input type=\"date\" />\n        TIME: 'HH:mm', // <input type=\"time\" />\n        TIME_SECONDS: 'HH:mm:ss', // <input type=\"time\" step=\"1\" />\n        TIME_MS: 'HH:mm:ss.SSS', // <input type=\"time\" step=\"0.001\" />\n        WEEK: 'GGGG-[W]WW', // <input type=\"week\" />\n        MONTH: 'YYYY-MM', // <input type=\"month\" />\n    };\n\n    return hooks;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbW9tZW50L21vbWVudC5qcz8yMDNkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanNcbi8vISB2ZXJzaW9uIDogMi4yOS40XG4vLyEgYXV0aG9ycyA6IFRpbSBXb29kLCBJc2tyZW4gQ2hlcm5ldiwgTW9tZW50LmpzIGNvbnRyaWJ1dG9yc1xuLy8hIGxpY2Vuc2UgOiBNSVRcbi8vISBtb21lbnRqcy5jb21cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaG9va0NhbGxiYWNrO1xuXG4gICAgZnVuY3Rpb24gaG9va3MoKSB7XG4gICAgICAgIHJldHVybiBob29rQ2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIGRvbmUgdG8gcmVnaXN0ZXIgdGhlIG1ldGhvZCBjYWxsZWQgd2l0aCBtb21lbnQoKVxuICAgIC8vIHdpdGhvdXQgY3JlYXRpbmcgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLlxuICAgIGZ1bmN0aW9uIHNldEhvb2tDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpbnB1dCBpbnN0YW5jZW9mIEFycmF5IHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBBcnJheV0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IHdpbGwgdHJlYXQgdW5kZWZpbmVkIGFuZCBudWxsIGFzIG9iamVjdCBpZiBpdCB3YXNuJ3QgZm9yXG4gICAgICAgIC8vIGlucHV0ICE9IG51bGxcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlucHV0ICE9IG51bGwgJiZcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE9iamVjdF0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzT3duUHJvcChhLCBiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggPT09IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaztcbiAgICAgICAgICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcChvYmosIGspKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PT0gdm9pZCAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBOdW1iZXJdJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaW5wdXQgaW5zdGFuY2VvZiBEYXRlIHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgICAgICB2YXIgcmVzID0gW10sXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgYXJyTGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyckxlbjsgKytpKSB7XG4gICAgICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgdHJ1ZSkudXRjKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBkZWVwIGNsb25lIHRoaXMgb2JqZWN0LlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW1wdHk6IGZhbHNlLFxuICAgICAgICAgICAgdW51c2VkVG9rZW5zOiBbXSxcbiAgICAgICAgICAgIHVudXNlZElucHV0OiBbXSxcbiAgICAgICAgICAgIG92ZXJmbG93OiAtMixcbiAgICAgICAgICAgIGNoYXJzTGVmdE92ZXI6IDAsXG4gICAgICAgICAgICBudWxsSW5wdXQ6IGZhbHNlLFxuICAgICAgICAgICAgaW52YWxpZEVyYTogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRNb250aDogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRGb3JtYXQ6IGZhbHNlLFxuICAgICAgICAgICAgdXNlckludmFsaWRhdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzbzogZmFsc2UsXG4gICAgICAgICAgICBwYXJzZWREYXRlUGFydHM6IFtdLFxuICAgICAgICAgICAgZXJhOiBudWxsLFxuICAgICAgICAgICAgbWVyaWRpZW06IG51bGwsXG4gICAgICAgICAgICByZmMyODIyOiBmYWxzZSxcbiAgICAgICAgICAgIHdlZWtkYXlNaXNtYXRjaDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICAgICAgaWYgKG0uX3BmID09IG51bGwpIHtcbiAgICAgICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9wZjtcbiAgICB9XG5cbiAgICB2YXIgc29tZTtcbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcbiAgICAgICAgc29tZSA9IEFycmF5LnByb3RvdHlwZS5zb21lO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNvbWUgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKSxcbiAgICAgICAgICAgICAgICBsZW4gPSB0Lmxlbmd0aCA+Pj4gMCxcbiAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiB0ICYmIGZ1bi5jYWxsKHRoaXMsIHRbaV0sIGksIHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQobSkge1xuICAgICAgICBpZiAobS5faXNWYWxpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSBnZXRQYXJzaW5nRmxhZ3MobSksXG4gICAgICAgICAgICAgICAgcGFyc2VkUGFydHMgPSBzb21lLmNhbGwoZmxhZ3MucGFyc2VkRGF0ZVBhcnRzLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGlzTm93VmFsaWQgPVxuICAgICAgICAgICAgICAgICAgICAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLm92ZXJmbG93IDwgMCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRFcmEgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZFdlZWtkYXkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLndlZWtkYXlNaXNtYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRm9ybWF0ICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFmbGFncy5tZXJpZGllbSB8fCAoZmxhZ3MubWVyaWRpZW0gJiYgcGFyc2VkUGFydHMpKTtcblxuICAgICAgICAgICAgaWYgKG0uX3N0cmljdCkge1xuICAgICAgICAgICAgICAgIGlzTm93VmFsaWQgPVxuICAgICAgICAgICAgICAgICAgICBpc05vd1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5iaWdIb3VyID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4gPT0gbnVsbCB8fCAhT2JqZWN0LmlzRnJvemVuKG0pKSB7XG4gICAgICAgICAgICAgICAgbS5faXNWYWxpZCA9IGlzTm93VmFsaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc05vd1ZhbGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQoZmxhZ3MpIHtcbiAgICAgICAgdmFyIG0gPSBjcmVhdGVVVEMoTmFOKTtcbiAgICAgICAgaWYgKGZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dGVuZChnZXRQYXJzaW5nRmxhZ3MobSksIGZsYWdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS51c2VySW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgLy8gUGx1Z2lucyB0aGF0IGFkZCBwcm9wZXJ0aWVzIHNob3VsZCBhbHNvIGFkZCB0aGUga2V5IGhlcmUgKG51bGwgdmFsdWUpLFxuICAgIC8vIHNvIHdlIGNhbiBwcm9wZXJseSBjbG9uZSBvdXJzZWx2ZXMuXG4gICAgdmFyIG1vbWVudFByb3BlcnRpZXMgPSAoaG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdKSxcbiAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHByb3AsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBtb21lbnRQcm9wZXJ0aWVzTGVuID0gbW9tZW50UHJvcGVydGllcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc0FNb21lbnRPYmplY3QpKSB7XG4gICAgICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faSkpIHtcbiAgICAgICAgICAgIHRvLl9pID0gZnJvbS5faTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2YpKSB7XG4gICAgICAgICAgICB0by5fZiA9IGZyb20uX2Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sKSkge1xuICAgICAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fc3RyaWN0KSkge1xuICAgICAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3R6bSkpIHtcbiAgICAgICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc1VUQykpIHtcbiAgICAgICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fb2Zmc2V0KSkge1xuICAgICAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3BmKSkge1xuICAgICAgICAgICAgdG8uX3BmID0gZ2V0UGFyc2luZ0ZsYWdzKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbG9jYWxlKSkge1xuICAgICAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb21lbnRQcm9wZXJ0aWVzTGVuID4gMCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG1vbWVudFByb3BlcnRpZXNMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICAvLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxuICAgIGZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICAgICAgY29weUNvbmZpZyh0aGlzLCBjb25maWcpO1xuICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoY29uZmlnLl9kICE9IG51bGwgPyBjb25maWcuX2QuZ2V0VGltZSgpIDogTmFOKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgICAgICAvLyBvYmplY3RzLlxuICAgICAgICBpZiAodXBkYXRlSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNNb21lbnQob2JqKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBjb25zb2xlLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICAgICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBhcmcsXG4gICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgYXJnTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9ICdcXG5bJyArIGkgKyAnXSAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093blByb3AoYXJndW1lbnRzWzBdLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSBrZXkgKyAnOiAnICsgYXJndW1lbnRzWzBdW2tleV0gKyAnLCAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgwLCAtMik7IC8vIFJlbW92ZSB0cmFpbGluZyBjb21tYSBhbmQgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAgICAgbXNnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXG5Bcmd1bWVudHM6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykuam9pbignJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKCkuc3RhY2tcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGZuKTtcbiAgICB9XG5cbiAgICB2YXIgZGVwcmVjYXRpb25zID0ge307XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XG4gICAgICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG5hbWUsIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcbiAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHR5cGVvZiBGdW5jdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvbikgfHxcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXQoY29uZmlnKSB7XG4gICAgICAgIHZhciBwcm9wLCBpO1xuICAgICAgICBmb3IgKGkgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjb25maWcsIGkpKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IGNvbmZpZ1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgICAgICAvLyBMZW5pZW50IG9yZGluYWwgcGFyc2luZyBhY2NlcHRzIGp1c3QgYSBudW1iZXIgaW4gYWRkaXRpb24gdG9cbiAgICAgICAgLy8gbnVtYmVyICsgKHBvc3NpYmx5KSBzdHVmZiBjb21pbmcgZnJvbSBfZGF5T2ZNb250aE9yZGluYWxQYXJzZS5cbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgICAgICB0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAodGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZS5zb3VyY2UgfHwgdGhpcy5fb3JkaW5hbFBhcnNlLnNvdXJjZSkgK1xuICAgICAgICAgICAgICAgICd8JyArXG4gICAgICAgICAgICAgICAgL1xcZHsxLDJ9Ly5zb3VyY2VcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjaGlsZENvbmZpZykge1xuICAgICAgICB2YXIgcmVzID0gZXh0ZW5kKHt9LCBwYXJlbnRDb25maWcpLFxuICAgICAgICAgICAgcHJvcDtcbiAgICAgICAgZm9yIChwcm9wIGluIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0ge307XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIHBhcmVudENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQ29uZmlnW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gY2hpbGRDb25maWdbcHJvcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc1twcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChwcm9wIGluIHBhcmVudENvbmZpZykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGhhc093blByb3AocGFyZW50Q29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICFoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgIGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgZG9uJ3QgbW9kaWZ5IHBhcmVudCBjb25maWdcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBleHRlbmQoe30sIHJlc1twcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2NhbGUoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cztcbiAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgcmVzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0Q2FsZW5kYXIgPSB7XG4gICAgICAgIHNhbWVEYXk6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgbmV4dERheTogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW2F0XSBMVCcsXG4gICAgICAgIGxhc3REYXk6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgIGxhc3RXZWVrOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgICAgIHNhbWVFbHNlOiAnTCcsXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGVuZGFyKGtleSwgbW9tLCBub3cpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX2NhbGVuZGFyW2tleV0gfHwgdGhpcy5fY2FsZW5kYXJbJ3NhbWVFbHNlJ107XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG91dHB1dCkgPyBvdXRwdXQuY2FsbChtb20sIG5vdykgOiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgICAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArXG4gICAgICAgICAgICBhYnNOdW1iZXJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9XG4gICAgICAgICAgICAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oW0hoXW1tKHNzKT98TW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UW8/fE57MSw1fXxZWVlZWVl8WVlZWVl8WVlZWXxZWXx5ezIsNH18eW8/fGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fGtrP3xtbT98c3M/fFN7MSw5fXx4fFh8eno/fFpaP3wuKS9nLFxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFRTfExUfExMP0w/TD98bHsxLDR9KS9nLFxuICAgICAgICBmb3JtYXRGdW5jdGlvbnMgPSB7fSxcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcblxuICAgIC8vIHRva2VuOiAgICAnTSdcbiAgICAvLyBwYWRkZWQ6ICAgWydNTScsIDJdXG4gICAgLy8gb3JkaW5hbDogICdNbydcbiAgICAvLyBjYWxsYmFjazogZnVuY3Rpb24gKCkgeyB0aGlzLm1vbnRoKCkgKyAxIH1cbiAgICBmdW5jdGlvbiBhZGRGb3JtYXRUb2tlbih0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoXG4gICAgICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnLFxuICAgICAgICAgICAgICAgIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gaXNGdW5jdGlvbihhcnJheVtpXSlcbiAgICAgICAgICAgICAgICAgICAgPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KVxuICAgICAgICAgICAgICAgICAgICA6IGFycmF5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbiAgICBmdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sb2NhbGVEYXRhKCkpO1xuICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9XG4gICAgICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBpID0gNTtcblxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLFxuICAgICAgICAgICAgICAgIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2Vuc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgICAgICBMVFM6ICdoOm1tOnNzIEEnLFxuICAgICAgICBMVDogJ2g6bW0gQScsXG4gICAgICAgIEw6ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgTEw6ICdNTU1NIEQsIFlZWVknLFxuICAgICAgICBMTEw6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICAgICAgTExMTDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb25nRGF0ZUZvcm1hdChrZXkpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlclxuICAgICAgICAgICAgLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0b2spIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHRvayA9PT0gJ01NTU0nIHx8XG4gICAgICAgICAgICAgICAgICAgIHRvayA9PT0gJ01NJyB8fFxuICAgICAgICAgICAgICAgICAgICB0b2sgPT09ICdERCcgfHxcbiAgICAgICAgICAgICAgICAgICAgdG9rID09PSAnZGRkZCdcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvay5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvaztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG4gICAgZnVuY3Rpb24gaW52YWxpZERhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE9yZGluYWwgPSAnJWQnLFxuICAgICAgICBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsKG51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3JkaW5hbC5yZXBsYWNlKCclZCcsIG51bWJlcik7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRSZWxhdGl2ZVRpbWUgPSB7XG4gICAgICAgIGZ1dHVyZTogJ2luICVzJyxcbiAgICAgICAgcGFzdDogJyVzIGFnbycsXG4gICAgICAgIHM6ICdhIGZldyBzZWNvbmRzJyxcbiAgICAgICAgc3M6ICclZCBzZWNvbmRzJyxcbiAgICAgICAgbTogJ2EgbWludXRlJyxcbiAgICAgICAgbW06ICclZCBtaW51dGVzJyxcbiAgICAgICAgaDogJ2FuIGhvdXInLFxuICAgICAgICBoaDogJyVkIGhvdXJzJyxcbiAgICAgICAgZDogJ2EgZGF5JyxcbiAgICAgICAgZGQ6ICclZCBkYXlzJyxcbiAgICAgICAgdzogJ2Egd2VlaycsXG4gICAgICAgIHd3OiAnJWQgd2Vla3MnLFxuICAgICAgICBNOiAnYSBtb250aCcsXG4gICAgICAgIE1NOiAnJWQgbW9udGhzJyxcbiAgICAgICAgeTogJ2EgeWVhcicsXG4gICAgICAgIHl5OiAnJWQgeWVhcnMnLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob3V0cHV0KVxuICAgICAgICAgICAgPyBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKVxuICAgICAgICAgICAgOiBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXN0RnV0dXJlKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWxpYXNlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdEFsaWFzKHVuaXQsIHNob3J0aGFuZCkge1xuICAgICAgICB2YXIgbG93ZXJDYXNlID0gdW5pdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBhbGlhc2VzW2xvd2VyQ2FzZV0gPSBhbGlhc2VzW2xvd2VyQ2FzZSArICdzJ10gPSBhbGlhc2VzW3Nob3J0aGFuZF0gPSB1bml0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdW5pdHMgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wLFxuICAgICAgICAgICAgcHJvcDtcblxuICAgICAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGlucHV0T2JqZWN0LCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xuICAgIH1cblxuICAgIHZhciBwcmlvcml0aWVzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRVbml0UHJpb3JpdHkodW5pdCwgcHJpb3JpdHkpIHtcbiAgICAgICAgcHJpb3JpdGllc1t1bml0XSA9IHByaW9yaXR5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFByaW9yaXRpemVkVW5pdHModW5pdHNPYmopIHtcbiAgICAgICAgdmFyIHVuaXRzID0gW10sXG4gICAgICAgICAgICB1O1xuICAgICAgICBmb3IgKHUgaW4gdW5pdHNPYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKHVuaXRzT2JqLCB1KSkge1xuICAgICAgICAgICAgICAgIHVuaXRzLnB1c2goeyB1bml0OiB1LCBwcmlvcml0eTogcHJpb3JpdGllc1t1XSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdW5pdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNGbG9vcihudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIC8vIC0wIC0+IDBcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKSB8fCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0U2V0KHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0JDEodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCBrZWVwVGltZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgdW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0KG1vbSwgdW5pdCkge1xuICAgICAgICByZXR1cm4gbW9tLmlzVmFsaWQoKVxuICAgICAgICAgICAgPyBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKVxuICAgICAgICAgICAgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0JDEobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICBpZiAobW9tLmlzVmFsaWQoKSAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdW5pdCA9PT0gJ0Z1bGxZZWFyJyAmJlxuICAgICAgICAgICAgICAgIGlzTGVhcFllYXIobW9tLnllYXIoKSkgJiZcbiAgICAgICAgICAgICAgICBtb20ubW9udGgoKSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgIG1vbS5kYXRlKCkgPT09IDI5XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvSW50KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBtb20ubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgZGF5c0luTW9udGgodmFsdWUsIG1vbS5tb250aCgpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzdHJpbmdHZXQodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RyaW5nU2V0KHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVPYmplY3RVbml0cyh1bml0cyk7XG4gICAgICAgICAgICB2YXIgcHJpb3JpdGl6ZWQgPSBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzKSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIHByaW9yaXRpemVkTGVuID0gcHJpb3JpdGl6ZWQubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHByaW9yaXRpemVkTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzW3ByaW9yaXRpemVkW2ldLnVuaXRdKHVuaXRzW3ByaW9yaXRpemVkW2ldLnVuaXRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2gxID0gL1xcZC8sIC8vICAgICAgIDAgLSA5XG4gICAgICAgIG1hdGNoMiA9IC9cXGRcXGQvLCAvLyAgICAgIDAwIC0gOTlcbiAgICAgICAgbWF0Y2gzID0gL1xcZHszfS8sIC8vICAgICAwMDAgLSA5OTlcbiAgICAgICAgbWF0Y2g0ID0gL1xcZHs0fS8sIC8vICAgIDAwMDAgLSA5OTk5XG4gICAgICAgIG1hdGNoNiA9IC9bKy1dP1xcZHs2fS8sIC8vIC05OTk5OTkgLSA5OTk5OTlcbiAgICAgICAgbWF0Y2gxdG8yID0gL1xcZFxcZD8vLCAvLyAgICAgICAwIC0gOTlcbiAgICAgICAgbWF0Y2gzdG80ID0gL1xcZFxcZFxcZFxcZD8vLCAvLyAgICAgOTk5IC0gOTk5OVxuICAgICAgICBtYXRjaDV0bzYgPSAvXFxkXFxkXFxkXFxkXFxkXFxkPy8sIC8vICAgOTk5OTkgLSA5OTk5OTlcbiAgICAgICAgbWF0Y2gxdG8zID0gL1xcZHsxLDN9LywgLy8gICAgICAgMCAtIDk5OVxuICAgICAgICBtYXRjaDF0bzQgPSAvXFxkezEsNH0vLCAvLyAgICAgICAwIC0gOTk5OVxuICAgICAgICBtYXRjaDF0bzYgPSAvWystXT9cXGR7MSw2fS8sIC8vIC05OTk5OTkgLSA5OTk5OTlcbiAgICAgICAgbWF0Y2hVbnNpZ25lZCA9IC9cXGQrLywgLy8gICAgICAgMCAtIGluZlxuICAgICAgICBtYXRjaFNpZ25lZCA9IC9bKy1dP1xcZCsvLCAvLyAgICAtaW5mIC0gaW5mXG4gICAgICAgIG1hdGNoT2Zmc2V0ID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpLCAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbiAgICAgICAgbWF0Y2hTaG9ydE9mZnNldCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/L2dpLCAvLyArMDAgLTAwICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuICAgICAgICBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy8sIC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG4gICAgICAgIC8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxuICAgICAgICAvLyBpbmNsdWRlcyBzY290dGlzaCBnYWVsaWMgdHdvIHdvcmQgYW5kIGh5cGhlbmF0ZWQgbW9udGhzXG4gICAgICAgIG1hdGNoV29yZCA9XG4gICAgICAgICAgICAvWzAtOV17MCwyNTZ9WydhLXpcXHUwMEEwLVxcdTA1RkZcXHUwNzAwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGMDdcXHVGRjEwLVxcdUZGRUZdezEsMjU2fXxbXFx1MDYwMC1cXHUwNkZGXFwvXXsxLDI1Nn0oXFxzKj9bXFx1MDYwMC1cXHUwNkZGXXsxLDI1Nn0pezEsMn0vaSxcbiAgICAgICAgcmVnZXhlcztcblxuICAgIHJlZ2V4ZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4odG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgICAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpXG4gICAgICAgICAgICA/IHJlZ2V4XG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlRGF0YSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4ID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICAgICAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykge1xuICAgICAgICBpZiAoIWhhc093blByb3AocmVnZXhlcywgdG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh1bmVzY2FwZUZvcm1hdCh0b2tlbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZ2V4ZXNbdG9rZW5dKGNvbmZpZy5fc3RyaWN0LCBjb25maWcuX2xvY2FsZSk7XG4gICAgfVxuXG4gICAgLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuICAgIGZ1bmN0aW9uIHVuZXNjYXBlRm9ybWF0KHMpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2V4RXNjYXBlKFxuICAgICAgICAgICAgc1xuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdcXFxcJywgJycpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgIC9cXFxcKFxcWyl8XFxcXChcXF0pfFxcWyhbXlxcXVxcW10qKVxcXXxcXFxcKC4pL2csXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChtYXRjaGVkLCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAxIHx8IHAyIHx8IHAzIHx8IHA0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgdmFyIHRva2VucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUGFyc2VUb2tlbih0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBmdW5jID0gY2FsbGJhY2ssXG4gICAgICAgICAgICB0b2tlbkxlbjtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRva2VuID0gW3Rva2VuXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOdW1iZXIoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2NhbGxiYWNrXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5MZW4gPSB0b2tlbi5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbkxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5baV1dID0gZnVuYztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtQYXJzZVRva2VuKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XG4gICAgICAgICAgICBjYWxsYmFjayhpbnB1dCwgY29uZmlnLl93LCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIGlucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwgJiYgaGFzT3duUHJvcCh0b2tlbnMsIHRva2VuKSkge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuXShpbnB1dCwgY29uZmlnLl9hLCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBZRUFSID0gMCxcbiAgICAgICAgTU9OVEggPSAxLFxuICAgICAgICBEQVRFID0gMixcbiAgICAgICAgSE9VUiA9IDMsXG4gICAgICAgIE1JTlVURSA9IDQsXG4gICAgICAgIFNFQ09ORCA9IDUsXG4gICAgICAgIE1JTExJU0VDT05EID0gNixcbiAgICAgICAgV0VFSyA9IDcsXG4gICAgICAgIFdFRUtEQVkgPSA4O1xuXG4gICAgZnVuY3Rpb24gbW9kKG4sIHgpIHtcbiAgICAgICAgcmV0dXJuICgobiAlIHgpICsgeCkgJSB4O1xuICAgIH1cblxuICAgIHZhciBpbmRleE9mO1xuXG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgICAgIGluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleE9mID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIC8vIEkga25vd1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSBvKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICAgICAgICBpZiAoaXNOYU4oeWVhcikgfHwgaXNOYU4obW9udGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtb2RNb250aCA9IG1vZChtb250aCwgMTIpO1xuICAgICAgICB5ZWFyICs9IChtb250aCAtIG1vZE1vbnRoKSAvIDEyO1xuICAgICAgICByZXR1cm4gbW9kTW9udGggPT09IDFcbiAgICAgICAgICAgID8gaXNMZWFwWWVhcih5ZWFyKVxuICAgICAgICAgICAgICAgID8gMjlcbiAgICAgICAgICAgICAgICA6IDI4XG4gICAgICAgICAgICA6IDMxIC0gKChtb2RNb250aCAlIDcpICUgMik7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ00nLCBbJ01NJywgMl0sICdNbycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9udGgoKSArIDE7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21vbnRoJywgJ00nKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21vbnRoJywgOCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdNJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU0nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTU0nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydNJywgJ01NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gdG9JbnQoaW5wdXQpIC0gMTtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydNTU0nLCAnTU1NTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciBtb250aCA9IGNvbmZpZy5fbG9jYWxlLm1vbnRoc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZmluZCBhIG1vbnRoIG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZC5cbiAgICAgICAgaWYgKG1vbnRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFycmF5W01PTlRIXSA9IG1vbnRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZE1vbnRoID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzID1cbiAgICAgICAgICAgICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdChcbiAgICAgICAgICAgICAgICAnXydcbiAgICAgICAgICAgICksXG4gICAgICAgIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCA9XG4gICAgICAgICAgICAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyksXG4gICAgICAgIE1PTlRIU19JTl9GT1JNQVQgPSAvRFtvRF0/KFxcW1teXFxbXFxdXSpcXF18XFxzKStNTU1NPy8sXG4gICAgICAgIGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkLFxuICAgICAgICBkZWZhdWx0TW9udGhzUmVnZXggPSBtYXRjaFdvcmQ7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHMobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKVxuICAgICAgICAgICAgICAgID8gdGhpcy5fbW9udGhzXG4gICAgICAgICAgICAgICAgOiB0aGlzLl9tb250aHNbJ3N0YW5kYWxvbmUnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHMpXG4gICAgICAgICAgICA/IHRoaXMuX21vbnRoc1ttLm1vbnRoKCldXG4gICAgICAgICAgICA6IHRoaXMuX21vbnRoc1tcbiAgICAgICAgICAgICAgICAgICh0aGlzLl9tb250aHMuaXNGb3JtYXQgfHwgTU9OVEhTX0lOX0ZPUk1BVCkudGVzdChmb3JtYXQpXG4gICAgICAgICAgICAgICAgICAgICAgPyAnZm9ybWF0J1xuICAgICAgICAgICAgICAgICAgICAgIDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgICAgIF1bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNTaG9ydChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydClcbiAgICAgICAgICAgICAgICA/IHRoaXMuX21vbnRoc1Nob3J0XG4gICAgICAgICAgICAgICAgOiB0aGlzLl9tb250aHNTaG9ydFsnc3RhbmRhbG9uZSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KVxuICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTaG9ydFttLm1vbnRoKCldXG4gICAgICAgICAgICA6IHRoaXMuX21vbnRoc1Nob3J0W1xuICAgICAgICAgICAgICAgICAgTU9OVEhTX0lOX0ZPUk1BVC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgICAgICBdW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGlpLFxuICAgICAgICAgICAgbW9tLFxuICAgICAgICAgICAgbGxjID0gbW9udGhOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHVzZWRcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgKytpKSB7XG4gICAgICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzU2hvcnQoXG4gICAgICAgICAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICApLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzUGFyc2UobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlLmNhbGwodGhpcywgbW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBhZGQgc29ydGluZ1xuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyXG4gICAgICAgIC8vIHNlZSBzb3J0aW5nIGluIGNvbXB1dGVNb250aHNQYXJzZVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJyxcbiAgICAgICAgICAgICAgICAgICAgJ2knXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RyaWN0ICYmICF0aGlzLl9tb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID1cbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykgKyAnfF4nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgZm9ybWF0ID09PSAnTU1NTScgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgZm9ybWF0ID09PSAnTU1NJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl9tb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHNldE1vbnRoKG1vbSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRheU9mTW9udGg7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoL15cXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvSW50KHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtb20ubG9jYWxlRGF0YSgpLm1vbnRoc1BhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBBbm90aGVyIHNpbGVudCBmYWlsdXJlP1xuICAgICAgICAgICAgICAgIGlmICghaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGF5T2ZNb250aCA9IE1hdGgubWluKG1vbS5kYXRlKCksIGRheXNJbk1vbnRoKG1vbS55ZWFyKCksIHZhbHVlKSk7XG4gICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyAnTW9udGgnXSh2YWx1ZSwgZGF5T2ZNb250aCk7XG4gICAgICAgIHJldHVybiBtb207XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0TW9udGgodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCAnTW9udGgnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERheXNJbk1vbnRoKCkge1xuICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzU2hvcnRSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3RcbiAgICAgICAgICAgICAgICA/IHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXhcbiAgICAgICAgICAgICAgICA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aHNSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBkZWZhdWx0TW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3RcbiAgICAgICAgICAgICAgICA/IHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVNb250aHNQYXJzZSgpIHtcbiAgICAgICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNob3J0UGllY2VzID0gW10sXG4gICAgICAgICAgICBsb25nUGllY2VzID0gW10sXG4gICAgICAgICAgICBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG1vbTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgc2hvcnRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShzaG9ydFBpZWNlc1tpXSk7XG4gICAgICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDI0OyBpKyspIHtcbiAgICAgICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdZJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeSA9IHRoaXMueWVhcigpO1xuICAgICAgICByZXR1cm4geSA8PSA5OTk5ID8gemVyb0ZpbGwoeSwgNCkgOiAnKycgKyB5O1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsIDRdLCAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVknLCA1XSwgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZWScsIDYsIHRydWVdLCAwLCAneWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd5ZWFyJywgJ3knKTtcblxuICAgIC8vIFBSSU9SSVRJRVNcblxuICAgIGFkZFVuaXRQcmlvcml0eSgneWVhcicsIDEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWScsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZJywgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydZWVlZWScsICdZWVlZWVknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPVxuICAgICAgICAgICAgaW5wdXQubGVuZ3RoID09PSAyID8gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpIDogdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG4gICAgfTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCB0cnVlKTtcblxuICAgIGZ1bmN0aW9uIGdldElzTGVhcFllYXIoKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgICAgIC8vIGNhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTgxMzQ4XG4gICAgICAgIHZhciBkYXRlO1xuICAgICAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHkgKyA0MDAsIG0sIGQsIGgsIE0sIHMsIG1zKTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShkYXRlLmdldEZ1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVENEYXRlKHkpIHtcbiAgICAgICAgdmFyIGRhdGUsIGFyZ3M7XG4gICAgICAgIC8vIHRoZSBEYXRlLlVUQyBmdW5jdGlvbiByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICBhcmdzWzBdID0geSArIDQwMDtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmdzKSk7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICAvLyBzdGFydC1vZi1maXJzdC13ZWVrIC0gc3RhcnQtb2YteWVhclxuICAgIGZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgLy8gZmlyc3Qtd2VlayBkYXkgLS0gd2hpY2ggamFudWFyeSBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgKDQgZm9yIGlzbywgMSBmb3Igb3RoZXIpXG4gICAgICAgICAgICBmd2QgPSA3ICsgZG93IC0gZG95LFxuICAgICAgICAgICAgLy8gZmlyc3Qtd2VlayBkYXkgbG9jYWwgd2Vla2RheSAtLSB3aGljaCBsb2NhbCB3ZWVrZGF5IGlzIGZ3ZFxuICAgICAgICAgICAgZndkbHcgPSAoNyArIGNyZWF0ZVVUQ0RhdGUoeWVhciwgMCwgZndkKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xuXG4gICAgICAgIHJldHVybiAtZndkbHcgKyBmd2QgLSAxO1xuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBsb2NhbFdlZWtkYXkgPSAoNyArIHdlZWtkYXkgLSBkb3cpICUgNyxcbiAgICAgICAgICAgIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF5T2ZZZWFyID0gMSArIDcgKiAod2VlayAtIDEpICsgbG9jYWxXZWVrZGF5ICsgd2Vla09mZnNldCxcbiAgICAgICAgICAgIHJlc1llYXIsXG4gICAgICAgICAgICByZXNEYXlPZlllYXI7XG5cbiAgICAgICAgaWYgKGRheU9mWWVhciA8PSAwKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciAtIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlzSW5ZZWFyKHJlc1llYXIpICsgZGF5T2ZZZWFyO1xuICAgICAgICB9IGVsc2UgaWYgKGRheU9mWWVhciA+IGRheXNJblllYXIoeWVhcikpIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyICsgMTtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhciAtIGRheXNJblllYXIoeWVhcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhcjtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyOiByZXNZZWFyLFxuICAgICAgICAgICAgZGF5T2ZZZWFyOiByZXNEYXlPZlllYXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KG1vbS55ZWFyKCksIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWsgPSBNYXRoLmZsb29yKChtb20uZGF5T2ZZZWFyKCkgLSB3ZWVrT2Zmc2V0IC0gMSkgLyA3KSArIDEsXG4gICAgICAgICAgICByZXNXZWVrLFxuICAgICAgICAgICAgcmVzWWVhcjtcblxuICAgICAgICBpZiAod2VlayA8IDEpIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpIC0gMTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrICsgd2Vla3NJblllYXIocmVzWWVhciwgZG93LCBkb3kpO1xuICAgICAgICB9IGVsc2UgaWYgKHdlZWsgPiB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrIC0gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCk7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3ZWVrOiByZXNXZWVrLFxuICAgICAgICAgICAgeWVhcjogcmVzWWVhcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrc0luWWVhcih5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0TmV4dCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyICsgMSwgZG93LCBkb3kpO1xuICAgICAgICByZXR1cm4gKGRheXNJblllYXIoeWVhcikgLSB3ZWVrT2Zmc2V0ICsgd2Vla09mZnNldE5leHQpIC8gNztcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigndycsIFsnd3cnLCAyXSwgJ3dvJywgJ3dlZWsnKTtcbiAgICBhZGRGb3JtYXRUb2tlbignVycsIFsnV1cnLCAyXSwgJ1dvJywgJ2lzb1dlZWsnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnd2VlaycsICd3Jyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrJywgJ1cnKTtcblxuICAgIC8vIFBSSU9SSVRJRVNcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnd2VlaycsIDUpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnaXNvV2VlaycsIDUpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigndycsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignVycsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihcbiAgICAgICAgWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSxcbiAgICAgICAgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAxKV0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vlayhtb20pIHtcbiAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIobW9tLCB0aGlzLl93ZWVrLmRvdywgdGhpcy5fd2Vlay5kb3kpLndlZWs7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrID0ge1xuICAgICAgICBkb3c6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICBkb3k6IDYsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDZ0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZldlZWsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrLmRvdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mWWVhcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWsoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayhpbnB1dCkge1xuICAgICAgICB2YXIgd2VlayA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkud2VlaztcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkJywgMCwgJ2RvJywgJ2RheScpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZScsIDAsIDAsICd3ZWVrZGF5Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ0UnLCAwLCAwLCAnaXNvV2Vla2RheScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXknLCAnZCcpO1xuICAgIGFkZFVuaXRBbGlhcygnd2Vla2RheScsICdlJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrZGF5JywgJ0UnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXknLCAxMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrZGF5JywgMTEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla2RheScsIDExKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2QnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2UnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0UnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGQnLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkZCcsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2RkJywgJ2RkZCcsICdkZGRkJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgd2Vla2RheSA9IGNvbmZpZy5fbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBnZXQgYSB3ZWVrZGF5IG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZFxuICAgICAgICBpZiAod2Vla2RheSAhPSBudWxsKSB7XG4gICAgICAgICAgICB3ZWVrLmQgPSB3ZWVrZGF5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZFdlZWtkYXkgPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkJywgJ2UnLCAnRSddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBwYXJzZVdlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc05hTihpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChpbnB1dCwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXQgPSBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KSAlIDcgfHwgNztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNOYU4oaW5wdXQpID8gbnVsbCA6IGlucHV0O1xuICAgIH1cblxuICAgIC8vIExPQ0FMRVNcbiAgICBmdW5jdGlvbiBzaGlmdFdlZWtkYXlzKHdzLCBuKSB7XG4gICAgICAgIHJldHVybiB3cy5zbGljZShuLCA3KS5jb25jYXQod3Muc2xpY2UoMCwgbikpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXMgPVxuICAgICAgICAgICAgJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpLFxuICAgICAgICBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyksXG4gICAgICAgIGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbiA9ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKSxcbiAgICAgICAgZGVmYXVsdFdlZWtkYXlzUmVnZXggPSBtYXRjaFdvcmQsXG4gICAgICAgIGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXggPSBtYXRjaFdvcmQsXG4gICAgICAgIGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4ID0gbWF0Y2hXb3JkO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXMobSwgZm9ybWF0KSB7XG4gICAgICAgIHZhciB3ZWVrZGF5cyA9IGlzQXJyYXkodGhpcy5fd2Vla2RheXMpXG4gICAgICAgICAgICA/IHRoaXMuX3dlZWtkYXlzXG4gICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzW1xuICAgICAgICAgICAgICAgICAgbSAmJiBtICE9PSB0cnVlICYmIHRoaXMuX3dlZWtkYXlzLmlzRm9ybWF0LnRlc3QoZm9ybWF0KVxuICAgICAgICAgICAgICAgICAgICAgID8gJ2Zvcm1hdCdcbiAgICAgICAgICAgICAgICAgICAgICA6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgICAgICBdO1xuICAgICAgICByZXR1cm4gbSA9PT0gdHJ1ZVxuICAgICAgICAgICAgPyBzaGlmdFdlZWtkYXlzKHdlZWtkYXlzLCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogbVxuICAgICAgICAgICAgPyB3ZWVrZGF5c1ttLmRheSgpXVxuICAgICAgICAgICAgOiB3ZWVrZGF5cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1Nob3J0KG0pIHtcbiAgICAgICAgcmV0dXJuIG0gPT09IHRydWVcbiAgICAgICAgICAgID8gc2hpZnRXZWVrZGF5cyh0aGlzLl93ZWVrZGF5c1Nob3J0LCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogbVxuICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1Nob3J0W20uZGF5KCldXG4gICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzU2hvcnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNNaW4obSkge1xuICAgICAgICByZXR1cm4gbSA9PT0gdHJ1ZVxuICAgICAgICAgICAgPyBzaGlmdFdlZWtkYXlzKHRoaXMuX3dlZWtkYXlzTWluLCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogbVxuICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXVxuICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c01pbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZSQxKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGlpLFxuICAgICAgICAgICAgbW9tLFxuICAgICAgICAgICAgbGxjID0gd2Vla2RheU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c01pbihcbiAgICAgICAgICAgICAgICAgICAgbW9tLFxuICAgICAgICAgICAgICAgICAgICAnJ1xuICAgICAgICAgICAgICAgICkudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzU2hvcnQoXG4gICAgICAgICAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICApLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzUGFyc2Uod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZSQxLmNhbGwodGhpcywgd2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG5cbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJyxcbiAgICAgICAgICAgICAgICAgICAgJ2knXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID1cbiAgICAgICAgICAgICAgICAgICAgJ14nICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5cyhtb20sICcnKSArXG4gICAgICAgICAgICAgICAgICAgICd8XicgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykgK1xuICAgICAgICAgICAgICAgICAgICAnfF4nICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzdHJpY3QgJiZcbiAgICAgICAgICAgICAgICBmb3JtYXQgPT09ICdkZGRkJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgZm9ybWF0ID09PSAnZGRkJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ2RkJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mV2VlayhpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheSA9IHRoaXMuX2lzVVRDID8gdGhpcy5fZC5nZXRVVENEYXkoKSA6IHRoaXMuX2QuZ2V0RGF5KCk7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGlucHV0IC0gZGF5LCAnZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRheTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayhpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdlZWtkYXkgPSAodGhpcy5kYXkoKSArIDcgLSB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3cpICUgNztcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrZGF5IDogdGhpcy5hZGQoaW5wdXQgLSB3ZWVrZGF5LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT0RheU9mV2VlayhpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXG4gICAgICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cblxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHdlZWtkYXkgPSBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IHdlZWtkYXkgOiB3ZWVrZGF5IC0gNyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkoKSB8fCA3O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla2RheXNSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3RcbiAgICAgICAgICAgICAgICA/IHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXhcbiAgICAgICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXhcbiAgICAgICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzTWluUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSBkZWZhdWx0V2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVdlZWtkYXlzUGFyc2UoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW5QaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIHNob3J0UGllY2VzID0gW10sXG4gICAgICAgICAgICBsb25nUGllY2VzID0gW10sXG4gICAgICAgICAgICBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgIG1pbnAsXG4gICAgICAgICAgICBzaG9ydHAsXG4gICAgICAgICAgICBsb25ncDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBtaW5wID0gcmVnZXhFc2NhcGUodGhpcy53ZWVrZGF5c01pbihtb20sICcnKSk7XG4gICAgICAgICAgICBzaG9ydHAgPSByZWdleEVzY2FwZSh0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICAgICAgbG9uZ3AgPSByZWdleEVzY2FwZSh0aGlzLndlZWtkYXlzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1pblBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIHdlZWtkYXkgKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBtaW5QaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgbWluUGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIGhGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgJSAxMiB8fCAxMjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpIHx8IDI0O1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdoJywgWydoaCcsIDJdLCAwLCBoRm9ybWF0KTtcbiAgICBhZGRGb3JtYXRUb2tlbignaycsIFsna2snLCAyXSwgMCwga0Zvcm1hdCk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgJycgK1xuICAgICAgICAgICAgaEZvcm1hdC5hcHBseSh0aGlzKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpXG4gICAgICAgICk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAnJyArXG4gICAgICAgICAgICB0aGlzLmhvdXJzKCkgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKVxuICAgICAgICApO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW0odG9rZW4sIGxvd2VyY2FzZSkge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1lcmlkaWVtKFxuICAgICAgICAgICAgICAgIHRoaXMuaG91cnMoKSxcbiAgICAgICAgICAgICAgICB0aGlzLm1pbnV0ZXMoKSxcbiAgICAgICAgICAgICAgICBsb3dlcmNhc2VcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1lcmlkaWVtKCdhJywgdHJ1ZSk7XG4gICAgbWVyaWRpZW0oJ0EnLCBmYWxzZSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2hvdXInLCAnaCcpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2hvdXInLCAxMyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBmdW5jdGlvbiBtYXRjaE1lcmlkaWVtKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5fbWVyaWRpZW1QYXJzZTtcbiAgICB9XG5cbiAgICBhZGRSZWdleFRva2VuKCdhJywgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignQScsIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0gnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2gnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2snLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0hIJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2hoJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2trJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkUmVnZXhUb2tlbignaG1tJywgbWF0Y2gzdG80KTtcbiAgICBhZGRSZWdleFRva2VuKCdobW1zcycsIG1hdGNoNXRvNik7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tJywgbWF0Y2gzdG80KTtcbiAgICBhZGRSZWdleFRva2VuKCdIbW1zcycsIG1hdGNoNXRvNik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnSCcsICdISCddLCBIT1VSKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaycsICdrayddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIGtJbnB1dCA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSBrSW5wdXQgPT09IDI0ID8gMCA6IGtJbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnYScsICdBJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2lzUG0gPSBjb25maWcuX2xvY2FsZS5pc1BNKGlucHV0KTtcbiAgICAgICAgY29uZmlnLl9tZXJpZGllbSA9IGlucHV0O1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oWydoJywgJ2hoJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignaG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignaG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0LFxuICAgICAgICAgICAgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNCxcbiAgICAgICAgICAgIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICB9KTtcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUlzUE0oaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IFF1aXJrcyBNb2RlICYgSUU3IFN0YW5kYXJkcyBNb2RlIGRvIG5vdCBhbGxvdyBhY2Nlc3Npbmcgc3RyaW5ncyBsaWtlIGFycmF5c1xuICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICAgICAgcmV0dXJuIChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSA9IC9bYXBdXFwuP20/XFwuPy9pLFxuICAgICAgICAvLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcbiAgICAgICAgLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgdGhleSB3YW50LiBTbyB0cnlpbmcgdG8gbWFpbnRhaW4gdGhlIHNhbWUgaG91ciAoaW5cbiAgICAgICAgLy8gYSBuZXcgdGltZXpvbmUpIG1ha2VzIHNlbnNlLiBBZGRpbmcvc3VidHJhY3RpbmcgaG91cnMgZG9lcyBub3QgZm9sbG93XG4gICAgICAgIC8vIHRoaXMgcnVsZS5cbiAgICAgICAgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNZXJpZGllbShob3VycywgbWludXRlcywgaXNMb3dlcikge1xuICAgICAgICBpZiAoaG91cnMgPiAxMSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAncG0nIDogJ1BNJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2FtJyA6ICdBTSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYmFzZUNvbmZpZyA9IHtcbiAgICAgICAgY2FsZW5kYXI6IGRlZmF1bHRDYWxlbmRhcixcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IGRlZmF1bHRMb25nRGF0ZUZvcm1hdCxcbiAgICAgICAgaW52YWxpZERhdGU6IGRlZmF1bHRJbnZhbGlkRGF0ZSxcbiAgICAgICAgb3JkaW5hbDogZGVmYXVsdE9yZGluYWwsXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlLFxuICAgICAgICByZWxhdGl2ZVRpbWU6IGRlZmF1bHRSZWxhdGl2ZVRpbWUsXG5cbiAgICAgICAgbW9udGhzOiBkZWZhdWx0TG9jYWxlTW9udGhzLFxuICAgICAgICBtb250aHNTaG9ydDogZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LFxuXG4gICAgICAgIHdlZWs6IGRlZmF1bHRMb2NhbGVXZWVrLFxuXG4gICAgICAgIHdlZWtkYXlzOiBkZWZhdWx0TG9jYWxlV2Vla2RheXMsXG4gICAgICAgIHdlZWtkYXlzTWluOiBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4sXG4gICAgICAgIHdlZWtkYXlzU2hvcnQ6IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LFxuXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlLFxuICAgIH07XG5cbiAgICAvLyBpbnRlcm5hbCBzdG9yYWdlIGZvciBsb2NhbGUgY29uZmlnIGZpbGVzXG4gICAgdmFyIGxvY2FsZXMgPSB7fSxcbiAgICAgICAgbG9jYWxlRmFtaWxpZXMgPSB7fSxcbiAgICAgICAgZ2xvYmFsTG9jYWxlO1xuXG4gICAgZnVuY3Rpb24gY29tbW9uUHJlZml4KGFycjEsIGFycjIpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBtaW5sID0gTWF0aC5taW4oYXJyMS5sZW5ndGgsIGFycjIubGVuZ3RoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1pbmw7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWlubDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGUoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbiAgICB9XG5cbiAgICAvLyBwaWNrIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXlcbiAgICAvLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuICAgIC8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbiAgICBmdW5jdGlvbiBjaG9vc2VMb2NhbGUobmFtZXMpIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICBzcGxpdDtcblxuICAgICAgICB3aGlsZSAoaSA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICAgICAgbmV4dCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpICsgMV0pO1xuICAgICAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShzcGxpdC5zbGljZSgwLCBqKS5qb2luKCctJykpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBuZXh0ICYmXG4gICAgICAgICAgICAgICAgICAgIG5leHQubGVuZ3RoID49IGogJiZcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uUHJlZml4KHNwbGl0LCBuZXh0KSA+PSBqIC0gMVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xvY2FsZU5hbWVTYW5lKG5hbWUpIHtcbiAgICAgICAgLy8gUHJldmVudCBuYW1lcyB0aGF0IGxvb2sgbGlrZSBmaWxlc3lzdGVtIHBhdGhzLCBpLmUgY29udGFpbiAnLycgb3IgJ1xcJ1xuICAgICAgICByZXR1cm4gbmFtZS5tYXRjaCgnXlteL1xcXFxcXFxcXSokJykgIT0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcbiAgICAgICAgdmFyIG9sZExvY2FsZSA9IG51bGwsXG4gICAgICAgICAgICBhbGlhc2VkUmVxdWlyZTtcbiAgICAgICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgbW9kdWxlICYmXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyAmJlxuICAgICAgICAgICAgaXNMb2NhbGVOYW1lU2FuZShuYW1lKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2xkTG9jYWxlID0gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgICAgICAgICAgICAgIGFsaWFzZWRSZXF1aXJlID0gcmVxdWlyZTtcbiAgICAgICAgICAgICAgICBhbGlhc2VkUmVxdWlyZSgnLi9sb2NhbGUvJyArIG5hbWUpO1xuICAgICAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShvbGRMb2NhbGUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIG1hcmsgYXMgbm90IGZvdW5kIHRvIGF2b2lkIHJlcGVhdGluZyBleHBlbnNpdmUgZmlsZSByZXF1aXJlIGNhbGwgY2F1c2luZyBoaWdoIENQVVxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdHJ5aW5nIHRvIGZpbmQgZW4tVVMsIGVuX1VTLCBlbi11cyBmb3IgZXZlcnkgZm9ybWF0IGNhbGxcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbnVsbDsgLy8gbnVsbCBtZWFucyBub3QgZm91bmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCBsb2NhbGUgYW5kIHRoZW4gc2V0IHRoZSBnbG9iYWwgbG9jYWxlLiAgSWZcbiAgICAvLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuICAgIC8vIGxvY2FsZSBrZXkuXG4gICAgZnVuY3Rpb24gZ2V0U2V0R2xvYmFsTG9jYWxlKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZ2xvYmFsTG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy93YXJuIHVzZXIgaWYgYXJndW1lbnRzIGFyZSBwYXNzZWQgYnV0IHRoZSBsb2NhbGUgY291bGQgbm90IGJlIHNldFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAgICAgICAnTG9jYWxlICcgKyBrZXkgKyAnIG5vdCBmb3VuZC4gRGlkIHlvdSBmb3JnZXQgdG8gbG9hZCBpdD8nXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZpbmVMb2NhbGUobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsXG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgICAgIGNvbmZpZy5hYmJyID0gbmFtZTtcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUoXG4gICAgICAgICAgICAgICAgICAgICdkZWZpbmVMb2NhbGVPdmVycmlkZScsXG4gICAgICAgICAgICAgICAgICAgICd1c2UgbW9tZW50LnVwZGF0ZUxvY2FsZShsb2NhbGVOYW1lLCBjb25maWcpIHRvIGNoYW5nZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhbiBleGlzdGluZyBsb2NhbGUuIG1vbWVudC5kZWZpbmVMb2NhbGUobG9jYWxlTmFtZSwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnY29uZmlnKSBzaG91bGQgb25seSBiZSB1c2VkIGZvciBjcmVhdGluZyBhIG5ldyBsb2NhbGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZGVmaW5lLWxvY2FsZS8gZm9yIG1vcmUgaW5mby4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW25hbWVdLl9jb25maWc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXS5fY29uZmlnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoY29uZmlnLnBhcmVudExvY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlLl9jb25maWc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG5ldyBMb2NhbGUobWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKSk7XG5cbiAgICAgICAgICAgIGlmIChsb2NhbGVGYW1pbGllc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lTG9jYWxlKHgubmFtZSwgeC5jb25maWcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGxvY2FsZSBBRlRFUiBhbGwgY2hpbGQgbG9jYWxlcyBoYXZlIGJlZW5cbiAgICAgICAgICAgIC8vIGNyZWF0ZWQsIHNvIHdlIHdvbid0IGVuZCB1cCB3aXRoIHRoZSBjaGlsZCBsb2NhbGUgc2V0LlxuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUxvY2FsZShuYW1lLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlLFxuICAgICAgICAgICAgICAgIHRtcExvY2FsZSxcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsICYmIGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgY2hpbGQgbG9jYWxlIGluLXBsYWNlIHRvIGF2b2lkIG1lbW9yeS1sZWFrc1xuICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0uc2V0KG1lcmdlQ29uZmlncyhsb2NhbGVzW25hbWVdLl9jb25maWcsIGNvbmZpZykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNRVJHRVxuICAgICAgICAgICAgICAgIHRtcExvY2FsZSA9IGxvYWRMb2NhbGUobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRtcExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IHRtcExvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIGlmICh0bXBMb2NhbGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGVMb2NhbGUgaXMgY2FsbGVkIGZvciBjcmVhdGluZyBhIG5ldyBsb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGFiYnIgc28gaXQgd2lsbCBoYXZlIGEgbmFtZSAoZ2V0dGVycyByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgLy8gdW5kZWZpbmVkIG90aGVyd2lzZSkuXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5hYmJyID0gbmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxlID0gbmV3IExvY2FsZShjb25maWcpO1xuICAgICAgICAgICAgICAgIGxvY2FsZS5wYXJlbnRMb2NhbGUgPSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcGFzcyBudWxsIGZvciBjb25maWcgdG8gdW51cGRhdGUsIHVzZWZ1bCBmb3IgdGVzdHNcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBnZXRTZXRHbG9iYWxMb2NhbGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH1cblxuICAgIC8vIHJldHVybnMgbG9jYWxlIGRhdGFcbiAgICBmdW5jdGlvbiBnZXRMb2NhbGUoa2V5KSB7XG4gICAgICAgIHZhciBsb2NhbGU7XG5cbiAgICAgICAgaWYgKGtleSAmJiBrZXkuX2xvY2FsZSAmJiBrZXkuX2xvY2FsZS5fYWJicikge1xuICAgICAgICAgICAga2V5ID0ga2V5Ll9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleSA9IFtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNob29zZUxvY2FsZShrZXkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RMb2NhbGVzKCkge1xuICAgICAgICByZXR1cm4ga2V5cyhsb2NhbGVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja092ZXJmbG93KG0pIHtcbiAgICAgICAgdmFyIG92ZXJmbG93LFxuICAgICAgICAgICAgYSA9IG0uX2E7XG5cbiAgICAgICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgICAgIGFbTU9OVEhdIDwgMCB8fCBhW01PTlRIXSA+IDExXG4gICAgICAgICAgICAgICAgICAgID8gTU9OVEhcbiAgICAgICAgICAgICAgICAgICAgOiBhW0RBVEVdIDwgMSB8fCBhW0RBVEVdID4gZGF5c0luTW9udGgoYVtZRUFSXSwgYVtNT05USF0pXG4gICAgICAgICAgICAgICAgICAgID8gREFURVxuICAgICAgICAgICAgICAgICAgICA6IGFbSE9VUl0gPCAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgYVtIT1VSXSA+IDI0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgKGFbSE9VUl0gPT09IDI0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChhW01JTlVURV0gIT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbU0VDT05EXSAhPT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYVtNSUxMSVNFQ09ORF0gIT09IDApKVxuICAgICAgICAgICAgICAgICAgICA/IEhPVVJcbiAgICAgICAgICAgICAgICAgICAgOiBhW01JTlVURV0gPCAwIHx8IGFbTUlOVVRFXSA+IDU5XG4gICAgICAgICAgICAgICAgICAgID8gTUlOVVRFXG4gICAgICAgICAgICAgICAgICAgIDogYVtTRUNPTkRdIDwgMCB8fCBhW1NFQ09ORF0gPiA1OVxuICAgICAgICAgICAgICAgICAgICA/IFNFQ09ORFxuICAgICAgICAgICAgICAgICAgICA6IGFbTUlMTElTRUNPTkRdIDwgMCB8fCBhW01JTExJU0VDT05EXSA+IDk5OVxuICAgICAgICAgICAgICAgICAgICA/IE1JTExJU0VDT05EXG4gICAgICAgICAgICAgICAgICAgIDogLTE7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmXG4gICAgICAgICAgICAgICAgKG92ZXJmbG93IDwgWUVBUiB8fCBvdmVyZmxvdyA+IERBVEUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IERBVEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtzICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFSztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla2RheSAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUtEQVk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgLy8gaXNvIDg2MDEgcmVnZXhcbiAgICAvLyAwMDAwLTAwLTAwIDAwMDAtVzAwIG9yIDAwMDAtVzAwLTAgKyBUICsgMDAgb3IgMDA6MDAgb3IgMDA6MDA6MDAgb3IgMDA6MDA6MDAuMDAwICsgKzAwOjAwIG9yICswMDAwIG9yICswMClcbiAgICB2YXIgZXh0ZW5kZWRJc29SZWdleCA9XG4gICAgICAgICAgICAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OlxcZFxcZC1cXGRcXGR8V1xcZFxcZC1cXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzo6XFxkXFxkKD86OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbKy1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLyxcbiAgICAgICAgYmFzaWNJc29SZWdleCA9XG4gICAgICAgICAgICAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pKD86XFxkXFxkXFxkXFxkfFdcXGRcXGRcXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkfCkpKD86KFR8ICkoXFxkXFxkKD86XFxkXFxkKD86XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvLFxuICAgICAgICB0elJlZ2V4ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vLFxuICAgICAgICBpc29EYXRlcyA9IFtcbiAgICAgICAgICAgIFsnWVlZWVlZLU1NLUREJywgL1srLV1cXGR7Nn0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICAgICAgWydZWVlZLU1NLUREJywgL1xcZHs0fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgICAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcbiAgICAgICAgICAgIFsnR0dHRy1bV11XVycsIC9cXGR7NH0tV1xcZFxcZC8sIGZhbHNlXSxcbiAgICAgICAgICAgIFsnWVlZWS1EREQnLCAvXFxkezR9LVxcZHszfS9dLFxuICAgICAgICAgICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgICAgICBbJ1lZWVlZWU1NREQnLCAvWystXVxcZHsxMH0vXSxcbiAgICAgICAgICAgIFsnWVlZWU1NREQnLCAvXFxkezh9L10sXG4gICAgICAgICAgICBbJ0dHR0dbV11XV0UnLCAvXFxkezR9V1xcZHszfS9dLFxuICAgICAgICAgICAgWydHR0dHW1ddV1cnLCAvXFxkezR9V1xcZHsyfS8sIGZhbHNlXSxcbiAgICAgICAgICAgIFsnWVlZWURERCcsIC9cXGR7N30vXSxcbiAgICAgICAgICAgIFsnWVlZWU1NJywgL1xcZHs2fS8sIGZhbHNlXSxcbiAgICAgICAgICAgIFsnWVlZWScsIC9cXGR7NH0vLCBmYWxzZV0sXG4gICAgICAgIF0sXG4gICAgICAgIC8vIGlzbyB0aW1lIGZvcm1hdHMgYW5kIHJlZ2V4ZXNcbiAgICAgICAgaXNvVGltZXMgPSBbXG4gICAgICAgICAgICBbJ0hIOm1tOnNzLlNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgICAgICBbJ0hIOm1tOnNzLFNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQsXFxkKy9dLFxuICAgICAgICAgICAgWydISDptbTpzcycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICAgICAgWydISDptbScsIC9cXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgICAgICBbJ0hIbW1zcy5TU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgICAgIFsnSEhtbXNzLFNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkLFxcZCsvXSxcbiAgICAgICAgICAgIFsnSEhtbXNzJywgL1xcZFxcZFxcZFxcZFxcZFxcZC9dLFxuICAgICAgICAgICAgWydISG1tJywgL1xcZFxcZFxcZFxcZC9dLFxuICAgICAgICAgICAgWydISCcsIC9cXGRcXGQvXSxcbiAgICAgICAgXSxcbiAgICAgICAgYXNwTmV0SnNvblJlZ2V4ID0gL15cXC8/RGF0ZVxcKCgtP1xcZCspL2ksXG4gICAgICAgIC8vIFJGQyAyODIyIHJlZ2V4OiBGb3IgZGV0YWlscyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI4MjIjc2VjdGlvbi0zLjNcbiAgICAgICAgcmZjMjgyMiA9XG4gICAgICAgICAgICAvXig/OihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pLD9cXHMpPyhcXGR7MSwyfSlcXHMoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpXFxzKFxcZHsyLDR9KVxccyhcXGRcXGQpOihcXGRcXGQpKD86OihcXGRcXGQpKT9cXHMoPzooVVR8R01UfFtFQ01QXVtTRF1UKXwoW1p6XSl8KFsrLV1cXGR7NH0pKSQvLFxuICAgICAgICBvYnNPZmZzZXRzID0ge1xuICAgICAgICAgICAgVVQ6IDAsXG4gICAgICAgICAgICBHTVQ6IDAsXG4gICAgICAgICAgICBFRFQ6IC00ICogNjAsXG4gICAgICAgICAgICBFU1Q6IC01ICogNjAsXG4gICAgICAgICAgICBDRFQ6IC01ICogNjAsXG4gICAgICAgICAgICBDU1Q6IC02ICogNjAsXG4gICAgICAgICAgICBNRFQ6IC02ICogNjAsXG4gICAgICAgICAgICBNU1Q6IC03ICogNjAsXG4gICAgICAgICAgICBQRFQ6IC03ICogNjAsXG4gICAgICAgICAgICBQU1Q6IC04ICogNjAsXG4gICAgICAgIH07XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JU08oY29uZmlnKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIHN0cmluZyA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIG1hdGNoID0gZXh0ZW5kZWRJc29SZWdleC5leGVjKHN0cmluZykgfHwgYmFzaWNJc29SZWdleC5leGVjKHN0cmluZyksXG4gICAgICAgICAgICBhbGxvd1RpbWUsXG4gICAgICAgICAgICBkYXRlRm9ybWF0LFxuICAgICAgICAgICAgdGltZUZvcm1hdCxcbiAgICAgICAgICAgIHR6Rm9ybWF0LFxuICAgICAgICAgICAgaXNvRGF0ZXNMZW4gPSBpc29EYXRlcy5sZW5ndGgsXG4gICAgICAgICAgICBpc29UaW1lc0xlbiA9IGlzb1RpbWVzLmxlbmd0aDtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXNMZW47IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvRGF0ZXNbaV1bMV0uZXhlYyhtYXRjaFsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUZvcm1hdCA9IGlzb0RhdGVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBhbGxvd1RpbWUgPSBpc29EYXRlc1tpXVsyXSAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvVGltZXNMZW47IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzb1RpbWVzW2ldWzFdLmV4ZWMobWF0Y2hbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFsyXSBzaG91bGQgYmUgJ1QnIG9yIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lRm9ybWF0ID0gKG1hdGNoWzJdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aW1lRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFsbG93VGltZSAmJiB0aW1lRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbNF0pIHtcbiAgICAgICAgICAgICAgICBpZiAodHpSZWdleC5leGVjKG1hdGNoWzRdKSkge1xuICAgICAgICAgICAgICAgICAgICB0ekZvcm1hdCA9ICdaJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZy5fZiA9IGRhdGVGb3JtYXQgKyAodGltZUZvcm1hdCB8fCAnJykgKyAodHpGb3JtYXQgfHwgJycpO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKFxuICAgICAgICB5ZWFyU3RyLFxuICAgICAgICBtb250aFN0cixcbiAgICAgICAgZGF5U3RyLFxuICAgICAgICBob3VyU3RyLFxuICAgICAgICBtaW51dGVTdHIsXG4gICAgICAgIHNlY29uZFN0clxuICAgICkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAgICAgICAgdW50cnVuY2F0ZVllYXIoeWVhclN0ciksXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQuaW5kZXhPZihtb250aFN0ciksXG4gICAgICAgICAgICBwYXJzZUludChkYXlTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KGhvdXJTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KG1pbnV0ZVN0ciwgMTApLFxuICAgICAgICBdO1xuXG4gICAgICAgIGlmIChzZWNvbmRTdHIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KHNlY29uZFN0ciwgMTApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW50cnVuY2F0ZVllYXIoeWVhclN0cikge1xuICAgICAgICB2YXIgeWVhciA9IHBhcnNlSW50KHllYXJTdHIsIDEwKTtcbiAgICAgICAgaWYgKHllYXIgPD0gNDkpIHtcbiAgICAgICAgICAgIHJldHVybiAyMDAwICsgeWVhcjtcbiAgICAgICAgfSBlbHNlIGlmICh5ZWFyIDw9IDk5OSkge1xuICAgICAgICAgICAgcmV0dXJuIDE5MDAgKyB5ZWFyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5ZWFyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXByb2Nlc3NSRkMyODIyKHMpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGNvbW1lbnRzIGFuZCBmb2xkaW5nIHdoaXRlc3BhY2UgYW5kIHJlcGxhY2UgbXVsdGlwbGUtc3BhY2VzIHdpdGggYSBzaW5nbGUgc3BhY2VcbiAgICAgICAgcmV0dXJuIHNcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXChbXigpXSpcXCl8W1xcblxcdF0vZywgJyAnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCAnICcpXG4gICAgICAgICAgICAucmVwbGFjZSgvXlxcc1xccyovLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHNcXHMqJC8sICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja1dlZWtkYXkod2Vla2RheVN0ciwgcGFyc2VkSW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAod2Vla2RheVN0cikge1xuICAgICAgICAgICAgLy8gVE9ETzogUmVwbGFjZSB0aGUgdmFuaWxsYSBKUyBEYXRlIG9iamVjdCB3aXRoIGFuIGluZGVwZW5kZW50IGRheS1vZi13ZWVrIGNoZWNrLlxuICAgICAgICAgICAgdmFyIHdlZWtkYXlQcm92aWRlZCA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LmluZGV4T2Yod2Vla2RheVN0ciksXG4gICAgICAgICAgICAgICAgd2Vla2RheUFjdHVhbCA9IG5ldyBEYXRlKFxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJbnB1dFswXSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkSW5wdXRbMV0sXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZElucHV0WzJdXG4gICAgICAgICAgICAgICAgKS5nZXREYXkoKTtcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5UHJvdmlkZWQgIT09IHdlZWtkYXlBY3R1YWwpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVPZmZzZXQob2JzT2Zmc2V0LCBtaWxpdGFyeU9mZnNldCwgbnVtT2Zmc2V0KSB7XG4gICAgICAgIGlmIChvYnNPZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBvYnNPZmZzZXRzW29ic09mZnNldF07XG4gICAgICAgIH0gZWxzZSBpZiAobWlsaXRhcnlPZmZzZXQpIHtcbiAgICAgICAgICAgIC8vIHRoZSBvbmx5IGFsbG93ZWQgbWlsaXRhcnkgdHogaXMgWlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaG0gPSBwYXJzZUludChudW1PZmZzZXQsIDEwKSxcbiAgICAgICAgICAgICAgICBtID0gaG0gJSAxMDAsXG4gICAgICAgICAgICAgICAgaCA9IChobSAtIG0pIC8gMTAwO1xuICAgICAgICAgICAgcmV0dXJuIGggKiA2MCArIG07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGFuZCB0aW1lIGZyb20gcmVmIDI4MjIgZm9ybWF0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHJmYzI4MjIuZXhlYyhwcmVwcm9jZXNzUkZDMjgyMihjb25maWcuX2kpKSxcbiAgICAgICAgICAgIHBhcnNlZEFycmF5O1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHBhcnNlZEFycmF5ID0gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyhcbiAgICAgICAgICAgICAgICBtYXRjaFs0XSxcbiAgICAgICAgICAgICAgICBtYXRjaFszXSxcbiAgICAgICAgICAgICAgICBtYXRjaFsyXSxcbiAgICAgICAgICAgICAgICBtYXRjaFs1XSxcbiAgICAgICAgICAgICAgICBtYXRjaFs2XSxcbiAgICAgICAgICAgICAgICBtYXRjaFs3XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghY2hlY2tXZWVrZGF5KG1hdGNoWzFdLCBwYXJzZWRBcnJheSwgY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uZmlnLl9hID0gcGFyc2VkQXJyYXk7XG4gICAgICAgICAgICBjb25maWcuX3R6bSA9IGNhbGN1bGF0ZU9mZnNldChtYXRjaFs4XSwgbWF0Y2hbOV0sIG1hdGNoWzEwXSk7XG5cbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGNyZWF0ZVVUQ0RhdGUuYXBwbHkobnVsbCwgY29uZmlnLl9hKTtcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnJmYzI4MjIgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gMSkgQVNQLk5FVCwgMikgSVNPLCAzKSBSRkMgMjgyMiBmb3JtYXRzLCBvciA0KSBvcHRpb25hbCBmYWxsYmFjayBpZiBwYXJzaW5nIGlzbid0IHN0cmljdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoY29uZmlnLl9pKTtcbiAgICAgICAgaWYgKG1hdGNoZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX3N0cmljdCkge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaW5hbCBhdHRlbXB0LCB1c2UgSW5wdXQgRmFsbGJhY2tcbiAgICAgICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ3ZhbHVlIHByb3ZpZGVkIGlzIG5vdCBpbiBhIHJlY29nbml6ZWQgUkZDMjgyMiBvciBJU08gZm9ybWF0LiBtb21lbnQgY29uc3RydWN0aW9uIGZhbGxzIGJhY2sgdG8ganMgRGF0ZSgpLCAnICtcbiAgICAgICAgICAgICd3aGljaCBpcyBub3QgcmVsaWFibGUgYWNyb3NzIGFsbCBicm93c2VycyBhbmQgdmVyc2lvbnMuIE5vbiBSRkMyODIyL0lTTyBkYXRlIGZvcm1hdHMgYXJlICcgK1xuICAgICAgICAgICAgJ2Rpc2NvdXJhZ2VkLiBQbGVhc2UgcmVmZXIgdG8gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9qcy1kYXRlLyBmb3IgbW9yZSBpbmZvLicsXG4gICAgICAgIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gUGljayB0aGUgZmlyc3QgZGVmaW5lZCBvZiB0d28gb3IgdGhyZWUgYXJndW1lbnRzLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRzKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcbiAgICAgICAgLy8gaG9va3MgaXMgYWN0dWFsbHkgdGhlIGV4cG9ydGVkIG1vbWVudCBvYmplY3RcbiAgICAgICAgdmFyIG5vd1ZhbHVlID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgbm93VmFsdWUuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgICAgICAgICBub3dWYWx1ZS5nZXRVVENNb250aCgpLFxuICAgICAgICAgICAgICAgIG5vd1ZhbHVlLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRNb250aCgpLCBub3dWYWx1ZS5nZXREYXRlKCldO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuICAgIC8vIHRoZSBhcnJheSBzaG91bGQgbWlycm9yIHRoZSBwYXJhbWV0ZXJzIGJlbG93XG4gICAgLy8gbm90ZTogYWxsIHZhbHVlcyBwYXN0IHRoZSB5ZWFyIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXG4gICAgLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGRhdGUsXG4gICAgICAgICAgICBpbnB1dCA9IFtdLFxuICAgICAgICAgICAgY3VycmVudERhdGUsXG4gICAgICAgICAgICBleHBlY3RlZFdlZWtkYXksXG4gICAgICAgICAgICB5ZWFyVG9Vc2U7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAgICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgICAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkgfHxcbiAgICAgICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9PT0gMFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93RGF5T2ZZZWFyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoeWVhclRvVXNlLCAwLCBjb25maWcuX2RheU9mWWVhcik7XG4gICAgICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgZGF0ZS5cbiAgICAgICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxuICAgICAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxuICAgICAgICAvLyAqIGlmIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG9ubHkgeWVhclxuICAgICAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSBjdXJyZW50RGF0ZVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFplcm8gb3V0IHdoYXRldmVyIHdhcyBub3QgZGVmYXVsdGVkLCBpbmNsdWRpbmcgdGltZVxuICAgICAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPVxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9PSBudWxsID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgMjQ6MDA6MDAuMDAwXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNSU5VVEVdID09PSAwICYmXG4gICAgICAgICAgICBjb25maWcuX2FbU0VDT05EXSA9PT0gMCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbmZpZy5fbmV4dERheSA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gY3JlYXRlVVRDRGF0ZSA6IGNyZWF0ZURhdGUpLmFwcGx5KFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGlucHV0XG4gICAgICAgICk7XG4gICAgICAgIGV4cGVjdGVkV2Vla2RheSA9IGNvbmZpZy5fdXNlVVRDXG4gICAgICAgICAgICA/IGNvbmZpZy5fZC5nZXRVVENEYXkoKVxuICAgICAgICAgICAgOiBjb25maWcuX2QuZ2V0RGF5KCk7XG5cbiAgICAgICAgLy8gQXBwbHkgdGltZXpvbmUgb2Zmc2V0IGZyb20gaW5wdXQuIFRoZSBhY3R1YWwgdXRjT2Zmc2V0IGNhbiBiZSBjaGFuZ2VkXG4gICAgICAgIC8vIHdpdGggcGFyc2Vab25lLlxuICAgICAgICBpZiAoY29uZmlnLl90em0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX25leHREYXkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDI0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIG1pc21hdGNoaW5nIGRheSBvZiB3ZWVrXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbmZpZy5fdyAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbmZpZy5fdy5kICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgY29uZmlnLl93LmQgIT09IGV4cGVjdGVkV2Vla2RheVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXAsIHdlZWtkYXlPdmVyZmxvdywgY3VyV2VlaztcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKFxuICAgICAgICAgICAgICAgIHcuR0csXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdLFxuICAgICAgICAgICAgICAgIHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgMSwgNCkueWVhclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICBjdXJXZWVrID0gd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCBkb3csIGRveSk7XG5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5nZywgY29uZmlnLl9hW1lFQVJdLCBjdXJXZWVrLnllYXIpO1xuXG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgd2Vlay5cbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIGN1cldlZWsud2Vlayk7XG5cbiAgICAgICAgICAgIGlmICh3LmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHdlZWtkYXkgLS0gbG93IGRheSBudW1iZXJzIGFyZSBjb25zaWRlcmVkIG5leHQgd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XG4gICAgICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAwIHx8IHdlZWtkYXkgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3LmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGxvY2FsIHdlZWtkYXkgLS0gY291bnRpbmcgc3RhcnRzIGZyb20gYmVnaW5uaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5lICsgZG93O1xuICAgICAgICAgICAgICAgIGlmICh3LmUgPCAwIHx8IHcuZSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5uaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gZG93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3ZWVrIDwgMSB8fCB3ZWVrID4gd2Vla3NJblllYXIod2Vla1llYXIsIGRvdywgZG95KSkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla3MgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHdlZWtkYXlPdmVyZmxvdyAhPSBudWxsKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrZGF5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlbXAgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IHRlbXAueWVhcjtcbiAgICAgICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdGVtcC5kYXlPZlllYXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgSVNPIHN0YW5kYXJkXG4gICAgaG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBSRkMgMjgyMiBmb3JtXG4gICAgaG9va3MuUkZDXzI4MjIgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmdcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xuICAgICAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5JU09fODYwMSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLlJGQ18yODIyKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgY29uZmlnLl9pLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHBhcnNlZElucHV0LFxuICAgICAgICAgICAgdG9rZW5zLFxuICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICBza2lwcGVkLFxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwLFxuICAgICAgICAgICAgZXJhLFxuICAgICAgICAgICAgdG9rZW5MZW47XG5cbiAgICAgICAgdG9rZW5zID1cbiAgICAgICAgICAgIGV4cGFuZEZvcm1hdChjb25maWcuX2YsIGNvbmZpZy5fbG9jYWxlKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSB8fCBbXTtcbiAgICAgICAgdG9rZW5MZW4gPSB0b2tlbnMubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5MZW47IGkrKykge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fFxuICAgICAgICAgICAgICAgIFtdKVswXTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHNraXBwZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9XG4gICAgICAgICAgICBzdHJpbmdMZW5ndGggLSB0b3RhbFBhcnNlZElucHV0TGVuZ3RoO1xuICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5wYXJzZWREYXRlUGFydHMgPSBjb25maWcuX2Euc2xpY2UoMCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLm1lcmlkaWVtID0gY29uZmlnLl9tZXJpZGllbTtcbiAgICAgICAgLy8gaGFuZGxlIG1lcmlkaWVtXG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IG1lcmlkaWVtRml4V3JhcChcbiAgICAgICAgICAgIGNvbmZpZy5fbG9jYWxlLFxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdLFxuICAgICAgICAgICAgY29uZmlnLl9tZXJpZGllbVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGhhbmRsZSBlcmFcbiAgICAgICAgZXJhID0gZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZXJhO1xuICAgICAgICBpZiAoZXJhICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSBjb25maWcuX2xvY2FsZS5lcmFzQ29udmVydFllYXIoZXJhLCBjb25maWcuX2FbWUVBUl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xuICAgICAgICB2YXIgaXNQbTtcblxuICAgICAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5tZXJpZGllbUhvdXIoaG91ciwgbWVyaWRpZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgICAgICBpc1BtID0gbG9jYWxlLmlzUE0obWVyaWRpZW0pO1xuICAgICAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBoYXBwZW5cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciB0ZW1wQ29uZmlnLFxuICAgICAgICAgICAgYmVzdE1vbWVudCxcbiAgICAgICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSxcbiAgICAgICAgICAgIHZhbGlkRm9ybWF0Rm91bmQsXG4gICAgICAgICAgICBiZXN0Rm9ybWF0SXNWYWxpZCA9IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlnZkxlbiA9IGNvbmZpZy5fZi5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGNvbmZpZ2ZMZW4gPT09IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRGb3JtYXQgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25maWdmTGVuOyBpKyspIHtcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XG4gICAgICAgICAgICB2YWxpZEZvcm1hdEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICB0ZW1wQ29uZmlnID0gY29weUNvbmZpZyh7fSwgY29uZmlnKTtcbiAgICAgICAgICAgIGlmIChjb25maWcuX3VzZVVUQyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGVtcENvbmZpZy5fdXNlVVRDID0gY29uZmlnLl91c2VVVEM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl9mID0gY29uZmlnLl9mW2ldO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdCh0ZW1wQ29uZmlnKTtcblxuICAgICAgICAgICAgaWYgKGlzVmFsaWQodGVtcENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICB2YWxpZEZvcm1hdEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55IGlucHV0IHRoYXQgd2FzIG5vdCBwYXJzZWQgYWRkIGEgcGVuYWx0eSBmb3IgdGhhdCBmb3JtYXRcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAgICAgLy9vciB0b2tlbnNcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuc2NvcmUgPSBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgICAgIGlmICghYmVzdEZvcm1hdElzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQgfHxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZEZvcm1hdEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0Rm9ybWF0SXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCkge1xuICAgICAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGNvbmZpZy5faSksXG4gICAgICAgICAgICBkYXlPckRhdGUgPSBpLmRheSA9PT0gdW5kZWZpbmVkID8gaS5kYXRlIDogaS5kYXk7XG4gICAgICAgIGNvbmZpZy5fYSA9IG1hcChcbiAgICAgICAgICAgIFtpLnllYXIsIGkubW9udGgsIGRheU9yRGF0ZSwgaS5ob3VyLCBpLm1pbnV0ZSwgaS5zZWNvbmQsIGkubWlsbGlzZWNvbmRdLFxuICAgICAgICAgICAgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogJiYgcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRnJvbUNvbmZpZyhjb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhwcmVwYXJlQ29uZmlnKGNvbmZpZykpKTtcbiAgICAgICAgaWYgKHJlcy5fbmV4dERheSkge1xuICAgICAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgICAgICByZXMuYWRkKDEsICdkJyk7XG4gICAgICAgICAgICByZXMuX25leHREYXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVDb25maWcoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcblxuICAgICAgICBjb25maWcuX2xvY2FsZSA9IGNvbmZpZy5fbG9jYWxlIHx8IGdldExvY2FsZShjb25maWcuX2wpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoeyBudWxsSW5wdXQ6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnLl9pID0gaW5wdXQgPSBjb25maWcuX2xvY2FsZS5wcmVwYXJzZShpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNNb21lbnQoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vbWVudChjaGVja092ZXJmbG93KGlucHV0KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gaW5wdXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShmb3JtYXQpKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkKGNvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQudmFsdWVPZigpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICAvLyBmcm9tIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGlzVVRDKSB7XG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gdHJ1ZSB8fCBmb3JtYXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9jYWxlID09PSB0cnVlIHx8IGxvY2FsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHN0cmljdCA9IGxvY2FsZTtcbiAgICAgICAgICAgIGxvY2FsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIChpc09iamVjdChpbnB1dCkgJiYgaXNPYmplY3RFbXB0eShpbnB1dCkpIHx8XG4gICAgICAgICAgICAoaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAwKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGlucHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9iamVjdCBjb25zdHJ1Y3Rpb24gbXVzdCBiZSBkb25lIHRoaXMgd2F5LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQyM1xuICAgICAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xuICAgICAgICBjLl91c2VVVEMgPSBjLl9pc1VUQyA9IGlzVVRDO1xuICAgICAgICBjLl9sID0gbG9jYWxlO1xuICAgICAgICBjLl9pID0gaW5wdXQ7XG4gICAgICAgIGMuX2YgPSBmb3JtYXQ7XG4gICAgICAgIGMuX3N0cmljdCA9IHN0cmljdDtcblxuICAgICAgICByZXR1cm4gY3JlYXRlRnJvbUNvbmZpZyhjKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBwcm90b3R5cGVNaW4gPSBkZXByZWNhdGUoXG4gICAgICAgICAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPCB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICBwcm90b3R5cGVNYXggPSBkZXByZWNhdGUoXG4gICAgICAgICAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPiB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbiAgICAvLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4gICAgLy9cbiAgICAvLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4gICAgLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbiAgICBmdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICAgICAgdmFyIHJlcywgaTtcbiAgICAgICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IG1vbWVudHNbMF07XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIW1vbWVudHNbaV0uaXNWYWxpZCgpIHx8IG1vbWVudHNbaV1bZm5dKHJlcykpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIFtdLnNvcnQgaW5zdGVhZD9cbiAgICBmdW5jdGlvbiBtaW4oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQmVmb3JlJywgYXJncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF4KCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0FmdGVyJywgYXJncyk7XG4gICAgfVxuXG4gICAgdmFyIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6ICtuZXcgRGF0ZSgpO1xuICAgIH07XG5cbiAgICB2YXIgb3JkZXJpbmcgPSBbXG4gICAgICAgICd5ZWFyJyxcbiAgICAgICAgJ3F1YXJ0ZXInLFxuICAgICAgICAnbW9udGgnLFxuICAgICAgICAnd2VlaycsXG4gICAgICAgICdkYXknLFxuICAgICAgICAnaG91cicsXG4gICAgICAgICdtaW51dGUnLFxuICAgICAgICAnc2Vjb25kJyxcbiAgICAgICAgJ21pbGxpc2Vjb25kJyxcbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvblZhbGlkKG0pIHtcbiAgICAgICAgdmFyIGtleSxcbiAgICAgICAgICAgIHVuaXRIYXNEZWNpbWFsID0gZmFsc2UsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgb3JkZXJMZW4gPSBvcmRlcmluZy5sZW5ndGg7XG4gICAgICAgIGZvciAoa2V5IGluIG0pIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBoYXNPd25Qcm9wKG0sIGtleSkgJiZcbiAgICAgICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAgICAgICBpbmRleE9mLmNhbGwob3JkZXJpbmcsIGtleSkgIT09IC0xICYmXG4gICAgICAgICAgICAgICAgICAgIChtW2tleV0gPT0gbnVsbCB8fCAhaXNOYU4obVtrZXldKSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3JkZXJMZW47ICsraSkge1xuICAgICAgICAgICAgaWYgKG1bb3JkZXJpbmdbaV1dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVuaXRIYXNEZWNpbWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gb25seSBhbGxvdyBub24taW50ZWdlcnMgZm9yIHNtYWxsZXN0IHVuaXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQobVtvcmRlcmluZ1tpXV0pICE9PSB0b0ludChtW29yZGVyaW5nW2ldXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pdEhhc0RlY2ltYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVmFsaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52YWxpZCQxKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oTmFOKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEdXJhdGlvbihkdXJhdGlvbikge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoZHVyYXRpb24pLFxuICAgICAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxuICAgICAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICAgICAgbW9udGhzID0gbm9ybWFsaXplZElucHV0Lm1vbnRoIHx8IDAsXG4gICAgICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IG5vcm1hbGl6ZWRJbnB1dC5pc29XZWVrIHx8IDAsXG4gICAgICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICAgICAgaG91cnMgPSBub3JtYWxpemVkSW5wdXQuaG91ciB8fCAwLFxuICAgICAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcbiAgICAgICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQubWlsbGlzZWNvbmQgfHwgMDtcblxuICAgICAgICB0aGlzLl9pc1ZhbGlkID0gaXNEdXJhdGlvblZhbGlkKG5vcm1hbGl6ZWRJbnB1dCk7XG5cbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID1cbiAgICAgICAgICAgICttaWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGhvdXJzICogMTAwMCAqIDYwICogNjA7IC8vdXNpbmcgMTAwMCAqIDYwICogNjAgaW5zdGVhZCBvZiAzNmU1IHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjk3OFxuICAgICAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAgICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxuICAgICAgICB0aGlzLl9kYXlzID0gK2RheXMgKyB3ZWVrcyAqIDc7XG4gICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdG8gdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgKyBxdWFydGVycyAqIDMgKyB5ZWFycyAqIDEyO1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgICAgICB0aGlzLl9sb2NhbGUgPSBnZXRMb2NhbGUoKTtcblxuICAgICAgICB0aGlzLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzUm91bmQobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgtMSAqIG51bWJlcikgKiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXG4gICAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0KHRva2VuLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnV0Y09mZnNldCgpLFxuICAgICAgICAgICAgICAgIHNpZ24gPSAnKyc7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XG4gICAgICAgICAgICAgICAgc2lnbiA9ICctJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgc2lnbiArXG4gICAgICAgICAgICAgICAgemVyb0ZpbGwofn4ob2Zmc2V0IC8gNjApLCAyKSArXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yICtcbiAgICAgICAgICAgICAgICB6ZXJvRmlsbCh+fm9mZnNldCAlIDYwLCAyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb2Zmc2V0KCdaJywgJzonKTtcbiAgICBvZmZzZXQoJ1paJywgJycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIHRpbWV6b25lIGNodW5rZXJcbiAgICAvLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cbiAgICAvLyAnLTE1MzAnICA+IFsnLTE1JywgJzMwJ11cbiAgICB2YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XG5cbiAgICBmdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoZXIsIHN0cmluZykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IChzdHJpbmcgfHwgJycpLm1hdGNoKG1hdGNoZXIpLFxuICAgICAgICAgICAgY2h1bmssXG4gICAgICAgICAgICBwYXJ0cyxcbiAgICAgICAgICAgIG1pbnV0ZXM7XG5cbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY2h1bmsgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0gfHwgW107XG4gICAgICAgIHBhcnRzID0gKGNodW5rICsgJycpLm1hdGNoKGNodW5rT2Zmc2V0KSB8fCBbJy0nLCAwLCAwXTtcbiAgICAgICAgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICAgICAgcmV0dXJuIG1pbnV0ZXMgPT09IDAgPyAwIDogcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuICAgIGZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICAgICAgdmFyIHJlcywgZGlmZjtcbiAgICAgICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgICAgIGRpZmYgPVxuICAgICAgICAgICAgICAgIChpc01vbWVudChpbnB1dCkgfHwgaXNEYXRlKGlucHV0KVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LnZhbHVlT2YoKVxuICAgICAgICAgICAgICAgICAgICA6IGNyZWF0ZUxvY2FsKGlucHV0KS52YWx1ZU9mKCkpIC0gcmVzLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIC8vIFVzZSBsb3ctbGV2ZWwgYXBpLCBiZWNhdXNlIHRoaXMgZm4gaXMgbG93LWxldmVsIGFwaS5cbiAgICAgICAgICAgIHJlcy5fZC5zZXRUaW1lKHJlcy5fZC52YWx1ZU9mKCkgKyBkaWZmKTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChyZXMsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXRlT2Zmc2V0KG0pIHtcbiAgICAgICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvcHVsbC8xODcxXG4gICAgICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4gICAgLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXG4gICAgaG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbiAgICAvLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuICAgIC8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbiAgICAvLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4gICAgLy9cbiAgICAvLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbiAgICAvLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbiAgICAvLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4gICAgLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbiAgICBmdW5jdGlvbiBnZXRTZXRPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUsIGtlZXBNaW51dGVzKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIGxvY2FsQWRqdXN0O1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhpbnB1dCkgPCAxNiAmJiAha2VlcE1pbnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzVVRDICYmIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICBsb2NhbEFkanVzdCA9IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbnB1dDtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChsb2NhbEFkanVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQobG9jYWxBZGp1c3QsICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmICgha2VlcExvY2FsVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFN1YnRyYWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUR1cmF0aW9uKGlucHV0IC0gb2Zmc2V0LCAnbScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IG9mZnNldCA6IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRab25lKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMoa2VlcExvY2FsVGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1VUQykge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VidHJhY3QoZ2V0RGF0ZU9mZnNldCh0aGlzKSwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciB0Wm9uZSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hPZmZzZXQsIHRoaXMuX2kpO1xuICAgICAgICAgICAgaWYgKHRab25lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0Wm9uZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0KGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dCA9IGlucHV0ID8gY3JlYXRlTG9jYWwoaW5wdXQpLnV0Y09mZnNldCgpIDogMDtcblxuICAgICAgICByZXR1cm4gKHRoaXMudXRjT2Zmc2V0KCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZSgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQoKSB7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5faXNEU1RTaGlmdGVkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0ge30sXG4gICAgICAgICAgICBvdGhlcjtcblxuICAgICAgICBjb3B5Q29uZmlnKGMsIHRoaXMpO1xuICAgICAgICBjID0gcHJlcGFyZUNvbmZpZyhjKTtcblxuICAgICAgICBpZiAoYy5fYSkge1xuICAgICAgICAgICAgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZVVUQyhjLl9hKSA6IGNyZWF0ZUxvY2FsKGMuX2EpO1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID1cbiAgICAgICAgICAgICAgICB0aGlzLmlzVmFsaWQoKSAmJiBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTG9jYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDAgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcbiAgICB2YXIgYXNwTmV0UmVnZXggPSAvXigtfFxcKyk/KD86KFxcZCopWy4gXSk/KFxcZCspOihcXGQrKSg/OjooXFxkKykoXFwuXFxkKik/KT8kLyxcbiAgICAgICAgLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbiAgICAgICAgLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuICAgICAgICAvLyBhbmQgZnVydGhlciBtb2RpZmllZCB0byBhbGxvdyBmb3Igc3RyaW5ncyBjb250YWluaW5nIGJvdGggd2VlayBhbmQgZGF5XG4gICAgICAgIGlzb1JlZ2V4ID1cbiAgICAgICAgICAgIC9eKC18XFwrKT9QKD86KFstK10/WzAtOSwuXSopWSk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopVyk/KD86KFstK10/WzAtOSwuXSopRCk/KD86VCg/OihbLStdP1swLTksLl0qKUgpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVMpPyk/JC87XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEdXJhdGlvbihpbnB1dCwga2V5KSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGlucHV0LFxuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgYWdhaW5zdCByZWdleHAgaXMgZXhwZW5zaXZlLCBkbyBpdCBvbiBkZW1hbmRcbiAgICAgICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgICAgIHNpZ24sXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBkaWZmUmVzO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgbXM6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgZDogaW5wdXQuX2RheXMsXG4gICAgICAgICAgICAgICAgTTogaW5wdXQuX21vbnRocyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpIHx8ICFpc05hTigraW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSAraW5wdXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9ICtpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgobWF0Y2ggPSBhc3BOZXRSZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSBtYXRjaFsxXSA9PT0gJy0nID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICBkOiB0b0ludChtYXRjaFtEQVRFXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIGg6IHRvSW50KG1hdGNoW0hPVVJdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbTogdG9JbnQobWF0Y2hbTUlOVVRFXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIHM6IHRvSW50KG1hdGNoW1NFQ09ORF0pICogc2lnbixcbiAgICAgICAgICAgICAgICBtczogdG9JbnQoYWJzUm91bmQobWF0Y2hbTUlMTElTRUNPTkRdICogMTAwMCkpICogc2lnbiwgLy8gdGhlIG1pbGxpc2Vjb25kIGRlY2ltYWwgcG9pbnQgaXMgaW5jbHVkZWQgaW4gdGhlIG1hdGNoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKChtYXRjaCA9IGlzb1JlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IG1hdGNoWzFdID09PSAnLScgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5OiBwYXJzZUlzbyhtYXRjaFsyXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgTTogcGFyc2VJc28obWF0Y2hbM10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHc6IHBhcnNlSXNvKG1hdGNoWzRdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBkOiBwYXJzZUlzbyhtYXRjaFs1XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgaDogcGFyc2VJc28obWF0Y2hbNl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIG06IHBhcnNlSXNvKG1hdGNoWzddLCBzaWduKSxcbiAgICAgICAgICAgICAgICBzOiBwYXJzZUlzbyhtYXRjaFs4XSwgc2lnbiksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICB0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAoJ2Zyb20nIGluIGR1cmF0aW9uIHx8ICd0bycgaW4gZHVyYXRpb24pXG4gICAgICAgICkge1xuICAgICAgICAgICAgZGlmZlJlcyA9IG1vbWVudHNEaWZmZXJlbmNlKFxuICAgICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKGR1cmF0aW9uLmZyb20pLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKGR1cmF0aW9uLnRvKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGR1cmF0aW9uLm1zID0gZGlmZlJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICBkdXJhdGlvbi5NID0gZGlmZlJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2xvY2FsZScpKSB7XG4gICAgICAgICAgICByZXQuX2xvY2FsZSA9IGlucHV0Ll9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19pc1ZhbGlkJykpIHtcbiAgICAgICAgICAgIHJldC5faXNWYWxpZCA9IGlucHV0Ll9pc1ZhbGlkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBjcmVhdGVEdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZTtcbiAgICBjcmVhdGVEdXJhdGlvbi5pbnZhbGlkID0gY3JlYXRlSW52YWxpZCQxO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJc28oaW5wLCBzaWduKSB7XG4gICAgICAgIC8vIFdlJ2Qgbm9ybWFsbHkgdXNlIH5+aW5wIGZvciB0aGlzLCBidXQgdW5mb3J0dW5hdGVseSBpdCBhbHNvXG4gICAgICAgIC8vIGNvbnZlcnRzIGZsb2F0cyB0byBpbnRzLlxuICAgICAgICAvLyBpbnAgbWF5IGJlIHVuZGVmaW5lZCwgc28gY2FyZWZ1bCBjYWxsaW5nIHJlcGxhY2Ugb24gaXQuXG4gICAgICAgIHZhciByZXMgPSBpbnAgJiYgcGFyc2VGbG9hdChpbnAucmVwbGFjZSgnLCcsICcuJykpO1xuICAgICAgICAvLyBhcHBseSBzaWduIHdoaWxlIHdlJ3JlIGF0IGl0XG4gICAgICAgIHJldHVybiAoaXNOYU4ocmVzKSA/IDAgOiByZXMpICogc2lnbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXMgPSB7fTtcblxuICAgICAgICByZXMubW9udGhzID1cbiAgICAgICAgICAgIG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgKyAob3RoZXIueWVhcigpIC0gYmFzZS55ZWFyKCkpICogMTI7XG4gICAgICAgIGlmIChiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykuaXNBZnRlcihvdGhlcikpIHtcbiAgICAgICAgICAgIC0tcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSArb3RoZXIgLSArYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKCEoYmFzZS5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyID0gY2xvbmVXaXRoT2Zmc2V0KG90aGVyLCBiYXNlKTtcbiAgICAgICAgaWYgKGJhc2UuaXNCZWZvcmUob3RoZXIpKSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2Uob3RoZXIsIGJhc2UpO1xuICAgICAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9IC1yZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgcmVzLm1vbnRocyA9IC1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgJ25hbWUnIGFyZyBhZnRlciBkZXByZWNhdGlvbiBpcyByZW1vdmVkXG4gICAgZnVuY3Rpb24gY3JlYXRlQWRkZXIoZGlyZWN0aW9uLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIHZhciBkdXIsIHRtcDtcbiAgICAgICAgICAgIC8vaW52ZXJ0IHRoZSBhcmd1bWVudHMsIGJ1dCBjb21wbGFpbiBhYm91dCBpdFxuICAgICAgICAgICAgaWYgKHBlcmlvZCAhPT0gbnVsbCAmJiAhaXNOYU4oK3BlcmlvZCkpIHtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUoXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICdtb21lbnQoKS4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyhwZXJpb2QsIG51bWJlcikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtb21lbnQoKS4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyhudW1iZXIsIHBlcmlvZCkuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2FkZC1pbnZlcnRlZC1wYXJhbS8gZm9yIG1vcmUgaW5mby4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0bXAgPSB2YWw7XG4gICAgICAgICAgICAgICAgdmFsID0gcGVyaW9kO1xuICAgICAgICAgICAgICAgIHBlcmlvZCA9IHRtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZHVyID0gY3JlYXRlRHVyYXRpb24odmFsLCBwZXJpb2QpO1xuICAgICAgICAgICAgYWRkU3VidHJhY3QodGhpcywgZHVyLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkU3VidHJhY3QobW9tLCBkdXJhdGlvbiwgaXNBZGRpbmcsIHVwZGF0ZU9mZnNldCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gZHVyYXRpb24uX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgIGRheXMgPSBhYnNSb3VuZChkdXJhdGlvbi5fZGF5cyksXG4gICAgICAgICAgICBtb250aHMgPSBhYnNSb3VuZChkdXJhdGlvbi5fbW9udGhzKTtcblxuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIC8vIE5vIG9wXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVPZmZzZXQgPSB1cGRhdGVPZmZzZXQgPT0gbnVsbCA/IHRydWUgOiB1cGRhdGVPZmZzZXQ7XG5cbiAgICAgICAgaWYgKG1vbnRocykge1xuICAgICAgICAgICAgc2V0TW9udGgobW9tLCBnZXQobW9tLCAnTW9udGgnKSArIG1vbnRocyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF5cykge1xuICAgICAgICAgICAgc2V0JDEobW9tLCAnRGF0ZScsIGdldChtb20sICdEYXRlJykgKyBkYXlzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgICAgIG1vbS5fZC5zZXRUaW1lKG1vbS5fZC52YWx1ZU9mKCkgKyBtaWxsaXNlY29uZHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZU9mZnNldCkge1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KG1vbSwgZGF5cyB8fCBtb250aHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFkZCA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKSxcbiAgICAgICAgc3VidHJhY3QgPSBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0Jyk7XG5cbiAgICBmdW5jdGlvbiBpc1N0cmluZyhpbnB1dCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyB8fCBpbnB1dCBpbnN0YW5jZW9mIFN0cmluZztcbiAgICB9XG5cbiAgICAvLyB0eXBlIE1vbWVudElucHV0ID0gTW9tZW50IHwgRGF0ZSB8IHN0cmluZyB8IG51bWJlciB8IChudW1iZXIgfCBzdHJpbmcpW10gfCBNb21lbnRJbnB1dE9iamVjdCB8IHZvaWQ7IC8vIG51bGwgfCB1bmRlZmluZWRcbiAgICBmdW5jdGlvbiBpc01vbWVudElucHV0KGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpc01vbWVudChpbnB1dCkgfHxcbiAgICAgICAgICAgIGlzRGF0ZShpbnB1dCkgfHxcbiAgICAgICAgICAgIGlzU3RyaW5nKGlucHV0KSB8fFxuICAgICAgICAgICAgaXNOdW1iZXIoaW5wdXQpIHx8XG4gICAgICAgICAgICBpc051bWJlck9yU3RyaW5nQXJyYXkoaW5wdXQpIHx8XG4gICAgICAgICAgICBpc01vbWVudElucHV0T2JqZWN0KGlucHV0KSB8fFxuICAgICAgICAgICAgaW5wdXQgPT09IG51bGwgfHxcbiAgICAgICAgICAgIGlucHV0ID09PSB1bmRlZmluZWRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc01vbWVudElucHV0T2JqZWN0KGlucHV0KSB7XG4gICAgICAgIHZhciBvYmplY3RUZXN0ID0gaXNPYmplY3QoaW5wdXQpICYmICFpc09iamVjdEVtcHR5KGlucHV0KSxcbiAgICAgICAgICAgIHByb3BlcnR5VGVzdCA9IGZhbHNlLFxuICAgICAgICAgICAgcHJvcGVydGllcyA9IFtcbiAgICAgICAgICAgICAgICAneWVhcnMnLFxuICAgICAgICAgICAgICAgICd5ZWFyJyxcbiAgICAgICAgICAgICAgICAneScsXG4gICAgICAgICAgICAgICAgJ21vbnRocycsXG4gICAgICAgICAgICAgICAgJ21vbnRoJyxcbiAgICAgICAgICAgICAgICAnTScsXG4gICAgICAgICAgICAgICAgJ2RheXMnLFxuICAgICAgICAgICAgICAgICdkYXknLFxuICAgICAgICAgICAgICAgICdkJyxcbiAgICAgICAgICAgICAgICAnZGF0ZXMnLFxuICAgICAgICAgICAgICAgICdkYXRlJyxcbiAgICAgICAgICAgICAgICAnRCcsXG4gICAgICAgICAgICAgICAgJ2hvdXJzJyxcbiAgICAgICAgICAgICAgICAnaG91cicsXG4gICAgICAgICAgICAgICAgJ2gnLFxuICAgICAgICAgICAgICAgICdtaW51dGVzJyxcbiAgICAgICAgICAgICAgICAnbWludXRlJyxcbiAgICAgICAgICAgICAgICAnbScsXG4gICAgICAgICAgICAgICAgJ3NlY29uZHMnLFxuICAgICAgICAgICAgICAgICdzZWNvbmQnLFxuICAgICAgICAgICAgICAgICdzJyxcbiAgICAgICAgICAgICAgICAnbWlsbGlzZWNvbmRzJyxcbiAgICAgICAgICAgICAgICAnbWlsbGlzZWNvbmQnLFxuICAgICAgICAgICAgICAgICdtcycsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgcHJvcGVydHlMZW4gPSBwcm9wZXJ0aWVzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcGVydHlMZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gcHJvcGVydHlUZXN0IHx8IGhhc093blByb3AoaW5wdXQsIHByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmplY3RUZXN0ICYmIHByb3BlcnR5VGVzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc051bWJlck9yU3RyaW5nQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgdmFyIGFycmF5VGVzdCA9IGlzQXJyYXkoaW5wdXQpLFxuICAgICAgICAgICAgZGF0YVR5cGVUZXN0ID0gZmFsc2U7XG4gICAgICAgIGlmIChhcnJheVRlc3QpIHtcbiAgICAgICAgICAgIGRhdGFUeXBlVGVzdCA9XG4gICAgICAgICAgICAgICAgaW5wdXQuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhaXNOdW1iZXIoaXRlbSkgJiYgaXNTdHJpbmcoaW5wdXQpO1xuICAgICAgICAgICAgICAgIH0pLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlUZXN0ICYmIGRhdGFUeXBlVGVzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0NhbGVuZGFyU3BlYyhpbnB1dCkge1xuICAgICAgICB2YXIgb2JqZWN0VGVzdCA9IGlzT2JqZWN0KGlucHV0KSAmJiAhaXNPYmplY3RFbXB0eShpbnB1dCksXG4gICAgICAgICAgICBwcm9wZXJ0eVRlc3QgPSBmYWxzZSxcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSBbXG4gICAgICAgICAgICAgICAgJ3NhbWVEYXknLFxuICAgICAgICAgICAgICAgICduZXh0RGF5JyxcbiAgICAgICAgICAgICAgICAnbGFzdERheScsXG4gICAgICAgICAgICAgICAgJ25leHRXZWVrJyxcbiAgICAgICAgICAgICAgICAnbGFzdFdlZWsnLFxuICAgICAgICAgICAgICAgICdzYW1lRWxzZScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHByb3BlcnR5O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICBwcm9wZXJ0eVRlc3QgPSBwcm9wZXJ0eVRlc3QgfHwgaGFzT3duUHJvcChpbnB1dCwgcHJvcGVydHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iamVjdFRlc3QgJiYgcHJvcGVydHlUZXN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENhbGVuZGFyRm9ybWF0KG15TW9tZW50LCBub3cpIHtcbiAgICAgICAgdmFyIGRpZmYgPSBteU1vbWVudC5kaWZmKG5vdywgJ2RheXMnLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGRpZmYgPCAtNlxuICAgICAgICAgICAgPyAnc2FtZUVsc2UnXG4gICAgICAgICAgICA6IGRpZmYgPCAtMVxuICAgICAgICAgICAgPyAnbGFzdFdlZWsnXG4gICAgICAgICAgICA6IGRpZmYgPCAwXG4gICAgICAgICAgICA/ICdsYXN0RGF5J1xuICAgICAgICAgICAgOiBkaWZmIDwgMVxuICAgICAgICAgICAgPyAnc2FtZURheSdcbiAgICAgICAgICAgIDogZGlmZiA8IDJcbiAgICAgICAgICAgID8gJ25leHREYXknXG4gICAgICAgICAgICA6IGRpZmYgPCA3XG4gICAgICAgICAgICA/ICduZXh0V2VlaydcbiAgICAgICAgICAgIDogJ3NhbWVFbHNlJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxlbmRhciQxKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAgICAgLy8gU3VwcG9ydCBmb3Igc2luZ2xlIHBhcmFtZXRlciwgZm9ybWF0cyBvbmx5IG92ZXJsb2FkIHRvIHRoZSBjYWxlbmRhciBmdW5jdGlvblxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGZvcm1hdHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTW9tZW50SW5wdXQoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgICAgIHRpbWUgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgZm9ybWF0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNDYWxlbmRhclNwZWMoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdHMgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgdGltZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXZSB3YW50IHRvIGNvbXBhcmUgdGhlIHN0YXJ0IG9mIHRvZGF5LCB2cyB0aGlzLlxuICAgICAgICAvLyBHZXR0aW5nIHN0YXJ0LW9mLXRvZGF5IGRlcGVuZHMgb24gd2hldGhlciB3ZSdyZSBsb2NhbC91dGMvb2Zmc2V0IG9yIG5vdC5cbiAgICAgICAgdmFyIG5vdyA9IHRpbWUgfHwgY3JlYXRlTG9jYWwoKSxcbiAgICAgICAgICAgIHNvZCA9IGNsb25lV2l0aE9mZnNldChub3csIHRoaXMpLnN0YXJ0T2YoJ2RheScpLFxuICAgICAgICAgICAgZm9ybWF0ID0gaG9va3MuY2FsZW5kYXJGb3JtYXQodGhpcywgc29kKSB8fCAnc2FtZUVsc2UnLFxuICAgICAgICAgICAgb3V0cHV0ID1cbiAgICAgICAgICAgICAgICBmb3JtYXRzICYmXG4gICAgICAgICAgICAgICAgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKVxuICAgICAgICAgICAgICAgICAgICA/IGZvcm1hdHNbZm9ybWF0XS5jYWxsKHRoaXMsIG5vdylcbiAgICAgICAgICAgICAgICAgICAgOiBmb3JtYXRzW2Zvcm1hdF0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChcbiAgICAgICAgICAgIG91dHB1dCB8fCB0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGNyZWF0ZUxvY2FsKG5vdykpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWZ0ZXIoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID4gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxJbnB1dC52YWx1ZU9mKCkgPCB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZWZvcmUoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmV0d2Vlbihmcm9tLCB0bywgdW5pdHMsIGluY2x1c2l2aXR5KSB7XG4gICAgICAgIHZhciBsb2NhbEZyb20gPSBpc01vbWVudChmcm9tKSA/IGZyb20gOiBjcmVhdGVMb2NhbChmcm9tKSxcbiAgICAgICAgICAgIGxvY2FsVG8gPSBpc01vbWVudCh0bykgPyB0byA6IGNyZWF0ZUxvY2FsKHRvKTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxGcm9tLmlzVmFsaWQoKSAmJiBsb2NhbFRvLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbmNsdXNpdml0eSA9IGluY2x1c2l2aXR5IHx8ICcoKSc7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoaW5jbHVzaXZpdHlbMF0gPT09ICcoJ1xuICAgICAgICAgICAgICAgID8gdGhpcy5pc0FmdGVyKGxvY2FsRnJvbSwgdW5pdHMpXG4gICAgICAgICAgICAgICAgOiAhdGhpcy5pc0JlZm9yZShsb2NhbEZyb20sIHVuaXRzKSkgJiZcbiAgICAgICAgICAgIChpbmNsdXNpdml0eVsxXSA9PT0gJyknXG4gICAgICAgICAgICAgICAgPyB0aGlzLmlzQmVmb3JlKGxvY2FsVG8sIHVuaXRzKVxuICAgICAgICAgICAgICAgIDogIXRoaXMuaXNBZnRlcihsb2NhbFRvLCB1bml0cykpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpLFxuICAgICAgICAgICAgaW5wdXRNcztcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPT09IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpIDw9IGlucHV0TXMgJiZcbiAgICAgICAgICAgICAgICBpbnB1dE1zIDw9IHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JBZnRlcihpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0FmdGVyKGlucHV0LCB1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JCZWZvcmUoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNCZWZvcmUoaW5wdXQsIHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaWZmKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgICAgICB2YXIgdGhhdCwgem9uZURlbHRhLCBvdXRwdXQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoYXQgPSBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIHRoaXMpO1xuXG4gICAgICAgIGlmICghdGhhdC5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB6b25lRGVsdGEgPSAodGhhdC51dGNPZmZzZXQoKSAtIHRoaXMudXRjT2Zmc2V0KCkpICogNmU0O1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDEyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAxZTM7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDBcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDZlNDtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMzZlNTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDg2NGU1O1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodGhpcyAtIHRoYXQgLSB6b25lRGVsdGEpIC8gNjA0OGU1O1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzIC0gdGhhdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhc0Zsb2F0ID8gb3V0cHV0IDogYWJzRmxvb3Iob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aERpZmYoYSwgYikge1xuICAgICAgICBpZiAoYS5kYXRlKCkgPCBiLmRhdGUoKSkge1xuICAgICAgICAgICAgLy8gZW5kLW9mLW1vbnRoIGNhbGN1bGF0aW9ucyB3b3JrIGNvcnJlY3Qgd2hlbiB0aGUgc3RhcnQgbW9udGggaGFzIG1vcmVcbiAgICAgICAgICAgIC8vIGRheXMgdGhhbiB0aGUgZW5kIG1vbnRoLlxuICAgICAgICAgICAgcmV0dXJuIC1tb250aERpZmYoYiwgYSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcbiAgICAgICAgdmFyIHdob2xlTW9udGhEaWZmID0gKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIgKyAoYi5tb250aCgpIC0gYS5tb250aCgpKSxcbiAgICAgICAgICAgIC8vIGIgaXMgaW4gKGFuY2hvciAtIDEgbW9udGgsIGFuY2hvciArIDEgbW9udGgpXG4gICAgICAgICAgICBhbmNob3IgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmLCAnbW9udGhzJyksXG4gICAgICAgICAgICBhbmNob3IyLFxuICAgICAgICAgICAgYWRqdXN0O1xuXG4gICAgICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgKyAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jaGVjayBmb3IgbmVnYXRpdmUgemVybywgcmV0dXJuIHplcm8gaWYgbmVnYXRpdmUgemVyb1xuICAgICAgICByZXR1cm4gLSh3aG9sZU1vbnRoRGlmZiArIGFkanVzdCkgfHwgMDtcbiAgICB9XG5cbiAgICBob29rcy5kZWZhdWx0Rm9ybWF0ID0gJ1lZWVktTU0tRERUSEg6bW06c3NaJztcbiAgICBob29rcy5kZWZhdWx0Rm9ybWF0VXRjID0gJ1lZWVktTU0tRERUSEg6bW06c3NbWl0nO1xuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0lTT1N0cmluZyhrZWVwT2Zmc2V0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1dGMgPSBrZWVwT2Zmc2V0ICE9PSB0cnVlLFxuICAgICAgICAgICAgbSA9IHV0YyA/IHRoaXMuY2xvbmUoKS51dGMoKSA6IHRoaXM7XG4gICAgICAgIGlmIChtLnllYXIoKSA8IDAgfHwgbS55ZWFyKCkgPiA5OTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KFxuICAgICAgICAgICAgICAgIG0sXG4gICAgICAgICAgICAgICAgdXRjXG4gICAgICAgICAgICAgICAgICAgID8gJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXSdcbiAgICAgICAgICAgICAgICAgICAgOiAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWidcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcpKSB7XG4gICAgICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gaXMgfjUweCBmYXN0ZXIsIHVzZSBpdCB3aGVuIHdlIGNhblxuICAgICAgICAgICAgaWYgKHV0Yykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSArIHRoaXMudXRjT2Zmc2V0KCkgKiA2MCAqIDEwMDApXG4gICAgICAgICAgICAgICAgICAgIC50b0lTT1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdaJywgZm9ybWF0TW9tZW50KG0sICdaJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQoXG4gICAgICAgICAgICBtLFxuICAgICAgICAgICAgdXRjID8gJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nIDogJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NaJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGh1bWFuIHJlYWRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGEgbW9tZW50IHRoYXQgY2FuXG4gICAgICogYWxzbyBiZSBldmFsdWF0ZWQgdG8gZ2V0IGEgbmV3IG1vbWVudCB3aGljaCBpcyB0aGUgc2FtZVxuICAgICAqXG4gICAgICogQGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0L2RvY3MvYXBpL3V0aWwuaHRtbCN1dGlsX2N1c3RvbV9pbnNwZWN0X2Z1bmN0aW9uX29uX29iamVjdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21vbWVudC5pbnZhbGlkKC8qICcgKyB0aGlzLl9pICsgJyAqLyknO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmdW5jID0gJ21vbWVudCcsXG4gICAgICAgICAgICB6b25lID0gJycsXG4gICAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgICB5ZWFyLFxuICAgICAgICAgICAgZGF0ZXRpbWUsXG4gICAgICAgICAgICBzdWZmaXg7XG4gICAgICAgIGlmICghdGhpcy5pc0xvY2FsKCkpIHtcbiAgICAgICAgICAgIGZ1bmMgPSB0aGlzLnV0Y09mZnNldCgpID09PSAwID8gJ21vbWVudC51dGMnIDogJ21vbWVudC5wYXJzZVpvbmUnO1xuICAgICAgICAgICAgem9uZSA9ICdaJztcbiAgICAgICAgfVxuICAgICAgICBwcmVmaXggPSAnWycgKyBmdW5jICsgJyhcIl0nO1xuICAgICAgICB5ZWFyID0gMCA8PSB0aGlzLnllYXIoKSAmJiB0aGlzLnllYXIoKSA8PSA5OTk5ID8gJ1lZWVknIDogJ1lZWVlZWSc7XG4gICAgICAgIGRhdGV0aW1lID0gJy1NTS1ERFtUXUhIOm1tOnNzLlNTUyc7XG4gICAgICAgIHN1ZmZpeCA9IHpvbmUgKyAnW1wiKV0nO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChwcmVmaXggKyB5ZWFyICsgZGF0ZXRpbWUgKyBzdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdChpbnB1dFN0cmluZykge1xuICAgICAgICBpZiAoIWlucHV0U3RyaW5nKSB7XG4gICAgICAgICAgICBpbnB1dFN0cmluZyA9IHRoaXMuaXNVdGMoKVxuICAgICAgICAgICAgICAgID8gaG9va3MuZGVmYXVsdEZvcm1hdFV0Y1xuICAgICAgICAgICAgICAgIDogaG9va3MuZGVmYXVsdEZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8IGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oeyB0bzogdGhpcywgZnJvbTogdGltZSB9KVxuICAgICAgICAgICAgICAgIC5sb2NhbGUodGhpcy5sb2NhbGUoKSlcbiAgICAgICAgICAgICAgICAuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tTm93KHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbShjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0byh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fCBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHsgZnJvbTogdGhpcywgdG86IHRpbWUgfSlcbiAgICAgICAgICAgICAgICAubG9jYWxlKHRoaXMubG9jYWxlKCkpXG4gICAgICAgICAgICAgICAgLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Ob3cod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy50byhjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICAvLyBJZiBwYXNzZWQgYSBsb2NhbGUga2V5LCBpdCB3aWxsIHNldCB0aGUgbG9jYWxlIGZvciB0aGlzXG4gICAgLy8gaW5zdGFuY2UuICBPdGhlcndpc2UsIGl0IHdpbGwgcmV0dXJuIHRoZSBsb2NhbGUgY29uZmlndXJhdGlvblxuICAgIC8vIHZhcmlhYmxlcyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICBmdW5jdGlvbiBsb2NhbGUoa2V5KSB7XG4gICAgICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xvY2FsZURhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICAgICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVEYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xuICAgIH1cblxuICAgIHZhciBNU19QRVJfU0VDT05EID0gMTAwMCxcbiAgICAgICAgTVNfUEVSX01JTlVURSA9IDYwICogTVNfUEVSX1NFQ09ORCxcbiAgICAgICAgTVNfUEVSX0hPVVIgPSA2MCAqIE1TX1BFUl9NSU5VVEUsXG4gICAgICAgIE1TX1BFUl80MDBfWUVBUlMgPSAoMzY1ICogNDAwICsgOTcpICogMjQgKiBNU19QRVJfSE9VUjtcblxuICAgIC8vIGFjdHVhbCBtb2R1bG8gLSBoYW5kbGVzIG5lZ2F0aXZlIG51bWJlcnMgKGZvciBkYXRlcyBiZWZvcmUgMTk3MCk6XG4gICAgZnVuY3Rpb24gbW9kJDEoZGl2aWRlbmQsIGRpdmlzb3IpIHtcbiAgICAgICAgcmV0dXJuICgoZGl2aWRlbmQgJSBkaXZpc29yKSArIGRpdmlzb3IpICUgZGl2aXNvcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbFN0YXJ0T2ZEYXRlKHksIG0sIGQpIHtcbiAgICAgICAgLy8gdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh5ICsgNDAwLCBtLCBkKSAtIE1TX1BFUl80MDBfWUVBUlM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoeSwgbSwgZCkudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXRjU3RhcnRPZkRhdGUoeSwgbSwgZCkge1xuICAgICAgICAvLyBEYXRlLlVUQyByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgcmV0dXJuIERhdGUuVVRDKHkgKyA0MDAsIG0sIGQpIC0gTVNfUEVSXzQwMF9ZRUFSUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBEYXRlLlVUQyh5LCBtLCBkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0T2YodW5pdHMpIHtcbiAgICAgICAgdmFyIHRpbWUsIHN0YXJ0T2ZEYXRlO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcgfHwgIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0T2ZEYXRlID0gdGhpcy5faXNVVEMgPyB1dGNTdGFydE9mRGF0ZSA6IGxvY2FsU3RhcnRPZkRhdGU7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCAwLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSAtICh0aGlzLm1vbnRoKCkgJSAzKSxcbiAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGUoKSAtIHRoaXMud2Vla2RheSgpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKCkgLSAodGhpcy5pc29XZWVrZGF5KCkgLSAxKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKFxuICAgICAgICAgICAgICAgICAgICB0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSxcbiAgICAgICAgICAgICAgICAgICAgTVNfUEVSX0hPVVJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMSh0aW1lLCBNU19QRVJfTUlOVVRFKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSwgTVNfUEVSX1NFQ09ORCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kLnNldFRpbWUodGltZSk7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kT2YodW5pdHMpIHtcbiAgICAgICAgdmFyIHRpbWUsIHN0YXJ0T2ZEYXRlO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcgfHwgIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0T2ZEYXRlID0gdGhpcy5faXNVVEMgPyB1dGNTdGFydE9mRGF0ZSA6IGxvY2FsU3RhcnRPZkRhdGU7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpICsgMSwgMCwgMSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICAgICAgdGltZSA9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0T2ZEYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCkgLSAodGhpcy5tb250aCgpICUgMykgKyAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgICApIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSArIDEsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPVxuICAgICAgICAgICAgICAgICAgICBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKCkgLSB0aGlzLndlZWtkYXkoKSArIDdcbiAgICAgICAgICAgICAgICAgICAgKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSkgKyA3XG4gICAgICAgICAgICAgICAgICAgICkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSArIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lICs9XG4gICAgICAgICAgICAgICAgICAgIE1TX1BFUl9IT1VSIC1cbiAgICAgICAgICAgICAgICAgICAgbW9kJDEoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIE1TX1BFUl9IT1VSXG4gICAgICAgICAgICAgICAgICAgICkgLVxuICAgICAgICAgICAgICAgICAgICAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSArPSBNU19QRVJfTUlOVVRFIC0gbW9kJDEodGltZSwgTVNfUEVSX01JTlVURSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSArPSBNU19QRVJfU0VDT05EIC0gbW9kJDEodGltZSwgTVNfUEVSX1NFQ09ORCkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZC5zZXRUaW1lKHRpbWUpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kLnZhbHVlT2YoKSAtICh0aGlzLl9vZmZzZXQgfHwgMCkgKiA2MDAwMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bml4KCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnZhbHVlT2YoKSAvIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvRGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtLnllYXIoKSxcbiAgICAgICAgICAgIG0ubW9udGgoKSxcbiAgICAgICAgICAgIG0uZGF0ZSgpLFxuICAgICAgICAgICAgbS5ob3VyKCksXG4gICAgICAgICAgICBtLm1pbnV0ZSgpLFxuICAgICAgICAgICAgbS5zZWNvbmQoKSxcbiAgICAgICAgICAgIG0ubWlsbGlzZWNvbmQoKSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b09iamVjdCgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcnM6IG0ueWVhcigpLFxuICAgICAgICAgICAgbW9udGhzOiBtLm1vbnRoKCksXG4gICAgICAgICAgICBkYXRlOiBtLmRhdGUoKSxcbiAgICAgICAgICAgIGhvdXJzOiBtLmhvdXJzKCksXG4gICAgICAgICAgICBtaW51dGVzOiBtLm1pbnV0ZXMoKSxcbiAgICAgICAgICAgIHNlY29uZHM6IG0uc2Vjb25kcygpLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBtLm1pbGxpc2Vjb25kcygpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgLy8gbmV3IERhdGUoTmFOKS50b0pTT04oKSA9PT0gbnVsbFxuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLnRvSVNPU3RyaW5nKCkgOiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQkMigpIHtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWQodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2luZ0ZsYWdzKCkge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBnZXRQYXJzaW5nRmxhZ3ModGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmFsaWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldFBhcnNpbmdGbGFncyh0aGlzKS5vdmVyZmxvdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGlvbkRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnB1dDogdGhpcy5faSxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5fZixcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxuICAgICAgICAgICAgaXNVVEM6IHRoaXMuX2lzVVRDLFxuICAgICAgICAgICAgc3RyaWN0OiB0aGlzLl9zdHJpY3QsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ04nLCAwLCAwLCAnZXJhQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTicsIDAsIDAsICdlcmFBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ05OTicsIDAsIDAsICdlcmFBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ05OTk4nLCAwLCAwLCAnZXJhTmFtZScpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTk5OTicsIDAsIDAsICdlcmFOYXJyb3cnKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5JywgMV0sICd5bycsICdlcmFZZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3knLCBbJ3l5JywgMl0sIDAsICdlcmFZZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3knLCBbJ3l5eScsIDNdLCAwLCAnZXJhWWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5eXl5JywgNF0sIDAsICdlcmFZZWFyJyk7XG5cbiAgICBhZGRSZWdleFRva2VuKCdOJywgbWF0Y2hFcmFBYmJyKTtcbiAgICBhZGRSZWdleFRva2VuKCdOTicsIG1hdGNoRXJhQWJicik7XG4gICAgYWRkUmVnZXhUb2tlbignTk5OJywgbWF0Y2hFcmFBYmJyKTtcbiAgICBhZGRSZWdleFRva2VuKCdOTk5OJywgbWF0Y2hFcmFOYW1lKTtcbiAgICBhZGRSZWdleFRva2VuKCdOTk5OTicsIG1hdGNoRXJhTmFycm93KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oXG4gICAgICAgIFsnTicsICdOTicsICdOTk4nLCAnTk5OTicsICdOTk5OTiddLFxuICAgICAgICBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICB2YXIgZXJhID0gY29uZmlnLl9sb2NhbGUuZXJhc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAgICAgaWYgKGVyYSkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVyYSA9IGVyYTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEVyYSA9IGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3knLCBtYXRjaFVuc2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCd5eScsIG1hdGNoVW5zaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3l5eScsIG1hdGNoVW5zaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3l5eXknLCBtYXRjaFVuc2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCd5bycsIG1hdGNoRXJhWWVhck9yZGluYWwpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ3knLCAneXknLCAneXl5JywgJ3l5eXknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3lvJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICBpZiAoY29uZmlnLl9sb2NhbGUuX2VyYVllYXJPcmRpbmFsUmVnZXgpIHtcbiAgICAgICAgICAgIG1hdGNoID0gaW5wdXQubWF0Y2goY29uZmlnLl9sb2NhbGUuX2VyYVllYXJPcmRpbmFsUmVnZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbG9jYWxlLmVyYVllYXJPcmRpbmFsUGFyc2UpIHtcbiAgICAgICAgICAgIGFycmF5W1lFQVJdID0gY29uZmlnLl9sb2NhbGUuZXJhWWVhck9yZGluYWxQYXJzZShpbnB1dCwgbWF0Y2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVFcmFzKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMuX2VyYXMgfHwgZ2V0TG9jYWxlKCdlbicpLl9lcmFzO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICAgICAgICAgIGRhdGUgPSBob29rcyhlcmFzW2ldLnNpbmNlKS5zdGFydE9mKCdkYXknKTtcbiAgICAgICAgICAgICAgICAgICAgZXJhc1tpXS5zaW5jZSA9IGRhdGUudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgZXJhc1tpXS51bnRpbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0udW50aWwgPSArSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IGhvb2tzKGVyYXNbaV0udW50aWwpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgZXJhc1tpXS51bnRpbCA9IGRhdGUudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJhcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVFcmFzUGFyc2UoZXJhTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMuZXJhcygpLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGFiYnIsXG4gICAgICAgICAgICBuYXJyb3c7XG4gICAgICAgIGVyYU5hbWUgPSBlcmFOYW1lLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBuYW1lID0gZXJhc1tpXS5uYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBhYmJyID0gZXJhc1tpXS5hYmJyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBuYXJyb3cgPSBlcmFzW2ldLm5hcnJvdy50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ05OJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTk5OJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhYmJyID09PSBlcmFOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOTk5OJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBlcmFOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOTk5OTic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFycm93ID09PSBlcmFOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFtuYW1lLCBhYmJyLCBuYXJyb3ddLmluZGV4T2YoZXJhTmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRXJhc0NvbnZlcnRZZWFyKGVyYSwgeWVhcikge1xuICAgICAgICB2YXIgZGlyID0gZXJhLnNpbmNlIDw9IGVyYS51bnRpbCA/ICsxIDogLTE7XG4gICAgICAgIGlmICh5ZWFyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBob29rcyhlcmEuc2luY2UpLnllYXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBob29rcyhlcmEuc2luY2UpLnllYXIoKSArICh5ZWFyIC0gZXJhLm9mZnNldCkgKiBkaXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFcmFOYW1lKCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5sb2NhbGVEYXRhKCkuZXJhcygpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgIHZhbCA9IHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG5cbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnNpbmNlIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS51bnRpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJhc1tpXS51bnRpbCA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVyYU5hcnJvdygpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgICAgICBpZiAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYXJyb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJhc1tpXS51bnRpbCA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYXJyb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RXJhQWJicigpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgICAgICBpZiAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5hYmJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0uYWJicjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFcmFZZWFyKCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBkaXIsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5sb2NhbGVEYXRhKCkuZXJhcygpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGRpciA9IGVyYXNbaV0uc2luY2UgPD0gZXJhc1tpXS51bnRpbCA/ICsxIDogLTE7XG5cbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgIHZhbCA9IHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHx8XG4gICAgICAgICAgICAgICAgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMueWVhcigpIC0gaG9va3MoZXJhc1tpXS5zaW5jZSkueWVhcigpKSAqIGRpciArXG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0ub2Zmc2V0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcmFzTmFtZVJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX2VyYXNOYW1lUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZUVyYXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/IHRoaXMuX2VyYXNOYW1lUmVnZXggOiB0aGlzLl9lcmFzUmVnZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJhc0FiYnJSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19lcmFzQWJiclJlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVFcmFzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyB0aGlzLl9lcmFzQWJiclJlZ2V4IDogdGhpcy5fZXJhc1JlZ2V4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVyYXNOYXJyb3dSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19lcmFzTmFycm93UmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZUVyYXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/IHRoaXMuX2VyYXNOYXJyb3dSZWdleCA6IHRoaXMuX2VyYXNSZWdleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaEVyYUFiYnIoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmVyYXNBYmJyUmVnZXgoaXNTdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoRXJhTmFtZShpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuZXJhc05hbWVSZWdleChpc1N0cmljdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hFcmFOYXJyb3coaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmVyYXNOYXJyb3dSZWdleChpc1N0cmljdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hFcmFZZWFyT3JkaW5hbChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuX2VyYVllYXJPcmRpbmFsUmVnZXggfHwgbWF0Y2hVbnNpZ25lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlRXJhc1BhcnNlKCkge1xuICAgICAgICB2YXIgYWJiclBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbmFtZVBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbmFycm93UGllY2VzID0gW10sXG4gICAgICAgICAgICBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5lcmFzKCk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBuYW1lUGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5uYW1lKSk7XG4gICAgICAgICAgICBhYmJyUGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5hYmJyKSk7XG4gICAgICAgICAgICBuYXJyb3dQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLm5hcnJvdykpO1xuXG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHJlZ2V4RXNjYXBlKGVyYXNbaV0ubmFtZSkpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLmFiYnIpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5uYXJyb3cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2VyYXNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fZXJhc05hbWVSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG5hbWVQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9lcmFzQWJiclJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgYWJiclBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX2VyYXNOYXJyb3dSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgbmFycm93UGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuKHRva2VuLCBnZXR0ZXIpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xuICAgIH1cblxuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnZycsICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0cnLCAnaXNvV2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrWWVhcicsICdnZycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtZZWFyJywgMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrWWVhcicsIDEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRycsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdnJywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0cnLCBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZycsIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHRycsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnZycsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFxuICAgICAgICBbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLFxuICAgICAgICBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDIpXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnJywgJ0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFyKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgdGhpcy53ZWVrKCksXG4gICAgICAgICAgICB0aGlzLndlZWtkYXkoKSxcbiAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdyxcbiAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRveVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWtZZWFyKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgdGhpcy5pc29XZWVrKCksXG4gICAgICAgICAgICB0aGlzLmlzb1dlZWtkYXkoKSxcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICA0XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJblllYXIoKSB7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJbklTT1dlZWtZZWFyKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy5pc29XZWVrWWVhcigpLCAxLCA0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXZWVrc0luWWVhcigpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5XZWVrWWVhcigpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLndlZWtZZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhckhlbHBlcihpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtzVGFyZ2V0O1xuICAgICAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIodGhpcywgZG93LCBkb3kpLnllYXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3ZWVrc1RhcmdldCA9IHdlZWtzSW5ZZWFyKGlucHV0LCBkb3csIGRveSk7XG4gICAgICAgICAgICBpZiAod2VlayA+IHdlZWtzVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgd2VlayA9IHdlZWtzVGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNldFdlZWtBbGwuY2FsbCh0aGlzLCBpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0V2Vla0FsbCh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhckRhdGEgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSxcbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKGRheU9mWWVhckRhdGEueWVhciwgMCwgZGF5T2ZZZWFyRGF0YS5kYXlPZlllYXIpO1xuXG4gICAgICAgIHRoaXMueWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpO1xuICAgICAgICB0aGlzLm1vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSk7XG4gICAgICAgIHRoaXMuZGF0ZShkYXRlLmdldFVUQ0RhdGUoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdRJywgMCwgJ1FvJywgJ3F1YXJ0ZXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygncXVhcnRlcicsICdRJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdxdWFydGVyJywgNyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcbiAgICBhZGRQYXJzZVRva2VuKCdRJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSAodG9JbnQoaW5wdXQpIC0gMSkgKiAzO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0UXVhcnRlcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbFxuICAgICAgICAgICAgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMylcbiAgICAgICAgICAgIDogdGhpcy5tb250aCgoaW5wdXQgLSAxKSAqIDMgKyAodGhpcy5tb250aCgpICUgMykpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEJywgWydERCcsIDJdLCAnRG8nLCAnZGF0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXRlJywgJ0QnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXRlJywgOSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdEbycsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0XG4gICAgICAgICAgICA/IGxvY2FsZS5fZGF5T2ZNb250aE9yZGluYWxQYXJzZSB8fCBsb2NhbGUuX29yZGluYWxQYXJzZVxuICAgICAgICAgICAgOiBsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50O1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG4gICAgYWRkUGFyc2VUb2tlbignRG8nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQubWF0Y2gobWF0Y2gxdG8yKVswXSk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheU9mWWVhcicsICdEREQnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXlPZlllYXInLCA0KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0RERCcsIG1hdGNoMXRvMyk7XG4gICAgYWRkUmVnZXhUb2tlbignRERERCcsIG1hdGNoMyk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ0RERCcsICdEREREJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mWWVhcihpbnB1dCkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyID1cbiAgICAgICAgICAgIE1hdGgucm91bmQoXG4gICAgICAgICAgICAgICAgKHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKSAtIHRoaXMuY2xvbmUoKS5zdGFydE9mKCd5ZWFyJykpIC8gODY0ZTVcbiAgICAgICAgICAgICkgKyAxO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IGRheU9mWWVhciA6IHRoaXMuYWRkKGlucHV0IC0gZGF5T2ZZZWFyLCAnZCcpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdtJywgWydtbScsIDJdLCAwLCAnbWludXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbnV0ZScsICdtJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtaW51dGUnLCAxNCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdtJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdtbScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnbScsICdtbSddLCBNSU5VVEUpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbnV0ZSA9IG1ha2VHZXRTZXQoJ01pbnV0ZXMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigncycsIFsnc3MnLCAyXSwgMCwgJ3NlY29uZCcpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdzZWNvbmQnLCAncycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnc2Vjb25kJywgMTUpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigncycsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3MnLCAnc3MnXSwgU0VDT05EKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTUycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTUycsIDNdLCAwLCAnbWlsbGlzZWNvbmQnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwMDtcbiAgICB9KTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWlsbGlzZWNvbmQnLCAnbXMnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21pbGxpc2Vjb25kJywgMTYpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUycsIG1hdGNoMXRvMywgbWF0Y2gxKTtcbiAgICBhZGRSZWdleFRva2VuKCdTUycsIG1hdGNoMXRvMywgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdTU1MnLCBtYXRjaDF0bzMsIG1hdGNoMyk7XG5cbiAgICB2YXIgdG9rZW4sIGdldFNldE1pbGxpc2Vjb25kO1xuICAgIGZvciAodG9rZW4gPSAnU1NTUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUmVnZXhUb2tlbih0b2tlbiwgbWF0Y2hVbnNpZ25lZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VNcyhpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTUlMTElTRUNPTkRdID0gdG9JbnQoKCcwLicgKyBpbnB1dCkgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmb3IgKHRva2VuID0gJ1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIHBhcnNlTXMpO1xuICAgIH1cblxuICAgIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3onLCAwLCAwLCAnem9uZUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignenonLCAwLCAwLCAnem9uZU5hbWUnKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFpvbmVBYmJyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFpvbmVOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvID0gTW9tZW50LnByb3RvdHlwZTtcblxuICAgIHByb3RvLmFkZCA9IGFkZDtcbiAgICBwcm90by5jYWxlbmRhciA9IGNhbGVuZGFyJDE7XG4gICAgcHJvdG8uY2xvbmUgPSBjbG9uZTtcbiAgICBwcm90by5kaWZmID0gZGlmZjtcbiAgICBwcm90by5lbmRPZiA9IGVuZE9mO1xuICAgIHByb3RvLmZvcm1hdCA9IGZvcm1hdDtcbiAgICBwcm90by5mcm9tID0gZnJvbTtcbiAgICBwcm90by5mcm9tTm93ID0gZnJvbU5vdztcbiAgICBwcm90by50byA9IHRvO1xuICAgIHByb3RvLnRvTm93ID0gdG9Ob3c7XG4gICAgcHJvdG8uZ2V0ID0gc3RyaW5nR2V0O1xuICAgIHByb3RvLmludmFsaWRBdCA9IGludmFsaWRBdDtcbiAgICBwcm90by5pc0FmdGVyID0gaXNBZnRlcjtcbiAgICBwcm90by5pc0JlZm9yZSA9IGlzQmVmb3JlO1xuICAgIHByb3RvLmlzQmV0d2VlbiA9IGlzQmV0d2VlbjtcbiAgICBwcm90by5pc1NhbWUgPSBpc1NhbWU7XG4gICAgcHJvdG8uaXNTYW1lT3JBZnRlciA9IGlzU2FtZU9yQWZ0ZXI7XG4gICAgcHJvdG8uaXNTYW1lT3JCZWZvcmUgPSBpc1NhbWVPckJlZm9yZTtcbiAgICBwcm90by5pc1ZhbGlkID0gaXNWYWxpZCQyO1xuICAgIHByb3RvLmxhbmcgPSBsYW5nO1xuICAgIHByb3RvLmxvY2FsZSA9IGxvY2FsZTtcbiAgICBwcm90by5sb2NhbGVEYXRhID0gbG9jYWxlRGF0YTtcbiAgICBwcm90by5tYXggPSBwcm90b3R5cGVNYXg7XG4gICAgcHJvdG8ubWluID0gcHJvdG90eXBlTWluO1xuICAgIHByb3RvLnBhcnNpbmdGbGFncyA9IHBhcnNpbmdGbGFncztcbiAgICBwcm90by5zZXQgPSBzdHJpbmdTZXQ7XG4gICAgcHJvdG8uc3RhcnRPZiA9IHN0YXJ0T2Y7XG4gICAgcHJvdG8uc3VidHJhY3QgPSBzdWJ0cmFjdDtcbiAgICBwcm90by50b0FycmF5ID0gdG9BcnJheTtcbiAgICBwcm90by50b09iamVjdCA9IHRvT2JqZWN0O1xuICAgIHByb3RvLnRvRGF0ZSA9IHRvRGF0ZTtcbiAgICBwcm90by50b0lTT1N0cmluZyA9IHRvSVNPU3RyaW5nO1xuICAgIHByb3RvLmluc3BlY3QgPSBpbnNwZWN0O1xuICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuZm9yICE9IG51bGwpIHtcbiAgICAgICAgcHJvdG9bU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ01vbWVudDwnICsgdGhpcy5mb3JtYXQoKSArICc+JztcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcHJvdG8udG9KU09OID0gdG9KU09OO1xuICAgIHByb3RvLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgcHJvdG8udW5peCA9IHVuaXg7XG4gICAgcHJvdG8udmFsdWVPZiA9IHZhbHVlT2Y7XG4gICAgcHJvdG8uY3JlYXRpb25EYXRhID0gY3JlYXRpb25EYXRhO1xuICAgIHByb3RvLmVyYU5hbWUgPSBnZXRFcmFOYW1lO1xuICAgIHByb3RvLmVyYU5hcnJvdyA9IGdldEVyYU5hcnJvdztcbiAgICBwcm90by5lcmFBYmJyID0gZ2V0RXJhQWJicjtcbiAgICBwcm90by5lcmFZZWFyID0gZ2V0RXJhWWVhcjtcbiAgICBwcm90by55ZWFyID0gZ2V0U2V0WWVhcjtcbiAgICBwcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcbiAgICBwcm90by53ZWVrWWVhciA9IGdldFNldFdlZWtZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XG4gICAgcHJvdG8ucXVhcnRlciA9IHByb3RvLnF1YXJ0ZXJzID0gZ2V0U2V0UXVhcnRlcjtcbiAgICBwcm90by5tb250aCA9IGdldFNldE1vbnRoO1xuICAgIHByb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG4gICAgcHJvdG8ud2VlayA9IHByb3RvLndlZWtzID0gZ2V0U2V0V2VlaztcbiAgICBwcm90by5pc29XZWVrID0gcHJvdG8uaXNvV2Vla3MgPSBnZXRTZXRJU09XZWVrO1xuICAgIHByb3RvLndlZWtzSW5ZZWFyID0gZ2V0V2Vla3NJblllYXI7XG4gICAgcHJvdG8ud2Vla3NJbldlZWtZZWFyID0gZ2V0V2Vla3NJbldlZWtZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtzSW5ZZWFyID0gZ2V0SVNPV2Vla3NJblllYXI7XG4gICAgcHJvdG8uaXNvV2Vla3NJbklTT1dlZWtZZWFyID0gZ2V0SVNPV2Vla3NJbklTT1dlZWtZZWFyO1xuICAgIHByb3RvLmRhdGUgPSBnZXRTZXREYXlPZk1vbnRoO1xuICAgIHByb3RvLmRheSA9IHByb3RvLmRheXMgPSBnZXRTZXREYXlPZldlZWs7XG4gICAgcHJvdG8ud2Vla2RheSA9IGdldFNldExvY2FsZURheU9mV2VlaztcbiAgICBwcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xuICAgIHByb3RvLmRheU9mWWVhciA9IGdldFNldERheU9mWWVhcjtcbiAgICBwcm90by5ob3VyID0gcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xuICAgIHByb3RvLm1pbnV0ZSA9IHByb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG4gICAgcHJvdG8uc2Vjb25kID0gcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcbiAgICBwcm90by5taWxsaXNlY29uZCA9IHByb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xuICAgIHByb3RvLnV0Y09mZnNldCA9IGdldFNldE9mZnNldDtcbiAgICBwcm90by51dGMgPSBzZXRPZmZzZXRUb1VUQztcbiAgICBwcm90by5sb2NhbCA9IHNldE9mZnNldFRvTG9jYWw7XG4gICAgcHJvdG8ucGFyc2Vab25lID0gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQ7XG4gICAgcHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbiAgICBwcm90by5pc0RTVCA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xuICAgIHByb3RvLmlzTG9jYWwgPSBpc0xvY2FsO1xuICAgIHByb3RvLmlzVXRjT2Zmc2V0ID0gaXNVdGNPZmZzZXQ7XG4gICAgcHJvdG8uaXNVdGMgPSBpc1V0YztcbiAgICBwcm90by5pc1VUQyA9IGlzVXRjO1xuICAgIHByb3RvLnpvbmVBYmJyID0gZ2V0Wm9uZUFiYnI7XG4gICAgcHJvdG8uem9uZU5hbWUgPSBnZXRab25lTmFtZTtcbiAgICBwcm90by5kYXRlcyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ2RhdGVzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBkYXRlIGluc3RlYWQuJyxcbiAgICAgICAgZ2V0U2V0RGF5T2ZNb250aFxuICAgICk7XG4gICAgcHJvdG8ubW9udGhzID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJyxcbiAgICAgICAgZ2V0U2V0TW9udGhcbiAgICApO1xuICAgIHByb3RvLnllYXJzID0gZGVwcmVjYXRlKFxuICAgICAgICAneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsXG4gICAgICAgIGdldFNldFllYXJcbiAgICApO1xuICAgIHByb3RvLnpvbmUgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS56b25lIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQoKS51dGNPZmZzZXQgaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy96b25lLycsXG4gICAgICAgIGdldFNldFpvbmVcbiAgICApO1xuICAgIHByb3RvLmlzRFNUU2hpZnRlZCA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ2lzRFNUU2hpZnRlZCBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kc3Qtc2hpZnRlZC8gZm9yIG1vcmUgaW5mb3JtYXRpb24nLFxuICAgICAgICBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWRcbiAgICApO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlVW5peChpbnB1dCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJblpvbmUoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhcnNlWm9uZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZVBhcnNlUG9zdEZvcm1hdChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMSA9IExvY2FsZS5wcm90b3R5cGU7XG5cbiAgICBwcm90byQxLmNhbGVuZGFyID0gY2FsZW5kYXI7XG4gICAgcHJvdG8kMS5sb25nRGF0ZUZvcm1hdCA9IGxvbmdEYXRlRm9ybWF0O1xuICAgIHByb3RvJDEuaW52YWxpZERhdGUgPSBpbnZhbGlkRGF0ZTtcbiAgICBwcm90byQxLm9yZGluYWwgPSBvcmRpbmFsO1xuICAgIHByb3RvJDEucHJlcGFyc2UgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG8kMS5wb3N0Zm9ybWF0ID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucmVsYXRpdmVUaW1lID0gcmVsYXRpdmVUaW1lO1xuICAgIHByb3RvJDEucGFzdEZ1dHVyZSA9IHBhc3RGdXR1cmU7XG4gICAgcHJvdG8kMS5zZXQgPSBzZXQ7XG4gICAgcHJvdG8kMS5lcmFzID0gbG9jYWxlRXJhcztcbiAgICBwcm90byQxLmVyYXNQYXJzZSA9IGxvY2FsZUVyYXNQYXJzZTtcbiAgICBwcm90byQxLmVyYXNDb252ZXJ0WWVhciA9IGxvY2FsZUVyYXNDb252ZXJ0WWVhcjtcbiAgICBwcm90byQxLmVyYXNBYmJyUmVnZXggPSBlcmFzQWJiclJlZ2V4O1xuICAgIHByb3RvJDEuZXJhc05hbWVSZWdleCA9IGVyYXNOYW1lUmVnZXg7XG4gICAgcHJvdG8kMS5lcmFzTmFycm93UmVnZXggPSBlcmFzTmFycm93UmVnZXg7XG5cbiAgICBwcm90byQxLm1vbnRocyA9IGxvY2FsZU1vbnRocztcbiAgICBwcm90byQxLm1vbnRoc1Nob3J0ID0gbG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgcHJvdG8kMS5tb250aHNQYXJzZSA9IGxvY2FsZU1vbnRoc1BhcnNlO1xuICAgIHByb3RvJDEubW9udGhzUmVnZXggPSBtb250aHNSZWdleDtcbiAgICBwcm90byQxLm1vbnRoc1Nob3J0UmVnZXggPSBtb250aHNTaG9ydFJlZ2V4O1xuICAgIHByb3RvJDEud2VlayA9IGxvY2FsZVdlZWs7XG4gICAgcHJvdG8kMS5maXJzdERheU9mWWVhciA9IGxvY2FsZUZpcnN0RGF5T2ZZZWFyO1xuICAgIHByb3RvJDEuZmlyc3REYXlPZldlZWsgPSBsb2NhbGVGaXJzdERheU9mV2VlaztcblxuICAgIHByb3RvJDEud2Vla2RheXMgPSBsb2NhbGVXZWVrZGF5cztcbiAgICBwcm90byQxLndlZWtkYXlzTWluID0gbG9jYWxlV2Vla2RheXNNaW47XG4gICAgcHJvdG8kMS53ZWVrZGF5c1Nob3J0ID0gbG9jYWxlV2Vla2RheXNTaG9ydDtcbiAgICBwcm90byQxLndlZWtkYXlzUGFyc2UgPSBsb2NhbGVXZWVrZGF5c1BhcnNlO1xuXG4gICAgcHJvdG8kMS53ZWVrZGF5c1JlZ2V4ID0gd2Vla2RheXNSZWdleDtcbiAgICBwcm90byQxLndlZWtkYXlzU2hvcnRSZWdleCA9IHdlZWtkYXlzU2hvcnRSZWdleDtcbiAgICBwcm90byQxLndlZWtkYXlzTWluUmVnZXggPSB3ZWVrZGF5c01pblJlZ2V4O1xuXG4gICAgcHJvdG8kMS5pc1BNID0gbG9jYWxlSXNQTTtcbiAgICBwcm90byQxLm1lcmlkaWVtID0gbG9jYWxlTWVyaWRpZW07XG5cbiAgICBmdW5jdGlvbiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKSxcbiAgICAgICAgICAgIHV0YyA9IGNyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcblxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIGksIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIC8vICgpXG4gICAgLy8gKDUpXG4gICAgLy8gKGZtdCwgNSlcbiAgICAvLyAoZm10KVxuICAgIC8vICh0cnVlKVxuICAgIC8vICh0cnVlLCA1KVxuICAgIC8vICh0cnVlLCBmbXQsIDUpXG4gICAgLy8gKHRydWUsIGZtdClcbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGVTb3J0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGxvY2FsZVNvcnRlZDtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgbG9jYWxlU29ydGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCksXG4gICAgICAgICAgICBzaGlmdCA9IGxvY2FsZVNvcnRlZCA/IGxvY2FsZS5fd2Vlay5kb3cgOiAwLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG91dCA9IFtdO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCAoaW5kZXggKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCAoaSArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzU2hvcnQoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRoc1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5cycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c1Nob3J0KGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzTWluKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c01pbicpO1xuICAgIH1cblxuICAgIGdldFNldEdsb2JhbExvY2FsZSgnZW4nLCB7XG4gICAgICAgIGVyYXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzaW5jZTogJzAwMDEtMDEtMDEnLFxuICAgICAgICAgICAgICAgIHVudGlsOiArSW5maW5pdHksXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdBbm5vIERvbWluaScsXG4gICAgICAgICAgICAgICAgbmFycm93OiAnQUQnLFxuICAgICAgICAgICAgICAgIGFiYnI6ICdBRCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNpbmNlOiAnMDAwMC0xMi0zMScsXG4gICAgICAgICAgICAgICAgdW50aWw6IC1JbmZpbml0eSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0JlZm9yZSBDaHJpc3QnLFxuICAgICAgICAgICAgICAgIG5hcnJvdzogJ0JDJyxcbiAgICAgICAgICAgICAgICBhYmJyOiAnQkMnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgICAgIG9yZGluYWw6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID1cbiAgICAgICAgICAgICAgICAgICAgdG9JbnQoKG51bWJlciAlIDEwMCkgLyAxMCkgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ3RoJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBiID09PSAxXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICdzdCdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYiA9PT0gMlxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnbmQnXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGIgPT09IDNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ3JkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiAndGgnO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIGhvb2tzLmxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsXG4gICAgICAgIGdldFNldEdsb2JhbExvY2FsZVxuICAgICk7XG4gICAgaG9va3MubGFuZ0RhdGEgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQubGFuZ0RhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGVEYXRhIGluc3RlYWQuJyxcbiAgICAgICAgZ2V0TG9jYWxlXG4gICAgKTtcblxuICAgIHZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBhYnMoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtYXRoQWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XG4gICAgICAgIHRoaXMuX2RheXMgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xuICAgICAgICB0aGlzLl9tb250aHMgPSBtYXRoQWJzKHRoaXMuX21vbnRocyk7XG5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtYXRoQWJzKGRhdGEubWlsbGlzZWNvbmRzKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XG4gICAgICAgIGRhdGEuaG91cnMgPSBtYXRoQWJzKGRhdGEuaG91cnMpO1xuICAgICAgICBkYXRhLm1vbnRocyA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgICAgICBkYXRhLnllYXJzID0gbWF0aEFicyhkYXRhLnllYXJzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTdWJ0cmFjdCQxKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xuXG4gICAgICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICAgICAgZHVyYXRpb24uX2RheXMgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgICAgIGR1cmF0aW9uLl9tb250aHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgICAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBhZGQkMShpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAxKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0JDEoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgLTEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0NlaWwobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnViYmxlKCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMsXG4gICAgICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMsXG4gICAgICAgICAgICBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgICAgICAgIHNlY29uZHMsXG4gICAgICAgICAgICBtaW51dGVzLFxuICAgICAgICAgICAgaG91cnMsXG4gICAgICAgICAgICB5ZWFycyxcbiAgICAgICAgICAgIG1vbnRoc0Zyb21EYXlzO1xuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcbiAgICAgICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA+PSAwICYmIGRheXMgPj0gMCAmJiBtb250aHMgPj0gMCkgfHxcbiAgICAgICAgICAgICAgICAobWlsbGlzZWNvbmRzIDw9IDAgJiYgZGF5cyA8PSAwICYmIG1vbnRocyA8PSAwKVxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyArPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHMpICsgZGF5cykgKiA4NjRlNTtcbiAgICAgICAgICAgIGRheXMgPSAwO1xuICAgICAgICAgICAgbW9udGhzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcbiAgICAgICAgLy8gZXhhbXBsZXMgb2Ygd2hhdCB0aGF0IG1lYW5zLlxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyAlIDEwMDA7XG5cbiAgICAgICAgc2Vjb25kcyA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICBkYXRhLnNlY29uZHMgPSBzZWNvbmRzICUgNjA7XG5cbiAgICAgICAgbWludXRlcyA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGRhdGEubWludXRlcyA9IG1pbnV0ZXMgJSA2MDtcblxuICAgICAgICBob3VycyA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIGRhdGEuaG91cnMgPSBob3VycyAlIDI0O1xuXG4gICAgICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAgICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgICAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XG4gICAgICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICAgICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICBkYXRhLmRheXMgPSBkYXlzO1xuICAgICAgICBkYXRhLm1vbnRocyA9IG1vbnRocztcbiAgICAgICAgZGF0YS55ZWFycyA9IHllYXJzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNUb01vbnRocyhkYXlzKSB7XG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTIgbW9udGhzID09PSA0ODAwXG4gICAgICAgIHJldHVybiAoZGF5cyAqIDQ4MDApIC8gMTQ2MDk3O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoc1RvRGF5cyhtb250aHMpIHtcbiAgICAgICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgICAgIHJldHVybiAobW9udGhzICogMTQ2MDk3KSAvIDQ4MDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXModW5pdHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF5cyxcbiAgICAgICAgICAgIG1vbnRocyxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICdxdWFydGVyJyB8fCB1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzICsgZGF5c1RvTW9udGhzKGRheXMpO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRocztcbiAgICAgICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRocyAvIDM7XG4gICAgICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb250aHMgLyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXlzIC8gNyArIG1pbGxpc2Vjb25kcyAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyAqIDI0ICsgbWlsbGlzZWNvbmRzIC8gMzZlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyAqIDE0NDAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKiA4NjQwMCArIG1pbGxpc2Vjb25kcyAvIDEwMDA7XG4gICAgICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBwcmV2ZW50cyBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyBoZXJlXG4gICAgICAgICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihkYXlzICogODY0ZTUpICsgbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB1bml0ICcgKyB1bml0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgdGhpcy5hcygnbXMnKT9cbiAgICBmdW5jdGlvbiB2YWx1ZU9mJDEoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICB0aGlzLl9kYXlzICogODY0ZTUgK1xuICAgICAgICAgICAgKHRoaXMuX21vbnRocyAlIDEyKSAqIDI1OTJlNiArXG4gICAgICAgICAgICB0b0ludCh0aGlzLl9tb250aHMgLyAxMikgKiAzMTUzNmU2XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUFzKGFsaWFzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpLFxuICAgICAgICBhc1NlY29uZHMgPSBtYWtlQXMoJ3MnKSxcbiAgICAgICAgYXNNaW51dGVzID0gbWFrZUFzKCdtJyksXG4gICAgICAgIGFzSG91cnMgPSBtYWtlQXMoJ2gnKSxcbiAgICAgICAgYXNEYXlzID0gbWFrZUFzKCdkJyksXG4gICAgICAgIGFzV2Vla3MgPSBtYWtlQXMoJ3cnKSxcbiAgICAgICAgYXNNb250aHMgPSBtYWtlQXMoJ00nKSxcbiAgICAgICAgYXNRdWFydGVycyA9IG1ha2VBcygnUScpLFxuICAgICAgICBhc1llYXJzID0gbWFrZUFzKCd5Jyk7XG5cbiAgICBmdW5jdGlvbiBjbG9uZSQxKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24odGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0JDIodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXNbdW5pdHMgKyAncyddKCkgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9kYXRhW25hbWVdIDogTmFOO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBtaWxsaXNlY29uZHMgPSBtYWtlR2V0dGVyKCdtaWxsaXNlY29uZHMnKSxcbiAgICAgICAgc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKSxcbiAgICAgICAgbWludXRlcyA9IG1ha2VHZXR0ZXIoJ21pbnV0ZXMnKSxcbiAgICAgICAgaG91cnMgPSBtYWtlR2V0dGVyKCdob3VycycpLFxuICAgICAgICBkYXlzID0gbWFrZUdldHRlcignZGF5cycpLFxuICAgICAgICBtb250aHMgPSBtYWtlR2V0dGVyKCdtb250aHMnKSxcbiAgICAgICAgeWVhcnMgPSBtYWtlR2V0dGVyKCd5ZWFycycpO1xuXG4gICAgZnVuY3Rpb24gd2Vla3MoKSB7XG4gICAgICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xuICAgIH1cblxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQsXG4gICAgICAgIHRocmVzaG9sZHMgPSB7XG4gICAgICAgICAgICBzczogNDQsIC8vIGEgZmV3IHNlY29uZHMgdG8gc2Vjb25kc1xuICAgICAgICAgICAgczogNDUsIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgICAgICAgICBtOiA0NSwgLy8gbWludXRlcyB0byBob3VyXG4gICAgICAgICAgICBoOiAyMiwgLy8gaG91cnMgdG8gZGF5XG4gICAgICAgICAgICBkOiAyNiwgLy8gZGF5cyB0byBtb250aC93ZWVrXG4gICAgICAgICAgICB3OiBudWxsLCAvLyB3ZWVrcyB0byBtb250aFxuICAgICAgICAgICAgTTogMTEsIC8vIG1vbnRocyB0byB5ZWFyXG4gICAgICAgIH07XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxuICAgIGZ1bmN0aW9uIHN1YnN0aXR1dGVUaW1lQWdvKHN0cmluZywgbnVtYmVyLCB3aXRob3V0U3VmZml4LCBpc0Z1dHVyZSwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSQxKHBvc05lZ0R1cmF0aW9uLCB3aXRob3V0U3VmZml4LCB0aHJlc2hvbGRzLCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpLFxuICAgICAgICAgICAgc2Vjb25kcyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpLFxuICAgICAgICAgICAgbWludXRlcyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpLFxuICAgICAgICAgICAgaG91cnMgPSByb3VuZChkdXJhdGlvbi5hcygnaCcpKSxcbiAgICAgICAgICAgIGRheXMgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKSxcbiAgICAgICAgICAgIG1vbnRocyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpLFxuICAgICAgICAgICAgd2Vla3MgPSByb3VuZChkdXJhdGlvbi5hcygndycpKSxcbiAgICAgICAgICAgIHllYXJzID0gcm91bmQoZHVyYXRpb24uYXMoJ3knKSksXG4gICAgICAgICAgICBhID1cbiAgICAgICAgICAgICAgICAoc2Vjb25kcyA8PSB0aHJlc2hvbGRzLnNzICYmIFsncycsIHNlY29uZHNdKSB8fFxuICAgICAgICAgICAgICAgIChzZWNvbmRzIDwgdGhyZXNob2xkcy5zICYmIFsnc3MnLCBzZWNvbmRzXSkgfHxcbiAgICAgICAgICAgICAgICAobWludXRlcyA8PSAxICYmIFsnbSddKSB8fFxuICAgICAgICAgICAgICAgIChtaW51dGVzIDwgdGhyZXNob2xkcy5tICYmIFsnbW0nLCBtaW51dGVzXSkgfHxcbiAgICAgICAgICAgICAgICAoaG91cnMgPD0gMSAmJiBbJ2gnXSkgfHxcbiAgICAgICAgICAgICAgICAoaG91cnMgPCB0aHJlc2hvbGRzLmggJiYgWydoaCcsIGhvdXJzXSkgfHxcbiAgICAgICAgICAgICAgICAoZGF5cyA8PSAxICYmIFsnZCddKSB8fFxuICAgICAgICAgICAgICAgIChkYXlzIDwgdGhyZXNob2xkcy5kICYmIFsnZGQnLCBkYXlzXSk7XG5cbiAgICAgICAgaWYgKHRocmVzaG9sZHMudyAhPSBudWxsKSB7XG4gICAgICAgICAgICBhID1cbiAgICAgICAgICAgICAgICBhIHx8XG4gICAgICAgICAgICAgICAgKHdlZWtzIDw9IDEgJiYgWyd3J10pIHx8XG4gICAgICAgICAgICAgICAgKHdlZWtzIDwgdGhyZXNob2xkcy53ICYmIFsnd3cnLCB3ZWVrc10pO1xuICAgICAgICB9XG4gICAgICAgIGEgPSBhIHx8XG4gICAgICAgICAgICAobW9udGhzIDw9IDEgJiYgWydNJ10pIHx8XG4gICAgICAgICAgICAobW9udGhzIDwgdGhyZXNob2xkcy5NICYmIFsnTU0nLCBtb250aHNdKSB8fFxuICAgICAgICAgICAgKHllYXJzIDw9IDEgJiYgWyd5J10pIHx8IFsneXknLCB5ZWFyc107XG5cbiAgICAgICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgICAgIGFbM10gPSArcG9zTmVnRHVyYXRpb24gPiAwO1xuICAgICAgICBhWzRdID0gbG9jYWxlO1xuICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCB0aGUgcm91bmRpbmcgZnVuY3Rpb24gZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nKHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKHJvdW5kaW5nRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygcm91bmRpbmdGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcm91bmQgPSByb3VuZGluZ0Z1bmN0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCh0aHJlc2hvbGQsIGxpbWl0KSB7XG4gICAgICAgIGlmICh0aHJlc2hvbGRzW3RocmVzaG9sZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhyZXNob2xkc1t0aHJlc2hvbGRdO1xuICAgICAgICB9XG4gICAgICAgIHRocmVzaG9sZHNbdGhyZXNob2xkXSA9IGxpbWl0O1xuICAgICAgICBpZiAodGhyZXNob2xkID09PSAncycpIHtcbiAgICAgICAgICAgIHRocmVzaG9sZHMuc3MgPSBsaW1pdCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHVtYW5pemUoYXJnV2l0aFN1ZmZpeCwgYXJnVGhyZXNob2xkcykge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3aXRoU3VmZml4ID0gZmFsc2UsXG4gICAgICAgICAgICB0aCA9IHRocmVzaG9sZHMsXG4gICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICBvdXRwdXQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcmdXaXRoU3VmZml4ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYXJnVGhyZXNob2xkcyA9IGFyZ1dpdGhTdWZmaXg7XG4gICAgICAgICAgICBhcmdXaXRoU3VmZml4ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhcmdXaXRoU3VmZml4ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHdpdGhTdWZmaXggPSBhcmdXaXRoU3VmZml4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYXJnVGhyZXNob2xkcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoID0gT2JqZWN0LmFzc2lnbih7fSwgdGhyZXNob2xkcywgYXJnVGhyZXNob2xkcyk7XG4gICAgICAgICAgICBpZiAoYXJnVGhyZXNob2xkcy5zICE9IG51bGwgJiYgYXJnVGhyZXNob2xkcy5zcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGguc3MgPSBhcmdUaHJlc2hvbGRzLnMgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxlID0gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgIG91dHB1dCA9IHJlbGF0aXZlVGltZSQxKHRoaXMsICF3aXRoU3VmZml4LCB0aCwgbG9jYWxlKTtcblxuICAgICAgICBpZiAod2l0aFN1ZmZpeCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gbG9jYWxlLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9jYWxlLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWJzJDEgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIHNpZ24oeCkge1xuICAgICAgICByZXR1cm4gKHggPiAwKSAtICh4IDwgMCkgfHwgK3g7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JU09TdHJpbmckMSgpIHtcbiAgICAgICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAgICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xuICAgICAgICAvLyAgKiBkYXlzIGRvIG5vdCBidWJibGUgYXQgYWxsXG4gICAgICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcbiAgICAgICAgLy8gKHRoaW5rIG9mIGNsb2NrIGNoYW5nZXMpXG4gICAgICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlY29uZHMgPSBhYnMkMSh0aGlzLl9taWxsaXNlY29uZHMpIC8gMTAwMCxcbiAgICAgICAgICAgIGRheXMgPSBhYnMkMSh0aGlzLl9kYXlzKSxcbiAgICAgICAgICAgIG1vbnRocyA9IGFicyQxKHRoaXMuX21vbnRocyksXG4gICAgICAgICAgICBtaW51dGVzLFxuICAgICAgICAgICAgaG91cnMsXG4gICAgICAgICAgICB5ZWFycyxcbiAgICAgICAgICAgIHMsXG4gICAgICAgICAgICB0b3RhbCA9IHRoaXMuYXNTZWNvbmRzKCksXG4gICAgICAgICAgICB0b3RhbFNpZ24sXG4gICAgICAgICAgICB5bVNpZ24sXG4gICAgICAgICAgICBkYXlzU2lnbixcbiAgICAgICAgICAgIGhtc1NpZ247XG5cbiAgICAgICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxuICAgICAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMzYwMCBzZWNvbmRzIC0+IDYwIG1pbnV0ZXMgLT4gMSBob3VyXG4gICAgICAgIG1pbnV0ZXMgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBob3VycyA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIHNlY29uZHMgJT0gNjA7XG4gICAgICAgIG1pbnV0ZXMgJT0gNjA7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG4gICAgICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXG4gICAgICAgIHMgPSBzZWNvbmRzID8gc2Vjb25kcy50b0ZpeGVkKDMpLnJlcGxhY2UoL1xcLj8wKyQvLCAnJykgOiAnJztcblxuICAgICAgICB0b3RhbFNpZ24gPSB0b3RhbCA8IDAgPyAnLScgOiAnJztcbiAgICAgICAgeW1TaWduID0gc2lnbih0aGlzLl9tb250aHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgICAgICBkYXlzU2lnbiA9IHNpZ24odGhpcy5fZGF5cykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgICAgIGhtc1NpZ24gPSBzaWduKHRoaXMuX21pbGxpc2Vjb25kcykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRvdGFsU2lnbiArXG4gICAgICAgICAgICAnUCcgK1xuICAgICAgICAgICAgKHllYXJzID8geW1TaWduICsgeWVhcnMgKyAnWScgOiAnJykgK1xuICAgICAgICAgICAgKG1vbnRocyA/IHltU2lnbiArIG1vbnRocyArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAoZGF5cyA/IGRheXNTaWduICsgZGF5cyArICdEJyA6ICcnKSArXG4gICAgICAgICAgICAoaG91cnMgfHwgbWludXRlcyB8fCBzZWNvbmRzID8gJ1QnIDogJycpICtcbiAgICAgICAgICAgIChob3VycyA/IGhtc1NpZ24gKyBob3VycyArICdIJyA6ICcnKSArXG4gICAgICAgICAgICAobWludXRlcyA/IGhtc1NpZ24gKyBtaW51dGVzICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChzZWNvbmRzID8gaG1zU2lnbiArIHMgKyAnUycgOiAnJylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMiA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAgIHByb3RvJDIuaXNWYWxpZCA9IGlzVmFsaWQkMTtcbiAgICBwcm90byQyLmFicyA9IGFicztcbiAgICBwcm90byQyLmFkZCA9IGFkZCQxO1xuICAgIHByb3RvJDIuc3VidHJhY3QgPSBzdWJ0cmFjdCQxO1xuICAgIHByb3RvJDIuYXMgPSBhcztcbiAgICBwcm90byQyLmFzTWlsbGlzZWNvbmRzID0gYXNNaWxsaXNlY29uZHM7XG4gICAgcHJvdG8kMi5hc1NlY29uZHMgPSBhc1NlY29uZHM7XG4gICAgcHJvdG8kMi5hc01pbnV0ZXMgPSBhc01pbnV0ZXM7XG4gICAgcHJvdG8kMi5hc0hvdXJzID0gYXNIb3VycztcbiAgICBwcm90byQyLmFzRGF5cyA9IGFzRGF5cztcbiAgICBwcm90byQyLmFzV2Vla3MgPSBhc1dlZWtzO1xuICAgIHByb3RvJDIuYXNNb250aHMgPSBhc01vbnRocztcbiAgICBwcm90byQyLmFzUXVhcnRlcnMgPSBhc1F1YXJ0ZXJzO1xuICAgIHByb3RvJDIuYXNZZWFycyA9IGFzWWVhcnM7XG4gICAgcHJvdG8kMi52YWx1ZU9mID0gdmFsdWVPZiQxO1xuICAgIHByb3RvJDIuX2J1YmJsZSA9IGJ1YmJsZTtcbiAgICBwcm90byQyLmNsb25lID0gY2xvbmUkMTtcbiAgICBwcm90byQyLmdldCA9IGdldCQyO1xuICAgIHByb3RvJDIubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzO1xuICAgIHByb3RvJDIuc2Vjb25kcyA9IHNlY29uZHM7XG4gICAgcHJvdG8kMi5taW51dGVzID0gbWludXRlcztcbiAgICBwcm90byQyLmhvdXJzID0gaG91cnM7XG4gICAgcHJvdG8kMi5kYXlzID0gZGF5cztcbiAgICBwcm90byQyLndlZWtzID0gd2Vla3M7XG4gICAgcHJvdG8kMi5tb250aHMgPSBtb250aHM7XG4gICAgcHJvdG8kMi55ZWFycyA9IHllYXJzO1xuICAgIHByb3RvJDIuaHVtYW5pemUgPSBodW1hbml6ZTtcbiAgICBwcm90byQyLnRvSVNPU3RyaW5nID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLnRvU3RyaW5nID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLnRvSlNPTiA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi5sb2NhbGUgPSBsb2NhbGU7XG4gICAgcHJvdG8kMi5sb2NhbGVEYXRhID0gbG9jYWxlRGF0YTtcblxuICAgIHByb3RvJDIudG9Jc29TdHJpbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsXG4gICAgICAgIHRvSVNPU3RyaW5nJDFcbiAgICApO1xuICAgIHByb3RvJDIubGFuZyA9IGxhbmc7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWCcsIDAsIDAsICd1bml4Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3gnLCAwLCAwLCAndmFsdWVPZicpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdYJywgbWF0Y2hUaW1lc3RhbXApO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCkgKiAxMDAwKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCd4JywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XG4gICAgfSk7XG5cbiAgICAvLyEgbW9tZW50LmpzXG5cbiAgICBob29rcy52ZXJzaW9uID0gJzIuMjkuNCc7XG5cbiAgICBzZXRIb29rQ2FsbGJhY2soY3JlYXRlTG9jYWwpO1xuXG4gICAgaG9va3MuZm4gPSBwcm90bztcbiAgICBob29rcy5taW4gPSBtaW47XG4gICAgaG9va3MubWF4ID0gbWF4O1xuICAgIGhvb2tzLm5vdyA9IG5vdztcbiAgICBob29rcy51dGMgPSBjcmVhdGVVVEM7XG4gICAgaG9va3MudW5peCA9IGNyZWF0ZVVuaXg7XG4gICAgaG9va3MubW9udGhzID0gbGlzdE1vbnRocztcbiAgICBob29rcy5pc0RhdGUgPSBpc0RhdGU7XG4gICAgaG9va3MubG9jYWxlID0gZ2V0U2V0R2xvYmFsTG9jYWxlO1xuICAgIGhvb2tzLmludmFsaWQgPSBjcmVhdGVJbnZhbGlkO1xuICAgIGhvb2tzLmR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb247XG4gICAgaG9va3MuaXNNb21lbnQgPSBpc01vbWVudDtcbiAgICBob29rcy53ZWVrZGF5cyA9IGxpc3RXZWVrZGF5cztcbiAgICBob29rcy5wYXJzZVpvbmUgPSBjcmVhdGVJblpvbmU7XG4gICAgaG9va3MubG9jYWxlRGF0YSA9IGdldExvY2FsZTtcbiAgICBob29rcy5pc0R1cmF0aW9uID0gaXNEdXJhdGlvbjtcbiAgICBob29rcy5tb250aHNTaG9ydCA9IGxpc3RNb250aHNTaG9ydDtcbiAgICBob29rcy53ZWVrZGF5c01pbiA9IGxpc3RXZWVrZGF5c01pbjtcbiAgICBob29rcy5kZWZpbmVMb2NhbGUgPSBkZWZpbmVMb2NhbGU7XG4gICAgaG9va3MudXBkYXRlTG9jYWxlID0gdXBkYXRlTG9jYWxlO1xuICAgIGhvb2tzLmxvY2FsZXMgPSBsaXN0TG9jYWxlcztcbiAgICBob29rcy53ZWVrZGF5c1Nob3J0ID0gbGlzdFdlZWtkYXlzU2hvcnQ7XG4gICAgaG9va3Mubm9ybWFsaXplVW5pdHMgPSBub3JtYWxpemVVbml0cztcbiAgICBob29rcy5yZWxhdGl2ZVRpbWVSb3VuZGluZyA9IGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nO1xuICAgIGhvb2tzLnJlbGF0aXZlVGltZVRocmVzaG9sZCA9IGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZDtcbiAgICBob29rcy5jYWxlbmRhckZvcm1hdCA9IGdldENhbGVuZGFyRm9ybWF0O1xuICAgIGhvb2tzLnByb3RvdHlwZSA9IHByb3RvO1xuXG4gICAgLy8gY3VycmVudGx5IEhUTUw1IGlucHV0IHR5cGUgb25seSBzdXBwb3J0cyAyNC1ob3VyIGZvcm1hdHNcbiAgICBob29rcy5IVE1MNV9GTVQgPSB7XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMOiAnWVlZWS1NTS1ERFRISDptbScsIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9TRUNPTkRTOiAnWVlZWS1NTS1ERFRISDptbTpzcycsIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiBzdGVwPVwiMVwiIC8+XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMX01TOiAnWVlZWS1NTS1ERFRISDptbTpzcy5TU1MnLCAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjAuMDAxXCIgLz5cbiAgICAgICAgREFURTogJ1lZWVktTU0tREQnLCAvLyA8aW5wdXQgdHlwZT1cImRhdGVcIiAvPlxuICAgICAgICBUSU1FOiAnSEg6bW0nLCAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiAvPlxuICAgICAgICBUSU1FX1NFQ09ORFM6ICdISDptbTpzcycsIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIxXCIgLz5cbiAgICAgICAgVElNRV9NUzogJ0hIOm1tOnNzLlNTUycsIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgICAgIFdFRUs6ICdHR0dHLVtXXVdXJywgLy8gPGlucHV0IHR5cGU9XCJ3ZWVrXCIgLz5cbiAgICAgICAgTU9OVEg6ICdZWVlZLU1NJywgLy8gPGlucHV0IHR5cGU9XCJtb250aFwiIC8+XG4gICAgfTtcblxuICAgIHJldHVybiBob29rcztcblxufSkpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/moment/moment.js\n");

/***/ }),

/***/ "../../../node_modules/react-fast-compare/index.js":
/***/ ((module) => {

"use strict";
eval("\n\nvar isArray = Array.isArray;\nvar keyList = Object.keys;\nvar hasProp = Object.prototype.hasOwnProperty;\nvar hasElementType = typeof Element !== 'undefined';\n\nfunction equal(a, b) {\n  // fast-deep-equal index.js 2.0.1\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var arrA = isArray(a)\n      , arrB = isArray(b)\n      , i\n      , length\n      , key;\n\n    if (arrA && arrB) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n    if (arrA != arrB) return false;\n\n    var dateA = a instanceof Date\n      , dateB = b instanceof Date;\n    if (dateA != dateB) return false;\n    if (dateA && dateB) return a.getTime() == b.getTime();\n\n    var regexpA = a instanceof RegExp\n      , regexpB = b instanceof RegExp;\n    if (regexpA != regexpB) return false;\n    if (regexpA && regexpB) return a.toString() == b.toString();\n\n    var keys = keyList(a);\n    length = keys.length;\n\n    if (length !== keyList(b).length)\n      return false;\n\n    for (i = length; i-- !== 0;)\n      if (!hasProp.call(b, keys[i])) return false;\n    // end fast-deep-equal\n\n    // start react-fast-compare\n    // custom handling for DOM elements\n    if (hasElementType && a instanceof Element && b instanceof Element)\n      return a === b;\n\n    // custom handling for React\n    for (i = length; i-- !== 0;) {\n      key = keys[i];\n      if (key === '_owner' && a.$$typeof) {\n        // React-specific: avoid traversing React elements' _owner.\n        //  _owner contains circular references\n        // and is not needed when comparing the actual elements (and not their owners)\n        // .$$typeof and ._store on just reasonable markers of a react element\n        continue;\n      } else {\n        // all other properties should be traversed as usual\n        if (!equal(a[key], b[key])) return false;\n      }\n    }\n    // end react-fast-compare\n\n    // fast-deep-equal index.js 2.0.1\n    return true;\n  }\n\n  return a !== a && b !== b;\n}\n// end fast-deep-equal\n\nmodule.exports = function exportedEqual(a, b) {\n  try {\n    return equal(a, b);\n  } catch (error) {\n    if ((error.message && error.message.match(/stack|recursion/i)) || (error.number === -2146828260)) {\n      // warn on circular references, don't crash\n      // browsers give this different errors name and messages:\n      // chrome/safari: \"RangeError\", \"Maximum call stack size exceeded\"\n      // firefox: \"InternalError\", too much recursion\"\n      // edge: \"Error\", \"Out of stack space\"\n      console.warn('Warning: react-fast-compare does not handle circular references.', error.name, error.message);\n      return false;\n    }\n    // some other error. we should definitely know about these\n    throw error;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWZhc3QtY29tcGFyZS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1mYXN0LWNvbXBhcmUvaW5kZXguanM/NjZmYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbnZhciBrZXlMaXN0ID0gT2JqZWN0LmtleXM7XG52YXIgaGFzUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaGFzRWxlbWVudFR5cGUgPSB0eXBlb2YgRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbmZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgLy8gZmFzdC1kZWVwLWVxdWFsIGluZGV4LmpzIDIuMC4xXG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XG4gICAgdmFyIGFyckEgPSBpc0FycmF5KGEpXG4gICAgICAsIGFyckIgPSBpc0FycmF5KGIpXG4gICAgICAsIGlcbiAgICAgICwgbGVuZ3RoXG4gICAgICAsIGtleTtcblxuICAgIGlmIChhcnJBICYmIGFyckIpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoYXJyQSAhPSBhcnJCKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgZGF0ZUEgPSBhIGluc3RhbmNlb2YgRGF0ZVxuICAgICAgLCBkYXRlQiA9IGIgaW5zdGFuY2VvZiBEYXRlO1xuICAgIGlmIChkYXRlQSAhPSBkYXRlQikgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkYXRlQSAmJiBkYXRlQikgcmV0dXJuIGEuZ2V0VGltZSgpID09IGIuZ2V0VGltZSgpO1xuXG4gICAgdmFyIHJlZ2V4cEEgPSBhIGluc3RhbmNlb2YgUmVnRXhwXG4gICAgICAsIHJlZ2V4cEIgPSBiIGluc3RhbmNlb2YgUmVnRXhwO1xuICAgIGlmIChyZWdleHBBICE9IHJlZ2V4cEIpIHJldHVybiBmYWxzZTtcbiAgICBpZiAocmVnZXhwQSAmJiByZWdleHBCKSByZXR1cm4gYS50b1N0cmluZygpID09IGIudG9TdHJpbmcoKTtcblxuICAgIHZhciBrZXlzID0ga2V5TGlzdChhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcblxuICAgIGlmIChsZW5ndGggIT09IGtleUxpc3QoYikubGVuZ3RoKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgaWYgKCFoYXNQcm9wLmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcbiAgICAvLyBlbmQgZmFzdC1kZWVwLWVxdWFsXG5cbiAgICAvLyBzdGFydCByZWFjdC1mYXN0LWNvbXBhcmVcbiAgICAvLyBjdXN0b20gaGFuZGxpbmcgZm9yIERPTSBlbGVtZW50c1xuICAgIGlmIChoYXNFbGVtZW50VHlwZSAmJiBhIGluc3RhbmNlb2YgRWxlbWVudCAmJiBiIGluc3RhbmNlb2YgRWxlbWVudClcbiAgICAgIHJldHVybiBhID09PSBiO1xuXG4gICAgLy8gY3VzdG9tIGhhbmRsaW5nIGZvciBSZWFjdFxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChrZXkgPT09ICdfb3duZXInICYmIGEuJCR0eXBlb2YpIHtcbiAgICAgICAgLy8gUmVhY3Qtc3BlY2lmaWM6IGF2b2lkIHRyYXZlcnNpbmcgUmVhY3QgZWxlbWVudHMnIF9vd25lci5cbiAgICAgICAgLy8gIF9vd25lciBjb250YWlucyBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgICAgIC8vIGFuZCBpcyBub3QgbmVlZGVkIHdoZW4gY29tcGFyaW5nIHRoZSBhY3R1YWwgZWxlbWVudHMgKGFuZCBub3QgdGhlaXIgb3duZXJzKVxuICAgICAgICAvLyAuJCR0eXBlb2YgYW5kIC5fc3RvcmUgb24ganVzdCByZWFzb25hYmxlIG1hcmtlcnMgb2YgYSByZWFjdCBlbGVtZW50XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWxsIG90aGVyIHByb3BlcnRpZXMgc2hvdWxkIGJlIHRyYXZlcnNlZCBhcyB1c3VhbFxuICAgICAgICBpZiAoIWVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBlbmQgcmVhY3QtZmFzdC1jb21wYXJlXG5cbiAgICAvLyBmYXN0LWRlZXAtZXF1YWwgaW5kZXguanMgMi4wLjFcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XG59XG4vLyBlbmQgZmFzdC1kZWVwLWVxdWFsXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXhwb3J0ZWRFcXVhbChhLCBiKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVxdWFsKGEsIGIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmICgoZXJyb3IubWVzc2FnZSAmJiBlcnJvci5tZXNzYWdlLm1hdGNoKC9zdGFja3xyZWN1cnNpb24vaSkpIHx8IChlcnJvci5udW1iZXIgPT09IC0yMTQ2ODI4MjYwKSkge1xuICAgICAgLy8gd2FybiBvbiBjaXJjdWxhciByZWZlcmVuY2VzLCBkb24ndCBjcmFzaFxuICAgICAgLy8gYnJvd3NlcnMgZ2l2ZSB0aGlzIGRpZmZlcmVudCBlcnJvcnMgbmFtZSBhbmQgbWVzc2FnZXM6XG4gICAgICAvLyBjaHJvbWUvc2FmYXJpOiBcIlJhbmdlRXJyb3JcIiwgXCJNYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiXG4gICAgICAvLyBmaXJlZm94OiBcIkludGVybmFsRXJyb3JcIiwgdG9vIG11Y2ggcmVjdXJzaW9uXCJcbiAgICAgIC8vIGVkZ2U6IFwiRXJyb3JcIiwgXCJPdXQgb2Ygc3RhY2sgc3BhY2VcIlxuICAgICAgY29uc29sZS53YXJuKCdXYXJuaW5nOiByZWFjdC1mYXN0LWNvbXBhcmUgZG9lcyBub3QgaGFuZGxlIGNpcmN1bGFyIHJlZmVyZW5jZXMuJywgZXJyb3IubmFtZSwgZXJyb3IubWVzc2FnZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIHNvbWUgb3RoZXIgZXJyb3IuIHdlIHNob3VsZCBkZWZpbml0ZWx5IGtub3cgYWJvdXQgdGhlc2VcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/react-fast-compare/index.js\n");

/***/ }),

/***/ "../../../node_modules/react-is/cjs/react-is.production.min.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/** @license React v16.13.1\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar b=\"function\"===typeof Symbol&&Symbol.for,c=b?Symbol.for(\"react.element\"):60103,d=b?Symbol.for(\"react.portal\"):60106,e=b?Symbol.for(\"react.fragment\"):60107,f=b?Symbol.for(\"react.strict_mode\"):60108,g=b?Symbol.for(\"react.profiler\"):60114,h=b?Symbol.for(\"react.provider\"):60109,k=b?Symbol.for(\"react.context\"):60110,l=b?Symbol.for(\"react.async_mode\"):60111,m=b?Symbol.for(\"react.concurrent_mode\"):60111,n=b?Symbol.for(\"react.forward_ref\"):60112,p=b?Symbol.for(\"react.suspense\"):60113,q=b?\nSymbol.for(\"react.suspense_list\"):60120,r=b?Symbol.for(\"react.memo\"):60115,t=b?Symbol.for(\"react.lazy\"):60116,v=b?Symbol.for(\"react.block\"):60121,w=b?Symbol.for(\"react.fundamental\"):60117,x=b?Symbol.for(\"react.responder\"):60118,y=b?Symbol.for(\"react.scope\"):60119;\nfunction z(a){if(\"object\"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;exports.Fragment=e;exports.Lazy=t;exports.Memo=r;exports.Portal=d;\nexports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isAsyncMode=function(a){return A(a)||z(a)===l};exports.isConcurrentMode=A;exports.isContextConsumer=function(a){return z(a)===k};exports.isContextProvider=function(a){return z(a)===h};exports.isElement=function(a){return\"object\"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return z(a)===n};exports.isFragment=function(a){return z(a)===e};exports.isLazy=function(a){return z(a)===t};\nexports.isMemo=function(a){return z(a)===r};exports.isPortal=function(a){return z(a)===d};exports.isProfiler=function(a){return z(a)===g};exports.isStrictMode=function(a){return z(a)===f};exports.isSuspense=function(a){return z(a)===p};\nexports.isValidElementType=function(a){return\"string\"===typeof a||\"function\"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||\"object\"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};exports.typeOf=z;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzPzBhOTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0Jzt2YXIgYj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuZm9yLGM9Yj9TeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKTo2MDEwMyxkPWI/U3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKTo2MDEwNixlPWI/U3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpOjYwMTA3LGY9Yj9TeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIik6NjAxMDgsZz1iP1N5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTo2MDExNCxoPWI/U3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpOjYwMTA5LGs9Yj9TeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKTo2MDExMCxsPWI/U3ltYm9sLmZvcihcInJlYWN0LmFzeW5jX21vZGVcIik6NjAxMTEsbT1iP1N5bWJvbC5mb3IoXCJyZWFjdC5jb25jdXJyZW50X21vZGVcIik6NjAxMTEsbj1iP1N5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKTo2MDExMixwPWI/U3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpOjYwMTEzLHE9Yj9cblN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpOjYwMTIwLHI9Yj9TeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKTo2MDExNSx0PWI/U3ltYm9sLmZvcihcInJlYWN0LmxhenlcIik6NjAxMTYsdj1iP1N5bWJvbC5mb3IoXCJyZWFjdC5ibG9ja1wiKTo2MDEyMSx3PWI/U3ltYm9sLmZvcihcInJlYWN0LmZ1bmRhbWVudGFsXCIpOjYwMTE3LHg9Yj9TeW1ib2wuZm9yKFwicmVhY3QucmVzcG9uZGVyXCIpOjYwMTE4LHk9Yj9TeW1ib2wuZm9yKFwicmVhY3Quc2NvcGVcIik6NjAxMTk7XG5mdW5jdGlvbiB6KGEpe2lmKFwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEpe3ZhciB1PWEuJCR0eXBlb2Y7c3dpdGNoKHUpe2Nhc2UgYzpzd2l0Y2goYT1hLnR5cGUsYSl7Y2FzZSBsOmNhc2UgbTpjYXNlIGU6Y2FzZSBnOmNhc2UgZjpjYXNlIHA6cmV0dXJuIGE7ZGVmYXVsdDpzd2l0Y2goYT1hJiZhLiQkdHlwZW9mLGEpe2Nhc2UgazpjYXNlIG46Y2FzZSB0OmNhc2UgcjpjYXNlIGg6cmV0dXJuIGE7ZGVmYXVsdDpyZXR1cm4gdX19Y2FzZSBkOnJldHVybiB1fX19ZnVuY3Rpb24gQShhKXtyZXR1cm4geihhKT09PW19ZXhwb3J0cy5Bc3luY01vZGU9bDtleHBvcnRzLkNvbmN1cnJlbnRNb2RlPW07ZXhwb3J0cy5Db250ZXh0Q29uc3VtZXI9aztleHBvcnRzLkNvbnRleHRQcm92aWRlcj1oO2V4cG9ydHMuRWxlbWVudD1jO2V4cG9ydHMuRm9yd2FyZFJlZj1uO2V4cG9ydHMuRnJhZ21lbnQ9ZTtleHBvcnRzLkxhenk9dDtleHBvcnRzLk1lbW89cjtleHBvcnRzLlBvcnRhbD1kO1xuZXhwb3J0cy5Qcm9maWxlcj1nO2V4cG9ydHMuU3RyaWN0TW9kZT1mO2V4cG9ydHMuU3VzcGVuc2U9cDtleHBvcnRzLmlzQXN5bmNNb2RlPWZ1bmN0aW9uKGEpe3JldHVybiBBKGEpfHx6KGEpPT09bH07ZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlPUE7ZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lcj1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PWt9O2V4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXI9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1ofTtleHBvcnRzLmlzRWxlbWVudD1mdW5jdGlvbihhKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZhLiQkdHlwZW9mPT09Y307ZXhwb3J0cy5pc0ZvcndhcmRSZWY9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1ufTtleHBvcnRzLmlzRnJhZ21lbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1lfTtleHBvcnRzLmlzTGF6eT1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PXR9O1xuZXhwb3J0cy5pc01lbW89ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1yfTtleHBvcnRzLmlzUG9ydGFsPWZ1bmN0aW9uKGEpe3JldHVybiB6KGEpPT09ZH07ZXhwb3J0cy5pc1Byb2ZpbGVyPWZ1bmN0aW9uKGEpe3JldHVybiB6KGEpPT09Z307ZXhwb3J0cy5pc1N0cmljdE1vZGU9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1mfTtleHBvcnRzLmlzU3VzcGVuc2U9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1wfTtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlPWZ1bmN0aW9uKGEpe3JldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYXx8XCJmdW5jdGlvblwiPT09dHlwZW9mIGF8fGE9PT1lfHxhPT09bXx8YT09PWd8fGE9PT1mfHxhPT09cHx8YT09PXF8fFwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJihhLiQkdHlwZW9mPT09dHx8YS4kJHR5cGVvZj09PXJ8fGEuJCR0eXBlb2Y9PT1ofHxhLiQkdHlwZW9mPT09a3x8YS4kJHR5cGVvZj09PW58fGEuJCR0eXBlb2Y9PT13fHxhLiQkdHlwZW9mPT09eHx8YS4kJHR5cGVvZj09PXl8fGEuJCR0eXBlb2Y9PT12KX07ZXhwb3J0cy50eXBlT2Y9ejtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/react-is/cjs/react-is.production.min.js\n");

/***/ }),

/***/ "../../../node_modules/react-is/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (true) {\n  module.exports = __webpack_require__(\"../../../node_modules/react-is/cjs/react-is.production.min.js\");\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanM/NzZkZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/react-is/index.js\n");

/***/ }),

/***/ "../../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * @license React\n * use-sync-external-store-shim.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar e=__webpack_require__(\"react\");function h(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var k=\"function\"===typeof Object.is?Object.is:h,l=e.useState,m=e.useEffect,n=e.useLayoutEffect,p=e.useDebugValue;function q(a,b){var d=b(),f=l({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];n(function(){c.value=d;c.getSnapshot=b;r(c)&&g({inst:c})},[a,d,b]);m(function(){r(c)&&g({inst:c});return a(function(){r(c)&&g({inst:c})})},[a]);p(d);return d}\nfunction r(a){var b=a.getSnapshot;a=a.value;try{var d=b();return!k(a,d)}catch(f){return!0}}function t(a,b){return b()}var u=\"undefined\"===typeof window||\"undefined\"===typeof window.document||\"undefined\"===typeof window.document.createElement?t:q;exports.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:u;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLnByb2R1Y3Rpb24ubWluLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZGVyaXYvYWNjb3VudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0ucHJvZHVjdGlvbi5taW4uanM/OThhNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiB1c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0Jzt2YXIgZT1yZXF1aXJlKFwicmVhY3RcIik7ZnVuY3Rpb24gaChhLGIpe3JldHVybiBhPT09YiYmKDAhPT1hfHwxL2E9PT0xL2IpfHxhIT09YSYmYiE9PWJ9dmFyIGs9XCJmdW5jdGlvblwiPT09dHlwZW9mIE9iamVjdC5pcz9PYmplY3QuaXM6aCxsPWUudXNlU3RhdGUsbT1lLnVzZUVmZmVjdCxuPWUudXNlTGF5b3V0RWZmZWN0LHA9ZS51c2VEZWJ1Z1ZhbHVlO2Z1bmN0aW9uIHEoYSxiKXt2YXIgZD1iKCksZj1sKHtpbnN0Ont2YWx1ZTpkLGdldFNuYXBzaG90OmJ9fSksYz1mWzBdLmluc3QsZz1mWzFdO24oZnVuY3Rpb24oKXtjLnZhbHVlPWQ7Yy5nZXRTbmFwc2hvdD1iO3IoYykmJmcoe2luc3Q6Y30pfSxbYSxkLGJdKTttKGZ1bmN0aW9uKCl7cihjKSYmZyh7aW5zdDpjfSk7cmV0dXJuIGEoZnVuY3Rpb24oKXtyKGMpJiZnKHtpbnN0OmN9KX0pfSxbYV0pO3AoZCk7cmV0dXJuIGR9XG5mdW5jdGlvbiByKGEpe3ZhciBiPWEuZ2V0U25hcHNob3Q7YT1hLnZhbHVlO3RyeXt2YXIgZD1iKCk7cmV0dXJuIWsoYSxkKX1jYXRjaChmKXtyZXR1cm4hMH19ZnVuY3Rpb24gdChhLGIpe3JldHVybiBiKCl9dmFyIHU9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiB3aW5kb3d8fFwidW5kZWZpbmVkXCI9PT10eXBlb2Ygd2luZG93LmRvY3VtZW50fHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50P3Q6cTtleHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlPXZvaWQgMCE9PWUudXNlU3luY0V4dGVybmFsU3RvcmU/ZS51c2VTeW5jRXh0ZXJuYWxTdG9yZTp1O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js\n");

/***/ }),

/***/ "../../../node_modules/use-sync-external-store/shim/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (true) {\n  module.exports = __webpack_require__(\"../../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js\");\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BkZXJpdi9hY2NvdW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzPzc2YjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/use-sync-external-store/shim/index.js\n");

/***/ }),

/***/ "@deriv/components":
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__deriv_components__;

/***/ }),

/***/ "@deriv/shared":
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__deriv_shared__;

/***/ }),

/***/ "@deriv/translations":
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__deriv_translations__;

/***/ }),

/***/ "mobx":
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_mobx__;

/***/ }),

/***/ "react":
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_react__;

/***/ }),

/***/ "react-dom":
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_react_dom__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./Components/address-details/index.js");
/******/ 	__webpack_exports__ = __webpack_exports__["default"];
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});